
Free_RTOS_Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000046d6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000006  00800060  000046d6  0000476a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000045f  00800066  00800066  00004770  2**0
                  ALLOC
  3 .stab         000074b8  00000000  00000000  00004770  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004494  00000000  00000000  0000bc28  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1b 0d 	jmp	0x1a36	; 0x1a36 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 ed       	ldi	r30, 0xD6	; 214
      68:	f6 e4       	ldi	r31, 0x46	; 70
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 36       	cpi	r26, 0x66	; 102
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a6 e6       	ldi	r26, 0x66	; 102
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 3c       	cpi	r26, 0xC5	; 197
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 b7 09 	call	0x136e	; 0x136e <main>
      8a:	0c 94 69 23 	jmp	0x46d2	; 0x46d2 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_voidInit>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	ea e3       	ldi	r30, 0x3A	; 58
      9c:	f0 e0       	ldi	r31, 0x00	; 0
      9e:	87 e0       	ldi	r24, 0x07	; 7
      a0:	80 83       	st	Z, r24
      a2:	e7 e3       	ldi	r30, 0x37	; 55
      a4:	f0 e0       	ldi	r31, 0x00	; 0
      a6:	10 82       	st	Z, r1
      a8:	e4 e3       	ldi	r30, 0x34	; 52
      aa:	f0 e0       	ldi	r31, 0x00	; 0
      ac:	10 82       	st	Z, r1
      ae:	e1 e3       	ldi	r30, 0x31	; 49
      b0:	f0 e0       	ldi	r31, 0x00	; 0
      b2:	10 82       	st	Z, r1
      b4:	eb e3       	ldi	r30, 0x3B	; 59
      b6:	f0 e0       	ldi	r31, 0x00	; 0
      b8:	10 82       	st	Z, r1
      ba:	e8 e3       	ldi	r30, 0x38	; 56
      bc:	f0 e0       	ldi	r31, 0x00	; 0
      be:	10 82       	st	Z, r1
      c0:	e5 e3       	ldi	r30, 0x35	; 53
      c2:	f0 e0       	ldi	r31, 0x00	; 0
      c4:	10 82       	st	Z, r1
      c6:	e2 e3       	ldi	r30, 0x32	; 50
      c8:	f0 e0       	ldi	r31, 0x00	; 0
      ca:	10 82       	st	Z, r1
      cc:	cf 91       	pop	r28
      ce:	df 91       	pop	r29
      d0:	08 95       	ret

000000d2 <DIO_u8SetPinDirection>:

}


u8 DIO_u8SetPinDirection(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8PinDirection)
{
      d2:	df 93       	push	r29
      d4:	cf 93       	push	r28
      d6:	cd b7       	in	r28, 0x3d	; 61
      d8:	de b7       	in	r29, 0x3e	; 62
      da:	2e 97       	sbiw	r28, 0x0e	; 14
      dc:	0f b6       	in	r0, 0x3f	; 63
      de:	f8 94       	cli
      e0:	de bf       	out	0x3e, r29	; 62
      e2:	0f be       	out	0x3f, r0	; 63
      e4:	cd bf       	out	0x3d, r28	; 61
      e6:	8a 83       	std	Y+2, r24	; 0x02
      e8:	6b 83       	std	Y+3, r22	; 0x03
      ea:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState = STD_TYPES_OK;
      ec:	81 e0       	ldi	r24, 0x01	; 1
      ee:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortId <= DIO_u8_PORTD) && (Copy_u8PinId <= DIO_u8_PIN7)&&((Copy_u8PinDirection == DIO_u8_INPUT)||(Copy_u8PinDirection == DIO_u8_OUTPUT)))
      f0:	8a 81       	ldd	r24, Y+2	; 0x02
      f2:	84 30       	cpi	r24, 0x04	; 4
      f4:	08 f0       	brcs	.+2      	; 0xf8 <DIO_u8SetPinDirection+0x26>
      f6:	0d c1       	rjmp	.+538    	; 0x312 <DIO_u8SetPinDirection+0x240>
      f8:	8b 81       	ldd	r24, Y+3	; 0x03
      fa:	88 30       	cpi	r24, 0x08	; 8
      fc:	08 f0       	brcs	.+2      	; 0x100 <DIO_u8SetPinDirection+0x2e>
      fe:	09 c1       	rjmp	.+530    	; 0x312 <DIO_u8SetPinDirection+0x240>
     100:	8c 81       	ldd	r24, Y+4	; 0x04
     102:	88 23       	and	r24, r24
     104:	21 f0       	breq	.+8      	; 0x10e <DIO_u8SetPinDirection+0x3c>
     106:	8c 81       	ldd	r24, Y+4	; 0x04
     108:	81 30       	cpi	r24, 0x01	; 1
     10a:	09 f0       	breq	.+2      	; 0x10e <DIO_u8SetPinDirection+0x3c>
     10c:	02 c1       	rjmp	.+516    	; 0x312 <DIO_u8SetPinDirection+0x240>
	{
		switch(Copy_u8PortId)
     10e:	8a 81       	ldd	r24, Y+2	; 0x02
     110:	28 2f       	mov	r18, r24
     112:	30 e0       	ldi	r19, 0x00	; 0
     114:	3e 87       	std	Y+14, r19	; 0x0e
     116:	2d 87       	std	Y+13, r18	; 0x0d
     118:	8d 85       	ldd	r24, Y+13	; 0x0d
     11a:	9e 85       	ldd	r25, Y+14	; 0x0e
     11c:	81 30       	cpi	r24, 0x01	; 1
     11e:	91 05       	cpc	r25, r1
     120:	09 f4       	brne	.+2      	; 0x124 <DIO_u8SetPinDirection+0x52>
     122:	4f c0       	rjmp	.+158    	; 0x1c2 <DIO_u8SetPinDirection+0xf0>
     124:	2d 85       	ldd	r18, Y+13	; 0x0d
     126:	3e 85       	ldd	r19, Y+14	; 0x0e
     128:	22 30       	cpi	r18, 0x02	; 2
     12a:	31 05       	cpc	r19, r1
     12c:	2c f4       	brge	.+10     	; 0x138 <DIO_u8SetPinDirection+0x66>
     12e:	8d 85       	ldd	r24, Y+13	; 0x0d
     130:	9e 85       	ldd	r25, Y+14	; 0x0e
     132:	00 97       	sbiw	r24, 0x00	; 0
     134:	71 f0       	breq	.+28     	; 0x152 <DIO_u8SetPinDirection+0x80>
     136:	ee c0       	rjmp	.+476    	; 0x314 <DIO_u8SetPinDirection+0x242>
     138:	2d 85       	ldd	r18, Y+13	; 0x0d
     13a:	3e 85       	ldd	r19, Y+14	; 0x0e
     13c:	22 30       	cpi	r18, 0x02	; 2
     13e:	31 05       	cpc	r19, r1
     140:	09 f4       	brne	.+2      	; 0x144 <DIO_u8SetPinDirection+0x72>
     142:	77 c0       	rjmp	.+238    	; 0x232 <DIO_u8SetPinDirection+0x160>
     144:	8d 85       	ldd	r24, Y+13	; 0x0d
     146:	9e 85       	ldd	r25, Y+14	; 0x0e
     148:	83 30       	cpi	r24, 0x03	; 3
     14a:	91 05       	cpc	r25, r1
     14c:	09 f4       	brne	.+2      	; 0x150 <DIO_u8SetPinDirection+0x7e>
     14e:	a9 c0       	rjmp	.+338    	; 0x2a2 <DIO_u8SetPinDirection+0x1d0>
     150:	e1 c0       	rjmp	.+450    	; 0x314 <DIO_u8SetPinDirection+0x242>
		{
			case DIO_u8_PORTA:
				switch(Copy_u8PinId)
     152:	8b 81       	ldd	r24, Y+3	; 0x03
     154:	28 2f       	mov	r18, r24
     156:	30 e0       	ldi	r19, 0x00	; 0
     158:	3c 87       	std	Y+12, r19	; 0x0c
     15a:	2b 87       	std	Y+11, r18	; 0x0b
     15c:	8b 85       	ldd	r24, Y+11	; 0x0b
     15e:	9c 85       	ldd	r25, Y+12	; 0x0c
     160:	00 97       	sbiw	r24, 0x00	; 0
     162:	31 f0       	breq	.+12     	; 0x170 <DIO_u8SetPinDirection+0x9e>
     164:	2b 85       	ldd	r18, Y+11	; 0x0b
     166:	3c 85       	ldd	r19, Y+12	; 0x0c
     168:	21 30       	cpi	r18, 0x01	; 1
     16a:	31 05       	cpc	r19, r1
     16c:	b1 f0       	breq	.+44     	; 0x19a <DIO_u8SetPinDirection+0xc8>
     16e:	d2 c0       	rjmp	.+420    	; 0x314 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRA_REG,Copy_u8PinId);break;
     170:	aa e3       	ldi	r26, 0x3A	; 58
     172:	b0 e0       	ldi	r27, 0x00	; 0
     174:	ea e3       	ldi	r30, 0x3A	; 58
     176:	f0 e0       	ldi	r31, 0x00	; 0
     178:	80 81       	ld	r24, Z
     17a:	48 2f       	mov	r20, r24
     17c:	8b 81       	ldd	r24, Y+3	; 0x03
     17e:	28 2f       	mov	r18, r24
     180:	30 e0       	ldi	r19, 0x00	; 0
     182:	81 e0       	ldi	r24, 0x01	; 1
     184:	90 e0       	ldi	r25, 0x00	; 0
     186:	02 2e       	mov	r0, r18
     188:	02 c0       	rjmp	.+4      	; 0x18e <DIO_u8SetPinDirection+0xbc>
     18a:	88 0f       	add	r24, r24
     18c:	99 1f       	adc	r25, r25
     18e:	0a 94       	dec	r0
     190:	e2 f7       	brpl	.-8      	; 0x18a <DIO_u8SetPinDirection+0xb8>
     192:	80 95       	com	r24
     194:	84 23       	and	r24, r20
     196:	8c 93       	st	X, r24
     198:	bd c0       	rjmp	.+378    	; 0x314 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRA_REG,Copy_u8PinId);break;
     19a:	aa e3       	ldi	r26, 0x3A	; 58
     19c:	b0 e0       	ldi	r27, 0x00	; 0
     19e:	ea e3       	ldi	r30, 0x3A	; 58
     1a0:	f0 e0       	ldi	r31, 0x00	; 0
     1a2:	80 81       	ld	r24, Z
     1a4:	48 2f       	mov	r20, r24
     1a6:	8b 81       	ldd	r24, Y+3	; 0x03
     1a8:	28 2f       	mov	r18, r24
     1aa:	30 e0       	ldi	r19, 0x00	; 0
     1ac:	81 e0       	ldi	r24, 0x01	; 1
     1ae:	90 e0       	ldi	r25, 0x00	; 0
     1b0:	02 2e       	mov	r0, r18
     1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <DIO_u8SetPinDirection+0xe6>
     1b4:	88 0f       	add	r24, r24
     1b6:	99 1f       	adc	r25, r25
     1b8:	0a 94       	dec	r0
     1ba:	e2 f7       	brpl	.-8      	; 0x1b4 <DIO_u8SetPinDirection+0xe2>
     1bc:	84 2b       	or	r24, r20
     1be:	8c 93       	st	X, r24
     1c0:	a9 c0       	rjmp	.+338    	; 0x314 <DIO_u8SetPinDirection+0x242>
				}
			break;
			case DIO_u8_PORTB:
				switch(Copy_u8PinId)
     1c2:	8b 81       	ldd	r24, Y+3	; 0x03
     1c4:	28 2f       	mov	r18, r24
     1c6:	30 e0       	ldi	r19, 0x00	; 0
     1c8:	3a 87       	std	Y+10, r19	; 0x0a
     1ca:	29 87       	std	Y+9, r18	; 0x09
     1cc:	89 85       	ldd	r24, Y+9	; 0x09
     1ce:	9a 85       	ldd	r25, Y+10	; 0x0a
     1d0:	00 97       	sbiw	r24, 0x00	; 0
     1d2:	31 f0       	breq	.+12     	; 0x1e0 <DIO_u8SetPinDirection+0x10e>
     1d4:	29 85       	ldd	r18, Y+9	; 0x09
     1d6:	3a 85       	ldd	r19, Y+10	; 0x0a
     1d8:	21 30       	cpi	r18, 0x01	; 1
     1da:	31 05       	cpc	r19, r1
     1dc:	b1 f0       	breq	.+44     	; 0x20a <DIO_u8SetPinDirection+0x138>
     1de:	9a c0       	rjmp	.+308    	; 0x314 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRB_REG,Copy_u8PinId);break;
     1e0:	a7 e3       	ldi	r26, 0x37	; 55
     1e2:	b0 e0       	ldi	r27, 0x00	; 0
     1e4:	e7 e3       	ldi	r30, 0x37	; 55
     1e6:	f0 e0       	ldi	r31, 0x00	; 0
     1e8:	80 81       	ld	r24, Z
     1ea:	48 2f       	mov	r20, r24
     1ec:	8b 81       	ldd	r24, Y+3	; 0x03
     1ee:	28 2f       	mov	r18, r24
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	81 e0       	ldi	r24, 0x01	; 1
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	02 2e       	mov	r0, r18
     1f8:	02 c0       	rjmp	.+4      	; 0x1fe <DIO_u8SetPinDirection+0x12c>
     1fa:	88 0f       	add	r24, r24
     1fc:	99 1f       	adc	r25, r25
     1fe:	0a 94       	dec	r0
     200:	e2 f7       	brpl	.-8      	; 0x1fa <DIO_u8SetPinDirection+0x128>
     202:	80 95       	com	r24
     204:	84 23       	and	r24, r20
     206:	8c 93       	st	X, r24
     208:	85 c0       	rjmp	.+266    	; 0x314 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRB_REG,Copy_u8PinId);break;
     20a:	a7 e3       	ldi	r26, 0x37	; 55
     20c:	b0 e0       	ldi	r27, 0x00	; 0
     20e:	e7 e3       	ldi	r30, 0x37	; 55
     210:	f0 e0       	ldi	r31, 0x00	; 0
     212:	80 81       	ld	r24, Z
     214:	48 2f       	mov	r20, r24
     216:	8b 81       	ldd	r24, Y+3	; 0x03
     218:	28 2f       	mov	r18, r24
     21a:	30 e0       	ldi	r19, 0x00	; 0
     21c:	81 e0       	ldi	r24, 0x01	; 1
     21e:	90 e0       	ldi	r25, 0x00	; 0
     220:	02 2e       	mov	r0, r18
     222:	02 c0       	rjmp	.+4      	; 0x228 <DIO_u8SetPinDirection+0x156>
     224:	88 0f       	add	r24, r24
     226:	99 1f       	adc	r25, r25
     228:	0a 94       	dec	r0
     22a:	e2 f7       	brpl	.-8      	; 0x224 <DIO_u8SetPinDirection+0x152>
     22c:	84 2b       	or	r24, r20
     22e:	8c 93       	st	X, r24
     230:	71 c0       	rjmp	.+226    	; 0x314 <DIO_u8SetPinDirection+0x242>
				}
			break;
			case DIO_u8_PORTC:
				switch(Copy_u8PinId)
     232:	8b 81       	ldd	r24, Y+3	; 0x03
     234:	28 2f       	mov	r18, r24
     236:	30 e0       	ldi	r19, 0x00	; 0
     238:	38 87       	std	Y+8, r19	; 0x08
     23a:	2f 83       	std	Y+7, r18	; 0x07
     23c:	8f 81       	ldd	r24, Y+7	; 0x07
     23e:	98 85       	ldd	r25, Y+8	; 0x08
     240:	00 97       	sbiw	r24, 0x00	; 0
     242:	31 f0       	breq	.+12     	; 0x250 <DIO_u8SetPinDirection+0x17e>
     244:	2f 81       	ldd	r18, Y+7	; 0x07
     246:	38 85       	ldd	r19, Y+8	; 0x08
     248:	21 30       	cpi	r18, 0x01	; 1
     24a:	31 05       	cpc	r19, r1
     24c:	b1 f0       	breq	.+44     	; 0x27a <DIO_u8SetPinDirection+0x1a8>
     24e:	62 c0       	rjmp	.+196    	; 0x314 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRC_REG,Copy_u8PinId);break;
     250:	a4 e3       	ldi	r26, 0x34	; 52
     252:	b0 e0       	ldi	r27, 0x00	; 0
     254:	e4 e3       	ldi	r30, 0x34	; 52
     256:	f0 e0       	ldi	r31, 0x00	; 0
     258:	80 81       	ld	r24, Z
     25a:	48 2f       	mov	r20, r24
     25c:	8b 81       	ldd	r24, Y+3	; 0x03
     25e:	28 2f       	mov	r18, r24
     260:	30 e0       	ldi	r19, 0x00	; 0
     262:	81 e0       	ldi	r24, 0x01	; 1
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	02 2e       	mov	r0, r18
     268:	02 c0       	rjmp	.+4      	; 0x26e <DIO_u8SetPinDirection+0x19c>
     26a:	88 0f       	add	r24, r24
     26c:	99 1f       	adc	r25, r25
     26e:	0a 94       	dec	r0
     270:	e2 f7       	brpl	.-8      	; 0x26a <DIO_u8SetPinDirection+0x198>
     272:	80 95       	com	r24
     274:	84 23       	and	r24, r20
     276:	8c 93       	st	X, r24
     278:	4d c0       	rjmp	.+154    	; 0x314 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRC_REG,Copy_u8PinId);break;
     27a:	a4 e3       	ldi	r26, 0x34	; 52
     27c:	b0 e0       	ldi	r27, 0x00	; 0
     27e:	e4 e3       	ldi	r30, 0x34	; 52
     280:	f0 e0       	ldi	r31, 0x00	; 0
     282:	80 81       	ld	r24, Z
     284:	48 2f       	mov	r20, r24
     286:	8b 81       	ldd	r24, Y+3	; 0x03
     288:	28 2f       	mov	r18, r24
     28a:	30 e0       	ldi	r19, 0x00	; 0
     28c:	81 e0       	ldi	r24, 0x01	; 1
     28e:	90 e0       	ldi	r25, 0x00	; 0
     290:	02 2e       	mov	r0, r18
     292:	02 c0       	rjmp	.+4      	; 0x298 <DIO_u8SetPinDirection+0x1c6>
     294:	88 0f       	add	r24, r24
     296:	99 1f       	adc	r25, r25
     298:	0a 94       	dec	r0
     29a:	e2 f7       	brpl	.-8      	; 0x294 <DIO_u8SetPinDirection+0x1c2>
     29c:	84 2b       	or	r24, r20
     29e:	8c 93       	st	X, r24
     2a0:	39 c0       	rjmp	.+114    	; 0x314 <DIO_u8SetPinDirection+0x242>
				}
			break;
			case DIO_u8_PORTD:
				switch(Copy_u8PinId)
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	28 2f       	mov	r18, r24
     2a6:	30 e0       	ldi	r19, 0x00	; 0
     2a8:	3e 83       	std	Y+6, r19	; 0x06
     2aa:	2d 83       	std	Y+5, r18	; 0x05
     2ac:	8d 81       	ldd	r24, Y+5	; 0x05
     2ae:	9e 81       	ldd	r25, Y+6	; 0x06
     2b0:	00 97       	sbiw	r24, 0x00	; 0
     2b2:	31 f0       	breq	.+12     	; 0x2c0 <DIO_u8SetPinDirection+0x1ee>
     2b4:	2d 81       	ldd	r18, Y+5	; 0x05
     2b6:	3e 81       	ldd	r19, Y+6	; 0x06
     2b8:	21 30       	cpi	r18, 0x01	; 1
     2ba:	31 05       	cpc	r19, r1
     2bc:	b1 f0       	breq	.+44     	; 0x2ea <DIO_u8SetPinDirection+0x218>
     2be:	2a c0       	rjmp	.+84     	; 0x314 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRD_REG,Copy_u8PinId);break;
     2c0:	a1 e3       	ldi	r26, 0x31	; 49
     2c2:	b0 e0       	ldi	r27, 0x00	; 0
     2c4:	e1 e3       	ldi	r30, 0x31	; 49
     2c6:	f0 e0       	ldi	r31, 0x00	; 0
     2c8:	80 81       	ld	r24, Z
     2ca:	48 2f       	mov	r20, r24
     2cc:	8b 81       	ldd	r24, Y+3	; 0x03
     2ce:	28 2f       	mov	r18, r24
     2d0:	30 e0       	ldi	r19, 0x00	; 0
     2d2:	81 e0       	ldi	r24, 0x01	; 1
     2d4:	90 e0       	ldi	r25, 0x00	; 0
     2d6:	02 2e       	mov	r0, r18
     2d8:	02 c0       	rjmp	.+4      	; 0x2de <DIO_u8SetPinDirection+0x20c>
     2da:	88 0f       	add	r24, r24
     2dc:	99 1f       	adc	r25, r25
     2de:	0a 94       	dec	r0
     2e0:	e2 f7       	brpl	.-8      	; 0x2da <DIO_u8SetPinDirection+0x208>
     2e2:	80 95       	com	r24
     2e4:	84 23       	and	r24, r20
     2e6:	8c 93       	st	X, r24
     2e8:	15 c0       	rjmp	.+42     	; 0x314 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRD_REG,Copy_u8PinId);break;
     2ea:	a1 e3       	ldi	r26, 0x31	; 49
     2ec:	b0 e0       	ldi	r27, 0x00	; 0
     2ee:	e1 e3       	ldi	r30, 0x31	; 49
     2f0:	f0 e0       	ldi	r31, 0x00	; 0
     2f2:	80 81       	ld	r24, Z
     2f4:	48 2f       	mov	r20, r24
     2f6:	8b 81       	ldd	r24, Y+3	; 0x03
     2f8:	28 2f       	mov	r18, r24
     2fa:	30 e0       	ldi	r19, 0x00	; 0
     2fc:	81 e0       	ldi	r24, 0x01	; 1
     2fe:	90 e0       	ldi	r25, 0x00	; 0
     300:	02 2e       	mov	r0, r18
     302:	02 c0       	rjmp	.+4      	; 0x308 <DIO_u8SetPinDirection+0x236>
     304:	88 0f       	add	r24, r24
     306:	99 1f       	adc	r25, r25
     308:	0a 94       	dec	r0
     30a:	e2 f7       	brpl	.-8      	; 0x304 <DIO_u8SetPinDirection+0x232>
     30c:	84 2b       	or	r24, r20
     30e:	8c 93       	st	X, r24
     310:	01 c0       	rjmp	.+2      	; 0x314 <DIO_u8SetPinDirection+0x242>
			break;
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
     312:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
     314:	89 81       	ldd	r24, Y+1	; 0x01
}
     316:	2e 96       	adiw	r28, 0x0e	; 14
     318:	0f b6       	in	r0, 0x3f	; 63
     31a:	f8 94       	cli
     31c:	de bf       	out	0x3e, r29	; 62
     31e:	0f be       	out	0x3f, r0	; 63
     320:	cd bf       	out	0x3d, r28	; 61
     322:	cf 91       	pop	r28
     324:	df 91       	pop	r29
     326:	08 95       	ret

00000328 <DIO_u8SetPinValue>:

u8 DIO_u8SetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8PinValue)
{
     328:	df 93       	push	r29
     32a:	cf 93       	push	r28
     32c:	cd b7       	in	r28, 0x3d	; 61
     32e:	de b7       	in	r29, 0x3e	; 62
     330:	2e 97       	sbiw	r28, 0x0e	; 14
     332:	0f b6       	in	r0, 0x3f	; 63
     334:	f8 94       	cli
     336:	de bf       	out	0x3e, r29	; 62
     338:	0f be       	out	0x3f, r0	; 63
     33a:	cd bf       	out	0x3d, r28	; 61
     33c:	8a 83       	std	Y+2, r24	; 0x02
     33e:	6b 83       	std	Y+3, r22	; 0x03
     340:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState = STD_TYPES_OK;
     342:	81 e0       	ldi	r24, 0x01	; 1
     344:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinId <= DIO_u8_PIN7)
     346:	8b 81       	ldd	r24, Y+3	; 0x03
     348:	88 30       	cpi	r24, 0x08	; 8
     34a:	08 f0       	brcs	.+2      	; 0x34e <DIO_u8SetPinValue+0x26>
     34c:	0c c1       	rjmp	.+536    	; 0x566 <DIO_u8SetPinValue+0x23e>
	{
		switch(Copy_u8PortId)
     34e:	8a 81       	ldd	r24, Y+2	; 0x02
     350:	28 2f       	mov	r18, r24
     352:	30 e0       	ldi	r19, 0x00	; 0
     354:	3e 87       	std	Y+14, r19	; 0x0e
     356:	2d 87       	std	Y+13, r18	; 0x0d
     358:	8d 85       	ldd	r24, Y+13	; 0x0d
     35a:	9e 85       	ldd	r25, Y+14	; 0x0e
     35c:	81 30       	cpi	r24, 0x01	; 1
     35e:	91 05       	cpc	r25, r1
     360:	09 f4       	brne	.+2      	; 0x364 <DIO_u8SetPinValue+0x3c>
     362:	51 c0       	rjmp	.+162    	; 0x406 <DIO_u8SetPinValue+0xde>
     364:	2d 85       	ldd	r18, Y+13	; 0x0d
     366:	3e 85       	ldd	r19, Y+14	; 0x0e
     368:	22 30       	cpi	r18, 0x02	; 2
     36a:	31 05       	cpc	r19, r1
     36c:	2c f4       	brge	.+10     	; 0x378 <DIO_u8SetPinValue+0x50>
     36e:	8d 85       	ldd	r24, Y+13	; 0x0d
     370:	9e 85       	ldd	r25, Y+14	; 0x0e
     372:	00 97       	sbiw	r24, 0x00	; 0
     374:	71 f0       	breq	.+28     	; 0x392 <DIO_u8SetPinValue+0x6a>
     376:	f5 c0       	rjmp	.+490    	; 0x562 <DIO_u8SetPinValue+0x23a>
     378:	2d 85       	ldd	r18, Y+13	; 0x0d
     37a:	3e 85       	ldd	r19, Y+14	; 0x0e
     37c:	22 30       	cpi	r18, 0x02	; 2
     37e:	31 05       	cpc	r19, r1
     380:	09 f4       	brne	.+2      	; 0x384 <DIO_u8SetPinValue+0x5c>
     382:	7b c0       	rjmp	.+246    	; 0x47a <DIO_u8SetPinValue+0x152>
     384:	8d 85       	ldd	r24, Y+13	; 0x0d
     386:	9e 85       	ldd	r25, Y+14	; 0x0e
     388:	83 30       	cpi	r24, 0x03	; 3
     38a:	91 05       	cpc	r25, r1
     38c:	09 f4       	brne	.+2      	; 0x390 <DIO_u8SetPinValue+0x68>
     38e:	af c0       	rjmp	.+350    	; 0x4ee <DIO_u8SetPinValue+0x1c6>
     390:	e8 c0       	rjmp	.+464    	; 0x562 <DIO_u8SetPinValue+0x23a>
		{
			case DIO_u8_PORTA:
				switch(Copy_u8PinValue)
     392:	8c 81       	ldd	r24, Y+4	; 0x04
     394:	28 2f       	mov	r18, r24
     396:	30 e0       	ldi	r19, 0x00	; 0
     398:	3c 87       	std	Y+12, r19	; 0x0c
     39a:	2b 87       	std	Y+11, r18	; 0x0b
     39c:	8b 85       	ldd	r24, Y+11	; 0x0b
     39e:	9c 85       	ldd	r25, Y+12	; 0x0c
     3a0:	00 97       	sbiw	r24, 0x00	; 0
     3a2:	31 f0       	breq	.+12     	; 0x3b0 <DIO_u8SetPinValue+0x88>
     3a4:	2b 85       	ldd	r18, Y+11	; 0x0b
     3a6:	3c 85       	ldd	r19, Y+12	; 0x0c
     3a8:	21 30       	cpi	r18, 0x01	; 1
     3aa:	31 05       	cpc	r19, r1
     3ac:	b1 f0       	breq	.+44     	; 0x3da <DIO_u8SetPinValue+0xb2>
     3ae:	29 c0       	rjmp	.+82     	; 0x402 <DIO_u8SetPinValue+0xda>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTA_REG,Copy_u8PinId);break;
     3b0:	ab e3       	ldi	r26, 0x3B	; 59
     3b2:	b0 e0       	ldi	r27, 0x00	; 0
     3b4:	eb e3       	ldi	r30, 0x3B	; 59
     3b6:	f0 e0       	ldi	r31, 0x00	; 0
     3b8:	80 81       	ld	r24, Z
     3ba:	48 2f       	mov	r20, r24
     3bc:	8b 81       	ldd	r24, Y+3	; 0x03
     3be:	28 2f       	mov	r18, r24
     3c0:	30 e0       	ldi	r19, 0x00	; 0
     3c2:	81 e0       	ldi	r24, 0x01	; 1
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	02 2e       	mov	r0, r18
     3c8:	02 c0       	rjmp	.+4      	; 0x3ce <DIO_u8SetPinValue+0xa6>
     3ca:	88 0f       	add	r24, r24
     3cc:	99 1f       	adc	r25, r25
     3ce:	0a 94       	dec	r0
     3d0:	e2 f7       	brpl	.-8      	; 0x3ca <DIO_u8SetPinValue+0xa2>
     3d2:	80 95       	com	r24
     3d4:	84 23       	and	r24, r20
     3d6:	8c 93       	st	X, r24
     3d8:	c7 c0       	rjmp	.+398    	; 0x568 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTA_REG,Copy_u8PinId);break;
     3da:	ab e3       	ldi	r26, 0x3B	; 59
     3dc:	b0 e0       	ldi	r27, 0x00	; 0
     3de:	eb e3       	ldi	r30, 0x3B	; 59
     3e0:	f0 e0       	ldi	r31, 0x00	; 0
     3e2:	80 81       	ld	r24, Z
     3e4:	48 2f       	mov	r20, r24
     3e6:	8b 81       	ldd	r24, Y+3	; 0x03
     3e8:	28 2f       	mov	r18, r24
     3ea:	30 e0       	ldi	r19, 0x00	; 0
     3ec:	81 e0       	ldi	r24, 0x01	; 1
     3ee:	90 e0       	ldi	r25, 0x00	; 0
     3f0:	02 2e       	mov	r0, r18
     3f2:	02 c0       	rjmp	.+4      	; 0x3f8 <DIO_u8SetPinValue+0xd0>
     3f4:	88 0f       	add	r24, r24
     3f6:	99 1f       	adc	r25, r25
     3f8:	0a 94       	dec	r0
     3fa:	e2 f7       	brpl	.-8      	; 0x3f4 <DIO_u8SetPinValue+0xcc>
     3fc:	84 2b       	or	r24, r20
     3fe:	8c 93       	st	X, r24
     400:	b3 c0       	rjmp	.+358    	; 0x568 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
     402:	19 82       	std	Y+1, r1	; 0x01
     404:	b1 c0       	rjmp	.+354    	; 0x568 <DIO_u8SetPinValue+0x240>
				}
			break;
			case DIO_u8_PORTB:
				switch(Copy_u8PinValue)
     406:	8c 81       	ldd	r24, Y+4	; 0x04
     408:	28 2f       	mov	r18, r24
     40a:	30 e0       	ldi	r19, 0x00	; 0
     40c:	3a 87       	std	Y+10, r19	; 0x0a
     40e:	29 87       	std	Y+9, r18	; 0x09
     410:	89 85       	ldd	r24, Y+9	; 0x09
     412:	9a 85       	ldd	r25, Y+10	; 0x0a
     414:	00 97       	sbiw	r24, 0x00	; 0
     416:	31 f0       	breq	.+12     	; 0x424 <DIO_u8SetPinValue+0xfc>
     418:	29 85       	ldd	r18, Y+9	; 0x09
     41a:	3a 85       	ldd	r19, Y+10	; 0x0a
     41c:	21 30       	cpi	r18, 0x01	; 1
     41e:	31 05       	cpc	r19, r1
     420:	b1 f0       	breq	.+44     	; 0x44e <DIO_u8SetPinValue+0x126>
     422:	29 c0       	rjmp	.+82     	; 0x476 <DIO_u8SetPinValue+0x14e>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTB_REG,Copy_u8PinId);break;
     424:	a8 e3       	ldi	r26, 0x38	; 56
     426:	b0 e0       	ldi	r27, 0x00	; 0
     428:	e8 e3       	ldi	r30, 0x38	; 56
     42a:	f0 e0       	ldi	r31, 0x00	; 0
     42c:	80 81       	ld	r24, Z
     42e:	48 2f       	mov	r20, r24
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	28 2f       	mov	r18, r24
     434:	30 e0       	ldi	r19, 0x00	; 0
     436:	81 e0       	ldi	r24, 0x01	; 1
     438:	90 e0       	ldi	r25, 0x00	; 0
     43a:	02 2e       	mov	r0, r18
     43c:	02 c0       	rjmp	.+4      	; 0x442 <DIO_u8SetPinValue+0x11a>
     43e:	88 0f       	add	r24, r24
     440:	99 1f       	adc	r25, r25
     442:	0a 94       	dec	r0
     444:	e2 f7       	brpl	.-8      	; 0x43e <DIO_u8SetPinValue+0x116>
     446:	80 95       	com	r24
     448:	84 23       	and	r24, r20
     44a:	8c 93       	st	X, r24
     44c:	8d c0       	rjmp	.+282    	; 0x568 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTB_REG,Copy_u8PinId);break;
     44e:	a8 e3       	ldi	r26, 0x38	; 56
     450:	b0 e0       	ldi	r27, 0x00	; 0
     452:	e8 e3       	ldi	r30, 0x38	; 56
     454:	f0 e0       	ldi	r31, 0x00	; 0
     456:	80 81       	ld	r24, Z
     458:	48 2f       	mov	r20, r24
     45a:	8b 81       	ldd	r24, Y+3	; 0x03
     45c:	28 2f       	mov	r18, r24
     45e:	30 e0       	ldi	r19, 0x00	; 0
     460:	81 e0       	ldi	r24, 0x01	; 1
     462:	90 e0       	ldi	r25, 0x00	; 0
     464:	02 2e       	mov	r0, r18
     466:	02 c0       	rjmp	.+4      	; 0x46c <DIO_u8SetPinValue+0x144>
     468:	88 0f       	add	r24, r24
     46a:	99 1f       	adc	r25, r25
     46c:	0a 94       	dec	r0
     46e:	e2 f7       	brpl	.-8      	; 0x468 <DIO_u8SetPinValue+0x140>
     470:	84 2b       	or	r24, r20
     472:	8c 93       	st	X, r24
     474:	79 c0       	rjmp	.+242    	; 0x568 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
     476:	19 82       	std	Y+1, r1	; 0x01
     478:	77 c0       	rjmp	.+238    	; 0x568 <DIO_u8SetPinValue+0x240>
				}
			break;
			case DIO_u8_PORTC:
				switch(Copy_u8PinValue)
     47a:	8c 81       	ldd	r24, Y+4	; 0x04
     47c:	28 2f       	mov	r18, r24
     47e:	30 e0       	ldi	r19, 0x00	; 0
     480:	38 87       	std	Y+8, r19	; 0x08
     482:	2f 83       	std	Y+7, r18	; 0x07
     484:	8f 81       	ldd	r24, Y+7	; 0x07
     486:	98 85       	ldd	r25, Y+8	; 0x08
     488:	00 97       	sbiw	r24, 0x00	; 0
     48a:	31 f0       	breq	.+12     	; 0x498 <DIO_u8SetPinValue+0x170>
     48c:	2f 81       	ldd	r18, Y+7	; 0x07
     48e:	38 85       	ldd	r19, Y+8	; 0x08
     490:	21 30       	cpi	r18, 0x01	; 1
     492:	31 05       	cpc	r19, r1
     494:	b1 f0       	breq	.+44     	; 0x4c2 <DIO_u8SetPinValue+0x19a>
     496:	29 c0       	rjmp	.+82     	; 0x4ea <DIO_u8SetPinValue+0x1c2>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTC_REG,Copy_u8PinId);break;
     498:	a5 e3       	ldi	r26, 0x35	; 53
     49a:	b0 e0       	ldi	r27, 0x00	; 0
     49c:	e5 e3       	ldi	r30, 0x35	; 53
     49e:	f0 e0       	ldi	r31, 0x00	; 0
     4a0:	80 81       	ld	r24, Z
     4a2:	48 2f       	mov	r20, r24
     4a4:	8b 81       	ldd	r24, Y+3	; 0x03
     4a6:	28 2f       	mov	r18, r24
     4a8:	30 e0       	ldi	r19, 0x00	; 0
     4aa:	81 e0       	ldi	r24, 0x01	; 1
     4ac:	90 e0       	ldi	r25, 0x00	; 0
     4ae:	02 2e       	mov	r0, r18
     4b0:	02 c0       	rjmp	.+4      	; 0x4b6 <DIO_u8SetPinValue+0x18e>
     4b2:	88 0f       	add	r24, r24
     4b4:	99 1f       	adc	r25, r25
     4b6:	0a 94       	dec	r0
     4b8:	e2 f7       	brpl	.-8      	; 0x4b2 <DIO_u8SetPinValue+0x18a>
     4ba:	80 95       	com	r24
     4bc:	84 23       	and	r24, r20
     4be:	8c 93       	st	X, r24
     4c0:	53 c0       	rjmp	.+166    	; 0x568 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTC_REG,Copy_u8PinId);break;
     4c2:	a5 e3       	ldi	r26, 0x35	; 53
     4c4:	b0 e0       	ldi	r27, 0x00	; 0
     4c6:	e5 e3       	ldi	r30, 0x35	; 53
     4c8:	f0 e0       	ldi	r31, 0x00	; 0
     4ca:	80 81       	ld	r24, Z
     4cc:	48 2f       	mov	r20, r24
     4ce:	8b 81       	ldd	r24, Y+3	; 0x03
     4d0:	28 2f       	mov	r18, r24
     4d2:	30 e0       	ldi	r19, 0x00	; 0
     4d4:	81 e0       	ldi	r24, 0x01	; 1
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	02 2e       	mov	r0, r18
     4da:	02 c0       	rjmp	.+4      	; 0x4e0 <DIO_u8SetPinValue+0x1b8>
     4dc:	88 0f       	add	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	0a 94       	dec	r0
     4e2:	e2 f7       	brpl	.-8      	; 0x4dc <DIO_u8SetPinValue+0x1b4>
     4e4:	84 2b       	or	r24, r20
     4e6:	8c 93       	st	X, r24
     4e8:	3f c0       	rjmp	.+126    	; 0x568 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
     4ea:	19 82       	std	Y+1, r1	; 0x01
     4ec:	3d c0       	rjmp	.+122    	; 0x568 <DIO_u8SetPinValue+0x240>
				}
			break;
			case DIO_u8_PORTD:
				switch(Copy_u8PinValue)
     4ee:	8c 81       	ldd	r24, Y+4	; 0x04
     4f0:	28 2f       	mov	r18, r24
     4f2:	30 e0       	ldi	r19, 0x00	; 0
     4f4:	3e 83       	std	Y+6, r19	; 0x06
     4f6:	2d 83       	std	Y+5, r18	; 0x05
     4f8:	8d 81       	ldd	r24, Y+5	; 0x05
     4fa:	9e 81       	ldd	r25, Y+6	; 0x06
     4fc:	00 97       	sbiw	r24, 0x00	; 0
     4fe:	31 f0       	breq	.+12     	; 0x50c <DIO_u8SetPinValue+0x1e4>
     500:	2d 81       	ldd	r18, Y+5	; 0x05
     502:	3e 81       	ldd	r19, Y+6	; 0x06
     504:	21 30       	cpi	r18, 0x01	; 1
     506:	31 05       	cpc	r19, r1
     508:	b1 f0       	breq	.+44     	; 0x536 <DIO_u8SetPinValue+0x20e>
     50a:	29 c0       	rjmp	.+82     	; 0x55e <DIO_u8SetPinValue+0x236>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTD_REG,Copy_u8PinId);break;
     50c:	a2 e3       	ldi	r26, 0x32	; 50
     50e:	b0 e0       	ldi	r27, 0x00	; 0
     510:	e2 e3       	ldi	r30, 0x32	; 50
     512:	f0 e0       	ldi	r31, 0x00	; 0
     514:	80 81       	ld	r24, Z
     516:	48 2f       	mov	r20, r24
     518:	8b 81       	ldd	r24, Y+3	; 0x03
     51a:	28 2f       	mov	r18, r24
     51c:	30 e0       	ldi	r19, 0x00	; 0
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	02 2e       	mov	r0, r18
     524:	02 c0       	rjmp	.+4      	; 0x52a <DIO_u8SetPinValue+0x202>
     526:	88 0f       	add	r24, r24
     528:	99 1f       	adc	r25, r25
     52a:	0a 94       	dec	r0
     52c:	e2 f7       	brpl	.-8      	; 0x526 <DIO_u8SetPinValue+0x1fe>
     52e:	80 95       	com	r24
     530:	84 23       	and	r24, r20
     532:	8c 93       	st	X, r24
     534:	19 c0       	rjmp	.+50     	; 0x568 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTD_REG,Copy_u8PinId);break;
     536:	a2 e3       	ldi	r26, 0x32	; 50
     538:	b0 e0       	ldi	r27, 0x00	; 0
     53a:	e2 e3       	ldi	r30, 0x32	; 50
     53c:	f0 e0       	ldi	r31, 0x00	; 0
     53e:	80 81       	ld	r24, Z
     540:	48 2f       	mov	r20, r24
     542:	8b 81       	ldd	r24, Y+3	; 0x03
     544:	28 2f       	mov	r18, r24
     546:	30 e0       	ldi	r19, 0x00	; 0
     548:	81 e0       	ldi	r24, 0x01	; 1
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	02 2e       	mov	r0, r18
     54e:	02 c0       	rjmp	.+4      	; 0x554 <DIO_u8SetPinValue+0x22c>
     550:	88 0f       	add	r24, r24
     552:	99 1f       	adc	r25, r25
     554:	0a 94       	dec	r0
     556:	e2 f7       	brpl	.-8      	; 0x550 <DIO_u8SetPinValue+0x228>
     558:	84 2b       	or	r24, r20
     55a:	8c 93       	st	X, r24
     55c:	05 c0       	rjmp	.+10     	; 0x568 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
     55e:	19 82       	std	Y+1, r1	; 0x01
     560:	03 c0       	rjmp	.+6      	; 0x568 <DIO_u8SetPinValue+0x240>
				}
			break;
			default:
				Local_u8ErrorState = STD_TYPES_NOK;
     562:	19 82       	std	Y+1, r1	; 0x01
     564:	01 c0       	rjmp	.+2      	; 0x568 <DIO_u8SetPinValue+0x240>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
     566:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
     568:	89 81       	ldd	r24, Y+1	; 0x01
}
     56a:	2e 96       	adiw	r28, 0x0e	; 14
     56c:	0f b6       	in	r0, 0x3f	; 63
     56e:	f8 94       	cli
     570:	de bf       	out	0x3e, r29	; 62
     572:	0f be       	out	0x3f, r0	; 63
     574:	cd bf       	out	0x3d, r28	; 61
     576:	cf 91       	pop	r28
     578:	df 91       	pop	r29
     57a:	08 95       	ret

0000057c <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 *Copy_pu8ReturnedPinValue)
{
     57c:	df 93       	push	r29
     57e:	cf 93       	push	r28
     580:	cd b7       	in	r28, 0x3d	; 61
     582:	de b7       	in	r29, 0x3e	; 62
     584:	28 97       	sbiw	r28, 0x08	; 8
     586:	0f b6       	in	r0, 0x3f	; 63
     588:	f8 94       	cli
     58a:	de bf       	out	0x3e, r29	; 62
     58c:	0f be       	out	0x3f, r0	; 63
     58e:	cd bf       	out	0x3d, r28	; 61
     590:	8b 83       	std	Y+3, r24	; 0x03
     592:	6c 83       	std	Y+4, r22	; 0x04
     594:	5e 83       	std	Y+6, r21	; 0x06
     596:	4d 83       	std	Y+5, r20	; 0x05
	u8 Local_u8ErrorState = STD_TYPES_OK;
     598:	81 e0       	ldi	r24, 0x01	; 1
     59a:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8PinValue;
	if((Copy_u8PortId <= DIO_u8_PORTD ) && (Copy_u8PinId <= DIO_u8_PIN7) && (Copy_pu8ReturnedPinValue != NULL))
     59c:	8b 81       	ldd	r24, Y+3	; 0x03
     59e:	84 30       	cpi	r24, 0x04	; 4
     5a0:	08 f0       	brcs	.+2      	; 0x5a4 <DIO_u8GetPinValue+0x28>
     5a2:	a1 c0       	rjmp	.+322    	; 0x6e6 <DIO_u8GetPinValue+0x16a>
     5a4:	8c 81       	ldd	r24, Y+4	; 0x04
     5a6:	88 30       	cpi	r24, 0x08	; 8
     5a8:	08 f0       	brcs	.+2      	; 0x5ac <DIO_u8GetPinValue+0x30>
     5aa:	9d c0       	rjmp	.+314    	; 0x6e6 <DIO_u8GetPinValue+0x16a>
     5ac:	8d 81       	ldd	r24, Y+5	; 0x05
     5ae:	9e 81       	ldd	r25, Y+6	; 0x06
     5b0:	00 97       	sbiw	r24, 0x00	; 0
     5b2:	09 f4       	brne	.+2      	; 0x5b6 <DIO_u8GetPinValue+0x3a>
     5b4:	98 c0       	rjmp	.+304    	; 0x6e6 <DIO_u8GetPinValue+0x16a>
	{
		switch(Copy_u8PortId)
     5b6:	8b 81       	ldd	r24, Y+3	; 0x03
     5b8:	28 2f       	mov	r18, r24
     5ba:	30 e0       	ldi	r19, 0x00	; 0
     5bc:	38 87       	std	Y+8, r19	; 0x08
     5be:	2f 83       	std	Y+7, r18	; 0x07
     5c0:	4f 81       	ldd	r20, Y+7	; 0x07
     5c2:	58 85       	ldd	r21, Y+8	; 0x08
     5c4:	41 30       	cpi	r20, 0x01	; 1
     5c6:	51 05       	cpc	r21, r1
     5c8:	a9 f1       	breq	.+106    	; 0x634 <DIO_u8GetPinValue+0xb8>
     5ca:	8f 81       	ldd	r24, Y+7	; 0x07
     5cc:	98 85       	ldd	r25, Y+8	; 0x08
     5ce:	82 30       	cpi	r24, 0x02	; 2
     5d0:	91 05       	cpc	r25, r1
     5d2:	34 f4       	brge	.+12     	; 0x5e0 <DIO_u8GetPinValue+0x64>
     5d4:	2f 81       	ldd	r18, Y+7	; 0x07
     5d6:	38 85       	ldd	r19, Y+8	; 0x08
     5d8:	21 15       	cp	r18, r1
     5da:	31 05       	cpc	r19, r1
     5dc:	71 f0       	breq	.+28     	; 0x5fa <DIO_u8GetPinValue+0x7e>
     5de:	81 c0       	rjmp	.+258    	; 0x6e2 <DIO_u8GetPinValue+0x166>
     5e0:	4f 81       	ldd	r20, Y+7	; 0x07
     5e2:	58 85       	ldd	r21, Y+8	; 0x08
     5e4:	42 30       	cpi	r20, 0x02	; 2
     5e6:	51 05       	cpc	r21, r1
     5e8:	09 f4       	brne	.+2      	; 0x5ec <DIO_u8GetPinValue+0x70>
     5ea:	41 c0       	rjmp	.+130    	; 0x66e <DIO_u8GetPinValue+0xf2>
     5ec:	8f 81       	ldd	r24, Y+7	; 0x07
     5ee:	98 85       	ldd	r25, Y+8	; 0x08
     5f0:	83 30       	cpi	r24, 0x03	; 3
     5f2:	91 05       	cpc	r25, r1
     5f4:	09 f4       	brne	.+2      	; 0x5f8 <DIO_u8GetPinValue+0x7c>
     5f6:	58 c0       	rjmp	.+176    	; 0x6a8 <DIO_u8GetPinValue+0x12c>
     5f8:	74 c0       	rjmp	.+232    	; 0x6e2 <DIO_u8GetPinValue+0x166>
		{
			case DIO_u8_PORTA: Local_u8PinValue = GET_BIT(DIO_u8_PINA_REG,Copy_u8PinId);
     5fa:	e9 e3       	ldi	r30, 0x39	; 57
     5fc:	f0 e0       	ldi	r31, 0x00	; 0
     5fe:	80 81       	ld	r24, Z
     600:	28 2f       	mov	r18, r24
     602:	30 e0       	ldi	r19, 0x00	; 0
     604:	8c 81       	ldd	r24, Y+4	; 0x04
     606:	88 2f       	mov	r24, r24
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	a9 01       	movw	r20, r18
     60c:	02 c0       	rjmp	.+4      	; 0x612 <DIO_u8GetPinValue+0x96>
     60e:	55 95       	asr	r21
     610:	47 95       	ror	r20
     612:	8a 95       	dec	r24
     614:	e2 f7       	brpl	.-8      	; 0x60e <DIO_u8GetPinValue+0x92>
     616:	ca 01       	movw	r24, r20
     618:	81 70       	andi	r24, 0x01	; 1
     61a:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
     61c:	89 81       	ldd	r24, Y+1	; 0x01
     61e:	88 23       	and	r24, r24
     620:	21 f4       	brne	.+8      	; 0x62a <DIO_u8GetPinValue+0xae>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
     622:	ed 81       	ldd	r30, Y+5	; 0x05
     624:	fe 81       	ldd	r31, Y+6	; 0x06
     626:	10 82       	st	Z, r1
     628:	5f c0       	rjmp	.+190    	; 0x6e8 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
     62a:	ed 81       	ldd	r30, Y+5	; 0x05
     62c:	fe 81       	ldd	r31, Y+6	; 0x06
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	80 83       	st	Z, r24
     632:	5a c0       	rjmp	.+180    	; 0x6e8 <DIO_u8GetPinValue+0x16c>
				}
			break;
			case DIO_u8_PORTB: Local_u8PinValue = GET_BIT(DIO_u8_PINB_REG,Copy_u8PinId);
     634:	e6 e3       	ldi	r30, 0x36	; 54
     636:	f0 e0       	ldi	r31, 0x00	; 0
     638:	80 81       	ld	r24, Z
     63a:	28 2f       	mov	r18, r24
     63c:	30 e0       	ldi	r19, 0x00	; 0
     63e:	8c 81       	ldd	r24, Y+4	; 0x04
     640:	88 2f       	mov	r24, r24
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	a9 01       	movw	r20, r18
     646:	02 c0       	rjmp	.+4      	; 0x64c <DIO_u8GetPinValue+0xd0>
     648:	55 95       	asr	r21
     64a:	47 95       	ror	r20
     64c:	8a 95       	dec	r24
     64e:	e2 f7       	brpl	.-8      	; 0x648 <DIO_u8GetPinValue+0xcc>
     650:	ca 01       	movw	r24, r20
     652:	81 70       	andi	r24, 0x01	; 1
     654:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
     656:	89 81       	ldd	r24, Y+1	; 0x01
     658:	88 23       	and	r24, r24
     65a:	21 f4       	brne	.+8      	; 0x664 <DIO_u8GetPinValue+0xe8>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
     65c:	ed 81       	ldd	r30, Y+5	; 0x05
     65e:	fe 81       	ldd	r31, Y+6	; 0x06
     660:	10 82       	st	Z, r1
     662:	42 c0       	rjmp	.+132    	; 0x6e8 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
     664:	ed 81       	ldd	r30, Y+5	; 0x05
     666:	fe 81       	ldd	r31, Y+6	; 0x06
     668:	81 e0       	ldi	r24, 0x01	; 1
     66a:	80 83       	st	Z, r24
     66c:	3d c0       	rjmp	.+122    	; 0x6e8 <DIO_u8GetPinValue+0x16c>
				}
			break;
			case DIO_u8_PORTC: Local_u8PinValue = GET_BIT(DIO_u8_PINC_REG,Copy_u8PinId);
     66e:	e3 e3       	ldi	r30, 0x33	; 51
     670:	f0 e0       	ldi	r31, 0x00	; 0
     672:	80 81       	ld	r24, Z
     674:	28 2f       	mov	r18, r24
     676:	30 e0       	ldi	r19, 0x00	; 0
     678:	8c 81       	ldd	r24, Y+4	; 0x04
     67a:	88 2f       	mov	r24, r24
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	a9 01       	movw	r20, r18
     680:	02 c0       	rjmp	.+4      	; 0x686 <DIO_u8GetPinValue+0x10a>
     682:	55 95       	asr	r21
     684:	47 95       	ror	r20
     686:	8a 95       	dec	r24
     688:	e2 f7       	brpl	.-8      	; 0x682 <DIO_u8GetPinValue+0x106>
     68a:	ca 01       	movw	r24, r20
     68c:	81 70       	andi	r24, 0x01	; 1
     68e:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
     690:	89 81       	ldd	r24, Y+1	; 0x01
     692:	88 23       	and	r24, r24
     694:	21 f4       	brne	.+8      	; 0x69e <DIO_u8GetPinValue+0x122>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
     696:	ed 81       	ldd	r30, Y+5	; 0x05
     698:	fe 81       	ldd	r31, Y+6	; 0x06
     69a:	10 82       	st	Z, r1
     69c:	25 c0       	rjmp	.+74     	; 0x6e8 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
     69e:	ed 81       	ldd	r30, Y+5	; 0x05
     6a0:	fe 81       	ldd	r31, Y+6	; 0x06
     6a2:	81 e0       	ldi	r24, 0x01	; 1
     6a4:	80 83       	st	Z, r24
     6a6:	20 c0       	rjmp	.+64     	; 0x6e8 <DIO_u8GetPinValue+0x16c>
				}
			break;
			case DIO_u8_PORTD: Local_u8PinValue = GET_BIT(DIO_u8_PIND_REG,Copy_u8PinId);
     6a8:	e0 e3       	ldi	r30, 0x30	; 48
     6aa:	f0 e0       	ldi	r31, 0x00	; 0
     6ac:	80 81       	ld	r24, Z
     6ae:	28 2f       	mov	r18, r24
     6b0:	30 e0       	ldi	r19, 0x00	; 0
     6b2:	8c 81       	ldd	r24, Y+4	; 0x04
     6b4:	88 2f       	mov	r24, r24
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	a9 01       	movw	r20, r18
     6ba:	02 c0       	rjmp	.+4      	; 0x6c0 <DIO_u8GetPinValue+0x144>
     6bc:	55 95       	asr	r21
     6be:	47 95       	ror	r20
     6c0:	8a 95       	dec	r24
     6c2:	e2 f7       	brpl	.-8      	; 0x6bc <DIO_u8GetPinValue+0x140>
     6c4:	ca 01       	movw	r24, r20
     6c6:	81 70       	andi	r24, 0x01	; 1
     6c8:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
     6ca:	89 81       	ldd	r24, Y+1	; 0x01
     6cc:	88 23       	and	r24, r24
     6ce:	21 f4       	brne	.+8      	; 0x6d8 <DIO_u8GetPinValue+0x15c>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
     6d0:	ed 81       	ldd	r30, Y+5	; 0x05
     6d2:	fe 81       	ldd	r31, Y+6	; 0x06
     6d4:	10 82       	st	Z, r1
     6d6:	08 c0       	rjmp	.+16     	; 0x6e8 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
     6d8:	ed 81       	ldd	r30, Y+5	; 0x05
     6da:	fe 81       	ldd	r31, Y+6	; 0x06
     6dc:	81 e0       	ldi	r24, 0x01	; 1
     6de:	80 83       	st	Z, r24
     6e0:	03 c0       	rjmp	.+6      	; 0x6e8 <DIO_u8GetPinValue+0x16c>
				}
			break;
			default: Local_u8ErrorState = STD_TYPES_NOK;
     6e2:	1a 82       	std	Y+2, r1	; 0x02
     6e4:	01 c0       	rjmp	.+2      	; 0x6e8 <DIO_u8GetPinValue+0x16c>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
     6e6:	1a 82       	std	Y+2, r1	; 0x02
	}
	return Local_u8ErrorState;
     6e8:	8a 81       	ldd	r24, Y+2	; 0x02
}
     6ea:	28 96       	adiw	r28, 0x08	; 8
     6ec:	0f b6       	in	r0, 0x3f	; 63
     6ee:	f8 94       	cli
     6f0:	de bf       	out	0x3e, r29	; 62
     6f2:	0f be       	out	0x3f, r0	; 63
     6f4:	cd bf       	out	0x3d, r28	; 61
     6f6:	cf 91       	pop	r28
     6f8:	df 91       	pop	r29
     6fa:	08 95       	ret

000006fc <DIO_u8SetPortDirection>:

u8 DIO_u8SetPortDirection(u8 Copy_u8PortId, u8 Copy_u8PortDirection)
{
     6fc:	df 93       	push	r29
     6fe:	cf 93       	push	r28
     700:	cd b7       	in	r28, 0x3d	; 61
     702:	de b7       	in	r29, 0x3e	; 62
     704:	2d 97       	sbiw	r28, 0x0d	; 13
     706:	0f b6       	in	r0, 0x3f	; 63
     708:	f8 94       	cli
     70a:	de bf       	out	0x3e, r29	; 62
     70c:	0f be       	out	0x3f, r0	; 63
     70e:	cd bf       	out	0x3d, r28	; 61
     710:	8a 83       	std	Y+2, r24	; 0x02
     712:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
     714:	81 e0       	ldi	r24, 0x01	; 1
     716:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection == DIO_u8_INPUT) || (Copy_u8PortDirection == DIO_u8_OUTPUT))
     718:	8b 81       	ldd	r24, Y+3	; 0x03
     71a:	88 23       	and	r24, r24
     71c:	21 f0       	breq	.+8      	; 0x726 <DIO_u8SetPortDirection+0x2a>
     71e:	8b 81       	ldd	r24, Y+3	; 0x03
     720:	81 30       	cpi	r24, 0x01	; 1
     722:	09 f0       	breq	.+2      	; 0x726 <DIO_u8SetPortDirection+0x2a>
     724:	82 c0       	rjmp	.+260    	; 0x82a <DIO_u8SetPortDirection+0x12e>
	{
		switch(Copy_u8PortId)
     726:	8a 81       	ldd	r24, Y+2	; 0x02
     728:	28 2f       	mov	r18, r24
     72a:	30 e0       	ldi	r19, 0x00	; 0
     72c:	3d 87       	std	Y+13, r19	; 0x0d
     72e:	2c 87       	std	Y+12, r18	; 0x0c
     730:	8c 85       	ldd	r24, Y+12	; 0x0c
     732:	9d 85       	ldd	r25, Y+13	; 0x0d
     734:	81 30       	cpi	r24, 0x01	; 1
     736:	91 05       	cpc	r25, r1
     738:	71 f1       	breq	.+92     	; 0x796 <DIO_u8SetPortDirection+0x9a>
     73a:	2c 85       	ldd	r18, Y+12	; 0x0c
     73c:	3d 85       	ldd	r19, Y+13	; 0x0d
     73e:	22 30       	cpi	r18, 0x02	; 2
     740:	31 05       	cpc	r19, r1
     742:	2c f4       	brge	.+10     	; 0x74e <DIO_u8SetPortDirection+0x52>
     744:	8c 85       	ldd	r24, Y+12	; 0x0c
     746:	9d 85       	ldd	r25, Y+13	; 0x0d
     748:	00 97       	sbiw	r24, 0x00	; 0
     74a:	69 f0       	breq	.+26     	; 0x766 <DIO_u8SetPortDirection+0x6a>
     74c:	6c c0       	rjmp	.+216    	; 0x826 <DIO_u8SetPortDirection+0x12a>
     74e:	2c 85       	ldd	r18, Y+12	; 0x0c
     750:	3d 85       	ldd	r19, Y+13	; 0x0d
     752:	22 30       	cpi	r18, 0x02	; 2
     754:	31 05       	cpc	r19, r1
     756:	b9 f1       	breq	.+110    	; 0x7c6 <DIO_u8SetPortDirection+0xca>
     758:	8c 85       	ldd	r24, Y+12	; 0x0c
     75a:	9d 85       	ldd	r25, Y+13	; 0x0d
     75c:	83 30       	cpi	r24, 0x03	; 3
     75e:	91 05       	cpc	r25, r1
     760:	09 f4       	brne	.+2      	; 0x764 <DIO_u8SetPortDirection+0x68>
     762:	49 c0       	rjmp	.+146    	; 0x7f6 <DIO_u8SetPortDirection+0xfa>
     764:	60 c0       	rjmp	.+192    	; 0x826 <DIO_u8SetPortDirection+0x12a>
		{
			case DIO_u8_PORTA:
				switch(Copy_u8PortDirection)
     766:	8b 81       	ldd	r24, Y+3	; 0x03
     768:	28 2f       	mov	r18, r24
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	3b 87       	std	Y+11, r19	; 0x0b
     76e:	2a 87       	std	Y+10, r18	; 0x0a
     770:	8a 85       	ldd	r24, Y+10	; 0x0a
     772:	9b 85       	ldd	r25, Y+11	; 0x0b
     774:	00 97       	sbiw	r24, 0x00	; 0
     776:	31 f0       	breq	.+12     	; 0x784 <DIO_u8SetPortDirection+0x88>
     778:	2a 85       	ldd	r18, Y+10	; 0x0a
     77a:	3b 85       	ldd	r19, Y+11	; 0x0b
     77c:	21 30       	cpi	r18, 0x01	; 1
     77e:	31 05       	cpc	r19, r1
     780:	29 f0       	breq	.+10     	; 0x78c <DIO_u8SetPortDirection+0x90>
     782:	54 c0       	rjmp	.+168    	; 0x82c <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRA_REG = 0x00;break;
     784:	ea e3       	ldi	r30, 0x3A	; 58
     786:	f0 e0       	ldi	r31, 0x00	; 0
     788:	10 82       	st	Z, r1
     78a:	50 c0       	rjmp	.+160    	; 0x82c <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRA_REG = 0xFF;break;
     78c:	ea e3       	ldi	r30, 0x3A	; 58
     78e:	f0 e0       	ldi	r31, 0x00	; 0
     790:	8f ef       	ldi	r24, 0xFF	; 255
     792:	80 83       	st	Z, r24
     794:	4b c0       	rjmp	.+150    	; 0x82c <DIO_u8SetPortDirection+0x130>
				}
			break;
			case DIO_u8_PORTB:
				switch(Copy_u8PortDirection)
     796:	8b 81       	ldd	r24, Y+3	; 0x03
     798:	28 2f       	mov	r18, r24
     79a:	30 e0       	ldi	r19, 0x00	; 0
     79c:	39 87       	std	Y+9, r19	; 0x09
     79e:	28 87       	std	Y+8, r18	; 0x08
     7a0:	88 85       	ldd	r24, Y+8	; 0x08
     7a2:	99 85       	ldd	r25, Y+9	; 0x09
     7a4:	00 97       	sbiw	r24, 0x00	; 0
     7a6:	31 f0       	breq	.+12     	; 0x7b4 <DIO_u8SetPortDirection+0xb8>
     7a8:	28 85       	ldd	r18, Y+8	; 0x08
     7aa:	39 85       	ldd	r19, Y+9	; 0x09
     7ac:	21 30       	cpi	r18, 0x01	; 1
     7ae:	31 05       	cpc	r19, r1
     7b0:	29 f0       	breq	.+10     	; 0x7bc <DIO_u8SetPortDirection+0xc0>
     7b2:	3c c0       	rjmp	.+120    	; 0x82c <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRB_REG = 0x00;break;
     7b4:	e7 e3       	ldi	r30, 0x37	; 55
     7b6:	f0 e0       	ldi	r31, 0x00	; 0
     7b8:	10 82       	st	Z, r1
     7ba:	38 c0       	rjmp	.+112    	; 0x82c <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRB_REG = 0xFF;break;
     7bc:	e7 e3       	ldi	r30, 0x37	; 55
     7be:	f0 e0       	ldi	r31, 0x00	; 0
     7c0:	8f ef       	ldi	r24, 0xFF	; 255
     7c2:	80 83       	st	Z, r24
     7c4:	33 c0       	rjmp	.+102    	; 0x82c <DIO_u8SetPortDirection+0x130>
				}
			break;
			case DIO_u8_PORTC:
				switch(Copy_u8PortDirection)
     7c6:	8b 81       	ldd	r24, Y+3	; 0x03
     7c8:	28 2f       	mov	r18, r24
     7ca:	30 e0       	ldi	r19, 0x00	; 0
     7cc:	3f 83       	std	Y+7, r19	; 0x07
     7ce:	2e 83       	std	Y+6, r18	; 0x06
     7d0:	8e 81       	ldd	r24, Y+6	; 0x06
     7d2:	9f 81       	ldd	r25, Y+7	; 0x07
     7d4:	00 97       	sbiw	r24, 0x00	; 0
     7d6:	31 f0       	breq	.+12     	; 0x7e4 <DIO_u8SetPortDirection+0xe8>
     7d8:	2e 81       	ldd	r18, Y+6	; 0x06
     7da:	3f 81       	ldd	r19, Y+7	; 0x07
     7dc:	21 30       	cpi	r18, 0x01	; 1
     7de:	31 05       	cpc	r19, r1
     7e0:	29 f0       	breq	.+10     	; 0x7ec <DIO_u8SetPortDirection+0xf0>
     7e2:	24 c0       	rjmp	.+72     	; 0x82c <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRC_REG = 0x00;break;
     7e4:	e4 e3       	ldi	r30, 0x34	; 52
     7e6:	f0 e0       	ldi	r31, 0x00	; 0
     7e8:	10 82       	st	Z, r1
     7ea:	20 c0       	rjmp	.+64     	; 0x82c <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRC_REG = 0xFF;break;
     7ec:	e4 e3       	ldi	r30, 0x34	; 52
     7ee:	f0 e0       	ldi	r31, 0x00	; 0
     7f0:	8f ef       	ldi	r24, 0xFF	; 255
     7f2:	80 83       	st	Z, r24
     7f4:	1b c0       	rjmp	.+54     	; 0x82c <DIO_u8SetPortDirection+0x130>
				}
			break;
			case DIO_u8_PORTD:
				switch(Copy_u8PortDirection)
     7f6:	8b 81       	ldd	r24, Y+3	; 0x03
     7f8:	28 2f       	mov	r18, r24
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	3d 83       	std	Y+5, r19	; 0x05
     7fe:	2c 83       	std	Y+4, r18	; 0x04
     800:	8c 81       	ldd	r24, Y+4	; 0x04
     802:	9d 81       	ldd	r25, Y+5	; 0x05
     804:	00 97       	sbiw	r24, 0x00	; 0
     806:	31 f0       	breq	.+12     	; 0x814 <DIO_u8SetPortDirection+0x118>
     808:	2c 81       	ldd	r18, Y+4	; 0x04
     80a:	3d 81       	ldd	r19, Y+5	; 0x05
     80c:	21 30       	cpi	r18, 0x01	; 1
     80e:	31 05       	cpc	r19, r1
     810:	29 f0       	breq	.+10     	; 0x81c <DIO_u8SetPortDirection+0x120>
     812:	0c c0       	rjmp	.+24     	; 0x82c <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRD_REG = 0x00;break;
     814:	e1 e3       	ldi	r30, 0x31	; 49
     816:	f0 e0       	ldi	r31, 0x00	; 0
     818:	10 82       	st	Z, r1
     81a:	08 c0       	rjmp	.+16     	; 0x82c <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRD_REG = 0xFF;break;
     81c:	e1 e3       	ldi	r30, 0x31	; 49
     81e:	f0 e0       	ldi	r31, 0x00	; 0
     820:	8f ef       	ldi	r24, 0xFF	; 255
     822:	80 83       	st	Z, r24
     824:	03 c0       	rjmp	.+6      	; 0x82c <DIO_u8SetPortDirection+0x130>
				}
			break;
			default:Local_u8ErrorState = STD_TYPES_NOK;
     826:	19 82       	std	Y+1, r1	; 0x01
     828:	01 c0       	rjmp	.+2      	; 0x82c <DIO_u8SetPortDirection+0x130>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
     82a:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
     82c:	89 81       	ldd	r24, Y+1	; 0x01
}
     82e:	2d 96       	adiw	r28, 0x0d	; 13
     830:	0f b6       	in	r0, 0x3f	; 63
     832:	f8 94       	cli
     834:	de bf       	out	0x3e, r29	; 62
     836:	0f be       	out	0x3f, r0	; 63
     838:	cd bf       	out	0x3d, r28	; 61
     83a:	cf 91       	pop	r28
     83c:	df 91       	pop	r29
     83e:	08 95       	ret

00000840 <DIO_u8SetPortValue>:

u8 DIO_u8SetPortValue(u8 Copy_u8PortId, u8 Copy_u8PortValue)
{
     840:	df 93       	push	r29
     842:	cf 93       	push	r28
     844:	00 d0       	rcall	.+0      	; 0x846 <DIO_u8SetPortValue+0x6>
     846:	00 d0       	rcall	.+0      	; 0x848 <DIO_u8SetPortValue+0x8>
     848:	0f 92       	push	r0
     84a:	cd b7       	in	r28, 0x3d	; 61
     84c:	de b7       	in	r29, 0x3e	; 62
     84e:	8a 83       	std	Y+2, r24	; 0x02
     850:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortId)
     856:	8a 81       	ldd	r24, Y+2	; 0x02
     858:	28 2f       	mov	r18, r24
     85a:	30 e0       	ldi	r19, 0x00	; 0
     85c:	3d 83       	std	Y+5, r19	; 0x05
     85e:	2c 83       	std	Y+4, r18	; 0x04
     860:	8c 81       	ldd	r24, Y+4	; 0x04
     862:	9d 81       	ldd	r25, Y+5	; 0x05
     864:	81 30       	cpi	r24, 0x01	; 1
     866:	91 05       	cpc	r25, r1
     868:	d1 f0       	breq	.+52     	; 0x89e <__stack+0x3f>
     86a:	2c 81       	ldd	r18, Y+4	; 0x04
     86c:	3d 81       	ldd	r19, Y+5	; 0x05
     86e:	22 30       	cpi	r18, 0x02	; 2
     870:	31 05       	cpc	r19, r1
     872:	2c f4       	brge	.+10     	; 0x87e <__stack+0x1f>
     874:	8c 81       	ldd	r24, Y+4	; 0x04
     876:	9d 81       	ldd	r25, Y+5	; 0x05
     878:	00 97       	sbiw	r24, 0x00	; 0
     87a:	61 f0       	breq	.+24     	; 0x894 <__stack+0x35>
     87c:	1f c0       	rjmp	.+62     	; 0x8bc <__stack+0x5d>
     87e:	2c 81       	ldd	r18, Y+4	; 0x04
     880:	3d 81       	ldd	r19, Y+5	; 0x05
     882:	22 30       	cpi	r18, 0x02	; 2
     884:	31 05       	cpc	r19, r1
     886:	81 f0       	breq	.+32     	; 0x8a8 <__stack+0x49>
     888:	8c 81       	ldd	r24, Y+4	; 0x04
     88a:	9d 81       	ldd	r25, Y+5	; 0x05
     88c:	83 30       	cpi	r24, 0x03	; 3
     88e:	91 05       	cpc	r25, r1
     890:	81 f0       	breq	.+32     	; 0x8b2 <__stack+0x53>
     892:	14 c0       	rjmp	.+40     	; 0x8bc <__stack+0x5d>
	{
		case DIO_u8_PORTA:DIO_u8_PORTA_REG = Copy_u8PortValue; break;
     894:	eb e3       	ldi	r30, 0x3B	; 59
     896:	f0 e0       	ldi	r31, 0x00	; 0
     898:	8b 81       	ldd	r24, Y+3	; 0x03
     89a:	80 83       	st	Z, r24
     89c:	10 c0       	rjmp	.+32     	; 0x8be <__stack+0x5f>
		case DIO_u8_PORTB:DIO_u8_PORTB_REG = Copy_u8PortValue; break;
     89e:	e8 e3       	ldi	r30, 0x38	; 56
     8a0:	f0 e0       	ldi	r31, 0x00	; 0
     8a2:	8b 81       	ldd	r24, Y+3	; 0x03
     8a4:	80 83       	st	Z, r24
     8a6:	0b c0       	rjmp	.+22     	; 0x8be <__stack+0x5f>
		case DIO_u8_PORTC:DIO_u8_PORTC_REG = Copy_u8PortValue; break;
     8a8:	e5 e3       	ldi	r30, 0x35	; 53
     8aa:	f0 e0       	ldi	r31, 0x00	; 0
     8ac:	8b 81       	ldd	r24, Y+3	; 0x03
     8ae:	80 83       	st	Z, r24
     8b0:	06 c0       	rjmp	.+12     	; 0x8be <__stack+0x5f>
		case DIO_u8_PORTD:DIO_u8_PORTD_REG = Copy_u8PortValue; break;
     8b2:	e2 e3       	ldi	r30, 0x32	; 50
     8b4:	f0 e0       	ldi	r31, 0x00	; 0
     8b6:	8b 81       	ldd	r24, Y+3	; 0x03
     8b8:	80 83       	st	Z, r24
     8ba:	01 c0       	rjmp	.+2      	; 0x8be <__stack+0x5f>
		default:Local_u8ErrorState = STD_TYPES_NOK;
     8bc:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
     8be:	89 81       	ldd	r24, Y+1	; 0x01
}
     8c0:	0f 90       	pop	r0
     8c2:	0f 90       	pop	r0
     8c4:	0f 90       	pop	r0
     8c6:	0f 90       	pop	r0
     8c8:	0f 90       	pop	r0
     8ca:	cf 91       	pop	r28
     8cc:	df 91       	pop	r29
     8ce:	08 95       	ret

000008d0 <DIO_u8GetPortValue>:

u8 DIO_u8GetPortValue(u8 Copy_u8PortId, u8 *Copy_pu8ReturnedPortValue)
{
     8d0:	df 93       	push	r29
     8d2:	cf 93       	push	r28
     8d4:	00 d0       	rcall	.+0      	; 0x8d6 <DIO_u8GetPortValue+0x6>
     8d6:	00 d0       	rcall	.+0      	; 0x8d8 <DIO_u8GetPortValue+0x8>
     8d8:	00 d0       	rcall	.+0      	; 0x8da <DIO_u8GetPortValue+0xa>
     8da:	cd b7       	in	r28, 0x3d	; 61
     8dc:	de b7       	in	r29, 0x3e	; 62
     8de:	8a 83       	std	Y+2, r24	; 0x02
     8e0:	7c 83       	std	Y+4, r23	; 0x04
     8e2:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_pu8ReturnedPortValue != NULL)
     8e8:	8b 81       	ldd	r24, Y+3	; 0x03
     8ea:	9c 81       	ldd	r25, Y+4	; 0x04
     8ec:	00 97       	sbiw	r24, 0x00	; 0
     8ee:	e9 f1       	breq	.+122    	; 0x96a <DIO_u8GetPortValue+0x9a>
	{
		switch(Copy_u8PortId)
     8f0:	8a 81       	ldd	r24, Y+2	; 0x02
     8f2:	28 2f       	mov	r18, r24
     8f4:	30 e0       	ldi	r19, 0x00	; 0
     8f6:	3e 83       	std	Y+6, r19	; 0x06
     8f8:	2d 83       	std	Y+5, r18	; 0x05
     8fa:	8d 81       	ldd	r24, Y+5	; 0x05
     8fc:	9e 81       	ldd	r25, Y+6	; 0x06
     8fe:	81 30       	cpi	r24, 0x01	; 1
     900:	91 05       	cpc	r25, r1
     902:	e1 f0       	breq	.+56     	; 0x93c <DIO_u8GetPortValue+0x6c>
     904:	2d 81       	ldd	r18, Y+5	; 0x05
     906:	3e 81       	ldd	r19, Y+6	; 0x06
     908:	22 30       	cpi	r18, 0x02	; 2
     90a:	31 05       	cpc	r19, r1
     90c:	2c f4       	brge	.+10     	; 0x918 <DIO_u8GetPortValue+0x48>
     90e:	8d 81       	ldd	r24, Y+5	; 0x05
     910:	9e 81       	ldd	r25, Y+6	; 0x06
     912:	00 97       	sbiw	r24, 0x00	; 0
     914:	61 f0       	breq	.+24     	; 0x92e <DIO_u8GetPortValue+0x5e>
     916:	27 c0       	rjmp	.+78     	; 0x966 <DIO_u8GetPortValue+0x96>
     918:	2d 81       	ldd	r18, Y+5	; 0x05
     91a:	3e 81       	ldd	r19, Y+6	; 0x06
     91c:	22 30       	cpi	r18, 0x02	; 2
     91e:	31 05       	cpc	r19, r1
     920:	a1 f0       	breq	.+40     	; 0x94a <DIO_u8GetPortValue+0x7a>
     922:	8d 81       	ldd	r24, Y+5	; 0x05
     924:	9e 81       	ldd	r25, Y+6	; 0x06
     926:	83 30       	cpi	r24, 0x03	; 3
     928:	91 05       	cpc	r25, r1
     92a:	b1 f0       	breq	.+44     	; 0x958 <DIO_u8GetPortValue+0x88>
     92c:	1c c0       	rjmp	.+56     	; 0x966 <DIO_u8GetPortValue+0x96>
		{
			case DIO_u8_PORTA: *Copy_pu8ReturnedPortValue = DIO_u8_PINA_REG;break;
     92e:	e9 e3       	ldi	r30, 0x39	; 57
     930:	f0 e0       	ldi	r31, 0x00	; 0
     932:	80 81       	ld	r24, Z
     934:	eb 81       	ldd	r30, Y+3	; 0x03
     936:	fc 81       	ldd	r31, Y+4	; 0x04
     938:	80 83       	st	Z, r24
     93a:	18 c0       	rjmp	.+48     	; 0x96c <DIO_u8GetPortValue+0x9c>
			case DIO_u8_PORTB: *Copy_pu8ReturnedPortValue = DIO_u8_PINB_REG;break;
     93c:	e6 e3       	ldi	r30, 0x36	; 54
     93e:	f0 e0       	ldi	r31, 0x00	; 0
     940:	80 81       	ld	r24, Z
     942:	eb 81       	ldd	r30, Y+3	; 0x03
     944:	fc 81       	ldd	r31, Y+4	; 0x04
     946:	80 83       	st	Z, r24
     948:	11 c0       	rjmp	.+34     	; 0x96c <DIO_u8GetPortValue+0x9c>
			case DIO_u8_PORTC: *Copy_pu8ReturnedPortValue = DIO_u8_PINC_REG;break;
     94a:	e3 e3       	ldi	r30, 0x33	; 51
     94c:	f0 e0       	ldi	r31, 0x00	; 0
     94e:	80 81       	ld	r24, Z
     950:	eb 81       	ldd	r30, Y+3	; 0x03
     952:	fc 81       	ldd	r31, Y+4	; 0x04
     954:	80 83       	st	Z, r24
     956:	0a c0       	rjmp	.+20     	; 0x96c <DIO_u8GetPortValue+0x9c>
			case DIO_u8_PORTD: *Copy_pu8ReturnedPortValue = DIO_u8_PIND_REG;break;
     958:	e0 e3       	ldi	r30, 0x30	; 48
     95a:	f0 e0       	ldi	r31, 0x00	; 0
     95c:	80 81       	ld	r24, Z
     95e:	eb 81       	ldd	r30, Y+3	; 0x03
     960:	fc 81       	ldd	r31, Y+4	; 0x04
     962:	80 83       	st	Z, r24
     964:	03 c0       	rjmp	.+6      	; 0x96c <DIO_u8GetPortValue+0x9c>
			default:Local_u8ErrorState = STD_TYPES_NOK;
     966:	19 82       	std	Y+1, r1	; 0x01
     968:	01 c0       	rjmp	.+2      	; 0x96c <DIO_u8GetPortValue+0x9c>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
     96a:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
     96c:	89 81       	ldd	r24, Y+1	; 0x01
     96e:	26 96       	adiw	r28, 0x06	; 6
     970:	0f b6       	in	r0, 0x3f	; 63
     972:	f8 94       	cli
     974:	de bf       	out	0x3e, r29	; 62
     976:	0f be       	out	0x3f, r0	; 63
     978:	cd bf       	out	0x3d, r28	; 61
     97a:	cf 91       	pop	r28
     97c:	df 91       	pop	r29
     97e:	08 95       	ret

00000980 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     980:	df 93       	push	r29
     982:	cf 93       	push	r28
     984:	00 d0       	rcall	.+0      	; 0x986 <xEventGroupCreate+0x6>
     986:	cd b7       	in	r28, 0x3d	; 61
     988:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     98a:	8b e0       	ldi	r24, 0x0B	; 11
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	0e 94 05 08 	call	0x100a	; 0x100a <pvPortMalloc>
     992:	9a 83       	std	Y+2, r25	; 0x02
     994:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     996:	89 81       	ldd	r24, Y+1	; 0x01
     998:	9a 81       	ldd	r25, Y+2	; 0x02
     99a:	00 97       	sbiw	r24, 0x00	; 0
     99c:	49 f0       	breq	.+18     	; 0x9b0 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     99e:	e9 81       	ldd	r30, Y+1	; 0x01
     9a0:	fa 81       	ldd	r31, Y+2	; 0x02
     9a2:	11 82       	std	Z+1, r1	; 0x01
     9a4:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     9a6:	89 81       	ldd	r24, Y+1	; 0x01
     9a8:	9a 81       	ldd	r25, Y+2	; 0x02
     9aa:	02 96       	adiw	r24, 0x02	; 2
     9ac:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     9b0:	89 81       	ldd	r24, Y+1	; 0x01
     9b2:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     9b4:	0f 90       	pop	r0
     9b6:	0f 90       	pop	r0
     9b8:	cf 91       	pop	r28
     9ba:	df 91       	pop	r29
     9bc:	08 95       	ret

000009be <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     9be:	df 93       	push	r29
     9c0:	cf 93       	push	r28
     9c2:	cd b7       	in	r28, 0x3d	; 61
     9c4:	de b7       	in	r29, 0x3e	; 62
     9c6:	60 97       	sbiw	r28, 0x10	; 16
     9c8:	0f b6       	in	r0, 0x3f	; 63
     9ca:	f8 94       	cli
     9cc:	de bf       	out	0x3e, r29	; 62
     9ce:	0f be       	out	0x3f, r0	; 63
     9d0:	cd bf       	out	0x3d, r28	; 61
     9d2:	9a 87       	std	Y+10, r25	; 0x0a
     9d4:	89 87       	std	Y+9, r24	; 0x09
     9d6:	7c 87       	std	Y+12, r23	; 0x0c
     9d8:	6b 87       	std	Y+11, r22	; 0x0b
     9da:	5e 87       	std	Y+14, r21	; 0x0e
     9dc:	4d 87       	std	Y+13, r20	; 0x0d
     9de:	38 8b       	std	Y+16, r19	; 0x10
     9e0:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     9e2:	89 85       	ldd	r24, Y+9	; 0x09
     9e4:	9a 85       	ldd	r25, Y+10	; 0x0a
     9e6:	9c 83       	std	Y+4, r25	; 0x04
     9e8:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     9ea:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     9ec:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     9f0:	eb 81       	ldd	r30, Y+3	; 0x03
     9f2:	fc 81       	ldd	r31, Y+4	; 0x04
     9f4:	80 81       	ld	r24, Z
     9f6:	91 81       	ldd	r25, Z+1	; 0x01
     9f8:	98 87       	std	Y+8, r25	; 0x08
     9fa:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     9fc:	89 85       	ldd	r24, Y+9	; 0x09
     9fe:	9a 85       	ldd	r25, Y+10	; 0x0a
     a00:	2b 85       	ldd	r18, Y+11	; 0x0b
     a02:	3c 85       	ldd	r19, Y+12	; 0x0c
     a04:	b9 01       	movw	r22, r18
     a06:	0e 94 b6 06 	call	0xd6c	; 0xd6c <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     a0a:	2f 81       	ldd	r18, Y+7	; 0x07
     a0c:	38 85       	ldd	r19, Y+8	; 0x08
     a0e:	8b 85       	ldd	r24, Y+11	; 0x0b
     a10:	9c 85       	ldd	r25, Y+12	; 0x0c
     a12:	28 2b       	or	r18, r24
     a14:	39 2b       	or	r19, r25
     a16:	8d 85       	ldd	r24, Y+13	; 0x0d
     a18:	9e 85       	ldd	r25, Y+14	; 0x0e
     a1a:	28 23       	and	r18, r24
     a1c:	39 23       	and	r19, r25
     a1e:	8d 85       	ldd	r24, Y+13	; 0x0d
     a20:	9e 85       	ldd	r25, Y+14	; 0x0e
     a22:	28 17       	cp	r18, r24
     a24:	39 07       	cpc	r19, r25
     a26:	c9 f4       	brne	.+50     	; 0xa5a <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     a28:	2f 81       	ldd	r18, Y+7	; 0x07
     a2a:	38 85       	ldd	r19, Y+8	; 0x08
     a2c:	8b 85       	ldd	r24, Y+11	; 0x0b
     a2e:	9c 85       	ldd	r25, Y+12	; 0x0c
     a30:	82 2b       	or	r24, r18
     a32:	93 2b       	or	r25, r19
     a34:	9e 83       	std	Y+6, r25	; 0x06
     a36:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     a38:	eb 81       	ldd	r30, Y+3	; 0x03
     a3a:	fc 81       	ldd	r31, Y+4	; 0x04
     a3c:	20 81       	ld	r18, Z
     a3e:	31 81       	ldd	r19, Z+1	; 0x01
     a40:	8d 85       	ldd	r24, Y+13	; 0x0d
     a42:	9e 85       	ldd	r25, Y+14	; 0x0e
     a44:	80 95       	com	r24
     a46:	90 95       	com	r25
     a48:	82 23       	and	r24, r18
     a4a:	93 23       	and	r25, r19
     a4c:	eb 81       	ldd	r30, Y+3	; 0x03
     a4e:	fc 81       	ldd	r31, Y+4	; 0x04
     a50:	91 83       	std	Z+1, r25	; 0x01
     a52:	80 83       	st	Z, r24

			xTicksToWait = 0;
     a54:	18 8a       	std	Y+16, r1	; 0x10
     a56:	1f 86       	std	Y+15, r1	; 0x0f
     a58:	1e c0       	rjmp	.+60     	; 0xa96 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     a5a:	8f 85       	ldd	r24, Y+15	; 0x0f
     a5c:	98 89       	ldd	r25, Y+16	; 0x10
     a5e:	00 97       	sbiw	r24, 0x00	; 0
     a60:	91 f0       	breq	.+36     	; 0xa86 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     a62:	8b 81       	ldd	r24, Y+3	; 0x03
     a64:	9c 81       	ldd	r25, Y+4	; 0x04
     a66:	bc 01       	movw	r22, r24
     a68:	6e 5f       	subi	r22, 0xFE	; 254
     a6a:	7f 4f       	sbci	r23, 0xFF	; 255
     a6c:	8d 85       	ldd	r24, Y+13	; 0x0d
     a6e:	9e 85       	ldd	r25, Y+14	; 0x0e
     a70:	9c 01       	movw	r18, r24
     a72:	35 60       	ori	r19, 0x05	; 5
     a74:	4f 85       	ldd	r20, Y+15	; 0x0f
     a76:	58 89       	ldd	r21, Y+16	; 0x10
     a78:	cb 01       	movw	r24, r22
     a7a:	b9 01       	movw	r22, r18
     a7c:	0e 94 59 1c 	call	0x38b2	; 0x38b2 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     a80:	1e 82       	std	Y+6, r1	; 0x06
     a82:	1d 82       	std	Y+5, r1	; 0x05
     a84:	08 c0       	rjmp	.+16     	; 0xa96 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     a86:	eb 81       	ldd	r30, Y+3	; 0x03
     a88:	fc 81       	ldd	r31, Y+4	; 0x04
     a8a:	80 81       	ld	r24, Z
     a8c:	91 81       	ldd	r25, Z+1	; 0x01
     a8e:	9e 83       	std	Y+6, r25	; 0x06
     a90:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     a92:	81 e0       	ldi	r24, 0x01	; 1
     a94:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     a96:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
     a9a:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     a9c:	8f 85       	ldd	r24, Y+15	; 0x0f
     a9e:	98 89       	ldd	r25, Y+16	; 0x10
     aa0:	00 97       	sbiw	r24, 0x00	; 0
     aa2:	09 f4       	brne	.+2      	; 0xaa6 <xEventGroupSync+0xe8>
     aa4:	3a c0       	rjmp	.+116    	; 0xb1a <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     aa6:	8a 81       	ldd	r24, Y+2	; 0x02
     aa8:	88 23       	and	r24, r24
     aaa:	11 f4       	brne	.+4      	; 0xab0 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     aac:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     ab0:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <uxTaskResetEventItemValue>
     ab4:	9e 83       	std	Y+6, r25	; 0x06
     ab6:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     ab8:	8d 81       	ldd	r24, Y+5	; 0x05
     aba:	9e 81       	ldd	r25, Y+6	; 0x06
     abc:	80 70       	andi	r24, 0x00	; 0
     abe:	92 70       	andi	r25, 0x02	; 2
     ac0:	00 97       	sbiw	r24, 0x00	; 0
     ac2:	31 f5       	brne	.+76     	; 0xb10 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     ac4:	0f b6       	in	r0, 0x3f	; 63
     ac6:	f8 94       	cli
     ac8:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     aca:	eb 81       	ldd	r30, Y+3	; 0x03
     acc:	fc 81       	ldd	r31, Y+4	; 0x04
     ace:	80 81       	ld	r24, Z
     ad0:	91 81       	ldd	r25, Z+1	; 0x01
     ad2:	9e 83       	std	Y+6, r25	; 0x06
     ad4:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     ad6:	2d 81       	ldd	r18, Y+5	; 0x05
     ad8:	3e 81       	ldd	r19, Y+6	; 0x06
     ada:	8d 85       	ldd	r24, Y+13	; 0x0d
     adc:	9e 85       	ldd	r25, Y+14	; 0x0e
     ade:	28 23       	and	r18, r24
     ae0:	39 23       	and	r19, r25
     ae2:	8d 85       	ldd	r24, Y+13	; 0x0d
     ae4:	9e 85       	ldd	r25, Y+14	; 0x0e
     ae6:	28 17       	cp	r18, r24
     ae8:	39 07       	cpc	r19, r25
     aea:	71 f4       	brne	.+28     	; 0xb08 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     aec:	eb 81       	ldd	r30, Y+3	; 0x03
     aee:	fc 81       	ldd	r31, Y+4	; 0x04
     af0:	20 81       	ld	r18, Z
     af2:	31 81       	ldd	r19, Z+1	; 0x01
     af4:	8d 85       	ldd	r24, Y+13	; 0x0d
     af6:	9e 85       	ldd	r25, Y+14	; 0x0e
     af8:	80 95       	com	r24
     afa:	90 95       	com	r25
     afc:	82 23       	and	r24, r18
     afe:	93 23       	and	r25, r19
     b00:	eb 81       	ldd	r30, Y+3	; 0x03
     b02:	fc 81       	ldd	r31, Y+4	; 0x04
     b04:	91 83       	std	Z+1, r25	; 0x01
     b06:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     b08:	0f 90       	pop	r0
     b0a:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     b0c:	81 e0       	ldi	r24, 0x01	; 1
     b0e:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     b10:	8d 81       	ldd	r24, Y+5	; 0x05
     b12:	9e 81       	ldd	r25, Y+6	; 0x06
     b14:	90 70       	andi	r25, 0x00	; 0
     b16:	9e 83       	std	Y+6, r25	; 0x06
     b18:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     b1a:	8d 81       	ldd	r24, Y+5	; 0x05
     b1c:	9e 81       	ldd	r25, Y+6	; 0x06
}
     b1e:	60 96       	adiw	r28, 0x10	; 16
     b20:	0f b6       	in	r0, 0x3f	; 63
     b22:	f8 94       	cli
     b24:	de bf       	out	0x3e, r29	; 62
     b26:	0f be       	out	0x3f, r0	; 63
     b28:	cd bf       	out	0x3d, r28	; 61
     b2a:	cf 91       	pop	r28
     b2c:	df 91       	pop	r29
     b2e:	08 95       	ret

00000b30 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     b30:	0f 93       	push	r16
     b32:	1f 93       	push	r17
     b34:	df 93       	push	r29
     b36:	cf 93       	push	r28
     b38:	cd b7       	in	r28, 0x3d	; 61
     b3a:	de b7       	in	r29, 0x3e	; 62
     b3c:	63 97       	sbiw	r28, 0x13	; 19
     b3e:	0f b6       	in	r0, 0x3f	; 63
     b40:	f8 94       	cli
     b42:	de bf       	out	0x3e, r29	; 62
     b44:	0f be       	out	0x3f, r0	; 63
     b46:	cd bf       	out	0x3d, r28	; 61
     b48:	9d 87       	std	Y+13, r25	; 0x0d
     b4a:	8c 87       	std	Y+12, r24	; 0x0c
     b4c:	7f 87       	std	Y+15, r23	; 0x0f
     b4e:	6e 87       	std	Y+14, r22	; 0x0e
     b50:	48 8b       	std	Y+16, r20	; 0x10
     b52:	29 8b       	std	Y+17, r18	; 0x11
     b54:	1b 8b       	std	Y+19, r17	; 0x13
     b56:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     b58:	8c 85       	ldd	r24, Y+12	; 0x0c
     b5a:	9d 85       	ldd	r25, Y+13	; 0x0d
     b5c:	9b 87       	std	Y+11, r25	; 0x0b
     b5e:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     b60:	1f 82       	std	Y+7, r1	; 0x07
     b62:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     b64:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     b66:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     b6a:	ea 85       	ldd	r30, Y+10	; 0x0a
     b6c:	fb 85       	ldd	r31, Y+11	; 0x0b
     b6e:	80 81       	ld	r24, Z
     b70:	91 81       	ldd	r25, Z+1	; 0x01
     b72:	9a 83       	std	Y+2, r25	; 0x02
     b74:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     b76:	89 81       	ldd	r24, Y+1	; 0x01
     b78:	9a 81       	ldd	r25, Y+2	; 0x02
     b7a:	2e 85       	ldd	r18, Y+14	; 0x0e
     b7c:	3f 85       	ldd	r19, Y+15	; 0x0f
     b7e:	b9 01       	movw	r22, r18
     b80:	49 89       	ldd	r20, Y+17	; 0x11
     b82:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <prvTestWaitCondition>
     b86:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     b88:	8d 81       	ldd	r24, Y+5	; 0x05
     b8a:	88 23       	and	r24, r24
     b8c:	c1 f0       	breq	.+48     	; 0xbbe <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     b8e:	89 81       	ldd	r24, Y+1	; 0x01
     b90:	9a 81       	ldd	r25, Y+2	; 0x02
     b92:	99 87       	std	Y+9, r25	; 0x09
     b94:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     b96:	1b 8a       	std	Y+19, r1	; 0x13
     b98:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     b9a:	88 89       	ldd	r24, Y+16	; 0x10
     b9c:	88 23       	and	r24, r24
     b9e:	e9 f1       	breq	.+122    	; 0xc1a <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     ba0:	ea 85       	ldd	r30, Y+10	; 0x0a
     ba2:	fb 85       	ldd	r31, Y+11	; 0x0b
     ba4:	20 81       	ld	r18, Z
     ba6:	31 81       	ldd	r19, Z+1	; 0x01
     ba8:	8e 85       	ldd	r24, Y+14	; 0x0e
     baa:	9f 85       	ldd	r25, Y+15	; 0x0f
     bac:	80 95       	com	r24
     bae:	90 95       	com	r25
     bb0:	82 23       	and	r24, r18
     bb2:	93 23       	and	r25, r19
     bb4:	ea 85       	ldd	r30, Y+10	; 0x0a
     bb6:	fb 85       	ldd	r31, Y+11	; 0x0b
     bb8:	91 83       	std	Z+1, r25	; 0x01
     bba:	80 83       	st	Z, r24
     bbc:	2e c0       	rjmp	.+92     	; 0xc1a <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     bbe:	8a 89       	ldd	r24, Y+18	; 0x12
     bc0:	9b 89       	ldd	r25, Y+19	; 0x13
     bc2:	00 97       	sbiw	r24, 0x00	; 0
     bc4:	39 f4       	brne	.+14     	; 0xbd4 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     bc6:	89 81       	ldd	r24, Y+1	; 0x01
     bc8:	9a 81       	ldd	r25, Y+2	; 0x02
     bca:	99 87       	std	Y+9, r25	; 0x09
     bcc:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	8b 83       	std	Y+3, r24	; 0x03
     bd2:	23 c0       	rjmp	.+70     	; 0xc1a <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     bd4:	88 89       	ldd	r24, Y+16	; 0x10
     bd6:	88 23       	and	r24, r24
     bd8:	29 f0       	breq	.+10     	; 0xbe4 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     bda:	8e 81       	ldd	r24, Y+6	; 0x06
     bdc:	9f 81       	ldd	r25, Y+7	; 0x07
     bde:	91 60       	ori	r25, 0x01	; 1
     be0:	9f 83       	std	Y+7, r25	; 0x07
     be2:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     be4:	89 89       	ldd	r24, Y+17	; 0x11
     be6:	88 23       	and	r24, r24
     be8:	29 f0       	breq	.+10     	; 0xbf4 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     bea:	8e 81       	ldd	r24, Y+6	; 0x06
     bec:	9f 81       	ldd	r25, Y+7	; 0x07
     bee:	94 60       	ori	r25, 0x04	; 4
     bf0:	9f 83       	std	Y+7, r25	; 0x07
     bf2:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     bf4:	8a 85       	ldd	r24, Y+10	; 0x0a
     bf6:	9b 85       	ldd	r25, Y+11	; 0x0b
     bf8:	bc 01       	movw	r22, r24
     bfa:	6e 5f       	subi	r22, 0xFE	; 254
     bfc:	7f 4f       	sbci	r23, 0xFF	; 255
     bfe:	2e 85       	ldd	r18, Y+14	; 0x0e
     c00:	3f 85       	ldd	r19, Y+15	; 0x0f
     c02:	8e 81       	ldd	r24, Y+6	; 0x06
     c04:	9f 81       	ldd	r25, Y+7	; 0x07
     c06:	28 2b       	or	r18, r24
     c08:	39 2b       	or	r19, r25
     c0a:	4a 89       	ldd	r20, Y+18	; 0x12
     c0c:	5b 89       	ldd	r21, Y+19	; 0x13
     c0e:	cb 01       	movw	r24, r22
     c10:	b9 01       	movw	r22, r18
     c12:	0e 94 59 1c 	call	0x38b2	; 0x38b2 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     c16:	19 86       	std	Y+9, r1	; 0x09
     c18:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     c1a:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
     c1e:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     c20:	8a 89       	ldd	r24, Y+18	; 0x12
     c22:	9b 89       	ldd	r25, Y+19	; 0x13
     c24:	00 97       	sbiw	r24, 0x00	; 0
     c26:	09 f4       	brne	.+2      	; 0xc2a <xEventGroupWaitBits+0xfa>
     c28:	3c c0       	rjmp	.+120    	; 0xca2 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     c2a:	8c 81       	ldd	r24, Y+4	; 0x04
     c2c:	88 23       	and	r24, r24
     c2e:	11 f4       	brne	.+4      	; 0xc34 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     c30:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     c34:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <uxTaskResetEventItemValue>
     c38:	99 87       	std	Y+9, r25	; 0x09
     c3a:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     c3c:	88 85       	ldd	r24, Y+8	; 0x08
     c3e:	99 85       	ldd	r25, Y+9	; 0x09
     c40:	80 70       	andi	r24, 0x00	; 0
     c42:	92 70       	andi	r25, 0x02	; 2
     c44:	00 97       	sbiw	r24, 0x00	; 0
     c46:	41 f5       	brne	.+80     	; 0xc98 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     c48:	0f b6       	in	r0, 0x3f	; 63
     c4a:	f8 94       	cli
     c4c:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     c4e:	ea 85       	ldd	r30, Y+10	; 0x0a
     c50:	fb 85       	ldd	r31, Y+11	; 0x0b
     c52:	80 81       	ld	r24, Z
     c54:	91 81       	ldd	r25, Z+1	; 0x01
     c56:	99 87       	std	Y+9, r25	; 0x09
     c58:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     c5a:	88 85       	ldd	r24, Y+8	; 0x08
     c5c:	99 85       	ldd	r25, Y+9	; 0x09
     c5e:	2e 85       	ldd	r18, Y+14	; 0x0e
     c60:	3f 85       	ldd	r19, Y+15	; 0x0f
     c62:	b9 01       	movw	r22, r18
     c64:	49 89       	ldd	r20, Y+17	; 0x11
     c66:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <prvTestWaitCondition>
     c6a:	88 23       	and	r24, r24
     c6c:	89 f0       	breq	.+34     	; 0xc90 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     c6e:	88 89       	ldd	r24, Y+16	; 0x10
     c70:	88 23       	and	r24, r24
     c72:	71 f0       	breq	.+28     	; 0xc90 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     c74:	ea 85       	ldd	r30, Y+10	; 0x0a
     c76:	fb 85       	ldd	r31, Y+11	; 0x0b
     c78:	20 81       	ld	r18, Z
     c7a:	31 81       	ldd	r19, Z+1	; 0x01
     c7c:	8e 85       	ldd	r24, Y+14	; 0x0e
     c7e:	9f 85       	ldd	r25, Y+15	; 0x0f
     c80:	80 95       	com	r24
     c82:	90 95       	com	r25
     c84:	82 23       	and	r24, r18
     c86:	93 23       	and	r25, r19
     c88:	ea 85       	ldd	r30, Y+10	; 0x0a
     c8a:	fb 85       	ldd	r31, Y+11	; 0x0b
     c8c:	91 83       	std	Z+1, r25	; 0x01
     c8e:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     c94:	0f 90       	pop	r0
     c96:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     c98:	88 85       	ldd	r24, Y+8	; 0x08
     c9a:	99 85       	ldd	r25, Y+9	; 0x09
     c9c:	90 70       	andi	r25, 0x00	; 0
     c9e:	99 87       	std	Y+9, r25	; 0x09
     ca0:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     ca2:	88 85       	ldd	r24, Y+8	; 0x08
     ca4:	99 85       	ldd	r25, Y+9	; 0x09
}
     ca6:	63 96       	adiw	r28, 0x13	; 19
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	f8 94       	cli
     cac:	de bf       	out	0x3e, r29	; 62
     cae:	0f be       	out	0x3f, r0	; 63
     cb0:	cd bf       	out	0x3d, r28	; 61
     cb2:	cf 91       	pop	r28
     cb4:	df 91       	pop	r29
     cb6:	1f 91       	pop	r17
     cb8:	0f 91       	pop	r16
     cba:	08 95       	ret

00000cbc <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     cbc:	df 93       	push	r29
     cbe:	cf 93       	push	r28
     cc0:	cd b7       	in	r28, 0x3d	; 61
     cc2:	de b7       	in	r29, 0x3e	; 62
     cc4:	28 97       	sbiw	r28, 0x08	; 8
     cc6:	0f b6       	in	r0, 0x3f	; 63
     cc8:	f8 94       	cli
     cca:	de bf       	out	0x3e, r29	; 62
     ccc:	0f be       	out	0x3f, r0	; 63
     cce:	cd bf       	out	0x3d, r28	; 61
     cd0:	9e 83       	std	Y+6, r25	; 0x06
     cd2:	8d 83       	std	Y+5, r24	; 0x05
     cd4:	78 87       	std	Y+8, r23	; 0x08
     cd6:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     cd8:	8d 81       	ldd	r24, Y+5	; 0x05
     cda:	9e 81       	ldd	r25, Y+6	; 0x06
     cdc:	9c 83       	std	Y+4, r25	; 0x04
     cde:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     ce0:	0f b6       	in	r0, 0x3f	; 63
     ce2:	f8 94       	cli
     ce4:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     ce6:	eb 81       	ldd	r30, Y+3	; 0x03
     ce8:	fc 81       	ldd	r31, Y+4	; 0x04
     cea:	80 81       	ld	r24, Z
     cec:	91 81       	ldd	r25, Z+1	; 0x01
     cee:	9a 83       	std	Y+2, r25	; 0x02
     cf0:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     cf2:	eb 81       	ldd	r30, Y+3	; 0x03
     cf4:	fc 81       	ldd	r31, Y+4	; 0x04
     cf6:	20 81       	ld	r18, Z
     cf8:	31 81       	ldd	r19, Z+1	; 0x01
     cfa:	8f 81       	ldd	r24, Y+7	; 0x07
     cfc:	98 85       	ldd	r25, Y+8	; 0x08
     cfe:	80 95       	com	r24
     d00:	90 95       	com	r25
     d02:	82 23       	and	r24, r18
     d04:	93 23       	and	r25, r19
     d06:	eb 81       	ldd	r30, Y+3	; 0x03
     d08:	fc 81       	ldd	r31, Y+4	; 0x04
     d0a:	91 83       	std	Z+1, r25	; 0x01
     d0c:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     d0e:	0f 90       	pop	r0
     d10:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     d12:	89 81       	ldd	r24, Y+1	; 0x01
     d14:	9a 81       	ldd	r25, Y+2	; 0x02
}
     d16:	28 96       	adiw	r28, 0x08	; 8
     d18:	0f b6       	in	r0, 0x3f	; 63
     d1a:	f8 94       	cli
     d1c:	de bf       	out	0x3e, r29	; 62
     d1e:	0f be       	out	0x3f, r0	; 63
     d20:	cd bf       	out	0x3d, r28	; 61
     d22:	cf 91       	pop	r28
     d24:	df 91       	pop	r29
     d26:	08 95       	ret

00000d28 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     d28:	df 93       	push	r29
     d2a:	cf 93       	push	r28
     d2c:	cd b7       	in	r28, 0x3d	; 61
     d2e:	de b7       	in	r29, 0x3e	; 62
     d30:	27 97       	sbiw	r28, 0x07	; 7
     d32:	0f b6       	in	r0, 0x3f	; 63
     d34:	f8 94       	cli
     d36:	de bf       	out	0x3e, r29	; 62
     d38:	0f be       	out	0x3f, r0	; 63
     d3a:	cd bf       	out	0x3d, r28	; 61
     d3c:	9f 83       	std	Y+7, r25	; 0x07
     d3e:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     d40:	8e 81       	ldd	r24, Y+6	; 0x06
     d42:	9f 81       	ldd	r25, Y+7	; 0x07
     d44:	9c 83       	std	Y+4, r25	; 0x04
     d46:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     d48:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     d4a:	eb 81       	ldd	r30, Y+3	; 0x03
     d4c:	fc 81       	ldd	r31, Y+4	; 0x04
     d4e:	80 81       	ld	r24, Z
     d50:	91 81       	ldd	r25, Z+1	; 0x01
     d52:	9a 83       	std	Y+2, r25	; 0x02
     d54:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     d56:	89 81       	ldd	r24, Y+1	; 0x01
     d58:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     d5a:	27 96       	adiw	r28, 0x07	; 7
     d5c:	0f b6       	in	r0, 0x3f	; 63
     d5e:	f8 94       	cli
     d60:	de bf       	out	0x3e, r29	; 62
     d62:	0f be       	out	0x3f, r0	; 63
     d64:	cd bf       	out	0x3d, r28	; 61
     d66:	cf 91       	pop	r28
     d68:	df 91       	pop	r29
     d6a:	08 95       	ret

00000d6c <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     d6c:	df 93       	push	r29
     d6e:	cf 93       	push	r28
     d70:	cd b7       	in	r28, 0x3d	; 61
     d72:	de b7       	in	r29, 0x3e	; 62
     d74:	65 97       	sbiw	r28, 0x15	; 21
     d76:	0f b6       	in	r0, 0x3f	; 63
     d78:	f8 94       	cli
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	0f be       	out	0x3f, r0	; 63
     d7e:	cd bf       	out	0x3d, r28	; 61
     d80:	9b 8b       	std	Y+19, r25	; 0x13
     d82:	8a 8b       	std	Y+18, r24	; 0x12
     d84:	7d 8b       	std	Y+21, r23	; 0x15
     d86:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     d88:	19 86       	std	Y+9, r1	; 0x09
     d8a:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     d8c:	8a 89       	ldd	r24, Y+18	; 0x12
     d8e:	9b 89       	ldd	r25, Y+19	; 0x13
     d90:	9b 83       	std	Y+3, r25	; 0x03
     d92:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     d94:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     d96:	8a 81       	ldd	r24, Y+2	; 0x02
     d98:	9b 81       	ldd	r25, Y+3	; 0x03
     d9a:	02 96       	adiw	r24, 0x02	; 2
     d9c:	9b 87       	std	Y+11, r25	; 0x0b
     d9e:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     da0:	8a 85       	ldd	r24, Y+10	; 0x0a
     da2:	9b 85       	ldd	r25, Y+11	; 0x0b
     da4:	03 96       	adiw	r24, 0x03	; 3
     da6:	9d 87       	std	Y+13, r25	; 0x0d
     da8:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     daa:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     dae:	ea 85       	ldd	r30, Y+10	; 0x0a
     db0:	fb 85       	ldd	r31, Y+11	; 0x0b
     db2:	85 81       	ldd	r24, Z+5	; 0x05
     db4:	96 81       	ldd	r25, Z+6	; 0x06
     db6:	99 8b       	std	Y+17, r25	; 0x11
     db8:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     dba:	ea 81       	ldd	r30, Y+2	; 0x02
     dbc:	fb 81       	ldd	r31, Y+3	; 0x03
     dbe:	20 81       	ld	r18, Z
     dc0:	31 81       	ldd	r19, Z+1	; 0x01
     dc2:	8c 89       	ldd	r24, Y+20	; 0x14
     dc4:	9d 89       	ldd	r25, Y+21	; 0x15
     dc6:	82 2b       	or	r24, r18
     dc8:	93 2b       	or	r25, r19
     dca:	ea 81       	ldd	r30, Y+2	; 0x02
     dcc:	fb 81       	ldd	r31, Y+3	; 0x03
     dce:	91 83       	std	Z+1, r25	; 0x01
     dd0:	80 83       	st	Z, r24
     dd2:	59 c0       	rjmp	.+178    	; 0xe86 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     dd4:	e8 89       	ldd	r30, Y+16	; 0x10
     dd6:	f9 89       	ldd	r31, Y+17	; 0x11
     dd8:	82 81       	ldd	r24, Z+2	; 0x02
     dda:	93 81       	ldd	r25, Z+3	; 0x03
     ddc:	9f 87       	std	Y+15, r25	; 0x0f
     dde:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     de0:	e8 89       	ldd	r30, Y+16	; 0x10
     de2:	f9 89       	ldd	r31, Y+17	; 0x11
     de4:	80 81       	ld	r24, Z
     de6:	91 81       	ldd	r25, Z+1	; 0x01
     de8:	9f 83       	std	Y+7, r25	; 0x07
     dea:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     dec:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     dee:	8e 81       	ldd	r24, Y+6	; 0x06
     df0:	9f 81       	ldd	r25, Y+7	; 0x07
     df2:	80 70       	andi	r24, 0x00	; 0
     df4:	9d 83       	std	Y+5, r25	; 0x05
     df6:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     df8:	8e 81       	ldd	r24, Y+6	; 0x06
     dfa:	9f 81       	ldd	r25, Y+7	; 0x07
     dfc:	90 70       	andi	r25, 0x00	; 0
     dfe:	9f 83       	std	Y+7, r25	; 0x07
     e00:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     e02:	8c 81       	ldd	r24, Y+4	; 0x04
     e04:	9d 81       	ldd	r25, Y+5	; 0x05
     e06:	80 70       	andi	r24, 0x00	; 0
     e08:	94 70       	andi	r25, 0x04	; 4
     e0a:	00 97       	sbiw	r24, 0x00	; 0
     e0c:	69 f4       	brne	.+26     	; 0xe28 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     e0e:	ea 81       	ldd	r30, Y+2	; 0x02
     e10:	fb 81       	ldd	r31, Y+3	; 0x03
     e12:	20 81       	ld	r18, Z
     e14:	31 81       	ldd	r19, Z+1	; 0x01
     e16:	8e 81       	ldd	r24, Y+6	; 0x06
     e18:	9f 81       	ldd	r25, Y+7	; 0x07
     e1a:	82 23       	and	r24, r18
     e1c:	93 23       	and	r25, r19
     e1e:	00 97       	sbiw	r24, 0x00	; 0
     e20:	91 f0       	breq	.+36     	; 0xe46 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     e22:	81 e0       	ldi	r24, 0x01	; 1
     e24:	89 83       	std	Y+1, r24	; 0x01
     e26:	0f c0       	rjmp	.+30     	; 0xe46 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     e28:	ea 81       	ldd	r30, Y+2	; 0x02
     e2a:	fb 81       	ldd	r31, Y+3	; 0x03
     e2c:	20 81       	ld	r18, Z
     e2e:	31 81       	ldd	r19, Z+1	; 0x01
     e30:	8e 81       	ldd	r24, Y+6	; 0x06
     e32:	9f 81       	ldd	r25, Y+7	; 0x07
     e34:	28 23       	and	r18, r24
     e36:	39 23       	and	r19, r25
     e38:	8e 81       	ldd	r24, Y+6	; 0x06
     e3a:	9f 81       	ldd	r25, Y+7	; 0x07
     e3c:	28 17       	cp	r18, r24
     e3e:	39 07       	cpc	r19, r25
     e40:	11 f4       	brne	.+4      	; 0xe46 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     e42:	81 e0       	ldi	r24, 0x01	; 1
     e44:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     e46:	89 81       	ldd	r24, Y+1	; 0x01
     e48:	88 23       	and	r24, r24
     e4a:	c9 f0       	breq	.+50     	; 0xe7e <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     e4c:	8c 81       	ldd	r24, Y+4	; 0x04
     e4e:	9d 81       	ldd	r25, Y+5	; 0x05
     e50:	80 70       	andi	r24, 0x00	; 0
     e52:	91 70       	andi	r25, 0x01	; 1
     e54:	00 97       	sbiw	r24, 0x00	; 0
     e56:	41 f0       	breq	.+16     	; 0xe68 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     e58:	88 85       	ldd	r24, Y+8	; 0x08
     e5a:	99 85       	ldd	r25, Y+9	; 0x09
     e5c:	2e 81       	ldd	r18, Y+6	; 0x06
     e5e:	3f 81       	ldd	r19, Y+7	; 0x07
     e60:	82 2b       	or	r24, r18
     e62:	93 2b       	or	r25, r19
     e64:	99 87       	std	Y+9, r25	; 0x09
     e66:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     e68:	ea 81       	ldd	r30, Y+2	; 0x02
     e6a:	fb 81       	ldd	r31, Y+3	; 0x03
     e6c:	80 81       	ld	r24, Z
     e6e:	91 81       	ldd	r25, Z+1	; 0x01
     e70:	9c 01       	movw	r18, r24
     e72:	32 60       	ori	r19, 0x02	; 2
     e74:	88 89       	ldd	r24, Y+16	; 0x10
     e76:	99 89       	ldd	r25, Y+17	; 0x11
     e78:	b9 01       	movw	r22, r18
     e7a:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     e7e:	8e 85       	ldd	r24, Y+14	; 0x0e
     e80:	9f 85       	ldd	r25, Y+15	; 0x0f
     e82:	99 8b       	std	Y+17, r25	; 0x11
     e84:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     e86:	28 89       	ldd	r18, Y+16	; 0x10
     e88:	39 89       	ldd	r19, Y+17	; 0x11
     e8a:	8c 85       	ldd	r24, Y+12	; 0x0c
     e8c:	9d 85       	ldd	r25, Y+13	; 0x0d
     e8e:	28 17       	cp	r18, r24
     e90:	39 07       	cpc	r19, r25
     e92:	09 f0       	breq	.+2      	; 0xe96 <xEventGroupSetBits+0x12a>
     e94:	9f cf       	rjmp	.-194    	; 0xdd4 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     e96:	ea 81       	ldd	r30, Y+2	; 0x02
     e98:	fb 81       	ldd	r31, Y+3	; 0x03
     e9a:	20 81       	ld	r18, Z
     e9c:	31 81       	ldd	r19, Z+1	; 0x01
     e9e:	88 85       	ldd	r24, Y+8	; 0x08
     ea0:	99 85       	ldd	r25, Y+9	; 0x09
     ea2:	80 95       	com	r24
     ea4:	90 95       	com	r25
     ea6:	82 23       	and	r24, r18
     ea8:	93 23       	and	r25, r19
     eaa:	ea 81       	ldd	r30, Y+2	; 0x02
     eac:	fb 81       	ldd	r31, Y+3	; 0x03
     eae:	91 83       	std	Z+1, r25	; 0x01
     eb0:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     eb2:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     eb6:	ea 81       	ldd	r30, Y+2	; 0x02
     eb8:	fb 81       	ldd	r31, Y+3	; 0x03
     eba:	80 81       	ld	r24, Z
     ebc:	91 81       	ldd	r25, Z+1	; 0x01
}
     ebe:	65 96       	adiw	r28, 0x15	; 21
     ec0:	0f b6       	in	r0, 0x3f	; 63
     ec2:	f8 94       	cli
     ec4:	de bf       	out	0x3e, r29	; 62
     ec6:	0f be       	out	0x3f, r0	; 63
     ec8:	cd bf       	out	0x3d, r28	; 61
     eca:	cf 91       	pop	r28
     ecc:	df 91       	pop	r29
     ece:	08 95       	ret

00000ed0 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     ed0:	df 93       	push	r29
     ed2:	cf 93       	push	r28
     ed4:	00 d0       	rcall	.+0      	; 0xed6 <vEventGroupDelete+0x6>
     ed6:	00 d0       	rcall	.+0      	; 0xed8 <vEventGroupDelete+0x8>
     ed8:	00 d0       	rcall	.+0      	; 0xeda <vEventGroupDelete+0xa>
     eda:	cd b7       	in	r28, 0x3d	; 61
     edc:	de b7       	in	r29, 0x3e	; 62
     ede:	9e 83       	std	Y+6, r25	; 0x06
     ee0:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     ee2:	8d 81       	ldd	r24, Y+5	; 0x05
     ee4:	9e 81       	ldd	r25, Y+6	; 0x06
     ee6:	9c 83       	std	Y+4, r25	; 0x04
     ee8:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     eea:	8b 81       	ldd	r24, Y+3	; 0x03
     eec:	9c 81       	ldd	r25, Y+4	; 0x04
     eee:	02 96       	adiw	r24, 0x02	; 2
     ef0:	9a 83       	std	Y+2, r25	; 0x02
     ef2:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     ef4:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
     ef8:	08 c0       	rjmp	.+16     	; 0xf0a <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     efa:	e9 81       	ldd	r30, Y+1	; 0x01
     efc:	fa 81       	ldd	r31, Y+2	; 0x02
     efe:	85 81       	ldd	r24, Z+5	; 0x05
     f00:	96 81       	ldd	r25, Z+6	; 0x06
     f02:	60 e0       	ldi	r22, 0x00	; 0
     f04:	72 e0       	ldi	r23, 0x02	; 2
     f06:	0e 94 f4 1c 	call	0x39e8	; 0x39e8 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     f0a:	e9 81       	ldd	r30, Y+1	; 0x01
     f0c:	fa 81       	ldd	r31, Y+2	; 0x02
     f0e:	80 81       	ld	r24, Z
     f10:	88 23       	and	r24, r24
     f12:	99 f7       	brne	.-26     	; 0xefa <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     f14:	8b 81       	ldd	r24, Y+3	; 0x03
     f16:	9c 81       	ldd	r25, Y+4	; 0x04
     f18:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     f1c:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
}
     f20:	26 96       	adiw	r28, 0x06	; 6
     f22:	0f b6       	in	r0, 0x3f	; 63
     f24:	f8 94       	cli
     f26:	de bf       	out	0x3e, r29	; 62
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	cd bf       	out	0x3d, r28	; 61
     f2c:	cf 91       	pop	r28
     f2e:	df 91       	pop	r29
     f30:	08 95       	ret

00000f32 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     f32:	df 93       	push	r29
     f34:	cf 93       	push	r28
     f36:	00 d0       	rcall	.+0      	; 0xf38 <vEventGroupSetBitsCallback+0x6>
     f38:	00 d0       	rcall	.+0      	; 0xf3a <vEventGroupSetBitsCallback+0x8>
     f3a:	00 d0       	rcall	.+0      	; 0xf3c <vEventGroupSetBitsCallback+0xa>
     f3c:	cd b7       	in	r28, 0x3d	; 61
     f3e:	de b7       	in	r29, 0x3e	; 62
     f40:	9a 83       	std	Y+2, r25	; 0x02
     f42:	89 83       	std	Y+1, r24	; 0x01
     f44:	4b 83       	std	Y+3, r20	; 0x03
     f46:	5c 83       	std	Y+4, r21	; 0x04
     f48:	6d 83       	std	Y+5, r22	; 0x05
     f4a:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     f4c:	89 81       	ldd	r24, Y+1	; 0x01
     f4e:	9a 81       	ldd	r25, Y+2	; 0x02
     f50:	2b 81       	ldd	r18, Y+3	; 0x03
     f52:	3c 81       	ldd	r19, Y+4	; 0x04
     f54:	b9 01       	movw	r22, r18
     f56:	0e 94 b6 06 	call	0xd6c	; 0xd6c <xEventGroupSetBits>
}
     f5a:	26 96       	adiw	r28, 0x06	; 6
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	f8 94       	cli
     f60:	de bf       	out	0x3e, r29	; 62
     f62:	0f be       	out	0x3f, r0	; 63
     f64:	cd bf       	out	0x3d, r28	; 61
     f66:	cf 91       	pop	r28
     f68:	df 91       	pop	r29
     f6a:	08 95       	ret

00000f6c <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     f6c:	df 93       	push	r29
     f6e:	cf 93       	push	r28
     f70:	00 d0       	rcall	.+0      	; 0xf72 <vEventGroupClearBitsCallback+0x6>
     f72:	00 d0       	rcall	.+0      	; 0xf74 <vEventGroupClearBitsCallback+0x8>
     f74:	00 d0       	rcall	.+0      	; 0xf76 <vEventGroupClearBitsCallback+0xa>
     f76:	cd b7       	in	r28, 0x3d	; 61
     f78:	de b7       	in	r29, 0x3e	; 62
     f7a:	9a 83       	std	Y+2, r25	; 0x02
     f7c:	89 83       	std	Y+1, r24	; 0x01
     f7e:	4b 83       	std	Y+3, r20	; 0x03
     f80:	5c 83       	std	Y+4, r21	; 0x04
     f82:	6d 83       	std	Y+5, r22	; 0x05
     f84:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     f86:	89 81       	ldd	r24, Y+1	; 0x01
     f88:	9a 81       	ldd	r25, Y+2	; 0x02
     f8a:	2b 81       	ldd	r18, Y+3	; 0x03
     f8c:	3c 81       	ldd	r19, Y+4	; 0x04
     f8e:	b9 01       	movw	r22, r18
     f90:	0e 94 5e 06 	call	0xcbc	; 0xcbc <xEventGroupClearBits>
}
     f94:	26 96       	adiw	r28, 0x06	; 6
     f96:	0f b6       	in	r0, 0x3f	; 63
     f98:	f8 94       	cli
     f9a:	de bf       	out	0x3e, r29	; 62
     f9c:	0f be       	out	0x3f, r0	; 63
     f9e:	cd bf       	out	0x3d, r28	; 61
     fa0:	cf 91       	pop	r28
     fa2:	df 91       	pop	r29
     fa4:	08 95       	ret

00000fa6 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     fa6:	df 93       	push	r29
     fa8:	cf 93       	push	r28
     faa:	00 d0       	rcall	.+0      	; 0xfac <prvTestWaitCondition+0x6>
     fac:	00 d0       	rcall	.+0      	; 0xfae <prvTestWaitCondition+0x8>
     fae:	00 d0       	rcall	.+0      	; 0xfb0 <prvTestWaitCondition+0xa>
     fb0:	cd b7       	in	r28, 0x3d	; 61
     fb2:	de b7       	in	r29, 0x3e	; 62
     fb4:	9b 83       	std	Y+3, r25	; 0x03
     fb6:	8a 83       	std	Y+2, r24	; 0x02
     fb8:	7d 83       	std	Y+5, r23	; 0x05
     fba:	6c 83       	std	Y+4, r22	; 0x04
     fbc:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     fbe:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     fc0:	8e 81       	ldd	r24, Y+6	; 0x06
     fc2:	88 23       	and	r24, r24
     fc4:	59 f4       	brne	.+22     	; 0xfdc <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     fc6:	8a 81       	ldd	r24, Y+2	; 0x02
     fc8:	9b 81       	ldd	r25, Y+3	; 0x03
     fca:	2c 81       	ldd	r18, Y+4	; 0x04
     fcc:	3d 81       	ldd	r19, Y+5	; 0x05
     fce:	82 23       	and	r24, r18
     fd0:	93 23       	and	r25, r19
     fd2:	00 97       	sbiw	r24, 0x00	; 0
     fd4:	81 f0       	breq	.+32     	; 0xff6 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     fd6:	81 e0       	ldi	r24, 0x01	; 1
     fd8:	89 83       	std	Y+1, r24	; 0x01
     fda:	0d c0       	rjmp	.+26     	; 0xff6 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     fdc:	2a 81       	ldd	r18, Y+2	; 0x02
     fde:	3b 81       	ldd	r19, Y+3	; 0x03
     fe0:	8c 81       	ldd	r24, Y+4	; 0x04
     fe2:	9d 81       	ldd	r25, Y+5	; 0x05
     fe4:	28 23       	and	r18, r24
     fe6:	39 23       	and	r19, r25
     fe8:	8c 81       	ldd	r24, Y+4	; 0x04
     fea:	9d 81       	ldd	r25, Y+5	; 0x05
     fec:	28 17       	cp	r18, r24
     fee:	39 07       	cpc	r19, r25
     ff0:	11 f4       	brne	.+4      	; 0xff6 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     ff2:	81 e0       	ldi	r24, 0x01	; 1
     ff4:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     ff6:	89 81       	ldd	r24, Y+1	; 0x01
}
     ff8:	26 96       	adiw	r28, 0x06	; 6
     ffa:	0f b6       	in	r0, 0x3f	; 63
     ffc:	f8 94       	cli
     ffe:	de bf       	out	0x3e, r29	; 62
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	cd bf       	out	0x3d, r28	; 61
    1004:	cf 91       	pop	r28
    1006:	df 91       	pop	r29
    1008:	08 95       	ret

0000100a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    100a:	df 93       	push	r29
    100c:	cf 93       	push	r28
    100e:	00 d0       	rcall	.+0      	; 0x1010 <pvPortMalloc+0x6>
    1010:	00 d0       	rcall	.+0      	; 0x1012 <pvPortMalloc+0x8>
    1012:	cd b7       	in	r28, 0x3d	; 61
    1014:	de b7       	in	r29, 0x3e	; 62
    1016:	9c 83       	std	Y+4, r25	; 0x04
    1018:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    101a:	1a 82       	std	Y+2, r1	; 0x02
    101c:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    101e:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1022:	80 91 68 00 	lds	r24, 0x0068
    1026:	90 91 69 00 	lds	r25, 0x0069
    102a:	00 97       	sbiw	r24, 0x00	; 0
    102c:	31 f4       	brne	.+12     	; 0x103a <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    102e:	8b e6       	ldi	r24, 0x6B	; 107
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	90 93 69 00 	sts	0x0069, r25
    1036:	80 93 68 00 	sts	0x0068, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    103a:	80 91 66 00 	lds	r24, 0x0066
    103e:	90 91 67 00 	lds	r25, 0x0067
    1042:	2b 81       	ldd	r18, Y+3	; 0x03
    1044:	3c 81       	ldd	r19, Y+4	; 0x04
    1046:	82 0f       	add	r24, r18
    1048:	93 1f       	adc	r25, r19
    104a:	23 e0       	ldi	r18, 0x03	; 3
    104c:	87 3e       	cpi	r24, 0xE7	; 231
    104e:	92 07       	cpc	r25, r18
    1050:	38 f5       	brcc	.+78     	; 0x10a0 <pvPortMalloc+0x96>
    1052:	20 91 66 00 	lds	r18, 0x0066
    1056:	30 91 67 00 	lds	r19, 0x0067
    105a:	8b 81       	ldd	r24, Y+3	; 0x03
    105c:	9c 81       	ldd	r25, Y+4	; 0x04
    105e:	28 0f       	add	r18, r24
    1060:	39 1f       	adc	r19, r25
    1062:	80 91 66 00 	lds	r24, 0x0066
    1066:	90 91 67 00 	lds	r25, 0x0067
    106a:	82 17       	cp	r24, r18
    106c:	93 07       	cpc	r25, r19
    106e:	c0 f4       	brcc	.+48     	; 0x10a0 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1070:	20 91 68 00 	lds	r18, 0x0068
    1074:	30 91 69 00 	lds	r19, 0x0069
    1078:	80 91 66 00 	lds	r24, 0x0066
    107c:	90 91 67 00 	lds	r25, 0x0067
    1080:	82 0f       	add	r24, r18
    1082:	93 1f       	adc	r25, r19
    1084:	9a 83       	std	Y+2, r25	; 0x02
    1086:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    1088:	20 91 66 00 	lds	r18, 0x0066
    108c:	30 91 67 00 	lds	r19, 0x0067
    1090:	8b 81       	ldd	r24, Y+3	; 0x03
    1092:	9c 81       	ldd	r25, Y+4	; 0x04
    1094:	82 0f       	add	r24, r18
    1096:	93 1f       	adc	r25, r19
    1098:	90 93 67 00 	sts	0x0067, r25
    109c:	80 93 66 00 	sts	0x0066, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    10a0:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    10a4:	89 81       	ldd	r24, Y+1	; 0x01
    10a6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    10a8:	0f 90       	pop	r0
    10aa:	0f 90       	pop	r0
    10ac:	0f 90       	pop	r0
    10ae:	0f 90       	pop	r0
    10b0:	cf 91       	pop	r28
    10b2:	df 91       	pop	r29
    10b4:	08 95       	ret

000010b6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    10b6:	df 93       	push	r29
    10b8:	cf 93       	push	r28
    10ba:	00 d0       	rcall	.+0      	; 0x10bc <vPortFree+0x6>
    10bc:	cd b7       	in	r28, 0x3d	; 61
    10be:	de b7       	in	r29, 0x3e	; 62
    10c0:	9a 83       	std	Y+2, r25	; 0x02
    10c2:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    10c4:	0f 90       	pop	r0
    10c6:	0f 90       	pop	r0
    10c8:	cf 91       	pop	r28
    10ca:	df 91       	pop	r29
    10cc:	08 95       	ret

000010ce <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    10ce:	df 93       	push	r29
    10d0:	cf 93       	push	r28
    10d2:	cd b7       	in	r28, 0x3d	; 61
    10d4:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    10d6:	10 92 67 00 	sts	0x0067, r1
    10da:	10 92 66 00 	sts	0x0066, r1
}
    10de:	cf 91       	pop	r28
    10e0:	df 91       	pop	r29
    10e2:	08 95       	ret

000010e4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    10e4:	df 93       	push	r29
    10e6:	cf 93       	push	r28
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    10ec:	20 91 66 00 	lds	r18, 0x0066
    10f0:	30 91 67 00 	lds	r19, 0x0067
    10f4:	87 ee       	ldi	r24, 0xE7	; 231
    10f6:	93 e0       	ldi	r25, 0x03	; 3
    10f8:	82 1b       	sub	r24, r18
    10fa:	93 0b       	sbc	r25, r19
}
    10fc:	cf 91       	pop	r28
    10fe:	df 91       	pop	r29
    1100:	08 95       	ret

00001102 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1102:	df 93       	push	r29
    1104:	cf 93       	push	r28
    1106:	00 d0       	rcall	.+0      	; 0x1108 <vListInitialise+0x6>
    1108:	cd b7       	in	r28, 0x3d	; 61
    110a:	de b7       	in	r29, 0x3e	; 62
    110c:	9a 83       	std	Y+2, r25	; 0x02
    110e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1110:	89 81       	ldd	r24, Y+1	; 0x01
    1112:	9a 81       	ldd	r25, Y+2	; 0x02
    1114:	03 96       	adiw	r24, 0x03	; 3
    1116:	e9 81       	ldd	r30, Y+1	; 0x01
    1118:	fa 81       	ldd	r31, Y+2	; 0x02
    111a:	92 83       	std	Z+2, r25	; 0x02
    111c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    111e:	e9 81       	ldd	r30, Y+1	; 0x01
    1120:	fa 81       	ldd	r31, Y+2	; 0x02
    1122:	8f ef       	ldi	r24, 0xFF	; 255
    1124:	9f ef       	ldi	r25, 0xFF	; 255
    1126:	94 83       	std	Z+4, r25	; 0x04
    1128:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    112a:	89 81       	ldd	r24, Y+1	; 0x01
    112c:	9a 81       	ldd	r25, Y+2	; 0x02
    112e:	03 96       	adiw	r24, 0x03	; 3
    1130:	e9 81       	ldd	r30, Y+1	; 0x01
    1132:	fa 81       	ldd	r31, Y+2	; 0x02
    1134:	96 83       	std	Z+6, r25	; 0x06
    1136:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1138:	89 81       	ldd	r24, Y+1	; 0x01
    113a:	9a 81       	ldd	r25, Y+2	; 0x02
    113c:	03 96       	adiw	r24, 0x03	; 3
    113e:	e9 81       	ldd	r30, Y+1	; 0x01
    1140:	fa 81       	ldd	r31, Y+2	; 0x02
    1142:	90 87       	std	Z+8, r25	; 0x08
    1144:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1146:	e9 81       	ldd	r30, Y+1	; 0x01
    1148:	fa 81       	ldd	r31, Y+2	; 0x02
    114a:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    114c:	0f 90       	pop	r0
    114e:	0f 90       	pop	r0
    1150:	cf 91       	pop	r28
    1152:	df 91       	pop	r29
    1154:	08 95       	ret

00001156 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1156:	df 93       	push	r29
    1158:	cf 93       	push	r28
    115a:	00 d0       	rcall	.+0      	; 0x115c <vListInitialiseItem+0x6>
    115c:	cd b7       	in	r28, 0x3d	; 61
    115e:	de b7       	in	r29, 0x3e	; 62
    1160:	9a 83       	std	Y+2, r25	; 0x02
    1162:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1164:	e9 81       	ldd	r30, Y+1	; 0x01
    1166:	fa 81       	ldd	r31, Y+2	; 0x02
    1168:	11 86       	std	Z+9, r1	; 0x09
    116a:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    116c:	0f 90       	pop	r0
    116e:	0f 90       	pop	r0
    1170:	cf 91       	pop	r28
    1172:	df 91       	pop	r29
    1174:	08 95       	ret

00001176 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1176:	df 93       	push	r29
    1178:	cf 93       	push	r28
    117a:	00 d0       	rcall	.+0      	; 0x117c <vListInsertEnd+0x6>
    117c:	00 d0       	rcall	.+0      	; 0x117e <vListInsertEnd+0x8>
    117e:	00 d0       	rcall	.+0      	; 0x1180 <vListInsertEnd+0xa>
    1180:	cd b7       	in	r28, 0x3d	; 61
    1182:	de b7       	in	r29, 0x3e	; 62
    1184:	9c 83       	std	Y+4, r25	; 0x04
    1186:	8b 83       	std	Y+3, r24	; 0x03
    1188:	7e 83       	std	Y+6, r23	; 0x06
    118a:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    118c:	eb 81       	ldd	r30, Y+3	; 0x03
    118e:	fc 81       	ldd	r31, Y+4	; 0x04
    1190:	81 81       	ldd	r24, Z+1	; 0x01
    1192:	92 81       	ldd	r25, Z+2	; 0x02
    1194:	9a 83       	std	Y+2, r25	; 0x02
    1196:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1198:	ed 81       	ldd	r30, Y+5	; 0x05
    119a:	fe 81       	ldd	r31, Y+6	; 0x06
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	9a 81       	ldd	r25, Y+2	; 0x02
    11a0:	93 83       	std	Z+3, r25	; 0x03
    11a2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    11a4:	e9 81       	ldd	r30, Y+1	; 0x01
    11a6:	fa 81       	ldd	r31, Y+2	; 0x02
    11a8:	84 81       	ldd	r24, Z+4	; 0x04
    11aa:	95 81       	ldd	r25, Z+5	; 0x05
    11ac:	ed 81       	ldd	r30, Y+5	; 0x05
    11ae:	fe 81       	ldd	r31, Y+6	; 0x06
    11b0:	95 83       	std	Z+5, r25	; 0x05
    11b2:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    11b4:	e9 81       	ldd	r30, Y+1	; 0x01
    11b6:	fa 81       	ldd	r31, Y+2	; 0x02
    11b8:	04 80       	ldd	r0, Z+4	; 0x04
    11ba:	f5 81       	ldd	r31, Z+5	; 0x05
    11bc:	e0 2d       	mov	r30, r0
    11be:	8d 81       	ldd	r24, Y+5	; 0x05
    11c0:	9e 81       	ldd	r25, Y+6	; 0x06
    11c2:	93 83       	std	Z+3, r25	; 0x03
    11c4:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    11c6:	e9 81       	ldd	r30, Y+1	; 0x01
    11c8:	fa 81       	ldd	r31, Y+2	; 0x02
    11ca:	8d 81       	ldd	r24, Y+5	; 0x05
    11cc:	9e 81       	ldd	r25, Y+6	; 0x06
    11ce:	95 83       	std	Z+5, r25	; 0x05
    11d0:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    11d2:	ed 81       	ldd	r30, Y+5	; 0x05
    11d4:	fe 81       	ldd	r31, Y+6	; 0x06
    11d6:	8b 81       	ldd	r24, Y+3	; 0x03
    11d8:	9c 81       	ldd	r25, Y+4	; 0x04
    11da:	91 87       	std	Z+9, r25	; 0x09
    11dc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    11de:	eb 81       	ldd	r30, Y+3	; 0x03
    11e0:	fc 81       	ldd	r31, Y+4	; 0x04
    11e2:	80 81       	ld	r24, Z
    11e4:	8f 5f       	subi	r24, 0xFF	; 255
    11e6:	eb 81       	ldd	r30, Y+3	; 0x03
    11e8:	fc 81       	ldd	r31, Y+4	; 0x04
    11ea:	80 83       	st	Z, r24
}
    11ec:	26 96       	adiw	r28, 0x06	; 6
    11ee:	0f b6       	in	r0, 0x3f	; 63
    11f0:	f8 94       	cli
    11f2:	de bf       	out	0x3e, r29	; 62
    11f4:	0f be       	out	0x3f, r0	; 63
    11f6:	cd bf       	out	0x3d, r28	; 61
    11f8:	cf 91       	pop	r28
    11fa:	df 91       	pop	r29
    11fc:	08 95       	ret

000011fe <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    11fe:	df 93       	push	r29
    1200:	cf 93       	push	r28
    1202:	cd b7       	in	r28, 0x3d	; 61
    1204:	de b7       	in	r29, 0x3e	; 62
    1206:	28 97       	sbiw	r28, 0x08	; 8
    1208:	0f b6       	in	r0, 0x3f	; 63
    120a:	f8 94       	cli
    120c:	de bf       	out	0x3e, r29	; 62
    120e:	0f be       	out	0x3f, r0	; 63
    1210:	cd bf       	out	0x3d, r28	; 61
    1212:	9e 83       	std	Y+6, r25	; 0x06
    1214:	8d 83       	std	Y+5, r24	; 0x05
    1216:	78 87       	std	Y+8, r23	; 0x08
    1218:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    121a:	ef 81       	ldd	r30, Y+7	; 0x07
    121c:	f8 85       	ldd	r31, Y+8	; 0x08
    121e:	80 81       	ld	r24, Z
    1220:	91 81       	ldd	r25, Z+1	; 0x01
    1222:	9a 83       	std	Y+2, r25	; 0x02
    1224:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1226:	89 81       	ldd	r24, Y+1	; 0x01
    1228:	9a 81       	ldd	r25, Y+2	; 0x02
    122a:	2f ef       	ldi	r18, 0xFF	; 255
    122c:	8f 3f       	cpi	r24, 0xFF	; 255
    122e:	92 07       	cpc	r25, r18
    1230:	39 f4       	brne	.+14     	; 0x1240 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1232:	ed 81       	ldd	r30, Y+5	; 0x05
    1234:	fe 81       	ldd	r31, Y+6	; 0x06
    1236:	87 81       	ldd	r24, Z+7	; 0x07
    1238:	90 85       	ldd	r25, Z+8	; 0x08
    123a:	9c 83       	std	Y+4, r25	; 0x04
    123c:	8b 83       	std	Y+3, r24	; 0x03
    123e:	18 c0       	rjmp	.+48     	; 0x1270 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1240:	8d 81       	ldd	r24, Y+5	; 0x05
    1242:	9e 81       	ldd	r25, Y+6	; 0x06
    1244:	03 96       	adiw	r24, 0x03	; 3
    1246:	9c 83       	std	Y+4, r25	; 0x04
    1248:	8b 83       	std	Y+3, r24	; 0x03
    124a:	06 c0       	rjmp	.+12     	; 0x1258 <vListInsert+0x5a>
    124c:	eb 81       	ldd	r30, Y+3	; 0x03
    124e:	fc 81       	ldd	r31, Y+4	; 0x04
    1250:	82 81       	ldd	r24, Z+2	; 0x02
    1252:	93 81       	ldd	r25, Z+3	; 0x03
    1254:	9c 83       	std	Y+4, r25	; 0x04
    1256:	8b 83       	std	Y+3, r24	; 0x03
    1258:	eb 81       	ldd	r30, Y+3	; 0x03
    125a:	fc 81       	ldd	r31, Y+4	; 0x04
    125c:	02 80       	ldd	r0, Z+2	; 0x02
    125e:	f3 81       	ldd	r31, Z+3	; 0x03
    1260:	e0 2d       	mov	r30, r0
    1262:	20 81       	ld	r18, Z
    1264:	31 81       	ldd	r19, Z+1	; 0x01
    1266:	89 81       	ldd	r24, Y+1	; 0x01
    1268:	9a 81       	ldd	r25, Y+2	; 0x02
    126a:	82 17       	cp	r24, r18
    126c:	93 07       	cpc	r25, r19
    126e:	70 f7       	brcc	.-36     	; 0x124c <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1270:	eb 81       	ldd	r30, Y+3	; 0x03
    1272:	fc 81       	ldd	r31, Y+4	; 0x04
    1274:	82 81       	ldd	r24, Z+2	; 0x02
    1276:	93 81       	ldd	r25, Z+3	; 0x03
    1278:	ef 81       	ldd	r30, Y+7	; 0x07
    127a:	f8 85       	ldd	r31, Y+8	; 0x08
    127c:	93 83       	std	Z+3, r25	; 0x03
    127e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1280:	ef 81       	ldd	r30, Y+7	; 0x07
    1282:	f8 85       	ldd	r31, Y+8	; 0x08
    1284:	02 80       	ldd	r0, Z+2	; 0x02
    1286:	f3 81       	ldd	r31, Z+3	; 0x03
    1288:	e0 2d       	mov	r30, r0
    128a:	8f 81       	ldd	r24, Y+7	; 0x07
    128c:	98 85       	ldd	r25, Y+8	; 0x08
    128e:	95 83       	std	Z+5, r25	; 0x05
    1290:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1292:	ef 81       	ldd	r30, Y+7	; 0x07
    1294:	f8 85       	ldd	r31, Y+8	; 0x08
    1296:	8b 81       	ldd	r24, Y+3	; 0x03
    1298:	9c 81       	ldd	r25, Y+4	; 0x04
    129a:	95 83       	std	Z+5, r25	; 0x05
    129c:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    129e:	eb 81       	ldd	r30, Y+3	; 0x03
    12a0:	fc 81       	ldd	r31, Y+4	; 0x04
    12a2:	8f 81       	ldd	r24, Y+7	; 0x07
    12a4:	98 85       	ldd	r25, Y+8	; 0x08
    12a6:	93 83       	std	Z+3, r25	; 0x03
    12a8:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    12aa:	ef 81       	ldd	r30, Y+7	; 0x07
    12ac:	f8 85       	ldd	r31, Y+8	; 0x08
    12ae:	8d 81       	ldd	r24, Y+5	; 0x05
    12b0:	9e 81       	ldd	r25, Y+6	; 0x06
    12b2:	91 87       	std	Z+9, r25	; 0x09
    12b4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    12b6:	ed 81       	ldd	r30, Y+5	; 0x05
    12b8:	fe 81       	ldd	r31, Y+6	; 0x06
    12ba:	80 81       	ld	r24, Z
    12bc:	8f 5f       	subi	r24, 0xFF	; 255
    12be:	ed 81       	ldd	r30, Y+5	; 0x05
    12c0:	fe 81       	ldd	r31, Y+6	; 0x06
    12c2:	80 83       	st	Z, r24
}
    12c4:	28 96       	adiw	r28, 0x08	; 8
    12c6:	0f b6       	in	r0, 0x3f	; 63
    12c8:	f8 94       	cli
    12ca:	de bf       	out	0x3e, r29	; 62
    12cc:	0f be       	out	0x3f, r0	; 63
    12ce:	cd bf       	out	0x3d, r28	; 61
    12d0:	cf 91       	pop	r28
    12d2:	df 91       	pop	r29
    12d4:	08 95       	ret

000012d6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    12d6:	df 93       	push	r29
    12d8:	cf 93       	push	r28
    12da:	00 d0       	rcall	.+0      	; 0x12dc <uxListRemove+0x6>
    12dc:	00 d0       	rcall	.+0      	; 0x12de <uxListRemove+0x8>
    12de:	cd b7       	in	r28, 0x3d	; 61
    12e0:	de b7       	in	r29, 0x3e	; 62
    12e2:	9c 83       	std	Y+4, r25	; 0x04
    12e4:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    12e6:	eb 81       	ldd	r30, Y+3	; 0x03
    12e8:	fc 81       	ldd	r31, Y+4	; 0x04
    12ea:	80 85       	ldd	r24, Z+8	; 0x08
    12ec:	91 85       	ldd	r25, Z+9	; 0x09
    12ee:	9a 83       	std	Y+2, r25	; 0x02
    12f0:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    12f2:	eb 81       	ldd	r30, Y+3	; 0x03
    12f4:	fc 81       	ldd	r31, Y+4	; 0x04
    12f6:	a2 81       	ldd	r26, Z+2	; 0x02
    12f8:	b3 81       	ldd	r27, Z+3	; 0x03
    12fa:	eb 81       	ldd	r30, Y+3	; 0x03
    12fc:	fc 81       	ldd	r31, Y+4	; 0x04
    12fe:	84 81       	ldd	r24, Z+4	; 0x04
    1300:	95 81       	ldd	r25, Z+5	; 0x05
    1302:	15 96       	adiw	r26, 0x05	; 5
    1304:	9c 93       	st	X, r25
    1306:	8e 93       	st	-X, r24
    1308:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    130a:	eb 81       	ldd	r30, Y+3	; 0x03
    130c:	fc 81       	ldd	r31, Y+4	; 0x04
    130e:	a4 81       	ldd	r26, Z+4	; 0x04
    1310:	b5 81       	ldd	r27, Z+5	; 0x05
    1312:	eb 81       	ldd	r30, Y+3	; 0x03
    1314:	fc 81       	ldd	r31, Y+4	; 0x04
    1316:	82 81       	ldd	r24, Z+2	; 0x02
    1318:	93 81       	ldd	r25, Z+3	; 0x03
    131a:	13 96       	adiw	r26, 0x03	; 3
    131c:	9c 93       	st	X, r25
    131e:	8e 93       	st	-X, r24
    1320:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1322:	e9 81       	ldd	r30, Y+1	; 0x01
    1324:	fa 81       	ldd	r31, Y+2	; 0x02
    1326:	21 81       	ldd	r18, Z+1	; 0x01
    1328:	32 81       	ldd	r19, Z+2	; 0x02
    132a:	8b 81       	ldd	r24, Y+3	; 0x03
    132c:	9c 81       	ldd	r25, Y+4	; 0x04
    132e:	28 17       	cp	r18, r24
    1330:	39 07       	cpc	r19, r25
    1332:	41 f4       	brne	.+16     	; 0x1344 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1334:	eb 81       	ldd	r30, Y+3	; 0x03
    1336:	fc 81       	ldd	r31, Y+4	; 0x04
    1338:	84 81       	ldd	r24, Z+4	; 0x04
    133a:	95 81       	ldd	r25, Z+5	; 0x05
    133c:	e9 81       	ldd	r30, Y+1	; 0x01
    133e:	fa 81       	ldd	r31, Y+2	; 0x02
    1340:	92 83       	std	Z+2, r25	; 0x02
    1342:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1344:	eb 81       	ldd	r30, Y+3	; 0x03
    1346:	fc 81       	ldd	r31, Y+4	; 0x04
    1348:	11 86       	std	Z+9, r1	; 0x09
    134a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    134c:	e9 81       	ldd	r30, Y+1	; 0x01
    134e:	fa 81       	ldd	r31, Y+2	; 0x02
    1350:	80 81       	ld	r24, Z
    1352:	81 50       	subi	r24, 0x01	; 1
    1354:	e9 81       	ldd	r30, Y+1	; 0x01
    1356:	fa 81       	ldd	r31, Y+2	; 0x02
    1358:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    135a:	e9 81       	ldd	r30, Y+1	; 0x01
    135c:	fa 81       	ldd	r31, Y+2	; 0x02
    135e:	80 81       	ld	r24, Z
}
    1360:	0f 90       	pop	r0
    1362:	0f 90       	pop	r0
    1364:	0f 90       	pop	r0
    1366:	0f 90       	pop	r0
    1368:	cf 91       	pop	r28
    136a:	df 91       	pop	r29
    136c:	08 95       	ret

0000136e <main>:
#define GREEN_TASK_PRIORITY         3
#define BLUE_TASK_PRIORITY          1


int main(void)
{
    136e:	ef 92       	push	r14
    1370:	ff 92       	push	r15
    1372:	0f 93       	push	r16
    1374:	df 93       	push	r29
    1376:	cf 93       	push	r28
    1378:	cd b7       	in	r28, 0x3d	; 61
    137a:	de b7       	in	r29, 0x3e	; 62
	DIO_voidInit();
    137c:	0e 94 49 00 	call	0x92	; 0x92 <DIO_voidInit>
	/* Create Tasks */
	xTaskCreate(&App_voidRedTask,NULL,200,NULL,RED_TASK_PRIORITY,NULL);
    1380:	8a ee       	ldi	r24, 0xEA	; 234
    1382:	99 e0       	ldi	r25, 0x09	; 9
    1384:	60 e0       	ldi	r22, 0x00	; 0
    1386:	70 e0       	ldi	r23, 0x00	; 0
    1388:	48 ec       	ldi	r20, 0xC8	; 200
    138a:	50 e0       	ldi	r21, 0x00	; 0
    138c:	20 e0       	ldi	r18, 0x00	; 0
    138e:	30 e0       	ldi	r19, 0x00	; 0
    1390:	04 e0       	ldi	r16, 0x04	; 4
    1392:	ee 24       	eor	r14, r14
    1394:	ff 24       	eor	r15, r15
    1396:	0e 94 3e 14 	call	0x287c	; 0x287c <xTaskCreate>
	xTaskCreate(&App_voidGreenTask,NULL,200,NULL,GREEN_TASK_PRIORITY,NULL);
    139a:	8a e0       	ldi	r24, 0x0A	; 10
    139c:	9a e0       	ldi	r25, 0x0A	; 10
    139e:	60 e0       	ldi	r22, 0x00	; 0
    13a0:	70 e0       	ldi	r23, 0x00	; 0
    13a2:	48 ec       	ldi	r20, 0xC8	; 200
    13a4:	50 e0       	ldi	r21, 0x00	; 0
    13a6:	20 e0       	ldi	r18, 0x00	; 0
    13a8:	30 e0       	ldi	r19, 0x00	; 0
    13aa:	03 e0       	ldi	r16, 0x03	; 3
    13ac:	ee 24       	eor	r14, r14
    13ae:	ff 24       	eor	r15, r15
    13b0:	0e 94 3e 14 	call	0x287c	; 0x287c <xTaskCreate>
	xTaskCreate(&App_voidBlueTask,NULL,200,NULL,BLUE_TASK_PRIORITY,NULL);
    13b4:	8a e2       	ldi	r24, 0x2A	; 42
    13b6:	9a e0       	ldi	r25, 0x0A	; 10
    13b8:	60 e0       	ldi	r22, 0x00	; 0
    13ba:	70 e0       	ldi	r23, 0x00	; 0
    13bc:	48 ec       	ldi	r20, 0xC8	; 200
    13be:	50 e0       	ldi	r21, 0x00	; 0
    13c0:	20 e0       	ldi	r18, 0x00	; 0
    13c2:	30 e0       	ldi	r19, 0x00	; 0
    13c4:	01 e0       	ldi	r16, 0x01	; 1
    13c6:	ee 24       	eor	r14, r14
    13c8:	ff 24       	eor	r15, r15
    13ca:	0e 94 3e 14 	call	0x287c	; 0x287c <xTaskCreate>

	/* Start Scheduler */
	vTaskStartScheduler();
    13ce:	0e 94 7b 19 	call	0x32f6	; 0x32f6 <vTaskStartScheduler>
    13d2:	ff cf       	rjmp	.-2      	; 0x13d2 <main+0x64>

000013d4 <App_voidRedTask>:

	return 0;
}

void App_voidRedTask(void * Copy_pv)
{
    13d4:	df 93       	push	r29
    13d6:	cf 93       	push	r28
    13d8:	00 d0       	rcall	.+0      	; 0x13da <App_voidRedTask+0x6>
    13da:	cd b7       	in	r28, 0x3d	; 61
    13dc:	de b7       	in	r29, 0x3e	; 62
    13de:	9a 83       	std	Y+2, r25	; 0x02
    13e0:	89 83       	std	Y+1, r24	; 0x01
	static u8 Local_u8Falg = 0;
	while(1)
	{
		if(Local_u8Falg == 0)
    13e2:	80 91 52 04 	lds	r24, 0x0452
    13e6:	88 23       	and	r24, r24
    13e8:	49 f4       	brne	.+18     	; 0x13fc <App_voidRedTask+0x28>
		{
			DIO_u8SetPinValue(DIO_u8_PORTA,DIO_u8_PIN0,DIO_u8_HIGH);
    13ea:	80 e0       	ldi	r24, 0x00	; 0
    13ec:	60 e0       	ldi	r22, 0x00	; 0
    13ee:	41 e0       	ldi	r20, 0x01	; 1
    13f0:	0e 94 94 01 	call	0x328	; 0x328 <DIO_u8SetPinValue>
			Local_u8Falg = 1;
    13f4:	81 e0       	ldi	r24, 0x01	; 1
    13f6:	80 93 52 04 	sts	0x0452, r24
    13fa:	07 c0       	rjmp	.+14     	; 0x140a <App_voidRedTask+0x36>
		}
		else
		{
			DIO_u8SetPinValue(DIO_u8_PORTA,DIO_u8_PIN0,DIO_u8_LOW);
    13fc:	80 e0       	ldi	r24, 0x00	; 0
    13fe:	60 e0       	ldi	r22, 0x00	; 0
    1400:	40 e0       	ldi	r20, 0x00	; 0
    1402:	0e 94 94 01 	call	0x328	; 0x328 <DIO_u8SetPinValue>
			Local_u8Falg = 0;
    1406:	10 92 52 04 	sts	0x0452, r1
		}
		vTaskDelay(1000);
    140a:	88 ee       	ldi	r24, 0xE8	; 232
    140c:	93 e0       	ldi	r25, 0x03	; 3
    140e:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <vTaskDelay>
    1412:	e7 cf       	rjmp	.-50     	; 0x13e2 <App_voidRedTask+0xe>

00001414 <App_voidGreenTask>:
	}
}
void App_voidGreenTask(void * Copy_pv)
{
    1414:	df 93       	push	r29
    1416:	cf 93       	push	r28
    1418:	00 d0       	rcall	.+0      	; 0x141a <App_voidGreenTask+0x6>
    141a:	cd b7       	in	r28, 0x3d	; 61
    141c:	de b7       	in	r29, 0x3e	; 62
    141e:	9a 83       	std	Y+2, r25	; 0x02
    1420:	89 83       	std	Y+1, r24	; 0x01
	static u8 Local_u8Falg = 0;
	while(1)
	{
		if(Local_u8Falg == 0)
    1422:	80 91 53 04 	lds	r24, 0x0453
    1426:	88 23       	and	r24, r24
    1428:	49 f4       	brne	.+18     	; 0x143c <App_voidGreenTask+0x28>
		{
			DIO_u8SetPinValue(DIO_u8_PORTA,DIO_u8_PIN1,DIO_u8_HIGH);
    142a:	80 e0       	ldi	r24, 0x00	; 0
    142c:	61 e0       	ldi	r22, 0x01	; 1
    142e:	41 e0       	ldi	r20, 0x01	; 1
    1430:	0e 94 94 01 	call	0x328	; 0x328 <DIO_u8SetPinValue>
			Local_u8Falg = 1;
    1434:	81 e0       	ldi	r24, 0x01	; 1
    1436:	80 93 53 04 	sts	0x0453, r24
    143a:	07 c0       	rjmp	.+14     	; 0x144a <App_voidGreenTask+0x36>
		}
		else
		{
			DIO_u8SetPinValue(DIO_u8_PORTA,DIO_u8_PIN1,DIO_u8_LOW);
    143c:	80 e0       	ldi	r24, 0x00	; 0
    143e:	61 e0       	ldi	r22, 0x01	; 1
    1440:	40 e0       	ldi	r20, 0x00	; 0
    1442:	0e 94 94 01 	call	0x328	; 0x328 <DIO_u8SetPinValue>
			Local_u8Falg = 0;
    1446:	10 92 53 04 	sts	0x0453, r1
		}
		vTaskDelay(2000);
    144a:	80 ed       	ldi	r24, 0xD0	; 208
    144c:	97 e0       	ldi	r25, 0x07	; 7
    144e:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <vTaskDelay>
    1452:	e7 cf       	rjmp	.-50     	; 0x1422 <App_voidGreenTask+0xe>

00001454 <App_voidBlueTask>:
	}
}
void App_voidBlueTask(void * Copy_pv)
{
    1454:	df 93       	push	r29
    1456:	cf 93       	push	r28
    1458:	00 d0       	rcall	.+0      	; 0x145a <App_voidBlueTask+0x6>
    145a:	cd b7       	in	r28, 0x3d	; 61
    145c:	de b7       	in	r29, 0x3e	; 62
    145e:	9a 83       	std	Y+2, r25	; 0x02
    1460:	89 83       	std	Y+1, r24	; 0x01
	static u8 Local_u8Falg = 0;
	while(1)
	{
		if(Local_u8Falg == 0)
    1462:	80 91 54 04 	lds	r24, 0x0454
    1466:	88 23       	and	r24, r24
    1468:	49 f4       	brne	.+18     	; 0x147c <App_voidBlueTask+0x28>
		{
			DIO_u8SetPinValue(DIO_u8_PORTA,DIO_u8_PIN2,DIO_u8_HIGH);
    146a:	80 e0       	ldi	r24, 0x00	; 0
    146c:	62 e0       	ldi	r22, 0x02	; 2
    146e:	41 e0       	ldi	r20, 0x01	; 1
    1470:	0e 94 94 01 	call	0x328	; 0x328 <DIO_u8SetPinValue>
			Local_u8Falg = 1;
    1474:	81 e0       	ldi	r24, 0x01	; 1
    1476:	80 93 54 04 	sts	0x0454, r24
    147a:	07 c0       	rjmp	.+14     	; 0x148a <App_voidBlueTask+0x36>
		}
		else
		{
			DIO_u8SetPinValue(DIO_u8_PORTA,DIO_u8_PIN2,DIO_u8_LOW);
    147c:	80 e0       	ldi	r24, 0x00	; 0
    147e:	62 e0       	ldi	r22, 0x02	; 2
    1480:	40 e0       	ldi	r20, 0x00	; 0
    1482:	0e 94 94 01 	call	0x328	; 0x328 <DIO_u8SetPinValue>
			Local_u8Falg = 0;
    1486:	10 92 54 04 	sts	0x0454, r1
		}
		vTaskDelay(4000);
    148a:	80 ea       	ldi	r24, 0xA0	; 160
    148c:	9f e0       	ldi	r25, 0x0F	; 15
    148e:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <vTaskDelay>
    1492:	e7 cf       	rjmp	.-50     	; 0x1462 <App_voidBlueTask+0xe>

00001494 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1494:	df 93       	push	r29
    1496:	cf 93       	push	r28
    1498:	cd b7       	in	r28, 0x3d	; 61
    149a:	de b7       	in	r29, 0x3e	; 62
    149c:	28 97       	sbiw	r28, 0x08	; 8
    149e:	0f b6       	in	r0, 0x3f	; 63
    14a0:	f8 94       	cli
    14a2:	de bf       	out	0x3e, r29	; 62
    14a4:	0f be       	out	0x3f, r0	; 63
    14a6:	cd bf       	out	0x3d, r28	; 61
    14a8:	9c 83       	std	Y+4, r25	; 0x04
    14aa:	8b 83       	std	Y+3, r24	; 0x03
    14ac:	7e 83       	std	Y+6, r23	; 0x06
    14ae:	6d 83       	std	Y+5, r22	; 0x05
    14b0:	58 87       	std	Y+8, r21	; 0x08
    14b2:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    14b4:	eb 81       	ldd	r30, Y+3	; 0x03
    14b6:	fc 81       	ldd	r31, Y+4	; 0x04
    14b8:	81 e1       	ldi	r24, 0x11	; 17
    14ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    14bc:	8b 81       	ldd	r24, Y+3	; 0x03
    14be:	9c 81       	ldd	r25, Y+4	; 0x04
    14c0:	01 97       	sbiw	r24, 0x01	; 1
    14c2:	9c 83       	std	Y+4, r25	; 0x04
    14c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    14c6:	eb 81       	ldd	r30, Y+3	; 0x03
    14c8:	fc 81       	ldd	r31, Y+4	; 0x04
    14ca:	82 e2       	ldi	r24, 0x22	; 34
    14cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    14ce:	8b 81       	ldd	r24, Y+3	; 0x03
    14d0:	9c 81       	ldd	r25, Y+4	; 0x04
    14d2:	01 97       	sbiw	r24, 0x01	; 1
    14d4:	9c 83       	std	Y+4, r25	; 0x04
    14d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    14d8:	eb 81       	ldd	r30, Y+3	; 0x03
    14da:	fc 81       	ldd	r31, Y+4	; 0x04
    14dc:	83 e3       	ldi	r24, 0x33	; 51
    14de:	80 83       	st	Z, r24
	pxTopOfStack--;
    14e0:	8b 81       	ldd	r24, Y+3	; 0x03
    14e2:	9c 81       	ldd	r25, Y+4	; 0x04
    14e4:	01 97       	sbiw	r24, 0x01	; 1
    14e6:	9c 83       	std	Y+4, r25	; 0x04
    14e8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    14ea:	8d 81       	ldd	r24, Y+5	; 0x05
    14ec:	9e 81       	ldd	r25, Y+6	; 0x06
    14ee:	9a 83       	std	Y+2, r25	; 0x02
    14f0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
    14f4:	eb 81       	ldd	r30, Y+3	; 0x03
    14f6:	fc 81       	ldd	r31, Y+4	; 0x04
    14f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    14fa:	8b 81       	ldd	r24, Y+3	; 0x03
    14fc:	9c 81       	ldd	r25, Y+4	; 0x04
    14fe:	01 97       	sbiw	r24, 0x01	; 1
    1500:	9c 83       	std	Y+4, r25	; 0x04
    1502:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1504:	89 81       	ldd	r24, Y+1	; 0x01
    1506:	9a 81       	ldd	r25, Y+2	; 0x02
    1508:	89 2f       	mov	r24, r25
    150a:	99 27       	eor	r25, r25
    150c:	9a 83       	std	Y+2, r25	; 0x02
    150e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1510:	89 81       	ldd	r24, Y+1	; 0x01
    1512:	eb 81       	ldd	r30, Y+3	; 0x03
    1514:	fc 81       	ldd	r31, Y+4	; 0x04
    1516:	80 83       	st	Z, r24
	pxTopOfStack--;
    1518:	8b 81       	ldd	r24, Y+3	; 0x03
    151a:	9c 81       	ldd	r25, Y+4	; 0x04
    151c:	01 97       	sbiw	r24, 0x01	; 1
    151e:	9c 83       	std	Y+4, r25	; 0x04
    1520:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1522:	eb 81       	ldd	r30, Y+3	; 0x03
    1524:	fc 81       	ldd	r31, Y+4	; 0x04
    1526:	10 82       	st	Z, r1
	pxTopOfStack--;
    1528:	8b 81       	ldd	r24, Y+3	; 0x03
    152a:	9c 81       	ldd	r25, Y+4	; 0x04
    152c:	01 97       	sbiw	r24, 0x01	; 1
    152e:	9c 83       	std	Y+4, r25	; 0x04
    1530:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1532:	eb 81       	ldd	r30, Y+3	; 0x03
    1534:	fc 81       	ldd	r31, Y+4	; 0x04
    1536:	80 e8       	ldi	r24, 0x80	; 128
    1538:	80 83       	st	Z, r24
	pxTopOfStack--;
    153a:	8b 81       	ldd	r24, Y+3	; 0x03
    153c:	9c 81       	ldd	r25, Y+4	; 0x04
    153e:	01 97       	sbiw	r24, 0x01	; 1
    1540:	9c 83       	std	Y+4, r25	; 0x04
    1542:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1544:	eb 81       	ldd	r30, Y+3	; 0x03
    1546:	fc 81       	ldd	r31, Y+4	; 0x04
    1548:	10 82       	st	Z, r1
	pxTopOfStack--;
    154a:	8b 81       	ldd	r24, Y+3	; 0x03
    154c:	9c 81       	ldd	r25, Y+4	; 0x04
    154e:	01 97       	sbiw	r24, 0x01	; 1
    1550:	9c 83       	std	Y+4, r25	; 0x04
    1552:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1554:	eb 81       	ldd	r30, Y+3	; 0x03
    1556:	fc 81       	ldd	r31, Y+4	; 0x04
    1558:	82 e0       	ldi	r24, 0x02	; 2
    155a:	80 83       	st	Z, r24
	pxTopOfStack--;
    155c:	8b 81       	ldd	r24, Y+3	; 0x03
    155e:	9c 81       	ldd	r25, Y+4	; 0x04
    1560:	01 97       	sbiw	r24, 0x01	; 1
    1562:	9c 83       	std	Y+4, r25	; 0x04
    1564:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1566:	eb 81       	ldd	r30, Y+3	; 0x03
    1568:	fc 81       	ldd	r31, Y+4	; 0x04
    156a:	83 e0       	ldi	r24, 0x03	; 3
    156c:	80 83       	st	Z, r24
	pxTopOfStack--;
    156e:	8b 81       	ldd	r24, Y+3	; 0x03
    1570:	9c 81       	ldd	r25, Y+4	; 0x04
    1572:	01 97       	sbiw	r24, 0x01	; 1
    1574:	9c 83       	std	Y+4, r25	; 0x04
    1576:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1578:	eb 81       	ldd	r30, Y+3	; 0x03
    157a:	fc 81       	ldd	r31, Y+4	; 0x04
    157c:	84 e0       	ldi	r24, 0x04	; 4
    157e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1580:	8b 81       	ldd	r24, Y+3	; 0x03
    1582:	9c 81       	ldd	r25, Y+4	; 0x04
    1584:	01 97       	sbiw	r24, 0x01	; 1
    1586:	9c 83       	std	Y+4, r25	; 0x04
    1588:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    158a:	eb 81       	ldd	r30, Y+3	; 0x03
    158c:	fc 81       	ldd	r31, Y+4	; 0x04
    158e:	85 e0       	ldi	r24, 0x05	; 5
    1590:	80 83       	st	Z, r24
	pxTopOfStack--;
    1592:	8b 81       	ldd	r24, Y+3	; 0x03
    1594:	9c 81       	ldd	r25, Y+4	; 0x04
    1596:	01 97       	sbiw	r24, 0x01	; 1
    1598:	9c 83       	std	Y+4, r25	; 0x04
    159a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    159c:	eb 81       	ldd	r30, Y+3	; 0x03
    159e:	fc 81       	ldd	r31, Y+4	; 0x04
    15a0:	86 e0       	ldi	r24, 0x06	; 6
    15a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    15a4:	8b 81       	ldd	r24, Y+3	; 0x03
    15a6:	9c 81       	ldd	r25, Y+4	; 0x04
    15a8:	01 97       	sbiw	r24, 0x01	; 1
    15aa:	9c 83       	std	Y+4, r25	; 0x04
    15ac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    15ae:	eb 81       	ldd	r30, Y+3	; 0x03
    15b0:	fc 81       	ldd	r31, Y+4	; 0x04
    15b2:	87 e0       	ldi	r24, 0x07	; 7
    15b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    15b6:	8b 81       	ldd	r24, Y+3	; 0x03
    15b8:	9c 81       	ldd	r25, Y+4	; 0x04
    15ba:	01 97       	sbiw	r24, 0x01	; 1
    15bc:	9c 83       	std	Y+4, r25	; 0x04
    15be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    15c0:	eb 81       	ldd	r30, Y+3	; 0x03
    15c2:	fc 81       	ldd	r31, Y+4	; 0x04
    15c4:	88 e0       	ldi	r24, 0x08	; 8
    15c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    15c8:	8b 81       	ldd	r24, Y+3	; 0x03
    15ca:	9c 81       	ldd	r25, Y+4	; 0x04
    15cc:	01 97       	sbiw	r24, 0x01	; 1
    15ce:	9c 83       	std	Y+4, r25	; 0x04
    15d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    15d2:	eb 81       	ldd	r30, Y+3	; 0x03
    15d4:	fc 81       	ldd	r31, Y+4	; 0x04
    15d6:	89 e0       	ldi	r24, 0x09	; 9
    15d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15da:	8b 81       	ldd	r24, Y+3	; 0x03
    15dc:	9c 81       	ldd	r25, Y+4	; 0x04
    15de:	01 97       	sbiw	r24, 0x01	; 1
    15e0:	9c 83       	std	Y+4, r25	; 0x04
    15e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    15e4:	eb 81       	ldd	r30, Y+3	; 0x03
    15e6:	fc 81       	ldd	r31, Y+4	; 0x04
    15e8:	80 e1       	ldi	r24, 0x10	; 16
    15ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    15ec:	8b 81       	ldd	r24, Y+3	; 0x03
    15ee:	9c 81       	ldd	r25, Y+4	; 0x04
    15f0:	01 97       	sbiw	r24, 0x01	; 1
    15f2:	9c 83       	std	Y+4, r25	; 0x04
    15f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    15f6:	eb 81       	ldd	r30, Y+3	; 0x03
    15f8:	fc 81       	ldd	r31, Y+4	; 0x04
    15fa:	81 e1       	ldi	r24, 0x11	; 17
    15fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    15fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1600:	9c 81       	ldd	r25, Y+4	; 0x04
    1602:	01 97       	sbiw	r24, 0x01	; 1
    1604:	9c 83       	std	Y+4, r25	; 0x04
    1606:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1608:	eb 81       	ldd	r30, Y+3	; 0x03
    160a:	fc 81       	ldd	r31, Y+4	; 0x04
    160c:	82 e1       	ldi	r24, 0x12	; 18
    160e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1610:	8b 81       	ldd	r24, Y+3	; 0x03
    1612:	9c 81       	ldd	r25, Y+4	; 0x04
    1614:	01 97       	sbiw	r24, 0x01	; 1
    1616:	9c 83       	std	Y+4, r25	; 0x04
    1618:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    161a:	eb 81       	ldd	r30, Y+3	; 0x03
    161c:	fc 81       	ldd	r31, Y+4	; 0x04
    161e:	83 e1       	ldi	r24, 0x13	; 19
    1620:	80 83       	st	Z, r24
	pxTopOfStack--;
    1622:	8b 81       	ldd	r24, Y+3	; 0x03
    1624:	9c 81       	ldd	r25, Y+4	; 0x04
    1626:	01 97       	sbiw	r24, 0x01	; 1
    1628:	9c 83       	std	Y+4, r25	; 0x04
    162a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    162c:	eb 81       	ldd	r30, Y+3	; 0x03
    162e:	fc 81       	ldd	r31, Y+4	; 0x04
    1630:	84 e1       	ldi	r24, 0x14	; 20
    1632:	80 83       	st	Z, r24
	pxTopOfStack--;
    1634:	8b 81       	ldd	r24, Y+3	; 0x03
    1636:	9c 81       	ldd	r25, Y+4	; 0x04
    1638:	01 97       	sbiw	r24, 0x01	; 1
    163a:	9c 83       	std	Y+4, r25	; 0x04
    163c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    163e:	eb 81       	ldd	r30, Y+3	; 0x03
    1640:	fc 81       	ldd	r31, Y+4	; 0x04
    1642:	85 e1       	ldi	r24, 0x15	; 21
    1644:	80 83       	st	Z, r24
	pxTopOfStack--;
    1646:	8b 81       	ldd	r24, Y+3	; 0x03
    1648:	9c 81       	ldd	r25, Y+4	; 0x04
    164a:	01 97       	sbiw	r24, 0x01	; 1
    164c:	9c 83       	std	Y+4, r25	; 0x04
    164e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1650:	eb 81       	ldd	r30, Y+3	; 0x03
    1652:	fc 81       	ldd	r31, Y+4	; 0x04
    1654:	86 e1       	ldi	r24, 0x16	; 22
    1656:	80 83       	st	Z, r24
	pxTopOfStack--;
    1658:	8b 81       	ldd	r24, Y+3	; 0x03
    165a:	9c 81       	ldd	r25, Y+4	; 0x04
    165c:	01 97       	sbiw	r24, 0x01	; 1
    165e:	9c 83       	std	Y+4, r25	; 0x04
    1660:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1662:	eb 81       	ldd	r30, Y+3	; 0x03
    1664:	fc 81       	ldd	r31, Y+4	; 0x04
    1666:	87 e1       	ldi	r24, 0x17	; 23
    1668:	80 83       	st	Z, r24
	pxTopOfStack--;
    166a:	8b 81       	ldd	r24, Y+3	; 0x03
    166c:	9c 81       	ldd	r25, Y+4	; 0x04
    166e:	01 97       	sbiw	r24, 0x01	; 1
    1670:	9c 83       	std	Y+4, r25	; 0x04
    1672:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1674:	eb 81       	ldd	r30, Y+3	; 0x03
    1676:	fc 81       	ldd	r31, Y+4	; 0x04
    1678:	88 e1       	ldi	r24, 0x18	; 24
    167a:	80 83       	st	Z, r24
	pxTopOfStack--;
    167c:	8b 81       	ldd	r24, Y+3	; 0x03
    167e:	9c 81       	ldd	r25, Y+4	; 0x04
    1680:	01 97       	sbiw	r24, 0x01	; 1
    1682:	9c 83       	std	Y+4, r25	; 0x04
    1684:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1686:	eb 81       	ldd	r30, Y+3	; 0x03
    1688:	fc 81       	ldd	r31, Y+4	; 0x04
    168a:	89 e1       	ldi	r24, 0x19	; 25
    168c:	80 83       	st	Z, r24
	pxTopOfStack--;
    168e:	8b 81       	ldd	r24, Y+3	; 0x03
    1690:	9c 81       	ldd	r25, Y+4	; 0x04
    1692:	01 97       	sbiw	r24, 0x01	; 1
    1694:	9c 83       	std	Y+4, r25	; 0x04
    1696:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1698:	eb 81       	ldd	r30, Y+3	; 0x03
    169a:	fc 81       	ldd	r31, Y+4	; 0x04
    169c:	80 e2       	ldi	r24, 0x20	; 32
    169e:	80 83       	st	Z, r24
	pxTopOfStack--;
    16a0:	8b 81       	ldd	r24, Y+3	; 0x03
    16a2:	9c 81       	ldd	r25, Y+4	; 0x04
    16a4:	01 97       	sbiw	r24, 0x01	; 1
    16a6:	9c 83       	std	Y+4, r25	; 0x04
    16a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    16aa:	eb 81       	ldd	r30, Y+3	; 0x03
    16ac:	fc 81       	ldd	r31, Y+4	; 0x04
    16ae:	81 e2       	ldi	r24, 0x21	; 33
    16b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    16b2:	8b 81       	ldd	r24, Y+3	; 0x03
    16b4:	9c 81       	ldd	r25, Y+4	; 0x04
    16b6:	01 97       	sbiw	r24, 0x01	; 1
    16b8:	9c 83       	std	Y+4, r25	; 0x04
    16ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    16bc:	eb 81       	ldd	r30, Y+3	; 0x03
    16be:	fc 81       	ldd	r31, Y+4	; 0x04
    16c0:	82 e2       	ldi	r24, 0x22	; 34
    16c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    16c4:	8b 81       	ldd	r24, Y+3	; 0x03
    16c6:	9c 81       	ldd	r25, Y+4	; 0x04
    16c8:	01 97       	sbiw	r24, 0x01	; 1
    16ca:	9c 83       	std	Y+4, r25	; 0x04
    16cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    16ce:	eb 81       	ldd	r30, Y+3	; 0x03
    16d0:	fc 81       	ldd	r31, Y+4	; 0x04
    16d2:	83 e2       	ldi	r24, 0x23	; 35
    16d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    16d6:	8b 81       	ldd	r24, Y+3	; 0x03
    16d8:	9c 81       	ldd	r25, Y+4	; 0x04
    16da:	01 97       	sbiw	r24, 0x01	; 1
    16dc:	9c 83       	std	Y+4, r25	; 0x04
    16de:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    16e0:	8f 81       	ldd	r24, Y+7	; 0x07
    16e2:	98 85       	ldd	r25, Y+8	; 0x08
    16e4:	9a 83       	std	Y+2, r25	; 0x02
    16e6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    16e8:	89 81       	ldd	r24, Y+1	; 0x01
    16ea:	eb 81       	ldd	r30, Y+3	; 0x03
    16ec:	fc 81       	ldd	r31, Y+4	; 0x04
    16ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    16f0:	8b 81       	ldd	r24, Y+3	; 0x03
    16f2:	9c 81       	ldd	r25, Y+4	; 0x04
    16f4:	01 97       	sbiw	r24, 0x01	; 1
    16f6:	9c 83       	std	Y+4, r25	; 0x04
    16f8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    16fa:	89 81       	ldd	r24, Y+1	; 0x01
    16fc:	9a 81       	ldd	r25, Y+2	; 0x02
    16fe:	89 2f       	mov	r24, r25
    1700:	99 27       	eor	r25, r25
    1702:	9a 83       	std	Y+2, r25	; 0x02
    1704:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1706:	89 81       	ldd	r24, Y+1	; 0x01
    1708:	eb 81       	ldd	r30, Y+3	; 0x03
    170a:	fc 81       	ldd	r31, Y+4	; 0x04
    170c:	80 83       	st	Z, r24
	pxTopOfStack--;
    170e:	8b 81       	ldd	r24, Y+3	; 0x03
    1710:	9c 81       	ldd	r25, Y+4	; 0x04
    1712:	01 97       	sbiw	r24, 0x01	; 1
    1714:	9c 83       	std	Y+4, r25	; 0x04
    1716:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1718:	eb 81       	ldd	r30, Y+3	; 0x03
    171a:	fc 81       	ldd	r31, Y+4	; 0x04
    171c:	86 e2       	ldi	r24, 0x26	; 38
    171e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1720:	8b 81       	ldd	r24, Y+3	; 0x03
    1722:	9c 81       	ldd	r25, Y+4	; 0x04
    1724:	01 97       	sbiw	r24, 0x01	; 1
    1726:	9c 83       	std	Y+4, r25	; 0x04
    1728:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    172a:	eb 81       	ldd	r30, Y+3	; 0x03
    172c:	fc 81       	ldd	r31, Y+4	; 0x04
    172e:	87 e2       	ldi	r24, 0x27	; 39
    1730:	80 83       	st	Z, r24
	pxTopOfStack--;
    1732:	8b 81       	ldd	r24, Y+3	; 0x03
    1734:	9c 81       	ldd	r25, Y+4	; 0x04
    1736:	01 97       	sbiw	r24, 0x01	; 1
    1738:	9c 83       	std	Y+4, r25	; 0x04
    173a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    173c:	eb 81       	ldd	r30, Y+3	; 0x03
    173e:	fc 81       	ldd	r31, Y+4	; 0x04
    1740:	88 e2       	ldi	r24, 0x28	; 40
    1742:	80 83       	st	Z, r24
	pxTopOfStack--;
    1744:	8b 81       	ldd	r24, Y+3	; 0x03
    1746:	9c 81       	ldd	r25, Y+4	; 0x04
    1748:	01 97       	sbiw	r24, 0x01	; 1
    174a:	9c 83       	std	Y+4, r25	; 0x04
    174c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    174e:	eb 81       	ldd	r30, Y+3	; 0x03
    1750:	fc 81       	ldd	r31, Y+4	; 0x04
    1752:	89 e2       	ldi	r24, 0x29	; 41
    1754:	80 83       	st	Z, r24
	pxTopOfStack--;
    1756:	8b 81       	ldd	r24, Y+3	; 0x03
    1758:	9c 81       	ldd	r25, Y+4	; 0x04
    175a:	01 97       	sbiw	r24, 0x01	; 1
    175c:	9c 83       	std	Y+4, r25	; 0x04
    175e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1760:	eb 81       	ldd	r30, Y+3	; 0x03
    1762:	fc 81       	ldd	r31, Y+4	; 0x04
    1764:	80 e3       	ldi	r24, 0x30	; 48
    1766:	80 83       	st	Z, r24
	pxTopOfStack--;
    1768:	8b 81       	ldd	r24, Y+3	; 0x03
    176a:	9c 81       	ldd	r25, Y+4	; 0x04
    176c:	01 97       	sbiw	r24, 0x01	; 1
    176e:	9c 83       	std	Y+4, r25	; 0x04
    1770:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1772:	eb 81       	ldd	r30, Y+3	; 0x03
    1774:	fc 81       	ldd	r31, Y+4	; 0x04
    1776:	81 e3       	ldi	r24, 0x31	; 49
    1778:	80 83       	st	Z, r24
	pxTopOfStack--;
    177a:	8b 81       	ldd	r24, Y+3	; 0x03
    177c:	9c 81       	ldd	r25, Y+4	; 0x04
    177e:	01 97       	sbiw	r24, 0x01	; 1
    1780:	9c 83       	std	Y+4, r25	; 0x04
    1782:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1784:	8b 81       	ldd	r24, Y+3	; 0x03
    1786:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1788:	28 96       	adiw	r28, 0x08	; 8
    178a:	0f b6       	in	r0, 0x3f	; 63
    178c:	f8 94       	cli
    178e:	de bf       	out	0x3e, r29	; 62
    1790:	0f be       	out	0x3f, r0	; 63
    1792:	cd bf       	out	0x3d, r28	; 61
    1794:	cf 91       	pop	r28
    1796:	df 91       	pop	r29
    1798:	08 95       	ret

0000179a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    179a:	df 93       	push	r29
    179c:	cf 93       	push	r28
    179e:	cd b7       	in	r28, 0x3d	; 61
    17a0:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    17a2:	0e 94 bf 0c 	call	0x197e	; 0x197e <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    17a6:	a0 91 55 04 	lds	r26, 0x0455
    17aa:	b0 91 56 04 	lds	r27, 0x0456
    17ae:	cd 91       	ld	r28, X+
    17b0:	cd bf       	out	0x3d, r28	; 61
    17b2:	dd 91       	ld	r29, X+
    17b4:	de bf       	out	0x3e, r29	; 62
    17b6:	ff 91       	pop	r31
    17b8:	ef 91       	pop	r30
    17ba:	df 91       	pop	r29
    17bc:	cf 91       	pop	r28
    17be:	bf 91       	pop	r27
    17c0:	af 91       	pop	r26
    17c2:	9f 91       	pop	r25
    17c4:	8f 91       	pop	r24
    17c6:	7f 91       	pop	r23
    17c8:	6f 91       	pop	r22
    17ca:	5f 91       	pop	r21
    17cc:	4f 91       	pop	r20
    17ce:	3f 91       	pop	r19
    17d0:	2f 91       	pop	r18
    17d2:	1f 91       	pop	r17
    17d4:	0f 91       	pop	r16
    17d6:	ff 90       	pop	r15
    17d8:	ef 90       	pop	r14
    17da:	df 90       	pop	r13
    17dc:	cf 90       	pop	r12
    17de:	bf 90       	pop	r11
    17e0:	af 90       	pop	r10
    17e2:	9f 90       	pop	r9
    17e4:	8f 90       	pop	r8
    17e6:	7f 90       	pop	r7
    17e8:	6f 90       	pop	r6
    17ea:	5f 90       	pop	r5
    17ec:	4f 90       	pop	r4
    17ee:	3f 90       	pop	r3
    17f0:	2f 90       	pop	r2
    17f2:	1f 90       	pop	r1
    17f4:	0f 90       	pop	r0
    17f6:	0f be       	out	0x3f, r0	; 63
    17f8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    17fa:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    17fc:	81 e0       	ldi	r24, 0x01	; 1
}
    17fe:	cf 91       	pop	r28
    1800:	df 91       	pop	r29
    1802:	08 95       	ret

00001804 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1804:	df 93       	push	r29
    1806:	cf 93       	push	r28
    1808:	cd b7       	in	r28, 0x3d	; 61
    180a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    180c:	cf 91       	pop	r28
    180e:	df 91       	pop	r29
    1810:	08 95       	ret

00001812 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1812:	0f 92       	push	r0
    1814:	0f b6       	in	r0, 0x3f	; 63
    1816:	f8 94       	cli
    1818:	0f 92       	push	r0
    181a:	1f 92       	push	r1
    181c:	11 24       	eor	r1, r1
    181e:	2f 92       	push	r2
    1820:	3f 92       	push	r3
    1822:	4f 92       	push	r4
    1824:	5f 92       	push	r5
    1826:	6f 92       	push	r6
    1828:	7f 92       	push	r7
    182a:	8f 92       	push	r8
    182c:	9f 92       	push	r9
    182e:	af 92       	push	r10
    1830:	bf 92       	push	r11
    1832:	cf 92       	push	r12
    1834:	df 92       	push	r13
    1836:	ef 92       	push	r14
    1838:	ff 92       	push	r15
    183a:	0f 93       	push	r16
    183c:	1f 93       	push	r17
    183e:	2f 93       	push	r18
    1840:	3f 93       	push	r19
    1842:	4f 93       	push	r20
    1844:	5f 93       	push	r21
    1846:	6f 93       	push	r22
    1848:	7f 93       	push	r23
    184a:	8f 93       	push	r24
    184c:	9f 93       	push	r25
    184e:	af 93       	push	r26
    1850:	bf 93       	push	r27
    1852:	cf 93       	push	r28
    1854:	df 93       	push	r29
    1856:	ef 93       	push	r30
    1858:	ff 93       	push	r31
    185a:	a0 91 55 04 	lds	r26, 0x0455
    185e:	b0 91 56 04 	lds	r27, 0x0456
    1862:	0d b6       	in	r0, 0x3d	; 61
    1864:	0d 92       	st	X+, r0
    1866:	0e b6       	in	r0, 0x3e	; 62
    1868:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    186a:	0e 94 ca 1b 	call	0x3794	; 0x3794 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    186e:	a0 91 55 04 	lds	r26, 0x0455
    1872:	b0 91 56 04 	lds	r27, 0x0456
    1876:	cd 91       	ld	r28, X+
    1878:	cd bf       	out	0x3d, r28	; 61
    187a:	dd 91       	ld	r29, X+
    187c:	de bf       	out	0x3e, r29	; 62
    187e:	ff 91       	pop	r31
    1880:	ef 91       	pop	r30
    1882:	df 91       	pop	r29
    1884:	cf 91       	pop	r28
    1886:	bf 91       	pop	r27
    1888:	af 91       	pop	r26
    188a:	9f 91       	pop	r25
    188c:	8f 91       	pop	r24
    188e:	7f 91       	pop	r23
    1890:	6f 91       	pop	r22
    1892:	5f 91       	pop	r21
    1894:	4f 91       	pop	r20
    1896:	3f 91       	pop	r19
    1898:	2f 91       	pop	r18
    189a:	1f 91       	pop	r17
    189c:	0f 91       	pop	r16
    189e:	ff 90       	pop	r15
    18a0:	ef 90       	pop	r14
    18a2:	df 90       	pop	r13
    18a4:	cf 90       	pop	r12
    18a6:	bf 90       	pop	r11
    18a8:	af 90       	pop	r10
    18aa:	9f 90       	pop	r9
    18ac:	8f 90       	pop	r8
    18ae:	7f 90       	pop	r7
    18b0:	6f 90       	pop	r6
    18b2:	5f 90       	pop	r5
    18b4:	4f 90       	pop	r4
    18b6:	3f 90       	pop	r3
    18b8:	2f 90       	pop	r2
    18ba:	1f 90       	pop	r1
    18bc:	0f 90       	pop	r0
    18be:	0f be       	out	0x3f, r0	; 63
    18c0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    18c2:	08 95       	ret

000018c4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    18c4:	0f 92       	push	r0
    18c6:	0f b6       	in	r0, 0x3f	; 63
    18c8:	f8 94       	cli
    18ca:	0f 92       	push	r0
    18cc:	1f 92       	push	r1
    18ce:	11 24       	eor	r1, r1
    18d0:	2f 92       	push	r2
    18d2:	3f 92       	push	r3
    18d4:	4f 92       	push	r4
    18d6:	5f 92       	push	r5
    18d8:	6f 92       	push	r6
    18da:	7f 92       	push	r7
    18dc:	8f 92       	push	r8
    18de:	9f 92       	push	r9
    18e0:	af 92       	push	r10
    18e2:	bf 92       	push	r11
    18e4:	cf 92       	push	r12
    18e6:	df 92       	push	r13
    18e8:	ef 92       	push	r14
    18ea:	ff 92       	push	r15
    18ec:	0f 93       	push	r16
    18ee:	1f 93       	push	r17
    18f0:	2f 93       	push	r18
    18f2:	3f 93       	push	r19
    18f4:	4f 93       	push	r20
    18f6:	5f 93       	push	r21
    18f8:	6f 93       	push	r22
    18fa:	7f 93       	push	r23
    18fc:	8f 93       	push	r24
    18fe:	9f 93       	push	r25
    1900:	af 93       	push	r26
    1902:	bf 93       	push	r27
    1904:	cf 93       	push	r28
    1906:	df 93       	push	r29
    1908:	ef 93       	push	r30
    190a:	ff 93       	push	r31
    190c:	a0 91 55 04 	lds	r26, 0x0455
    1910:	b0 91 56 04 	lds	r27, 0x0456
    1914:	0d b6       	in	r0, 0x3d	; 61
    1916:	0d 92       	st	X+, r0
    1918:	0e b6       	in	r0, 0x3e	; 62
    191a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    191c:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <xTaskIncrementTick>
    1920:	88 23       	and	r24, r24
    1922:	11 f0       	breq	.+4      	; 0x1928 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1924:	0e 94 ca 1b 	call	0x3794	; 0x3794 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1928:	a0 91 55 04 	lds	r26, 0x0455
    192c:	b0 91 56 04 	lds	r27, 0x0456
    1930:	cd 91       	ld	r28, X+
    1932:	cd bf       	out	0x3d, r28	; 61
    1934:	dd 91       	ld	r29, X+
    1936:	de bf       	out	0x3e, r29	; 62
    1938:	ff 91       	pop	r31
    193a:	ef 91       	pop	r30
    193c:	df 91       	pop	r29
    193e:	cf 91       	pop	r28
    1940:	bf 91       	pop	r27
    1942:	af 91       	pop	r26
    1944:	9f 91       	pop	r25
    1946:	8f 91       	pop	r24
    1948:	7f 91       	pop	r23
    194a:	6f 91       	pop	r22
    194c:	5f 91       	pop	r21
    194e:	4f 91       	pop	r20
    1950:	3f 91       	pop	r19
    1952:	2f 91       	pop	r18
    1954:	1f 91       	pop	r17
    1956:	0f 91       	pop	r16
    1958:	ff 90       	pop	r15
    195a:	ef 90       	pop	r14
    195c:	df 90       	pop	r13
    195e:	cf 90       	pop	r12
    1960:	bf 90       	pop	r11
    1962:	af 90       	pop	r10
    1964:	9f 90       	pop	r9
    1966:	8f 90       	pop	r8
    1968:	7f 90       	pop	r7
    196a:	6f 90       	pop	r6
    196c:	5f 90       	pop	r5
    196e:	4f 90       	pop	r4
    1970:	3f 90       	pop	r3
    1972:	2f 90       	pop	r2
    1974:	1f 90       	pop	r1
    1976:	0f 90       	pop	r0
    1978:	0f be       	out	0x3f, r0	; 63
    197a:	0f 90       	pop	r0

	asm volatile ( "ret" );
    197c:	08 95       	ret

0000197e <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    197e:	df 93       	push	r29
    1980:	cf 93       	push	r28
    1982:	00 d0       	rcall	.+0      	; 0x1984 <prvSetupTimerInterrupt+0x6>
    1984:	00 d0       	rcall	.+0      	; 0x1986 <prvSetupTimerInterrupt+0x8>
    1986:	00 d0       	rcall	.+0      	; 0x1988 <prvSetupTimerInterrupt+0xa>
    1988:	cd b7       	in	r28, 0x3d	; 61
    198a:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    198c:	80 e4       	ldi	r24, 0x40	; 64
    198e:	9f e1       	ldi	r25, 0x1F	; 31
    1990:	a0 e0       	ldi	r26, 0x00	; 0
    1992:	b0 e0       	ldi	r27, 0x00	; 0
    1994:	8b 83       	std	Y+3, r24	; 0x03
    1996:	9c 83       	std	Y+4, r25	; 0x04
    1998:	ad 83       	std	Y+5, r26	; 0x05
    199a:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    199c:	8b 81       	ldd	r24, Y+3	; 0x03
    199e:	9c 81       	ldd	r25, Y+4	; 0x04
    19a0:	ad 81       	ldd	r26, Y+5	; 0x05
    19a2:	be 81       	ldd	r27, Y+6	; 0x06
    19a4:	68 94       	set
    19a6:	15 f8       	bld	r1, 5
    19a8:	b6 95       	lsr	r27
    19aa:	a7 95       	ror	r26
    19ac:	97 95       	ror	r25
    19ae:	87 95       	ror	r24
    19b0:	16 94       	lsr	r1
    19b2:	d1 f7       	brne	.-12     	; 0x19a8 <prvSetupTimerInterrupt+0x2a>
    19b4:	8b 83       	std	Y+3, r24	; 0x03
    19b6:	9c 83       	std	Y+4, r25	; 0x04
    19b8:	ad 83       	std	Y+5, r26	; 0x05
    19ba:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    19bc:	8b 81       	ldd	r24, Y+3	; 0x03
    19be:	9c 81       	ldd	r25, Y+4	; 0x04
    19c0:	ad 81       	ldd	r26, Y+5	; 0x05
    19c2:	be 81       	ldd	r27, Y+6	; 0x06
    19c4:	01 97       	sbiw	r24, 0x01	; 1
    19c6:	a1 09       	sbc	r26, r1
    19c8:	b1 09       	sbc	r27, r1
    19ca:	8b 83       	std	Y+3, r24	; 0x03
    19cc:	9c 83       	std	Y+4, r25	; 0x04
    19ce:	ad 83       	std	Y+5, r26	; 0x05
    19d0:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    19d2:	8b 81       	ldd	r24, Y+3	; 0x03
    19d4:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    19d6:	8b 81       	ldd	r24, Y+3	; 0x03
    19d8:	9c 81       	ldd	r25, Y+4	; 0x04
    19da:	ad 81       	ldd	r26, Y+5	; 0x05
    19dc:	be 81       	ldd	r27, Y+6	; 0x06
    19de:	89 2f       	mov	r24, r25
    19e0:	9a 2f       	mov	r25, r26
    19e2:	ab 2f       	mov	r26, r27
    19e4:	bb 27       	eor	r27, r27
    19e6:	8b 83       	std	Y+3, r24	; 0x03
    19e8:	9c 83       	std	Y+4, r25	; 0x04
    19ea:	ad 83       	std	Y+5, r26	; 0x05
    19ec:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    19ee:	8b 81       	ldd	r24, Y+3	; 0x03
    19f0:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    19f2:	eb e4       	ldi	r30, 0x4B	; 75
    19f4:	f0 e0       	ldi	r31, 0x00	; 0
    19f6:	8a 81       	ldd	r24, Y+2	; 0x02
    19f8:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    19fa:	ea e4       	ldi	r30, 0x4A	; 74
    19fc:	f0 e0       	ldi	r31, 0x00	; 0
    19fe:	89 81       	ldd	r24, Y+1	; 0x01
    1a00:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1a02:	8b e0       	ldi	r24, 0x0B	; 11
    1a04:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1a06:	ee e4       	ldi	r30, 0x4E	; 78
    1a08:	f0 e0       	ldi	r31, 0x00	; 0
    1a0a:	89 81       	ldd	r24, Y+1	; 0x01
    1a0c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1a0e:	e9 e5       	ldi	r30, 0x59	; 89
    1a10:	f0 e0       	ldi	r31, 0x00	; 0
    1a12:	80 81       	ld	r24, Z
    1a14:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1a16:	89 81       	ldd	r24, Y+1	; 0x01
    1a18:	80 61       	ori	r24, 0x10	; 16
    1a1a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1a1c:	e9 e5       	ldi	r30, 0x59	; 89
    1a1e:	f0 e0       	ldi	r31, 0x00	; 0
    1a20:	89 81       	ldd	r24, Y+1	; 0x01
    1a22:	80 83       	st	Z, r24
}
    1a24:	26 96       	adiw	r28, 0x06	; 6
    1a26:	0f b6       	in	r0, 0x3f	; 63
    1a28:	f8 94       	cli
    1a2a:	de bf       	out	0x3e, r29	; 62
    1a2c:	0f be       	out	0x3f, r0	; 63
    1a2e:	cd bf       	out	0x3d, r28	; 61
    1a30:	cf 91       	pop	r28
    1a32:	df 91       	pop	r29
    1a34:	08 95       	ret

00001a36 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1a36:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1a3a:	18 95       	reti

00001a3c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1a3c:	df 93       	push	r29
    1a3e:	cf 93       	push	r28
    1a40:	00 d0       	rcall	.+0      	; 0x1a42 <xQueueGenericReset+0x6>
    1a42:	00 d0       	rcall	.+0      	; 0x1a44 <xQueueGenericReset+0x8>
    1a44:	0f 92       	push	r0
    1a46:	cd b7       	in	r28, 0x3d	; 61
    1a48:	de b7       	in	r29, 0x3e	; 62
    1a4a:	9c 83       	std	Y+4, r25	; 0x04
    1a4c:	8b 83       	std	Y+3, r24	; 0x03
    1a4e:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1a50:	8b 81       	ldd	r24, Y+3	; 0x03
    1a52:	9c 81       	ldd	r25, Y+4	; 0x04
    1a54:	9a 83       	std	Y+2, r25	; 0x02
    1a56:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a58:	0f b6       	in	r0, 0x3f	; 63
    1a5a:	f8 94       	cli
    1a5c:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1a5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a60:	fa 81       	ldd	r31, Y+2	; 0x02
    1a62:	40 81       	ld	r20, Z
    1a64:	51 81       	ldd	r21, Z+1	; 0x01
    1a66:	e9 81       	ldd	r30, Y+1	; 0x01
    1a68:	fa 81       	ldd	r31, Y+2	; 0x02
    1a6a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a6c:	28 2f       	mov	r18, r24
    1a6e:	30 e0       	ldi	r19, 0x00	; 0
    1a70:	e9 81       	ldd	r30, Y+1	; 0x01
    1a72:	fa 81       	ldd	r31, Y+2	; 0x02
    1a74:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a76:	88 2f       	mov	r24, r24
    1a78:	90 e0       	ldi	r25, 0x00	; 0
    1a7a:	bc 01       	movw	r22, r24
    1a7c:	26 9f       	mul	r18, r22
    1a7e:	c0 01       	movw	r24, r0
    1a80:	27 9f       	mul	r18, r23
    1a82:	90 0d       	add	r25, r0
    1a84:	36 9f       	mul	r19, r22
    1a86:	90 0d       	add	r25, r0
    1a88:	11 24       	eor	r1, r1
    1a8a:	84 0f       	add	r24, r20
    1a8c:	95 1f       	adc	r25, r21
    1a8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a90:	fa 81       	ldd	r31, Y+2	; 0x02
    1a92:	95 83       	std	Z+5, r25	; 0x05
    1a94:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1a96:	e9 81       	ldd	r30, Y+1	; 0x01
    1a98:	fa 81       	ldd	r31, Y+2	; 0x02
    1a9a:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1a9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa0:	80 81       	ld	r24, Z
    1aa2:	91 81       	ldd	r25, Z+1	; 0x01
    1aa4:	e9 81       	ldd	r30, Y+1	; 0x01
    1aa6:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa8:	93 83       	std	Z+3, r25	; 0x03
    1aaa:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1aac:	e9 81       	ldd	r30, Y+1	; 0x01
    1aae:	fa 81       	ldd	r31, Y+2	; 0x02
    1ab0:	40 81       	ld	r20, Z
    1ab2:	51 81       	ldd	r21, Z+1	; 0x01
    1ab4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ab8:	83 8d       	ldd	r24, Z+27	; 0x1b
    1aba:	88 2f       	mov	r24, r24
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	9c 01       	movw	r18, r24
    1ac0:	21 50       	subi	r18, 0x01	; 1
    1ac2:	30 40       	sbci	r19, 0x00	; 0
    1ac4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ac6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ac8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1aca:	88 2f       	mov	r24, r24
    1acc:	90 e0       	ldi	r25, 0x00	; 0
    1ace:	bc 01       	movw	r22, r24
    1ad0:	26 9f       	mul	r18, r22
    1ad2:	c0 01       	movw	r24, r0
    1ad4:	27 9f       	mul	r18, r23
    1ad6:	90 0d       	add	r25, r0
    1ad8:	36 9f       	mul	r19, r22
    1ada:	90 0d       	add	r25, r0
    1adc:	11 24       	eor	r1, r1
    1ade:	84 0f       	add	r24, r20
    1ae0:	95 1f       	adc	r25, r21
    1ae2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ae4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ae6:	97 83       	std	Z+7, r25	; 0x07
    1ae8:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1aea:	e9 81       	ldd	r30, Y+1	; 0x01
    1aec:	fa 81       	ldd	r31, Y+2	; 0x02
    1aee:	8f ef       	ldi	r24, 0xFF	; 255
    1af0:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1af2:	e9 81       	ldd	r30, Y+1	; 0x01
    1af4:	fa 81       	ldd	r31, Y+2	; 0x02
    1af6:	8f ef       	ldi	r24, 0xFF	; 255
    1af8:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1afa:	8d 81       	ldd	r24, Y+5	; 0x05
    1afc:	88 23       	and	r24, r24
    1afe:	79 f4       	brne	.+30     	; 0x1b1e <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1b00:	e9 81       	ldd	r30, Y+1	; 0x01
    1b02:	fa 81       	ldd	r31, Y+2	; 0x02
    1b04:	80 85       	ldd	r24, Z+8	; 0x08
    1b06:	88 23       	and	r24, r24
    1b08:	a1 f0       	breq	.+40     	; 0x1b32 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b0a:	89 81       	ldd	r24, Y+1	; 0x01
    1b0c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b0e:	08 96       	adiw	r24, 0x08	; 8
    1b10:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    1b14:	88 23       	and	r24, r24
    1b16:	69 f0       	breq	.+26     	; 0x1b32 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1b18:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
    1b1c:	0a c0       	rjmp	.+20     	; 0x1b32 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1b1e:	89 81       	ldd	r24, Y+1	; 0x01
    1b20:	9a 81       	ldd	r25, Y+2	; 0x02
    1b22:	08 96       	adiw	r24, 0x08	; 8
    1b24:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1b28:	89 81       	ldd	r24, Y+1	; 0x01
    1b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2c:	41 96       	adiw	r24, 0x11	; 17
    1b2e:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1b32:	0f 90       	pop	r0
    1b34:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1b36:	81 e0       	ldi	r24, 0x01	; 1
}
    1b38:	0f 90       	pop	r0
    1b3a:	0f 90       	pop	r0
    1b3c:	0f 90       	pop	r0
    1b3e:	0f 90       	pop	r0
    1b40:	0f 90       	pop	r0
    1b42:	cf 91       	pop	r28
    1b44:	df 91       	pop	r29
    1b46:	08 95       	ret

00001b48 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1b48:	0f 93       	push	r16
    1b4a:	1f 93       	push	r17
    1b4c:	df 93       	push	r29
    1b4e:	cf 93       	push	r28
    1b50:	cd b7       	in	r28, 0x3d	; 61
    1b52:	de b7       	in	r29, 0x3e	; 62
    1b54:	29 97       	sbiw	r28, 0x09	; 9
    1b56:	0f b6       	in	r0, 0x3f	; 63
    1b58:	f8 94       	cli
    1b5a:	de bf       	out	0x3e, r29	; 62
    1b5c:	0f be       	out	0x3f, r0	; 63
    1b5e:	cd bf       	out	0x3d, r28	; 61
    1b60:	8f 83       	std	Y+7, r24	; 0x07
    1b62:	68 87       	std	Y+8, r22	; 0x08
    1b64:	49 87       	std	Y+9, r20	; 0x09
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1b66:	8f 81       	ldd	r24, Y+7	; 0x07
    1b68:	28 2f       	mov	r18, r24
    1b6a:	30 e0       	ldi	r19, 0x00	; 0
    1b6c:	88 85       	ldd	r24, Y+8	; 0x08
    1b6e:	88 2f       	mov	r24, r24
    1b70:	90 e0       	ldi	r25, 0x00	; 0
    1b72:	ac 01       	movw	r20, r24
    1b74:	24 9f       	mul	r18, r20
    1b76:	c0 01       	movw	r24, r0
    1b78:	25 9f       	mul	r18, r21
    1b7a:	90 0d       	add	r25, r0
    1b7c:	34 9f       	mul	r19, r20
    1b7e:	90 0d       	add	r25, r0
    1b80:	11 24       	eor	r1, r1
    1b82:	9c 83       	std	Y+4, r25	; 0x04
    1b84:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1b86:	8b 81       	ldd	r24, Y+3	; 0x03
    1b88:	9c 81       	ldd	r25, Y+4	; 0x04
    1b8a:	4f 96       	adiw	r24, 0x1f	; 31
    1b8c:	0e 94 05 08 	call	0x100a	; 0x100a <pvPortMalloc>
    1b90:	9e 83       	std	Y+6, r25	; 0x06
    1b92:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1b94:	8d 81       	ldd	r24, Y+5	; 0x05
    1b96:	9e 81       	ldd	r25, Y+6	; 0x06
    1b98:	00 97       	sbiw	r24, 0x00	; 0
    1b9a:	a1 f0       	breq	.+40     	; 0x1bc4 <xQueueGenericCreate+0x7c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1b9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b9e:	9e 81       	ldd	r25, Y+6	; 0x06
    1ba0:	9a 83       	std	Y+2, r25	; 0x02
    1ba2:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1ba4:	89 81       	ldd	r24, Y+1	; 0x01
    1ba6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ba8:	4f 96       	adiw	r24, 0x1f	; 31
    1baa:	9a 83       	std	Y+2, r25	; 0x02
    1bac:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1bae:	29 81       	ldd	r18, Y+1	; 0x01
    1bb0:	3a 81       	ldd	r19, Y+2	; 0x02
    1bb2:	ed 81       	ldd	r30, Y+5	; 0x05
    1bb4:	fe 81       	ldd	r31, Y+6	; 0x06
    1bb6:	8f 81       	ldd	r24, Y+7	; 0x07
    1bb8:	68 85       	ldd	r22, Y+8	; 0x08
    1bba:	a9 01       	movw	r20, r18
    1bbc:	29 85       	ldd	r18, Y+9	; 0x09
    1bbe:	8f 01       	movw	r16, r30
    1bc0:	0e 94 ef 0d 	call	0x1bde	; 0x1bde <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1bc4:	8d 81       	ldd	r24, Y+5	; 0x05
    1bc6:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1bc8:	29 96       	adiw	r28, 0x09	; 9
    1bca:	0f b6       	in	r0, 0x3f	; 63
    1bcc:	f8 94       	cli
    1bce:	de bf       	out	0x3e, r29	; 62
    1bd0:	0f be       	out	0x3f, r0	; 63
    1bd2:	cd bf       	out	0x3d, r28	; 61
    1bd4:	cf 91       	pop	r28
    1bd6:	df 91       	pop	r29
    1bd8:	1f 91       	pop	r17
    1bda:	0f 91       	pop	r16
    1bdc:	08 95       	ret

00001bde <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1bde:	0f 93       	push	r16
    1be0:	1f 93       	push	r17
    1be2:	df 93       	push	r29
    1be4:	cf 93       	push	r28
    1be6:	cd b7       	in	r28, 0x3d	; 61
    1be8:	de b7       	in	r29, 0x3e	; 62
    1bea:	27 97       	sbiw	r28, 0x07	; 7
    1bec:	0f b6       	in	r0, 0x3f	; 63
    1bee:	f8 94       	cli
    1bf0:	de bf       	out	0x3e, r29	; 62
    1bf2:	0f be       	out	0x3f, r0	; 63
    1bf4:	cd bf       	out	0x3d, r28	; 61
    1bf6:	89 83       	std	Y+1, r24	; 0x01
    1bf8:	6a 83       	std	Y+2, r22	; 0x02
    1bfa:	5c 83       	std	Y+4, r21	; 0x04
    1bfc:	4b 83       	std	Y+3, r20	; 0x03
    1bfe:	2d 83       	std	Y+5, r18	; 0x05
    1c00:	1f 83       	std	Y+7, r17	; 0x07
    1c02:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1c04:	8a 81       	ldd	r24, Y+2	; 0x02
    1c06:	88 23       	and	r24, r24
    1c08:	39 f4       	brne	.+14     	; 0x1c18 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1c0a:	8e 81       	ldd	r24, Y+6	; 0x06
    1c0c:	9f 81       	ldd	r25, Y+7	; 0x07
    1c0e:	ee 81       	ldd	r30, Y+6	; 0x06
    1c10:	ff 81       	ldd	r31, Y+7	; 0x07
    1c12:	91 83       	std	Z+1, r25	; 0x01
    1c14:	80 83       	st	Z, r24
    1c16:	06 c0       	rjmp	.+12     	; 0x1c24 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1c18:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c1c:	ee 81       	ldd	r30, Y+6	; 0x06
    1c1e:	ff 81       	ldd	r31, Y+7	; 0x07
    1c20:	91 83       	std	Z+1, r25	; 0x01
    1c22:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1c24:	ee 81       	ldd	r30, Y+6	; 0x06
    1c26:	ff 81       	ldd	r31, Y+7	; 0x07
    1c28:	89 81       	ldd	r24, Y+1	; 0x01
    1c2a:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1c2c:	ee 81       	ldd	r30, Y+6	; 0x06
    1c2e:	ff 81       	ldd	r31, Y+7	; 0x07
    1c30:	8a 81       	ldd	r24, Y+2	; 0x02
    1c32:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1c34:	8e 81       	ldd	r24, Y+6	; 0x06
    1c36:	9f 81       	ldd	r25, Y+7	; 0x07
    1c38:	61 e0       	ldi	r22, 0x01	; 1
    1c3a:	0e 94 1e 0d 	call	0x1a3c	; 0x1a3c <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1c3e:	27 96       	adiw	r28, 0x07	; 7
    1c40:	0f b6       	in	r0, 0x3f	; 63
    1c42:	f8 94       	cli
    1c44:	de bf       	out	0x3e, r29	; 62
    1c46:	0f be       	out	0x3f, r0	; 63
    1c48:	cd bf       	out	0x3d, r28	; 61
    1c4a:	cf 91       	pop	r28
    1c4c:	df 91       	pop	r29
    1c4e:	1f 91       	pop	r17
    1c50:	0f 91       	pop	r16
    1c52:	08 95       	ret

00001c54 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1c54:	df 93       	push	r29
    1c56:	cf 93       	push	r28
    1c58:	cd b7       	in	r28, 0x3d	; 61
    1c5a:	de b7       	in	r29, 0x3e	; 62
    1c5c:	2f 97       	sbiw	r28, 0x0f	; 15
    1c5e:	0f b6       	in	r0, 0x3f	; 63
    1c60:	f8 94       	cli
    1c62:	de bf       	out	0x3e, r29	; 62
    1c64:	0f be       	out	0x3f, r0	; 63
    1c66:	cd bf       	out	0x3d, r28	; 61
    1c68:	99 87       	std	Y+9, r25	; 0x09
    1c6a:	88 87       	std	Y+8, r24	; 0x08
    1c6c:	7b 87       	std	Y+11, r23	; 0x0b
    1c6e:	6a 87       	std	Y+10, r22	; 0x0a
    1c70:	5d 87       	std	Y+13, r21	; 0x0d
    1c72:	4c 87       	std	Y+12, r20	; 0x0c
    1c74:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1c76:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1c78:	88 85       	ldd	r24, Y+8	; 0x08
    1c7a:	99 85       	ldd	r25, Y+9	; 0x09
    1c7c:	9a 83       	std	Y+2, r25	; 0x02
    1c7e:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1c80:	0f b6       	in	r0, 0x3f	; 63
    1c82:	f8 94       	cli
    1c84:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1c86:	e9 81       	ldd	r30, Y+1	; 0x01
    1c88:	fa 81       	ldd	r31, Y+2	; 0x02
    1c8a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c90:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c92:	98 17       	cp	r25, r24
    1c94:	18 f0       	brcs	.+6      	; 0x1c9c <xQueueGenericSend+0x48>
    1c96:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c98:	82 30       	cpi	r24, 0x02	; 2
    1c9a:	11 f5       	brne	.+68     	; 0x1ce0 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1c9c:	89 81       	ldd	r24, Y+1	; 0x01
    1c9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1ca0:	2a 85       	ldd	r18, Y+10	; 0x0a
    1ca2:	3b 85       	ldd	r19, Y+11	; 0x0b
    1ca4:	b9 01       	movw	r22, r18
    1ca6:	4e 85       	ldd	r20, Y+14	; 0x0e
    1ca8:	0e 94 80 12 	call	0x2500	; 0x2500 <prvCopyDataToQueue>
    1cac:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1cae:	e9 81       	ldd	r30, Y+1	; 0x01
    1cb0:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb2:	81 89       	ldd	r24, Z+17	; 0x11
    1cb4:	88 23       	and	r24, r24
    1cb6:	51 f0       	breq	.+20     	; 0x1ccc <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1cb8:	89 81       	ldd	r24, Y+1	; 0x01
    1cba:	9a 81       	ldd	r25, Y+2	; 0x02
    1cbc:	41 96       	adiw	r24, 0x11	; 17
    1cbe:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    1cc2:	88 23       	and	r24, r24
    1cc4:	41 f0       	breq	.+16     	; 0x1cd6 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1cc6:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
    1cca:	05 c0       	rjmp	.+10     	; 0x1cd6 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cce:	88 23       	and	r24, r24
    1cd0:	11 f0       	breq	.+4      	; 0x1cd6 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1cd2:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1cd6:	0f 90       	pop	r0
    1cd8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1cda:	81 e0       	ldi	r24, 0x01	; 1
    1cdc:	8f 87       	std	Y+15, r24	; 0x0f
    1cde:	5c c0       	rjmp	.+184    	; 0x1d98 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1ce0:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ce2:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ce4:	00 97       	sbiw	r24, 0x00	; 0
    1ce6:	21 f4       	brne	.+8      	; 0x1cf0 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ce8:	0f 90       	pop	r0
    1cea:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1cec:	1f 86       	std	Y+15, r1	; 0x0f
    1cee:	54 c0       	rjmp	.+168    	; 0x1d98 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1cf0:	8c 81       	ldd	r24, Y+4	; 0x04
    1cf2:	88 23       	and	r24, r24
    1cf4:	31 f4       	brne	.+12     	; 0x1d02 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1cf6:	ce 01       	movw	r24, r28
    1cf8:	05 96       	adiw	r24, 0x05	; 5
    1cfa:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1cfe:	81 e0       	ldi	r24, 0x01	; 1
    1d00:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1d02:	0f 90       	pop	r0
    1d04:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d06:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1d0a:	0f b6       	in	r0, 0x3f	; 63
    1d0c:	f8 94       	cli
    1d0e:	0f 92       	push	r0
    1d10:	e9 81       	ldd	r30, Y+1	; 0x01
    1d12:	fa 81       	ldd	r31, Y+2	; 0x02
    1d14:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d16:	8f 3f       	cpi	r24, 0xFF	; 255
    1d18:	19 f4       	brne	.+6      	; 0x1d20 <xQueueGenericSend+0xcc>
    1d1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1e:	15 8e       	std	Z+29, r1	; 0x1d
    1d20:	e9 81       	ldd	r30, Y+1	; 0x01
    1d22:	fa 81       	ldd	r31, Y+2	; 0x02
    1d24:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d26:	8f 3f       	cpi	r24, 0xFF	; 255
    1d28:	19 f4       	brne	.+6      	; 0x1d30 <xQueueGenericSend+0xdc>
    1d2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d2e:	16 8e       	std	Z+30, r1	; 0x1e
    1d30:	0f 90       	pop	r0
    1d32:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d34:	ce 01       	movw	r24, r28
    1d36:	05 96       	adiw	r24, 0x05	; 5
    1d38:	9e 01       	movw	r18, r28
    1d3a:	24 5f       	subi	r18, 0xF4	; 244
    1d3c:	3f 4f       	sbci	r19, 0xFF	; 255
    1d3e:	b9 01       	movw	r22, r18
    1d40:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <xTaskCheckForTimeOut>
    1d44:	88 23       	and	r24, r24
    1d46:	09 f5       	brne	.+66     	; 0x1d8a <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1d48:	89 81       	ldd	r24, Y+1	; 0x01
    1d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1d4c:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <prvIsQueueFull>
    1d50:	88 23       	and	r24, r24
    1d52:	a1 f0       	breq	.+40     	; 0x1d7c <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d54:	89 81       	ldd	r24, Y+1	; 0x01
    1d56:	9a 81       	ldd	r25, Y+2	; 0x02
    1d58:	08 96       	adiw	r24, 0x08	; 8
    1d5a:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d5c:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d5e:	b9 01       	movw	r22, r18
    1d60:	0e 94 37 1c 	call	0x386e	; 0x386e <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1d64:	89 81       	ldd	r24, Y+1	; 0x01
    1d66:	9a 81       	ldd	r25, Y+2	; 0x02
    1d68:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1d6c:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    1d70:	88 23       	and	r24, r24
    1d72:	09 f0       	breq	.+2      	; 0x1d76 <xQueueGenericSend+0x122>
    1d74:	85 cf       	rjmp	.-246    	; 0x1c80 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1d76:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
    1d7a:	82 cf       	rjmp	.-252    	; 0x1c80 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1d7c:	89 81       	ldd	r24, Y+1	; 0x01
    1d7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1d80:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1d84:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    1d88:	7b cf       	rjmp	.-266    	; 0x1c80 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1d8a:	89 81       	ldd	r24, Y+1	; 0x01
    1d8c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d8e:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1d92:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1d96:	1f 86       	std	Y+15, r1	; 0x0f
    1d98:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    1d9a:	2f 96       	adiw	r28, 0x0f	; 15
    1d9c:	0f b6       	in	r0, 0x3f	; 63
    1d9e:	f8 94       	cli
    1da0:	de bf       	out	0x3e, r29	; 62
    1da2:	0f be       	out	0x3f, r0	; 63
    1da4:	cd bf       	out	0x3d, r28	; 61
    1da6:	cf 91       	pop	r28
    1da8:	df 91       	pop	r29
    1daa:	08 95       	ret

00001dac <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1dac:	df 93       	push	r29
    1dae:	cf 93       	push	r28
    1db0:	cd b7       	in	r28, 0x3d	; 61
    1db2:	de b7       	in	r29, 0x3e	; 62
    1db4:	2d 97       	sbiw	r28, 0x0d	; 13
    1db6:	0f b6       	in	r0, 0x3f	; 63
    1db8:	f8 94       	cli
    1dba:	de bf       	out	0x3e, r29	; 62
    1dbc:	0f be       	out	0x3f, r0	; 63
    1dbe:	cd bf       	out	0x3d, r28	; 61
    1dc0:	98 87       	std	Y+8, r25	; 0x08
    1dc2:	8f 83       	std	Y+7, r24	; 0x07
    1dc4:	7a 87       	std	Y+10, r23	; 0x0a
    1dc6:	69 87       	std	Y+9, r22	; 0x09
    1dc8:	5c 87       	std	Y+12, r21	; 0x0c
    1dca:	4b 87       	std	Y+11, r20	; 0x0b
    1dcc:	2d 87       	std	Y+13, r18	; 0x0d
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1dce:	8f 81       	ldd	r24, Y+7	; 0x07
    1dd0:	98 85       	ldd	r25, Y+8	; 0x08
    1dd2:	9c 83       	std	Y+4, r25	; 0x04
    1dd4:	8b 83       	std	Y+3, r24	; 0x03
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1dd6:	1d 82       	std	Y+5, r1	; 0x05
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1dd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1dda:	fc 81       	ldd	r31, Y+4	; 0x04
    1ddc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1dde:	eb 81       	ldd	r30, Y+3	; 0x03
    1de0:	fc 81       	ldd	r31, Y+4	; 0x04
    1de2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1de4:	98 17       	cp	r25, r24
    1de6:	18 f0       	brcs	.+6      	; 0x1dee <xQueueGenericSendFromISR+0x42>
    1de8:	8d 85       	ldd	r24, Y+13	; 0x0d
    1dea:	82 30       	cpi	r24, 0x02	; 2
    1dec:	81 f5       	brne	.+96     	; 0x1e4e <xQueueGenericSendFromISR+0xa2>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1dee:	eb 81       	ldd	r30, Y+3	; 0x03
    1df0:	fc 81       	ldd	r31, Y+4	; 0x04
    1df2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1df4:	8a 83       	std	Y+2, r24	; 0x02
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1df6:	eb 81       	ldd	r30, Y+3	; 0x03
    1df8:	fc 81       	ldd	r31, Y+4	; 0x04
    1dfa:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dfc:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1dfe:	8b 81       	ldd	r24, Y+3	; 0x03
    1e00:	9c 81       	ldd	r25, Y+4	; 0x04
    1e02:	29 85       	ldd	r18, Y+9	; 0x09
    1e04:	3a 85       	ldd	r19, Y+10	; 0x0a
    1e06:	b9 01       	movw	r22, r18
    1e08:	4d 85       	ldd	r20, Y+13	; 0x0d
    1e0a:	0e 94 80 12 	call	0x2500	; 0x2500 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1e0e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e10:	8f 3f       	cpi	r24, 0xFF	; 255
    1e12:	a9 f4       	brne	.+42     	; 0x1e3e <xQueueGenericSendFromISR+0x92>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e14:	eb 81       	ldd	r30, Y+3	; 0x03
    1e16:	fc 81       	ldd	r31, Y+4	; 0x04
    1e18:	81 89       	ldd	r24, Z+17	; 0x11
    1e1a:	88 23       	and	r24, r24
    1e1c:	a9 f0       	breq	.+42     	; 0x1e48 <xQueueGenericSendFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e1e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e20:	9c 81       	ldd	r25, Y+4	; 0x04
    1e22:	41 96       	adiw	r24, 0x11	; 17
    1e24:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    1e28:	88 23       	and	r24, r24
    1e2a:	71 f0       	breq	.+28     	; 0x1e48 <xQueueGenericSendFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1e2c:	8b 85       	ldd	r24, Y+11	; 0x0b
    1e2e:	9c 85       	ldd	r25, Y+12	; 0x0c
    1e30:	00 97       	sbiw	r24, 0x00	; 0
    1e32:	51 f0       	breq	.+20     	; 0x1e48 <xQueueGenericSendFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1e34:	eb 85       	ldd	r30, Y+11	; 0x0b
    1e36:	fc 85       	ldd	r31, Y+12	; 0x0c
    1e38:	81 e0       	ldi	r24, 0x01	; 1
    1e3a:	80 83       	st	Z, r24
    1e3c:	05 c0       	rjmp	.+10     	; 0x1e48 <xQueueGenericSendFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1e3e:	8a 81       	ldd	r24, Y+2	; 0x02
    1e40:	8f 5f       	subi	r24, 0xFF	; 255
    1e42:	eb 81       	ldd	r30, Y+3	; 0x03
    1e44:	fc 81       	ldd	r31, Y+4	; 0x04
    1e46:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1e48:	81 e0       	ldi	r24, 0x01	; 1
    1e4a:	8e 83       	std	Y+6, r24	; 0x06
    1e4c:	01 c0       	rjmp	.+2      	; 0x1e50 <xQueueGenericSendFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1e4e:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1e50:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1e52:	2d 96       	adiw	r28, 0x0d	; 13
    1e54:	0f b6       	in	r0, 0x3f	; 63
    1e56:	f8 94       	cli
    1e58:	de bf       	out	0x3e, r29	; 62
    1e5a:	0f be       	out	0x3f, r0	; 63
    1e5c:	cd bf       	out	0x3d, r28	; 61
    1e5e:	cf 91       	pop	r28
    1e60:	df 91       	pop	r29
    1e62:	08 95       	ret

00001e64 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1e64:	df 93       	push	r29
    1e66:	cf 93       	push	r28
    1e68:	cd b7       	in	r28, 0x3d	; 61
    1e6a:	de b7       	in	r29, 0x3e	; 62
    1e6c:	2a 97       	sbiw	r28, 0x0a	; 10
    1e6e:	0f b6       	in	r0, 0x3f	; 63
    1e70:	f8 94       	cli
    1e72:	de bf       	out	0x3e, r29	; 62
    1e74:	0f be       	out	0x3f, r0	; 63
    1e76:	cd bf       	out	0x3d, r28	; 61
    1e78:	98 87       	std	Y+8, r25	; 0x08
    1e7a:	8f 83       	std	Y+7, r24	; 0x07
    1e7c:	7a 87       	std	Y+10, r23	; 0x0a
    1e7e:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1e80:	8f 81       	ldd	r24, Y+7	; 0x07
    1e82:	98 85       	ldd	r25, Y+8	; 0x08
    1e84:	9c 83       	std	Y+4, r25	; 0x04
    1e86:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1e88:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1e8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e90:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    1e92:	eb 81       	ldd	r30, Y+3	; 0x03
    1e94:	fc 81       	ldd	r31, Y+4	; 0x04
    1e96:	93 8d       	ldd	r25, Z+27	; 0x1b
    1e98:	8a 81       	ldd	r24, Y+2	; 0x02
    1e9a:	89 17       	cp	r24, r25
    1e9c:	48 f5       	brcc	.+82     	; 0x1ef0 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1e9e:	eb 81       	ldd	r30, Y+3	; 0x03
    1ea0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ea2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ea4:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1ea6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ea8:	8f 5f       	subi	r24, 0xFF	; 255
    1eaa:	eb 81       	ldd	r30, Y+3	; 0x03
    1eac:	fc 81       	ldd	r31, Y+4	; 0x04
    1eae:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1eb0:	89 81       	ldd	r24, Y+1	; 0x01
    1eb2:	8f 3f       	cpi	r24, 0xFF	; 255
    1eb4:	a9 f4       	brne	.+42     	; 0x1ee0 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1eb6:	eb 81       	ldd	r30, Y+3	; 0x03
    1eb8:	fc 81       	ldd	r31, Y+4	; 0x04
    1eba:	81 89       	ldd	r24, Z+17	; 0x11
    1ebc:	88 23       	and	r24, r24
    1ebe:	a9 f0       	breq	.+42     	; 0x1eea <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ec0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec4:	41 96       	adiw	r24, 0x11	; 17
    1ec6:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    1eca:	88 23       	and	r24, r24
    1ecc:	71 f0       	breq	.+28     	; 0x1eea <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1ece:	89 85       	ldd	r24, Y+9	; 0x09
    1ed0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ed2:	00 97       	sbiw	r24, 0x00	; 0
    1ed4:	51 f0       	breq	.+20     	; 0x1eea <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1ed6:	e9 85       	ldd	r30, Y+9	; 0x09
    1ed8:	fa 85       	ldd	r31, Y+10	; 0x0a
    1eda:	81 e0       	ldi	r24, 0x01	; 1
    1edc:	80 83       	st	Z, r24
    1ede:	05 c0       	rjmp	.+10     	; 0x1eea <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1ee0:	89 81       	ldd	r24, Y+1	; 0x01
    1ee2:	8f 5f       	subi	r24, 0xFF	; 255
    1ee4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ee6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ee8:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1eea:	81 e0       	ldi	r24, 0x01	; 1
    1eec:	8e 83       	std	Y+6, r24	; 0x06
    1eee:	01 c0       	rjmp	.+2      	; 0x1ef2 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1ef0:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1ef2:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1ef4:	2a 96       	adiw	r28, 0x0a	; 10
    1ef6:	0f b6       	in	r0, 0x3f	; 63
    1ef8:	f8 94       	cli
    1efa:	de bf       	out	0x3e, r29	; 62
    1efc:	0f be       	out	0x3f, r0	; 63
    1efe:	cd bf       	out	0x3d, r28	; 61
    1f00:	cf 91       	pop	r28
    1f02:	df 91       	pop	r29
    1f04:	08 95       	ret

00001f06 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    1f06:	df 93       	push	r29
    1f08:	cf 93       	push	r28
    1f0a:	cd b7       	in	r28, 0x3d	; 61
    1f0c:	de b7       	in	r29, 0x3e	; 62
    1f0e:	2e 97       	sbiw	r28, 0x0e	; 14
    1f10:	0f b6       	in	r0, 0x3f	; 63
    1f12:	f8 94       	cli
    1f14:	de bf       	out	0x3e, r29	; 62
    1f16:	0f be       	out	0x3f, r0	; 63
    1f18:	cd bf       	out	0x3d, r28	; 61
    1f1a:	99 87       	std	Y+9, r25	; 0x09
    1f1c:	88 87       	std	Y+8, r24	; 0x08
    1f1e:	7b 87       	std	Y+11, r23	; 0x0b
    1f20:	6a 87       	std	Y+10, r22	; 0x0a
    1f22:	5d 87       	std	Y+13, r21	; 0x0d
    1f24:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    1f26:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1f28:	88 85       	ldd	r24, Y+8	; 0x08
    1f2a:	99 85       	ldd	r25, Y+9	; 0x09
    1f2c:	9b 83       	std	Y+3, r25	; 0x03
    1f2e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1f30:	0f b6       	in	r0, 0x3f	; 63
    1f32:	f8 94       	cli
    1f34:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1f36:	ea 81       	ldd	r30, Y+2	; 0x02
    1f38:	fb 81       	ldd	r31, Y+3	; 0x03
    1f3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f3c:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f3e:	89 81       	ldd	r24, Y+1	; 0x01
    1f40:	88 23       	and	r24, r24
    1f42:	f9 f0       	breq	.+62     	; 0x1f82 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f44:	8a 81       	ldd	r24, Y+2	; 0x02
    1f46:	9b 81       	ldd	r25, Y+3	; 0x03
    1f48:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f4a:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f4c:	b9 01       	movw	r22, r18
    1f4e:	0e 94 26 13 	call	0x264c	; 0x264c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1f52:	89 81       	ldd	r24, Y+1	; 0x01
    1f54:	81 50       	subi	r24, 0x01	; 1
    1f56:	ea 81       	ldd	r30, Y+2	; 0x02
    1f58:	fb 81       	ldd	r31, Y+3	; 0x03
    1f5a:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f5c:	ea 81       	ldd	r30, Y+2	; 0x02
    1f5e:	fb 81       	ldd	r31, Y+3	; 0x03
    1f60:	80 85       	ldd	r24, Z+8	; 0x08
    1f62:	88 23       	and	r24, r24
    1f64:	49 f0       	breq	.+18     	; 0x1f78 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f66:	8a 81       	ldd	r24, Y+2	; 0x02
    1f68:	9b 81       	ldd	r25, Y+3	; 0x03
    1f6a:	08 96       	adiw	r24, 0x08	; 8
    1f6c:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    1f70:	88 23       	and	r24, r24
    1f72:	11 f0       	breq	.+4      	; 0x1f78 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    1f74:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    1f78:	0f 90       	pop	r0
    1f7a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f7c:	81 e0       	ldi	r24, 0x01	; 1
    1f7e:	8e 87       	std	Y+14, r24	; 0x0e
    1f80:	63 c0       	rjmp	.+198    	; 0x2048 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f82:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f84:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f86:	00 97       	sbiw	r24, 0x00	; 0
    1f88:	21 f4       	brne	.+8      	; 0x1f92 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f8a:	0f 90       	pop	r0
    1f8c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f8e:	1e 86       	std	Y+14, r1	; 0x0e
    1f90:	5b c0       	rjmp	.+182    	; 0x2048 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f92:	8c 81       	ldd	r24, Y+4	; 0x04
    1f94:	88 23       	and	r24, r24
    1f96:	31 f4       	brne	.+12     	; 0x1fa4 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1f98:	ce 01       	movw	r24, r28
    1f9a:	05 96       	adiw	r24, 0x05	; 5
    1f9c:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1fa0:	81 e0       	ldi	r24, 0x01	; 1
    1fa2:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1fa4:	0f 90       	pop	r0
    1fa6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1fa8:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1fac:	0f b6       	in	r0, 0x3f	; 63
    1fae:	f8 94       	cli
    1fb0:	0f 92       	push	r0
    1fb2:	ea 81       	ldd	r30, Y+2	; 0x02
    1fb4:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fb8:	8f 3f       	cpi	r24, 0xFF	; 255
    1fba:	19 f4       	brne	.+6      	; 0x1fc2 <xQueueReceive+0xbc>
    1fbc:	ea 81       	ldd	r30, Y+2	; 0x02
    1fbe:	fb 81       	ldd	r31, Y+3	; 0x03
    1fc0:	15 8e       	std	Z+29, r1	; 0x1d
    1fc2:	ea 81       	ldd	r30, Y+2	; 0x02
    1fc4:	fb 81       	ldd	r31, Y+3	; 0x03
    1fc6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fc8:	8f 3f       	cpi	r24, 0xFF	; 255
    1fca:	19 f4       	brne	.+6      	; 0x1fd2 <xQueueReceive+0xcc>
    1fcc:	ea 81       	ldd	r30, Y+2	; 0x02
    1fce:	fb 81       	ldd	r31, Y+3	; 0x03
    1fd0:	16 8e       	std	Z+30, r1	; 0x1e
    1fd2:	0f 90       	pop	r0
    1fd4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fd6:	ce 01       	movw	r24, r28
    1fd8:	05 96       	adiw	r24, 0x05	; 5
    1fda:	9e 01       	movw	r18, r28
    1fdc:	24 5f       	subi	r18, 0xF4	; 244
    1fde:	3f 4f       	sbci	r19, 0xFF	; 255
    1fe0:	b9 01       	movw	r22, r18
    1fe2:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <xTaskCheckForTimeOut>
    1fe6:	88 23       	and	r24, r24
    1fe8:	09 f5       	brne	.+66     	; 0x202c <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fea:	8a 81       	ldd	r24, Y+2	; 0x02
    1fec:	9b 81       	ldd	r25, Y+3	; 0x03
    1fee:	0e 94 c0 13 	call	0x2780	; 0x2780 <prvIsQueueEmpty>
    1ff2:	88 23       	and	r24, r24
    1ff4:	a1 f0       	breq	.+40     	; 0x201e <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ff6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ff8:	9b 81       	ldd	r25, Y+3	; 0x03
    1ffa:	41 96       	adiw	r24, 0x11	; 17
    1ffc:	2c 85       	ldd	r18, Y+12	; 0x0c
    1ffe:	3d 85       	ldd	r19, Y+13	; 0x0d
    2000:	b9 01       	movw	r22, r18
    2002:	0e 94 37 1c 	call	0x386e	; 0x386e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2006:	8a 81       	ldd	r24, Y+2	; 0x02
    2008:	9b 81       	ldd	r25, Y+3	; 0x03
    200a:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    200e:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    2012:	88 23       	and	r24, r24
    2014:	09 f0       	breq	.+2      	; 0x2018 <xQueueReceive+0x112>
    2016:	8c cf       	rjmp	.-232    	; 0x1f30 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    2018:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
    201c:	89 cf       	rjmp	.-238    	; 0x1f30 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    201e:	8a 81       	ldd	r24, Y+2	; 0x02
    2020:	9b 81       	ldd	r25, Y+3	; 0x03
    2022:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2026:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    202a:	82 cf       	rjmp	.-252    	; 0x1f30 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    202c:	8a 81       	ldd	r24, Y+2	; 0x02
    202e:	9b 81       	ldd	r25, Y+3	; 0x03
    2030:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2034:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2038:	8a 81       	ldd	r24, Y+2	; 0x02
    203a:	9b 81       	ldd	r25, Y+3	; 0x03
    203c:	0e 94 c0 13 	call	0x2780	; 0x2780 <prvIsQueueEmpty>
    2040:	88 23       	and	r24, r24
    2042:	09 f4       	brne	.+2      	; 0x2046 <xQueueReceive+0x140>
    2044:	75 cf       	rjmp	.-278    	; 0x1f30 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2046:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2048:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    204a:	2e 96       	adiw	r28, 0x0e	; 14
    204c:	0f b6       	in	r0, 0x3f	; 63
    204e:	f8 94       	cli
    2050:	de bf       	out	0x3e, r29	; 62
    2052:	0f be       	out	0x3f, r0	; 63
    2054:	cd bf       	out	0x3d, r28	; 61
    2056:	cf 91       	pop	r28
    2058:	df 91       	pop	r29
    205a:	08 95       	ret

0000205c <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    205c:	df 93       	push	r29
    205e:	cf 93       	push	r28
    2060:	cd b7       	in	r28, 0x3d	; 61
    2062:	de b7       	in	r29, 0x3e	; 62
    2064:	2c 97       	sbiw	r28, 0x0c	; 12
    2066:	0f b6       	in	r0, 0x3f	; 63
    2068:	f8 94       	cli
    206a:	de bf       	out	0x3e, r29	; 62
    206c:	0f be       	out	0x3f, r0	; 63
    206e:	cd bf       	out	0x3d, r28	; 61
    2070:	99 87       	std	Y+9, r25	; 0x09
    2072:	88 87       	std	Y+8, r24	; 0x08
    2074:	7b 87       	std	Y+11, r23	; 0x0b
    2076:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    2078:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    207a:	88 85       	ldd	r24, Y+8	; 0x08
    207c:	99 85       	ldd	r25, Y+9	; 0x09
    207e:	9b 83       	std	Y+3, r25	; 0x03
    2080:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2082:	0f b6       	in	r0, 0x3f	; 63
    2084:	f8 94       	cli
    2086:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2088:	ea 81       	ldd	r30, Y+2	; 0x02
    208a:	fb 81       	ldd	r31, Y+3	; 0x03
    208c:	82 8d       	ldd	r24, Z+26	; 0x1a
    208e:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    2090:	89 81       	ldd	r24, Y+1	; 0x01
    2092:	88 23       	and	r24, r24
    2094:	c1 f0       	breq	.+48     	; 0x20c6 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2096:	89 81       	ldd	r24, Y+1	; 0x01
    2098:	81 50       	subi	r24, 0x01	; 1
    209a:	ea 81       	ldd	r30, Y+2	; 0x02
    209c:	fb 81       	ldd	r31, Y+3	; 0x03
    209e:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20a0:	ea 81       	ldd	r30, Y+2	; 0x02
    20a2:	fb 81       	ldd	r31, Y+3	; 0x03
    20a4:	80 85       	ldd	r24, Z+8	; 0x08
    20a6:	88 23       	and	r24, r24
    20a8:	49 f0       	breq	.+18     	; 0x20bc <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20aa:	8a 81       	ldd	r24, Y+2	; 0x02
    20ac:	9b 81       	ldd	r25, Y+3	; 0x03
    20ae:	08 96       	adiw	r24, 0x08	; 8
    20b0:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    20b4:	88 23       	and	r24, r24
    20b6:	11 f0       	breq	.+4      	; 0x20bc <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    20b8:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    20bc:	0f 90       	pop	r0
    20be:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    20c0:	81 e0       	ldi	r24, 0x01	; 1
    20c2:	8c 87       	std	Y+12, r24	; 0x0c
    20c4:	63 c0       	rjmp	.+198    	; 0x218c <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    20c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    20c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    20ca:	00 97       	sbiw	r24, 0x00	; 0
    20cc:	21 f4       	brne	.+8      	; 0x20d6 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    20ce:	0f 90       	pop	r0
    20d0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    20d2:	1c 86       	std	Y+12, r1	; 0x0c
    20d4:	5b c0       	rjmp	.+182    	; 0x218c <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    20d6:	8c 81       	ldd	r24, Y+4	; 0x04
    20d8:	88 23       	and	r24, r24
    20da:	31 f4       	brne	.+12     	; 0x20e8 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    20dc:	ce 01       	movw	r24, r28
    20de:	05 96       	adiw	r24, 0x05	; 5
    20e0:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    20e8:	0f 90       	pop	r0
    20ea:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    20ec:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    20f0:	0f b6       	in	r0, 0x3f	; 63
    20f2:	f8 94       	cli
    20f4:	0f 92       	push	r0
    20f6:	ea 81       	ldd	r30, Y+2	; 0x02
    20f8:	fb 81       	ldd	r31, Y+3	; 0x03
    20fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    20fc:	8f 3f       	cpi	r24, 0xFF	; 255
    20fe:	19 f4       	brne	.+6      	; 0x2106 <xQueueSemaphoreTake+0xaa>
    2100:	ea 81       	ldd	r30, Y+2	; 0x02
    2102:	fb 81       	ldd	r31, Y+3	; 0x03
    2104:	15 8e       	std	Z+29, r1	; 0x1d
    2106:	ea 81       	ldd	r30, Y+2	; 0x02
    2108:	fb 81       	ldd	r31, Y+3	; 0x03
    210a:	86 8d       	ldd	r24, Z+30	; 0x1e
    210c:	8f 3f       	cpi	r24, 0xFF	; 255
    210e:	19 f4       	brne	.+6      	; 0x2116 <xQueueSemaphoreTake+0xba>
    2110:	ea 81       	ldd	r30, Y+2	; 0x02
    2112:	fb 81       	ldd	r31, Y+3	; 0x03
    2114:	16 8e       	std	Z+30, r1	; 0x1e
    2116:	0f 90       	pop	r0
    2118:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    211a:	ce 01       	movw	r24, r28
    211c:	05 96       	adiw	r24, 0x05	; 5
    211e:	9e 01       	movw	r18, r28
    2120:	26 5f       	subi	r18, 0xF6	; 246
    2122:	3f 4f       	sbci	r19, 0xFF	; 255
    2124:	b9 01       	movw	r22, r18
    2126:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <xTaskCheckForTimeOut>
    212a:	88 23       	and	r24, r24
    212c:	09 f5       	brne	.+66     	; 0x2170 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    212e:	8a 81       	ldd	r24, Y+2	; 0x02
    2130:	9b 81       	ldd	r25, Y+3	; 0x03
    2132:	0e 94 c0 13 	call	0x2780	; 0x2780 <prvIsQueueEmpty>
    2136:	88 23       	and	r24, r24
    2138:	a1 f0       	breq	.+40     	; 0x2162 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    213a:	8a 81       	ldd	r24, Y+2	; 0x02
    213c:	9b 81       	ldd	r25, Y+3	; 0x03
    213e:	41 96       	adiw	r24, 0x11	; 17
    2140:	2a 85       	ldd	r18, Y+10	; 0x0a
    2142:	3b 85       	ldd	r19, Y+11	; 0x0b
    2144:	b9 01       	movw	r22, r18
    2146:	0e 94 37 1c 	call	0x386e	; 0x386e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    214a:	8a 81       	ldd	r24, Y+2	; 0x02
    214c:	9b 81       	ldd	r25, Y+3	; 0x03
    214e:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2152:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    2156:	88 23       	and	r24, r24
    2158:	09 f0       	breq	.+2      	; 0x215c <xQueueSemaphoreTake+0x100>
    215a:	93 cf       	rjmp	.-218    	; 0x2082 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    215c:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
    2160:	90 cf       	rjmp	.-224    	; 0x2082 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    2162:	8a 81       	ldd	r24, Y+2	; 0x02
    2164:	9b 81       	ldd	r25, Y+3	; 0x03
    2166:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
				( void ) xTaskResumeAll();
    216a:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    216e:	89 cf       	rjmp	.-238    	; 0x2082 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    2170:	8a 81       	ldd	r24, Y+2	; 0x02
    2172:	9b 81       	ldd	r25, Y+3	; 0x03
    2174:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2178:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    217c:	8a 81       	ldd	r24, Y+2	; 0x02
    217e:	9b 81       	ldd	r25, Y+3	; 0x03
    2180:	0e 94 c0 13 	call	0x2780	; 0x2780 <prvIsQueueEmpty>
    2184:	88 23       	and	r24, r24
    2186:	09 f4       	brne	.+2      	; 0x218a <xQueueSemaphoreTake+0x12e>
    2188:	7c cf       	rjmp	.-264    	; 0x2082 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    218a:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    218c:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    218e:	2c 96       	adiw	r28, 0x0c	; 12
    2190:	0f b6       	in	r0, 0x3f	; 63
    2192:	f8 94       	cli
    2194:	de bf       	out	0x3e, r29	; 62
    2196:	0f be       	out	0x3f, r0	; 63
    2198:	cd bf       	out	0x3d, r28	; 61
    219a:	cf 91       	pop	r28
    219c:	df 91       	pop	r29
    219e:	08 95       	ret

000021a0 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    21a0:	df 93       	push	r29
    21a2:	cf 93       	push	r28
    21a4:	cd b7       	in	r28, 0x3d	; 61
    21a6:	de b7       	in	r29, 0x3e	; 62
    21a8:	60 97       	sbiw	r28, 0x10	; 16
    21aa:	0f b6       	in	r0, 0x3f	; 63
    21ac:	f8 94       	cli
    21ae:	de bf       	out	0x3e, r29	; 62
    21b0:	0f be       	out	0x3f, r0	; 63
    21b2:	cd bf       	out	0x3d, r28	; 61
    21b4:	9b 87       	std	Y+11, r25	; 0x0b
    21b6:	8a 87       	std	Y+10, r24	; 0x0a
    21b8:	7d 87       	std	Y+13, r23	; 0x0d
    21ba:	6c 87       	std	Y+12, r22	; 0x0c
    21bc:	5f 87       	std	Y+15, r21	; 0x0f
    21be:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    21c0:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    21c2:	8a 85       	ldd	r24, Y+10	; 0x0a
    21c4:	9b 85       	ldd	r25, Y+11	; 0x0b
    21c6:	9b 83       	std	Y+3, r25	; 0x03
    21c8:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    21ca:	0f b6       	in	r0, 0x3f	; 63
    21cc:	f8 94       	cli
    21ce:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    21d0:	ea 81       	ldd	r30, Y+2	; 0x02
    21d2:	fb 81       	ldd	r31, Y+3	; 0x03
    21d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    21d6:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    21d8:	89 81       	ldd	r24, Y+1	; 0x01
    21da:	88 23       	and	r24, r24
    21dc:	31 f1       	breq	.+76     	; 0x222a <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    21de:	ea 81       	ldd	r30, Y+2	; 0x02
    21e0:	fb 81       	ldd	r31, Y+3	; 0x03
    21e2:	86 81       	ldd	r24, Z+6	; 0x06
    21e4:	97 81       	ldd	r25, Z+7	; 0x07
    21e6:	9d 83       	std	Y+5, r25	; 0x05
    21e8:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    21ea:	8a 81       	ldd	r24, Y+2	; 0x02
    21ec:	9b 81       	ldd	r25, Y+3	; 0x03
    21ee:	2c 85       	ldd	r18, Y+12	; 0x0c
    21f0:	3d 85       	ldd	r19, Y+13	; 0x0d
    21f2:	b9 01       	movw	r22, r18
    21f4:	0e 94 26 13 	call	0x264c	; 0x264c <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    21f8:	ea 81       	ldd	r30, Y+2	; 0x02
    21fa:	fb 81       	ldd	r31, Y+3	; 0x03
    21fc:	8c 81       	ldd	r24, Y+4	; 0x04
    21fe:	9d 81       	ldd	r25, Y+5	; 0x05
    2200:	97 83       	std	Z+7, r25	; 0x07
    2202:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2204:	ea 81       	ldd	r30, Y+2	; 0x02
    2206:	fb 81       	ldd	r31, Y+3	; 0x03
    2208:	81 89       	ldd	r24, Z+17	; 0x11
    220a:	88 23       	and	r24, r24
    220c:	49 f0       	breq	.+18     	; 0x2220 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    220e:	8a 81       	ldd	r24, Y+2	; 0x02
    2210:	9b 81       	ldd	r25, Y+3	; 0x03
    2212:	41 96       	adiw	r24, 0x11	; 17
    2214:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    2218:	88 23       	and	r24, r24
    221a:	11 f0       	breq	.+4      	; 0x2220 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    221c:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2220:	0f 90       	pop	r0
    2222:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2224:	81 e0       	ldi	r24, 0x01	; 1
    2226:	88 8b       	std	Y+16, r24	; 0x10
    2228:	63 c0       	rjmp	.+198    	; 0x22f0 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    222a:	8e 85       	ldd	r24, Y+14	; 0x0e
    222c:	9f 85       	ldd	r25, Y+15	; 0x0f
    222e:	00 97       	sbiw	r24, 0x00	; 0
    2230:	21 f4       	brne	.+8      	; 0x223a <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2232:	0f 90       	pop	r0
    2234:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2236:	18 8a       	std	Y+16, r1	; 0x10
    2238:	5b c0       	rjmp	.+182    	; 0x22f0 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    223a:	8e 81       	ldd	r24, Y+6	; 0x06
    223c:	88 23       	and	r24, r24
    223e:	31 f4       	brne	.+12     	; 0x224c <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2240:	ce 01       	movw	r24, r28
    2242:	07 96       	adiw	r24, 0x07	; 7
    2244:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2248:	81 e0       	ldi	r24, 0x01	; 1
    224a:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    224c:	0f 90       	pop	r0
    224e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2250:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2254:	0f b6       	in	r0, 0x3f	; 63
    2256:	f8 94       	cli
    2258:	0f 92       	push	r0
    225a:	ea 81       	ldd	r30, Y+2	; 0x02
    225c:	fb 81       	ldd	r31, Y+3	; 0x03
    225e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2260:	8f 3f       	cpi	r24, 0xFF	; 255
    2262:	19 f4       	brne	.+6      	; 0x226a <xQueuePeek+0xca>
    2264:	ea 81       	ldd	r30, Y+2	; 0x02
    2266:	fb 81       	ldd	r31, Y+3	; 0x03
    2268:	15 8e       	std	Z+29, r1	; 0x1d
    226a:	ea 81       	ldd	r30, Y+2	; 0x02
    226c:	fb 81       	ldd	r31, Y+3	; 0x03
    226e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2270:	8f 3f       	cpi	r24, 0xFF	; 255
    2272:	19 f4       	brne	.+6      	; 0x227a <xQueuePeek+0xda>
    2274:	ea 81       	ldd	r30, Y+2	; 0x02
    2276:	fb 81       	ldd	r31, Y+3	; 0x03
    2278:	16 8e       	std	Z+30, r1	; 0x1e
    227a:	0f 90       	pop	r0
    227c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    227e:	ce 01       	movw	r24, r28
    2280:	07 96       	adiw	r24, 0x07	; 7
    2282:	9e 01       	movw	r18, r28
    2284:	22 5f       	subi	r18, 0xF2	; 242
    2286:	3f 4f       	sbci	r19, 0xFF	; 255
    2288:	b9 01       	movw	r22, r18
    228a:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <xTaskCheckForTimeOut>
    228e:	88 23       	and	r24, r24
    2290:	09 f5       	brne	.+66     	; 0x22d4 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2292:	8a 81       	ldd	r24, Y+2	; 0x02
    2294:	9b 81       	ldd	r25, Y+3	; 0x03
    2296:	0e 94 c0 13 	call	0x2780	; 0x2780 <prvIsQueueEmpty>
    229a:	88 23       	and	r24, r24
    229c:	a1 f0       	breq	.+40     	; 0x22c6 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    229e:	8a 81       	ldd	r24, Y+2	; 0x02
    22a0:	9b 81       	ldd	r25, Y+3	; 0x03
    22a2:	41 96       	adiw	r24, 0x11	; 17
    22a4:	2e 85       	ldd	r18, Y+14	; 0x0e
    22a6:	3f 85       	ldd	r19, Y+15	; 0x0f
    22a8:	b9 01       	movw	r22, r18
    22aa:	0e 94 37 1c 	call	0x386e	; 0x386e <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    22ae:	8a 81       	ldd	r24, Y+2	; 0x02
    22b0:	9b 81       	ldd	r25, Y+3	; 0x03
    22b2:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    22b6:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    22ba:	88 23       	and	r24, r24
    22bc:	09 f0       	breq	.+2      	; 0x22c0 <xQueuePeek+0x120>
    22be:	85 cf       	rjmp	.-246    	; 0x21ca <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    22c0:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
    22c4:	82 cf       	rjmp	.-252    	; 0x21ca <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    22c6:	8a 81       	ldd	r24, Y+2	; 0x02
    22c8:	9b 81       	ldd	r25, Y+3	; 0x03
    22ca:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
				( void ) xTaskResumeAll();
    22ce:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    22d2:	7b cf       	rjmp	.-266    	; 0x21ca <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    22d4:	8a 81       	ldd	r24, Y+2	; 0x02
    22d6:	9b 81       	ldd	r25, Y+3	; 0x03
    22d8:	0e 94 6d 13 	call	0x26da	; 0x26da <prvUnlockQueue>
			( void ) xTaskResumeAll();
    22dc:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22e0:	8a 81       	ldd	r24, Y+2	; 0x02
    22e2:	9b 81       	ldd	r25, Y+3	; 0x03
    22e4:	0e 94 c0 13 	call	0x2780	; 0x2780 <prvIsQueueEmpty>
    22e8:	88 23       	and	r24, r24
    22ea:	09 f4       	brne	.+2      	; 0x22ee <xQueuePeek+0x14e>
    22ec:	6e cf       	rjmp	.-292    	; 0x21ca <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    22ee:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    22f0:	88 89       	ldd	r24, Y+16	; 0x10
}
    22f2:	60 96       	adiw	r28, 0x10	; 16
    22f4:	0f b6       	in	r0, 0x3f	; 63
    22f6:	f8 94       	cli
    22f8:	de bf       	out	0x3e, r29	; 62
    22fa:	0f be       	out	0x3f, r0	; 63
    22fc:	cd bf       	out	0x3d, r28	; 61
    22fe:	cf 91       	pop	r28
    2300:	df 91       	pop	r29
    2302:	08 95       	ret

00002304 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2304:	df 93       	push	r29
    2306:	cf 93       	push	r28
    2308:	cd b7       	in	r28, 0x3d	; 61
    230a:	de b7       	in	r29, 0x3e	; 62
    230c:	2c 97       	sbiw	r28, 0x0c	; 12
    230e:	0f b6       	in	r0, 0x3f	; 63
    2310:	f8 94       	cli
    2312:	de bf       	out	0x3e, r29	; 62
    2314:	0f be       	out	0x3f, r0	; 63
    2316:	cd bf       	out	0x3d, r28	; 61
    2318:	98 87       	std	Y+8, r25	; 0x08
    231a:	8f 83       	std	Y+7, r24	; 0x07
    231c:	7a 87       	std	Y+10, r23	; 0x0a
    231e:	69 87       	std	Y+9, r22	; 0x09
    2320:	5c 87       	std	Y+12, r21	; 0x0c
    2322:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    2324:	8f 81       	ldd	r24, Y+7	; 0x07
    2326:	98 85       	ldd	r25, Y+8	; 0x08
    2328:	9c 83       	std	Y+4, r25	; 0x04
    232a:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    232c:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    232e:	eb 81       	ldd	r30, Y+3	; 0x03
    2330:	fc 81       	ldd	r31, Y+4	; 0x04
    2332:	82 8d       	ldd	r24, Z+26	; 0x1a
    2334:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2336:	8a 81       	ldd	r24, Y+2	; 0x02
    2338:	88 23       	and	r24, r24
    233a:	81 f1       	breq	.+96     	; 0x239c <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    233c:	eb 81       	ldd	r30, Y+3	; 0x03
    233e:	fc 81       	ldd	r31, Y+4	; 0x04
    2340:	85 8d       	ldd	r24, Z+29	; 0x1d
    2342:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    2344:	8b 81       	ldd	r24, Y+3	; 0x03
    2346:	9c 81       	ldd	r25, Y+4	; 0x04
    2348:	29 85       	ldd	r18, Y+9	; 0x09
    234a:	3a 85       	ldd	r19, Y+10	; 0x0a
    234c:	b9 01       	movw	r22, r18
    234e:	0e 94 26 13 	call	0x264c	; 0x264c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2352:	8a 81       	ldd	r24, Y+2	; 0x02
    2354:	81 50       	subi	r24, 0x01	; 1
    2356:	eb 81       	ldd	r30, Y+3	; 0x03
    2358:	fc 81       	ldd	r31, Y+4	; 0x04
    235a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    235c:	89 81       	ldd	r24, Y+1	; 0x01
    235e:	8f 3f       	cpi	r24, 0xFF	; 255
    2360:	a9 f4       	brne	.+42     	; 0x238c <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2362:	eb 81       	ldd	r30, Y+3	; 0x03
    2364:	fc 81       	ldd	r31, Y+4	; 0x04
    2366:	80 85       	ldd	r24, Z+8	; 0x08
    2368:	88 23       	and	r24, r24
    236a:	a9 f0       	breq	.+42     	; 0x2396 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    236c:	8b 81       	ldd	r24, Y+3	; 0x03
    236e:	9c 81       	ldd	r25, Y+4	; 0x04
    2370:	08 96       	adiw	r24, 0x08	; 8
    2372:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    2376:	88 23       	and	r24, r24
    2378:	71 f0       	breq	.+28     	; 0x2396 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    237a:	8b 85       	ldd	r24, Y+11	; 0x0b
    237c:	9c 85       	ldd	r25, Y+12	; 0x0c
    237e:	00 97       	sbiw	r24, 0x00	; 0
    2380:	51 f0       	breq	.+20     	; 0x2396 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2382:	eb 85       	ldd	r30, Y+11	; 0x0b
    2384:	fc 85       	ldd	r31, Y+12	; 0x0c
    2386:	81 e0       	ldi	r24, 0x01	; 1
    2388:	80 83       	st	Z, r24
    238a:	05 c0       	rjmp	.+10     	; 0x2396 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    238c:	89 81       	ldd	r24, Y+1	; 0x01
    238e:	8f 5f       	subi	r24, 0xFF	; 255
    2390:	eb 81       	ldd	r30, Y+3	; 0x03
    2392:	fc 81       	ldd	r31, Y+4	; 0x04
    2394:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2396:	81 e0       	ldi	r24, 0x01	; 1
    2398:	8e 83       	std	Y+6, r24	; 0x06
    239a:	01 c0       	rjmp	.+2      	; 0x239e <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    239c:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    239e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    23a0:	2c 96       	adiw	r28, 0x0c	; 12
    23a2:	0f b6       	in	r0, 0x3f	; 63
    23a4:	f8 94       	cli
    23a6:	de bf       	out	0x3e, r29	; 62
    23a8:	0f be       	out	0x3f, r0	; 63
    23aa:	cd bf       	out	0x3d, r28	; 61
    23ac:	cf 91       	pop	r28
    23ae:	df 91       	pop	r29
    23b0:	08 95       	ret

000023b2 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    23b2:	df 93       	push	r29
    23b4:	cf 93       	push	r28
    23b6:	cd b7       	in	r28, 0x3d	; 61
    23b8:	de b7       	in	r29, 0x3e	; 62
    23ba:	2a 97       	sbiw	r28, 0x0a	; 10
    23bc:	0f b6       	in	r0, 0x3f	; 63
    23be:	f8 94       	cli
    23c0:	de bf       	out	0x3e, r29	; 62
    23c2:	0f be       	out	0x3f, r0	; 63
    23c4:	cd bf       	out	0x3d, r28	; 61
    23c6:	98 87       	std	Y+8, r25	; 0x08
    23c8:	8f 83       	std	Y+7, r24	; 0x07
    23ca:	7a 87       	std	Y+10, r23	; 0x0a
    23cc:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    23ce:	8f 81       	ldd	r24, Y+7	; 0x07
    23d0:	98 85       	ldd	r25, Y+8	; 0x08
    23d2:	9a 83       	std	Y+2, r25	; 0x02
    23d4:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    23d6:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    23d8:	e9 81       	ldd	r30, Y+1	; 0x01
    23da:	fa 81       	ldd	r31, Y+2	; 0x02
    23dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    23de:	88 23       	and	r24, r24
    23e0:	b1 f0       	breq	.+44     	; 0x240e <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    23e2:	e9 81       	ldd	r30, Y+1	; 0x01
    23e4:	fa 81       	ldd	r31, Y+2	; 0x02
    23e6:	86 81       	ldd	r24, Z+6	; 0x06
    23e8:	97 81       	ldd	r25, Z+7	; 0x07
    23ea:	9c 83       	std	Y+4, r25	; 0x04
    23ec:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    23ee:	89 81       	ldd	r24, Y+1	; 0x01
    23f0:	9a 81       	ldd	r25, Y+2	; 0x02
    23f2:	29 85       	ldd	r18, Y+9	; 0x09
    23f4:	3a 85       	ldd	r19, Y+10	; 0x0a
    23f6:	b9 01       	movw	r22, r18
    23f8:	0e 94 26 13 	call	0x264c	; 0x264c <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    23fc:	e9 81       	ldd	r30, Y+1	; 0x01
    23fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2400:	8b 81       	ldd	r24, Y+3	; 0x03
    2402:	9c 81       	ldd	r25, Y+4	; 0x04
    2404:	97 83       	std	Z+7, r25	; 0x07
    2406:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    2408:	81 e0       	ldi	r24, 0x01	; 1
    240a:	8e 83       	std	Y+6, r24	; 0x06
    240c:	01 c0       	rjmp	.+2      	; 0x2410 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    240e:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2410:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2412:	2a 96       	adiw	r28, 0x0a	; 10
    2414:	0f b6       	in	r0, 0x3f	; 63
    2416:	f8 94       	cli
    2418:	de bf       	out	0x3e, r29	; 62
    241a:	0f be       	out	0x3f, r0	; 63
    241c:	cd bf       	out	0x3d, r28	; 61
    241e:	cf 91       	pop	r28
    2420:	df 91       	pop	r29
    2422:	08 95       	ret

00002424 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2424:	df 93       	push	r29
    2426:	cf 93       	push	r28
    2428:	00 d0       	rcall	.+0      	; 0x242a <uxQueueMessagesWaiting+0x6>
    242a:	0f 92       	push	r0
    242c:	cd b7       	in	r28, 0x3d	; 61
    242e:	de b7       	in	r29, 0x3e	; 62
    2430:	9b 83       	std	Y+3, r25	; 0x03
    2432:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    2434:	0f b6       	in	r0, 0x3f	; 63
    2436:	f8 94       	cli
    2438:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    243a:	ea 81       	ldd	r30, Y+2	; 0x02
    243c:	fb 81       	ldd	r31, Y+3	; 0x03
    243e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2440:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2442:	0f 90       	pop	r0
    2444:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2446:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2448:	0f 90       	pop	r0
    244a:	0f 90       	pop	r0
    244c:	0f 90       	pop	r0
    244e:	cf 91       	pop	r28
    2450:	df 91       	pop	r29
    2452:	08 95       	ret

00002454 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2454:	df 93       	push	r29
    2456:	cf 93       	push	r28
    2458:	00 d0       	rcall	.+0      	; 0x245a <uxQueueSpacesAvailable+0x6>
    245a:	00 d0       	rcall	.+0      	; 0x245c <uxQueueSpacesAvailable+0x8>
    245c:	0f 92       	push	r0
    245e:	cd b7       	in	r28, 0x3d	; 61
    2460:	de b7       	in	r29, 0x3e	; 62
    2462:	9d 83       	std	Y+5, r25	; 0x05
    2464:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2466:	8c 81       	ldd	r24, Y+4	; 0x04
    2468:	9d 81       	ldd	r25, Y+5	; 0x05
    246a:	9a 83       	std	Y+2, r25	; 0x02
    246c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    246e:	0f b6       	in	r0, 0x3f	; 63
    2470:	f8 94       	cli
    2472:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2474:	e9 81       	ldd	r30, Y+1	; 0x01
    2476:	fa 81       	ldd	r31, Y+2	; 0x02
    2478:	93 8d       	ldd	r25, Z+27	; 0x1b
    247a:	e9 81       	ldd	r30, Y+1	; 0x01
    247c:	fa 81       	ldd	r31, Y+2	; 0x02
    247e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2480:	29 2f       	mov	r18, r25
    2482:	28 1b       	sub	r18, r24
    2484:	82 2f       	mov	r24, r18
    2486:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2488:	0f 90       	pop	r0
    248a:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    248c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    248e:	0f 90       	pop	r0
    2490:	0f 90       	pop	r0
    2492:	0f 90       	pop	r0
    2494:	0f 90       	pop	r0
    2496:	0f 90       	pop	r0
    2498:	cf 91       	pop	r28
    249a:	df 91       	pop	r29
    249c:	08 95       	ret

0000249e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    249e:	df 93       	push	r29
    24a0:	cf 93       	push	r28
    24a2:	00 d0       	rcall	.+0      	; 0x24a4 <uxQueueMessagesWaitingFromISR+0x6>
    24a4:	00 d0       	rcall	.+0      	; 0x24a6 <uxQueueMessagesWaitingFromISR+0x8>
    24a6:	0f 92       	push	r0
    24a8:	cd b7       	in	r28, 0x3d	; 61
    24aa:	de b7       	in	r29, 0x3e	; 62
    24ac:	9d 83       	std	Y+5, r25	; 0x05
    24ae:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    24b0:	8c 81       	ldd	r24, Y+4	; 0x04
    24b2:	9d 81       	ldd	r25, Y+5	; 0x05
    24b4:	9a 83       	std	Y+2, r25	; 0x02
    24b6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    24b8:	e9 81       	ldd	r30, Y+1	; 0x01
    24ba:	fa 81       	ldd	r31, Y+2	; 0x02
    24bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    24be:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    24c0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    24c2:	0f 90       	pop	r0
    24c4:	0f 90       	pop	r0
    24c6:	0f 90       	pop	r0
    24c8:	0f 90       	pop	r0
    24ca:	0f 90       	pop	r0
    24cc:	cf 91       	pop	r28
    24ce:	df 91       	pop	r29
    24d0:	08 95       	ret

000024d2 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    24d2:	df 93       	push	r29
    24d4:	cf 93       	push	r28
    24d6:	00 d0       	rcall	.+0      	; 0x24d8 <vQueueDelete+0x6>
    24d8:	00 d0       	rcall	.+0      	; 0x24da <vQueueDelete+0x8>
    24da:	cd b7       	in	r28, 0x3d	; 61
    24dc:	de b7       	in	r29, 0x3e	; 62
    24de:	9c 83       	std	Y+4, r25	; 0x04
    24e0:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    24e2:	8b 81       	ldd	r24, Y+3	; 0x03
    24e4:	9c 81       	ldd	r25, Y+4	; 0x04
    24e6:	9a 83       	std	Y+2, r25	; 0x02
    24e8:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    24ea:	89 81       	ldd	r24, Y+1	; 0x01
    24ec:	9a 81       	ldd	r25, Y+2	; 0x02
    24ee:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    24f2:	0f 90       	pop	r0
    24f4:	0f 90       	pop	r0
    24f6:	0f 90       	pop	r0
    24f8:	0f 90       	pop	r0
    24fa:	cf 91       	pop	r28
    24fc:	df 91       	pop	r29
    24fe:	08 95       	ret

00002500 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2500:	df 93       	push	r29
    2502:	cf 93       	push	r28
    2504:	cd b7       	in	r28, 0x3d	; 61
    2506:	de b7       	in	r29, 0x3e	; 62
    2508:	27 97       	sbiw	r28, 0x07	; 7
    250a:	0f b6       	in	r0, 0x3f	; 63
    250c:	f8 94       	cli
    250e:	de bf       	out	0x3e, r29	; 62
    2510:	0f be       	out	0x3f, r0	; 63
    2512:	cd bf       	out	0x3d, r28	; 61
    2514:	9c 83       	std	Y+4, r25	; 0x04
    2516:	8b 83       	std	Y+3, r24	; 0x03
    2518:	7e 83       	std	Y+6, r23	; 0x06
    251a:	6d 83       	std	Y+5, r22	; 0x05
    251c:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    251e:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2520:	eb 81       	ldd	r30, Y+3	; 0x03
    2522:	fc 81       	ldd	r31, Y+4	; 0x04
    2524:	82 8d       	ldd	r24, Z+26	; 0x1a
    2526:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2528:	eb 81       	ldd	r30, Y+3	; 0x03
    252a:	fc 81       	ldd	r31, Y+4	; 0x04
    252c:	84 8d       	ldd	r24, Z+28	; 0x1c
    252e:	88 23       	and	r24, r24
    2530:	09 f4       	brne	.+2      	; 0x2534 <prvCopyDataToQueue+0x34>
    2532:	7d c0       	rjmp	.+250    	; 0x262e <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    2534:	8f 81       	ldd	r24, Y+7	; 0x07
    2536:	88 23       	and	r24, r24
    2538:	99 f5       	brne	.+102    	; 0x25a0 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    253a:	eb 81       	ldd	r30, Y+3	; 0x03
    253c:	fc 81       	ldd	r31, Y+4	; 0x04
    253e:	62 81       	ldd	r22, Z+2	; 0x02
    2540:	73 81       	ldd	r23, Z+3	; 0x03
    2542:	eb 81       	ldd	r30, Y+3	; 0x03
    2544:	fc 81       	ldd	r31, Y+4	; 0x04
    2546:	84 8d       	ldd	r24, Z+28	; 0x1c
    2548:	48 2f       	mov	r20, r24
    254a:	50 e0       	ldi	r21, 0x00	; 0
    254c:	2d 81       	ldd	r18, Y+5	; 0x05
    254e:	3e 81       	ldd	r19, Y+6	; 0x06
    2550:	cb 01       	movw	r24, r22
    2552:	b9 01       	movw	r22, r18
    2554:	0e 94 60 23 	call	0x46c0	; 0x46c0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2558:	eb 81       	ldd	r30, Y+3	; 0x03
    255a:	fc 81       	ldd	r31, Y+4	; 0x04
    255c:	22 81       	ldd	r18, Z+2	; 0x02
    255e:	33 81       	ldd	r19, Z+3	; 0x03
    2560:	eb 81       	ldd	r30, Y+3	; 0x03
    2562:	fc 81       	ldd	r31, Y+4	; 0x04
    2564:	84 8d       	ldd	r24, Z+28	; 0x1c
    2566:	88 2f       	mov	r24, r24
    2568:	90 e0       	ldi	r25, 0x00	; 0
    256a:	82 0f       	add	r24, r18
    256c:	93 1f       	adc	r25, r19
    256e:	eb 81       	ldd	r30, Y+3	; 0x03
    2570:	fc 81       	ldd	r31, Y+4	; 0x04
    2572:	93 83       	std	Z+3, r25	; 0x03
    2574:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2576:	eb 81       	ldd	r30, Y+3	; 0x03
    2578:	fc 81       	ldd	r31, Y+4	; 0x04
    257a:	22 81       	ldd	r18, Z+2	; 0x02
    257c:	33 81       	ldd	r19, Z+3	; 0x03
    257e:	eb 81       	ldd	r30, Y+3	; 0x03
    2580:	fc 81       	ldd	r31, Y+4	; 0x04
    2582:	84 81       	ldd	r24, Z+4	; 0x04
    2584:	95 81       	ldd	r25, Z+5	; 0x05
    2586:	28 17       	cp	r18, r24
    2588:	39 07       	cpc	r19, r25
    258a:	08 f4       	brcc	.+2      	; 0x258e <prvCopyDataToQueue+0x8e>
    258c:	50 c0       	rjmp	.+160    	; 0x262e <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    258e:	eb 81       	ldd	r30, Y+3	; 0x03
    2590:	fc 81       	ldd	r31, Y+4	; 0x04
    2592:	80 81       	ld	r24, Z
    2594:	91 81       	ldd	r25, Z+1	; 0x01
    2596:	eb 81       	ldd	r30, Y+3	; 0x03
    2598:	fc 81       	ldd	r31, Y+4	; 0x04
    259a:	93 83       	std	Z+3, r25	; 0x03
    259c:	82 83       	std	Z+2, r24	; 0x02
    259e:	47 c0       	rjmp	.+142    	; 0x262e <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    25a0:	eb 81       	ldd	r30, Y+3	; 0x03
    25a2:	fc 81       	ldd	r31, Y+4	; 0x04
    25a4:	66 81       	ldd	r22, Z+6	; 0x06
    25a6:	77 81       	ldd	r23, Z+7	; 0x07
    25a8:	eb 81       	ldd	r30, Y+3	; 0x03
    25aa:	fc 81       	ldd	r31, Y+4	; 0x04
    25ac:	84 8d       	ldd	r24, Z+28	; 0x1c
    25ae:	48 2f       	mov	r20, r24
    25b0:	50 e0       	ldi	r21, 0x00	; 0
    25b2:	2d 81       	ldd	r18, Y+5	; 0x05
    25b4:	3e 81       	ldd	r19, Y+6	; 0x06
    25b6:	cb 01       	movw	r24, r22
    25b8:	b9 01       	movw	r22, r18
    25ba:	0e 94 60 23 	call	0x46c0	; 0x46c0 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    25be:	eb 81       	ldd	r30, Y+3	; 0x03
    25c0:	fc 81       	ldd	r31, Y+4	; 0x04
    25c2:	26 81       	ldd	r18, Z+6	; 0x06
    25c4:	37 81       	ldd	r19, Z+7	; 0x07
    25c6:	eb 81       	ldd	r30, Y+3	; 0x03
    25c8:	fc 81       	ldd	r31, Y+4	; 0x04
    25ca:	84 8d       	ldd	r24, Z+28	; 0x1c
    25cc:	88 2f       	mov	r24, r24
    25ce:	90 e0       	ldi	r25, 0x00	; 0
    25d0:	90 95       	com	r25
    25d2:	81 95       	neg	r24
    25d4:	9f 4f       	sbci	r25, 0xFF	; 255
    25d6:	82 0f       	add	r24, r18
    25d8:	93 1f       	adc	r25, r19
    25da:	eb 81       	ldd	r30, Y+3	; 0x03
    25dc:	fc 81       	ldd	r31, Y+4	; 0x04
    25de:	97 83       	std	Z+7, r25	; 0x07
    25e0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    25e2:	eb 81       	ldd	r30, Y+3	; 0x03
    25e4:	fc 81       	ldd	r31, Y+4	; 0x04
    25e6:	26 81       	ldd	r18, Z+6	; 0x06
    25e8:	37 81       	ldd	r19, Z+7	; 0x07
    25ea:	eb 81       	ldd	r30, Y+3	; 0x03
    25ec:	fc 81       	ldd	r31, Y+4	; 0x04
    25ee:	80 81       	ld	r24, Z
    25f0:	91 81       	ldd	r25, Z+1	; 0x01
    25f2:	28 17       	cp	r18, r24
    25f4:	39 07       	cpc	r19, r25
    25f6:	90 f4       	brcc	.+36     	; 0x261c <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    25f8:	eb 81       	ldd	r30, Y+3	; 0x03
    25fa:	fc 81       	ldd	r31, Y+4	; 0x04
    25fc:	24 81       	ldd	r18, Z+4	; 0x04
    25fe:	35 81       	ldd	r19, Z+5	; 0x05
    2600:	eb 81       	ldd	r30, Y+3	; 0x03
    2602:	fc 81       	ldd	r31, Y+4	; 0x04
    2604:	84 8d       	ldd	r24, Z+28	; 0x1c
    2606:	88 2f       	mov	r24, r24
    2608:	90 e0       	ldi	r25, 0x00	; 0
    260a:	90 95       	com	r25
    260c:	81 95       	neg	r24
    260e:	9f 4f       	sbci	r25, 0xFF	; 255
    2610:	82 0f       	add	r24, r18
    2612:	93 1f       	adc	r25, r19
    2614:	eb 81       	ldd	r30, Y+3	; 0x03
    2616:	fc 81       	ldd	r31, Y+4	; 0x04
    2618:	97 83       	std	Z+7, r25	; 0x07
    261a:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    261c:	8f 81       	ldd	r24, Y+7	; 0x07
    261e:	82 30       	cpi	r24, 0x02	; 2
    2620:	31 f4       	brne	.+12     	; 0x262e <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2622:	89 81       	ldd	r24, Y+1	; 0x01
    2624:	88 23       	and	r24, r24
    2626:	19 f0       	breq	.+6      	; 0x262e <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    2628:	89 81       	ldd	r24, Y+1	; 0x01
    262a:	81 50       	subi	r24, 0x01	; 1
    262c:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    262e:	89 81       	ldd	r24, Y+1	; 0x01
    2630:	8f 5f       	subi	r24, 0xFF	; 255
    2632:	eb 81       	ldd	r30, Y+3	; 0x03
    2634:	fc 81       	ldd	r31, Y+4	; 0x04
    2636:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    2638:	8a 81       	ldd	r24, Y+2	; 0x02
}
    263a:	27 96       	adiw	r28, 0x07	; 7
    263c:	0f b6       	in	r0, 0x3f	; 63
    263e:	f8 94       	cli
    2640:	de bf       	out	0x3e, r29	; 62
    2642:	0f be       	out	0x3f, r0	; 63
    2644:	cd bf       	out	0x3d, r28	; 61
    2646:	cf 91       	pop	r28
    2648:	df 91       	pop	r29
    264a:	08 95       	ret

0000264c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    264c:	df 93       	push	r29
    264e:	cf 93       	push	r28
    2650:	00 d0       	rcall	.+0      	; 0x2652 <prvCopyDataFromQueue+0x6>
    2652:	00 d0       	rcall	.+0      	; 0x2654 <prvCopyDataFromQueue+0x8>
    2654:	cd b7       	in	r28, 0x3d	; 61
    2656:	de b7       	in	r29, 0x3e	; 62
    2658:	9a 83       	std	Y+2, r25	; 0x02
    265a:	89 83       	std	Y+1, r24	; 0x01
    265c:	7c 83       	std	Y+4, r23	; 0x04
    265e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2660:	e9 81       	ldd	r30, Y+1	; 0x01
    2662:	fa 81       	ldd	r31, Y+2	; 0x02
    2664:	84 8d       	ldd	r24, Z+28	; 0x1c
    2666:	88 23       	and	r24, r24
    2668:	89 f1       	breq	.+98     	; 0x26cc <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    266a:	e9 81       	ldd	r30, Y+1	; 0x01
    266c:	fa 81       	ldd	r31, Y+2	; 0x02
    266e:	26 81       	ldd	r18, Z+6	; 0x06
    2670:	37 81       	ldd	r19, Z+7	; 0x07
    2672:	e9 81       	ldd	r30, Y+1	; 0x01
    2674:	fa 81       	ldd	r31, Y+2	; 0x02
    2676:	84 8d       	ldd	r24, Z+28	; 0x1c
    2678:	88 2f       	mov	r24, r24
    267a:	90 e0       	ldi	r25, 0x00	; 0
    267c:	82 0f       	add	r24, r18
    267e:	93 1f       	adc	r25, r19
    2680:	e9 81       	ldd	r30, Y+1	; 0x01
    2682:	fa 81       	ldd	r31, Y+2	; 0x02
    2684:	97 83       	std	Z+7, r25	; 0x07
    2686:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2688:	e9 81       	ldd	r30, Y+1	; 0x01
    268a:	fa 81       	ldd	r31, Y+2	; 0x02
    268c:	26 81       	ldd	r18, Z+6	; 0x06
    268e:	37 81       	ldd	r19, Z+7	; 0x07
    2690:	e9 81       	ldd	r30, Y+1	; 0x01
    2692:	fa 81       	ldd	r31, Y+2	; 0x02
    2694:	84 81       	ldd	r24, Z+4	; 0x04
    2696:	95 81       	ldd	r25, Z+5	; 0x05
    2698:	28 17       	cp	r18, r24
    269a:	39 07       	cpc	r19, r25
    269c:	40 f0       	brcs	.+16     	; 0x26ae <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    269e:	e9 81       	ldd	r30, Y+1	; 0x01
    26a0:	fa 81       	ldd	r31, Y+2	; 0x02
    26a2:	80 81       	ld	r24, Z
    26a4:	91 81       	ldd	r25, Z+1	; 0x01
    26a6:	e9 81       	ldd	r30, Y+1	; 0x01
    26a8:	fa 81       	ldd	r31, Y+2	; 0x02
    26aa:	97 83       	std	Z+7, r25	; 0x07
    26ac:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    26ae:	e9 81       	ldd	r30, Y+1	; 0x01
    26b0:	fa 81       	ldd	r31, Y+2	; 0x02
    26b2:	46 81       	ldd	r20, Z+6	; 0x06
    26b4:	57 81       	ldd	r21, Z+7	; 0x07
    26b6:	e9 81       	ldd	r30, Y+1	; 0x01
    26b8:	fa 81       	ldd	r31, Y+2	; 0x02
    26ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    26bc:	28 2f       	mov	r18, r24
    26be:	30 e0       	ldi	r19, 0x00	; 0
    26c0:	8b 81       	ldd	r24, Y+3	; 0x03
    26c2:	9c 81       	ldd	r25, Y+4	; 0x04
    26c4:	ba 01       	movw	r22, r20
    26c6:	a9 01       	movw	r20, r18
    26c8:	0e 94 60 23 	call	0x46c0	; 0x46c0 <memcpy>
	}
}
    26cc:	0f 90       	pop	r0
    26ce:	0f 90       	pop	r0
    26d0:	0f 90       	pop	r0
    26d2:	0f 90       	pop	r0
    26d4:	cf 91       	pop	r28
    26d6:	df 91       	pop	r29
    26d8:	08 95       	ret

000026da <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    26da:	df 93       	push	r29
    26dc:	cf 93       	push	r28
    26de:	00 d0       	rcall	.+0      	; 0x26e0 <prvUnlockQueue+0x6>
    26e0:	00 d0       	rcall	.+0      	; 0x26e2 <prvUnlockQueue+0x8>
    26e2:	cd b7       	in	r28, 0x3d	; 61
    26e4:	de b7       	in	r29, 0x3e	; 62
    26e6:	9c 83       	std	Y+4, r25	; 0x04
    26e8:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    26ea:	0f b6       	in	r0, 0x3f	; 63
    26ec:	f8 94       	cli
    26ee:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    26f0:	eb 81       	ldd	r30, Y+3	; 0x03
    26f2:	fc 81       	ldd	r31, Y+4	; 0x04
    26f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    26f6:	8a 83       	std	Y+2, r24	; 0x02
    26f8:	11 c0       	rjmp	.+34     	; 0x271c <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26fa:	eb 81       	ldd	r30, Y+3	; 0x03
    26fc:	fc 81       	ldd	r31, Y+4	; 0x04
    26fe:	81 89       	ldd	r24, Z+17	; 0x11
    2700:	88 23       	and	r24, r24
    2702:	79 f0       	breq	.+30     	; 0x2722 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2704:	8b 81       	ldd	r24, Y+3	; 0x03
    2706:	9c 81       	ldd	r25, Y+4	; 0x04
    2708:	41 96       	adiw	r24, 0x11	; 17
    270a:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    270e:	88 23       	and	r24, r24
    2710:	11 f0       	breq	.+4      	; 0x2716 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    2712:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    2716:	8a 81       	ldd	r24, Y+2	; 0x02
    2718:	81 50       	subi	r24, 0x01	; 1
    271a:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    271c:	8a 81       	ldd	r24, Y+2	; 0x02
    271e:	18 16       	cp	r1, r24
    2720:	64 f3       	brlt	.-40     	; 0x26fa <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    2722:	eb 81       	ldd	r30, Y+3	; 0x03
    2724:	fc 81       	ldd	r31, Y+4	; 0x04
    2726:	8f ef       	ldi	r24, 0xFF	; 255
    2728:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    272a:	0f 90       	pop	r0
    272c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    272e:	0f b6       	in	r0, 0x3f	; 63
    2730:	f8 94       	cli
    2732:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    2734:	eb 81       	ldd	r30, Y+3	; 0x03
    2736:	fc 81       	ldd	r31, Y+4	; 0x04
    2738:	85 8d       	ldd	r24, Z+29	; 0x1d
    273a:	89 83       	std	Y+1, r24	; 0x01
    273c:	11 c0       	rjmp	.+34     	; 0x2760 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    273e:	eb 81       	ldd	r30, Y+3	; 0x03
    2740:	fc 81       	ldd	r31, Y+4	; 0x04
    2742:	80 85       	ldd	r24, Z+8	; 0x08
    2744:	88 23       	and	r24, r24
    2746:	79 f0       	breq	.+30     	; 0x2766 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2748:	8b 81       	ldd	r24, Y+3	; 0x03
    274a:	9c 81       	ldd	r25, Y+4	; 0x04
    274c:	08 96       	adiw	r24, 0x08	; 8
    274e:	0e 94 89 1c 	call	0x3912	; 0x3912 <xTaskRemoveFromEventList>
    2752:	88 23       	and	r24, r24
    2754:	11 f0       	breq	.+4      	; 0x275a <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2756:	0e 94 f5 1d 	call	0x3bea	; 0x3bea <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    275a:	89 81       	ldd	r24, Y+1	; 0x01
    275c:	81 50       	subi	r24, 0x01	; 1
    275e:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2760:	89 81       	ldd	r24, Y+1	; 0x01
    2762:	18 16       	cp	r1, r24
    2764:	64 f3       	brlt	.-40     	; 0x273e <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2766:	eb 81       	ldd	r30, Y+3	; 0x03
    2768:	fc 81       	ldd	r31, Y+4	; 0x04
    276a:	8f ef       	ldi	r24, 0xFF	; 255
    276c:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    276e:	0f 90       	pop	r0
    2770:	0f be       	out	0x3f, r0	; 63
}
    2772:	0f 90       	pop	r0
    2774:	0f 90       	pop	r0
    2776:	0f 90       	pop	r0
    2778:	0f 90       	pop	r0
    277a:	cf 91       	pop	r28
    277c:	df 91       	pop	r29
    277e:	08 95       	ret

00002780 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2780:	df 93       	push	r29
    2782:	cf 93       	push	r28
    2784:	00 d0       	rcall	.+0      	; 0x2786 <prvIsQueueEmpty+0x6>
    2786:	0f 92       	push	r0
    2788:	cd b7       	in	r28, 0x3d	; 61
    278a:	de b7       	in	r29, 0x3e	; 62
    278c:	9b 83       	std	Y+3, r25	; 0x03
    278e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2790:	0f b6       	in	r0, 0x3f	; 63
    2792:	f8 94       	cli
    2794:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2796:	ea 81       	ldd	r30, Y+2	; 0x02
    2798:	fb 81       	ldd	r31, Y+3	; 0x03
    279a:	82 8d       	ldd	r24, Z+26	; 0x1a
    279c:	88 23       	and	r24, r24
    279e:	19 f4       	brne	.+6      	; 0x27a6 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    27a0:	81 e0       	ldi	r24, 0x01	; 1
    27a2:	89 83       	std	Y+1, r24	; 0x01
    27a4:	01 c0       	rjmp	.+2      	; 0x27a8 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    27a6:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    27a8:	0f 90       	pop	r0
    27aa:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    27ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    27ae:	0f 90       	pop	r0
    27b0:	0f 90       	pop	r0
    27b2:	0f 90       	pop	r0
    27b4:	cf 91       	pop	r28
    27b6:	df 91       	pop	r29
    27b8:	08 95       	ret

000027ba <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    27ba:	df 93       	push	r29
    27bc:	cf 93       	push	r28
    27be:	00 d0       	rcall	.+0      	; 0x27c0 <xQueueIsQueueEmptyFromISR+0x6>
    27c0:	00 d0       	rcall	.+0      	; 0x27c2 <xQueueIsQueueEmptyFromISR+0x8>
    27c2:	0f 92       	push	r0
    27c4:	cd b7       	in	r28, 0x3d	; 61
    27c6:	de b7       	in	r29, 0x3e	; 62
    27c8:	9d 83       	std	Y+5, r25	; 0x05
    27ca:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    27cc:	8c 81       	ldd	r24, Y+4	; 0x04
    27ce:	9d 81       	ldd	r25, Y+5	; 0x05
    27d0:	9a 83       	std	Y+2, r25	; 0x02
    27d2:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    27d4:	e9 81       	ldd	r30, Y+1	; 0x01
    27d6:	fa 81       	ldd	r31, Y+2	; 0x02
    27d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    27da:	88 23       	and	r24, r24
    27dc:	19 f4       	brne	.+6      	; 0x27e4 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    27de:	81 e0       	ldi	r24, 0x01	; 1
    27e0:	8b 83       	std	Y+3, r24	; 0x03
    27e2:	01 c0       	rjmp	.+2      	; 0x27e6 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    27e4:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    27e6:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    27e8:	0f 90       	pop	r0
    27ea:	0f 90       	pop	r0
    27ec:	0f 90       	pop	r0
    27ee:	0f 90       	pop	r0
    27f0:	0f 90       	pop	r0
    27f2:	cf 91       	pop	r28
    27f4:	df 91       	pop	r29
    27f6:	08 95       	ret

000027f8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    27f8:	df 93       	push	r29
    27fa:	cf 93       	push	r28
    27fc:	00 d0       	rcall	.+0      	; 0x27fe <prvIsQueueFull+0x6>
    27fe:	0f 92       	push	r0
    2800:	cd b7       	in	r28, 0x3d	; 61
    2802:	de b7       	in	r29, 0x3e	; 62
    2804:	9b 83       	std	Y+3, r25	; 0x03
    2806:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2808:	0f b6       	in	r0, 0x3f	; 63
    280a:	f8 94       	cli
    280c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    280e:	ea 81       	ldd	r30, Y+2	; 0x02
    2810:	fb 81       	ldd	r31, Y+3	; 0x03
    2812:	92 8d       	ldd	r25, Z+26	; 0x1a
    2814:	ea 81       	ldd	r30, Y+2	; 0x02
    2816:	fb 81       	ldd	r31, Y+3	; 0x03
    2818:	83 8d       	ldd	r24, Z+27	; 0x1b
    281a:	98 17       	cp	r25, r24
    281c:	19 f4       	brne	.+6      	; 0x2824 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    281e:	81 e0       	ldi	r24, 0x01	; 1
    2820:	89 83       	std	Y+1, r24	; 0x01
    2822:	01 c0       	rjmp	.+2      	; 0x2826 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2824:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2826:	0f 90       	pop	r0
    2828:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    282a:	89 81       	ldd	r24, Y+1	; 0x01
}
    282c:	0f 90       	pop	r0
    282e:	0f 90       	pop	r0
    2830:	0f 90       	pop	r0
    2832:	cf 91       	pop	r28
    2834:	df 91       	pop	r29
    2836:	08 95       	ret

00002838 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2838:	df 93       	push	r29
    283a:	cf 93       	push	r28
    283c:	00 d0       	rcall	.+0      	; 0x283e <xQueueIsQueueFullFromISR+0x6>
    283e:	00 d0       	rcall	.+0      	; 0x2840 <xQueueIsQueueFullFromISR+0x8>
    2840:	0f 92       	push	r0
    2842:	cd b7       	in	r28, 0x3d	; 61
    2844:	de b7       	in	r29, 0x3e	; 62
    2846:	9d 83       	std	Y+5, r25	; 0x05
    2848:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    284a:	8c 81       	ldd	r24, Y+4	; 0x04
    284c:	9d 81       	ldd	r25, Y+5	; 0x05
    284e:	9a 83       	std	Y+2, r25	; 0x02
    2850:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2852:	e9 81       	ldd	r30, Y+1	; 0x01
    2854:	fa 81       	ldd	r31, Y+2	; 0x02
    2856:	92 8d       	ldd	r25, Z+26	; 0x1a
    2858:	e9 81       	ldd	r30, Y+1	; 0x01
    285a:	fa 81       	ldd	r31, Y+2	; 0x02
    285c:	83 8d       	ldd	r24, Z+27	; 0x1b
    285e:	98 17       	cp	r25, r24
    2860:	19 f4       	brne	.+6      	; 0x2868 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2862:	81 e0       	ldi	r24, 0x01	; 1
    2864:	8b 83       	std	Y+3, r24	; 0x03
    2866:	01 c0       	rjmp	.+2      	; 0x286a <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2868:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    286a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    286c:	0f 90       	pop	r0
    286e:	0f 90       	pop	r0
    2870:	0f 90       	pop	r0
    2872:	0f 90       	pop	r0
    2874:	0f 90       	pop	r0
    2876:	cf 91       	pop	r28
    2878:	df 91       	pop	r29
    287a:	08 95       	ret

0000287c <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    287c:	8f 92       	push	r8
    287e:	9f 92       	push	r9
    2880:	af 92       	push	r10
    2882:	bf 92       	push	r11
    2884:	cf 92       	push	r12
    2886:	df 92       	push	r13
    2888:	ef 92       	push	r14
    288a:	ff 92       	push	r15
    288c:	0f 93       	push	r16
    288e:	1f 93       	push	r17
    2890:	df 93       	push	r29
    2892:	cf 93       	push	r28
    2894:	cd b7       	in	r28, 0x3d	; 61
    2896:	de b7       	in	r29, 0x3e	; 62
    2898:	60 97       	sbiw	r28, 0x10	; 16
    289a:	0f b6       	in	r0, 0x3f	; 63
    289c:	f8 94       	cli
    289e:	de bf       	out	0x3e, r29	; 62
    28a0:	0f be       	out	0x3f, r0	; 63
    28a2:	cd bf       	out	0x3d, r28	; 61
    28a4:	9f 83       	std	Y+7, r25	; 0x07
    28a6:	8e 83       	std	Y+6, r24	; 0x06
    28a8:	79 87       	std	Y+9, r23	; 0x09
    28aa:	68 87       	std	Y+8, r22	; 0x08
    28ac:	5b 87       	std	Y+11, r21	; 0x0b
    28ae:	4a 87       	std	Y+10, r20	; 0x0a
    28b0:	3d 87       	std	Y+13, r19	; 0x0d
    28b2:	2c 87       	std	Y+12, r18	; 0x0c
    28b4:	0e 87       	std	Y+14, r16	; 0x0e
    28b6:	f8 8a       	std	Y+16, r15	; 0x10
    28b8:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    28ba:	8a 85       	ldd	r24, Y+10	; 0x0a
    28bc:	9b 85       	ldd	r25, Y+11	; 0x0b
    28be:	0e 94 05 08 	call	0x100a	; 0x100a <pvPortMalloc>
    28c2:	9a 83       	std	Y+2, r25	; 0x02
    28c4:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    28c6:	89 81       	ldd	r24, Y+1	; 0x01
    28c8:	9a 81       	ldd	r25, Y+2	; 0x02
    28ca:	00 97       	sbiw	r24, 0x00	; 0
    28cc:	b1 f0       	breq	.+44     	; 0x28fa <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    28ce:	86 e2       	ldi	r24, 0x26	; 38
    28d0:	90 e0       	ldi	r25, 0x00	; 0
    28d2:	0e 94 05 08 	call	0x100a	; 0x100a <pvPortMalloc>
    28d6:	9d 83       	std	Y+5, r25	; 0x05
    28d8:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    28da:	8c 81       	ldd	r24, Y+4	; 0x04
    28dc:	9d 81       	ldd	r25, Y+5	; 0x05
    28de:	00 97       	sbiw	r24, 0x00	; 0
    28e0:	39 f0       	breq	.+14     	; 0x28f0 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    28e2:	ec 81       	ldd	r30, Y+4	; 0x04
    28e4:	fd 81       	ldd	r31, Y+5	; 0x05
    28e6:	89 81       	ldd	r24, Y+1	; 0x01
    28e8:	9a 81       	ldd	r25, Y+2	; 0x02
    28ea:	90 8f       	std	Z+24, r25	; 0x18
    28ec:	87 8b       	std	Z+23, r24	; 0x17
    28ee:	07 c0       	rjmp	.+14     	; 0x28fe <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    28f0:	89 81       	ldd	r24, Y+1	; 0x01
    28f2:	9a 81       	ldd	r25, Y+2	; 0x02
    28f4:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <vPortFree>
    28f8:	02 c0       	rjmp	.+4      	; 0x28fe <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    28fa:	1d 82       	std	Y+5, r1	; 0x05
    28fc:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    28fe:	8c 81       	ldd	r24, Y+4	; 0x04
    2900:	9d 81       	ldd	r25, Y+5	; 0x05
    2902:	00 97       	sbiw	r24, 0x00	; 0
    2904:	e9 f0       	breq	.+58     	; 0x2940 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2906:	8a 85       	ldd	r24, Y+10	; 0x0a
    2908:	9b 85       	ldd	r25, Y+11	; 0x0b
    290a:	9c 01       	movw	r18, r24
    290c:	40 e0       	ldi	r20, 0x00	; 0
    290e:	50 e0       	ldi	r21, 0x00	; 0
    2910:	8e 81       	ldd	r24, Y+6	; 0x06
    2912:	9f 81       	ldd	r25, Y+7	; 0x07
    2914:	68 85       	ldd	r22, Y+8	; 0x08
    2916:	79 85       	ldd	r23, Y+9	; 0x09
    2918:	ec 85       	ldd	r30, Y+12	; 0x0c
    291a:	fd 85       	ldd	r31, Y+13	; 0x0d
    291c:	af 85       	ldd	r26, Y+15	; 0x0f
    291e:	b8 89       	ldd	r27, Y+16	; 0x10
    2920:	ac 80       	ldd	r10, Y+4	; 0x04
    2922:	bd 80       	ldd	r11, Y+5	; 0x05
    2924:	8f 01       	movw	r16, r30
    2926:	ee 84       	ldd	r14, Y+14	; 0x0e
    2928:	6d 01       	movw	r12, r26
    292a:	88 24       	eor	r8, r8
    292c:	99 24       	eor	r9, r9
    292e:	0e 94 b6 14 	call	0x296c	; 0x296c <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    2932:	8c 81       	ldd	r24, Y+4	; 0x04
    2934:	9d 81       	ldd	r25, Y+5	; 0x05
    2936:	0e 94 72 15 	call	0x2ae4	; 0x2ae4 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    293a:	81 e0       	ldi	r24, 0x01	; 1
    293c:	8b 83       	std	Y+3, r24	; 0x03
    293e:	02 c0       	rjmp	.+4      	; 0x2944 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2940:	8f ef       	ldi	r24, 0xFF	; 255
    2942:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    2944:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2946:	60 96       	adiw	r28, 0x10	; 16
    2948:	0f b6       	in	r0, 0x3f	; 63
    294a:	f8 94       	cli
    294c:	de bf       	out	0x3e, r29	; 62
    294e:	0f be       	out	0x3f, r0	; 63
    2950:	cd bf       	out	0x3d, r28	; 61
    2952:	cf 91       	pop	r28
    2954:	df 91       	pop	r29
    2956:	1f 91       	pop	r17
    2958:	0f 91       	pop	r16
    295a:	ff 90       	pop	r15
    295c:	ef 90       	pop	r14
    295e:	df 90       	pop	r13
    2960:	cf 90       	pop	r12
    2962:	bf 90       	pop	r11
    2964:	af 90       	pop	r10
    2966:	9f 90       	pop	r9
    2968:	8f 90       	pop	r8
    296a:	08 95       	ret

0000296c <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    296c:	8f 92       	push	r8
    296e:	9f 92       	push	r9
    2970:	af 92       	push	r10
    2972:	bf 92       	push	r11
    2974:	cf 92       	push	r12
    2976:	df 92       	push	r13
    2978:	ef 92       	push	r14
    297a:	0f 93       	push	r16
    297c:	1f 93       	push	r17
    297e:	df 93       	push	r29
    2980:	cf 93       	push	r28
    2982:	cd b7       	in	r28, 0x3d	; 61
    2984:	de b7       	in	r29, 0x3e	; 62
    2986:	64 97       	sbiw	r28, 0x14	; 20
    2988:	0f b6       	in	r0, 0x3f	; 63
    298a:	f8 94       	cli
    298c:	de bf       	out	0x3e, r29	; 62
    298e:	0f be       	out	0x3f, r0	; 63
    2990:	cd bf       	out	0x3d, r28	; 61
    2992:	9d 83       	std	Y+5, r25	; 0x05
    2994:	8c 83       	std	Y+4, r24	; 0x04
    2996:	7f 83       	std	Y+7, r23	; 0x07
    2998:	6e 83       	std	Y+6, r22	; 0x06
    299a:	28 87       	std	Y+8, r18	; 0x08
    299c:	39 87       	std	Y+9, r19	; 0x09
    299e:	4a 87       	std	Y+10, r20	; 0x0a
    29a0:	5b 87       	std	Y+11, r21	; 0x0b
    29a2:	1d 87       	std	Y+13, r17	; 0x0d
    29a4:	0c 87       	std	Y+12, r16	; 0x0c
    29a6:	ee 86       	std	Y+14, r14	; 0x0e
    29a8:	d8 8a       	std	Y+16, r13	; 0x10
    29aa:	cf 86       	std	Y+15, r12	; 0x0f
    29ac:	ba 8a       	std	Y+18, r11	; 0x12
    29ae:	a9 8a       	std	Y+17, r10	; 0x11
    29b0:	9c 8a       	std	Y+20, r9	; 0x14
    29b2:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    29b4:	e9 89       	ldd	r30, Y+17	; 0x11
    29b6:	fa 89       	ldd	r31, Y+18	; 0x12
    29b8:	27 89       	ldd	r18, Z+23	; 0x17
    29ba:	30 8d       	ldd	r19, Z+24	; 0x18
    29bc:	88 85       	ldd	r24, Y+8	; 0x08
    29be:	99 85       	ldd	r25, Y+9	; 0x09
    29c0:	01 97       	sbiw	r24, 0x01	; 1
    29c2:	82 0f       	add	r24, r18
    29c4:	93 1f       	adc	r25, r19
    29c6:	9b 83       	std	Y+3, r25	; 0x03
    29c8:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    29ca:	8e 81       	ldd	r24, Y+6	; 0x06
    29cc:	9f 81       	ldd	r25, Y+7	; 0x07
    29ce:	00 97       	sbiw	r24, 0x00	; 0
    29d0:	51 f1       	breq	.+84     	; 0x2a26 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    29d2:	19 82       	std	Y+1, r1	; 0x01
    29d4:	21 c0       	rjmp	.+66     	; 0x2a18 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    29d6:	89 81       	ldd	r24, Y+1	; 0x01
    29d8:	48 2f       	mov	r20, r24
    29da:	50 e0       	ldi	r21, 0x00	; 0
    29dc:	89 81       	ldd	r24, Y+1	; 0x01
    29de:	28 2f       	mov	r18, r24
    29e0:	30 e0       	ldi	r19, 0x00	; 0
    29e2:	8e 81       	ldd	r24, Y+6	; 0x06
    29e4:	9f 81       	ldd	r25, Y+7	; 0x07
    29e6:	fc 01       	movw	r30, r24
    29e8:	e2 0f       	add	r30, r18
    29ea:	f3 1f       	adc	r31, r19
    29ec:	20 81       	ld	r18, Z
    29ee:	89 89       	ldd	r24, Y+17	; 0x11
    29f0:	9a 89       	ldd	r25, Y+18	; 0x12
    29f2:	84 0f       	add	r24, r20
    29f4:	95 1f       	adc	r25, r21
    29f6:	fc 01       	movw	r30, r24
    29f8:	79 96       	adiw	r30, 0x19	; 25
    29fa:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    29fc:	89 81       	ldd	r24, Y+1	; 0x01
    29fe:	28 2f       	mov	r18, r24
    2a00:	30 e0       	ldi	r19, 0x00	; 0
    2a02:	8e 81       	ldd	r24, Y+6	; 0x06
    2a04:	9f 81       	ldd	r25, Y+7	; 0x07
    2a06:	fc 01       	movw	r30, r24
    2a08:	e2 0f       	add	r30, r18
    2a0a:	f3 1f       	adc	r31, r19
    2a0c:	80 81       	ld	r24, Z
    2a0e:	88 23       	and	r24, r24
    2a10:	31 f0       	breq	.+12     	; 0x2a1e <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2a12:	89 81       	ldd	r24, Y+1	; 0x01
    2a14:	8f 5f       	subi	r24, 0xFF	; 255
    2a16:	89 83       	std	Y+1, r24	; 0x01
    2a18:	89 81       	ldd	r24, Y+1	; 0x01
    2a1a:	88 30       	cpi	r24, 0x08	; 8
    2a1c:	e0 f2       	brcs	.-72     	; 0x29d6 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2a1e:	e9 89       	ldd	r30, Y+17	; 0x11
    2a20:	fa 89       	ldd	r31, Y+18	; 0x12
    2a22:	10 a2       	std	Z+32, r1	; 0x20
    2a24:	03 c0       	rjmp	.+6      	; 0x2a2c <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2a26:	e9 89       	ldd	r30, Y+17	; 0x11
    2a28:	fa 89       	ldd	r31, Y+18	; 0x12
    2a2a:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2a2c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a2e:	85 30       	cpi	r24, 0x05	; 5
    2a30:	10 f0       	brcs	.+4      	; 0x2a36 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2a32:	84 e0       	ldi	r24, 0x04	; 4
    2a34:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    2a36:	e9 89       	ldd	r30, Y+17	; 0x11
    2a38:	fa 89       	ldd	r31, Y+18	; 0x12
    2a3a:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a3c:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2a3e:	89 89       	ldd	r24, Y+17	; 0x11
    2a40:	9a 89       	ldd	r25, Y+18	; 0x12
    2a42:	02 96       	adiw	r24, 0x02	; 2
    2a44:	0e 94 ab 08 	call	0x1156	; 0x1156 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2a48:	89 89       	ldd	r24, Y+17	; 0x11
    2a4a:	9a 89       	ldd	r25, Y+18	; 0x12
    2a4c:	0c 96       	adiw	r24, 0x0c	; 12
    2a4e:	0e 94 ab 08 	call	0x1156	; 0x1156 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2a52:	e9 89       	ldd	r30, Y+17	; 0x11
    2a54:	fa 89       	ldd	r31, Y+18	; 0x12
    2a56:	89 89       	ldd	r24, Y+17	; 0x11
    2a58:	9a 89       	ldd	r25, Y+18	; 0x12
    2a5a:	91 87       	std	Z+9, r25	; 0x09
    2a5c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2a5e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a60:	28 2f       	mov	r18, r24
    2a62:	30 e0       	ldi	r19, 0x00	; 0
    2a64:	85 e0       	ldi	r24, 0x05	; 5
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	82 1b       	sub	r24, r18
    2a6a:	93 0b       	sbc	r25, r19
    2a6c:	e9 89       	ldd	r30, Y+17	; 0x11
    2a6e:	fa 89       	ldd	r31, Y+18	; 0x12
    2a70:	95 87       	std	Z+13, r25	; 0x0d
    2a72:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2a74:	e9 89       	ldd	r30, Y+17	; 0x11
    2a76:	fa 89       	ldd	r31, Y+18	; 0x12
    2a78:	89 89       	ldd	r24, Y+17	; 0x11
    2a7a:	9a 89       	ldd	r25, Y+18	; 0x12
    2a7c:	93 8b       	std	Z+19, r25	; 0x13
    2a7e:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    2a80:	e9 89       	ldd	r30, Y+17	; 0x11
    2a82:	fa 89       	ldd	r31, Y+18	; 0x12
    2a84:	11 a2       	std	Z+33, r1	; 0x21
    2a86:	12 a2       	std	Z+34, r1	; 0x22
    2a88:	13 a2       	std	Z+35, r1	; 0x23
    2a8a:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2a8c:	e9 89       	ldd	r30, Y+17	; 0x11
    2a8e:	fa 89       	ldd	r31, Y+18	; 0x12
    2a90:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2a92:	8a 81       	ldd	r24, Y+2	; 0x02
    2a94:	9b 81       	ldd	r25, Y+3	; 0x03
    2a96:	2c 81       	ldd	r18, Y+4	; 0x04
    2a98:	3d 81       	ldd	r19, Y+5	; 0x05
    2a9a:	4c 85       	ldd	r20, Y+12	; 0x0c
    2a9c:	5d 85       	ldd	r21, Y+13	; 0x0d
    2a9e:	b9 01       	movw	r22, r18
    2aa0:	0e 94 4a 0a 	call	0x1494	; 0x1494 <pxPortInitialiseStack>
    2aa4:	e9 89       	ldd	r30, Y+17	; 0x11
    2aa6:	fa 89       	ldd	r31, Y+18	; 0x12
    2aa8:	91 83       	std	Z+1, r25	; 0x01
    2aaa:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    2aac:	8f 85       	ldd	r24, Y+15	; 0x0f
    2aae:	98 89       	ldd	r25, Y+16	; 0x10
    2ab0:	00 97       	sbiw	r24, 0x00	; 0
    2ab2:	31 f0       	breq	.+12     	; 0x2ac0 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2ab4:	ef 85       	ldd	r30, Y+15	; 0x0f
    2ab6:	f8 89       	ldd	r31, Y+16	; 0x10
    2ab8:	89 89       	ldd	r24, Y+17	; 0x11
    2aba:	9a 89       	ldd	r25, Y+18	; 0x12
    2abc:	91 83       	std	Z+1, r25	; 0x01
    2abe:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2ac0:	64 96       	adiw	r28, 0x14	; 20
    2ac2:	0f b6       	in	r0, 0x3f	; 63
    2ac4:	f8 94       	cli
    2ac6:	de bf       	out	0x3e, r29	; 62
    2ac8:	0f be       	out	0x3f, r0	; 63
    2aca:	cd bf       	out	0x3d, r28	; 61
    2acc:	cf 91       	pop	r28
    2ace:	df 91       	pop	r29
    2ad0:	1f 91       	pop	r17
    2ad2:	0f 91       	pop	r16
    2ad4:	ef 90       	pop	r14
    2ad6:	df 90       	pop	r13
    2ad8:	cf 90       	pop	r12
    2ada:	bf 90       	pop	r11
    2adc:	af 90       	pop	r10
    2ade:	9f 90       	pop	r9
    2ae0:	8f 90       	pop	r8
    2ae2:	08 95       	ret

00002ae4 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    2ae4:	df 93       	push	r29
    2ae6:	cf 93       	push	r28
    2ae8:	00 d0       	rcall	.+0      	; 0x2aea <prvAddNewTaskToReadyList+0x6>
    2aea:	cd b7       	in	r28, 0x3d	; 61
    2aec:	de b7       	in	r29, 0x3e	; 62
    2aee:	9a 83       	std	Y+2, r25	; 0x02
    2af0:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    2af2:	0f b6       	in	r0, 0x3f	; 63
    2af4:	f8 94       	cli
    2af6:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    2af8:	80 91 58 04 	lds	r24, 0x0458
    2afc:	8f 5f       	subi	r24, 0xFF	; 255
    2afe:	80 93 58 04 	sts	0x0458, r24
		if( pxCurrentTCB == NULL )
    2b02:	80 91 55 04 	lds	r24, 0x0455
    2b06:	90 91 56 04 	lds	r25, 0x0456
    2b0a:	00 97       	sbiw	r24, 0x00	; 0
    2b0c:	69 f4       	brne	.+26     	; 0x2b28 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    2b0e:	89 81       	ldd	r24, Y+1	; 0x01
    2b10:	9a 81       	ldd	r25, Y+2	; 0x02
    2b12:	90 93 56 04 	sts	0x0456, r25
    2b16:	80 93 55 04 	sts	0x0455, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2b1a:	80 91 58 04 	lds	r24, 0x0458
    2b1e:	81 30       	cpi	r24, 0x01	; 1
    2b20:	b9 f4       	brne	.+46     	; 0x2b50 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    2b22:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <prvInitialiseTaskLists>
    2b26:	14 c0       	rjmp	.+40     	; 0x2b50 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    2b28:	80 91 5c 04 	lds	r24, 0x045C
    2b2c:	88 23       	and	r24, r24
    2b2e:	81 f4       	brne	.+32     	; 0x2b50 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2b30:	e0 91 55 04 	lds	r30, 0x0455
    2b34:	f0 91 56 04 	lds	r31, 0x0456
    2b38:	96 89       	ldd	r25, Z+22	; 0x16
    2b3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b3e:	86 89       	ldd	r24, Z+22	; 0x16
    2b40:	89 17       	cp	r24, r25
    2b42:	30 f0       	brcs	.+12     	; 0x2b50 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    2b44:	89 81       	ldd	r24, Y+1	; 0x01
    2b46:	9a 81       	ldd	r25, Y+2	; 0x02
    2b48:	90 93 56 04 	sts	0x0456, r25
    2b4c:	80 93 55 04 	sts	0x0455, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    2b50:	80 91 61 04 	lds	r24, 0x0461
    2b54:	8f 5f       	subi	r24, 0xFF	; 255
    2b56:	80 93 61 04 	sts	0x0461, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    2b5a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b5c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b5e:	96 89       	ldd	r25, Z+22	; 0x16
    2b60:	80 91 5b 04 	lds	r24, 0x045B
    2b64:	89 17       	cp	r24, r25
    2b66:	28 f4       	brcc	.+10     	; 0x2b72 <prvAddNewTaskToReadyList+0x8e>
    2b68:	e9 81       	ldd	r30, Y+1	; 0x01
    2b6a:	fa 81       	ldd	r31, Y+2	; 0x02
    2b6c:	86 89       	ldd	r24, Z+22	; 0x16
    2b6e:	80 93 5b 04 	sts	0x045B, r24
    2b72:	e9 81       	ldd	r30, Y+1	; 0x01
    2b74:	fa 81       	ldd	r31, Y+2	; 0x02
    2b76:	86 89       	ldd	r24, Z+22	; 0x16
    2b78:	28 2f       	mov	r18, r24
    2b7a:	30 e0       	ldi	r19, 0x00	; 0
    2b7c:	c9 01       	movw	r24, r18
    2b7e:	88 0f       	add	r24, r24
    2b80:	99 1f       	adc	r25, r25
    2b82:	88 0f       	add	r24, r24
    2b84:	99 1f       	adc	r25, r25
    2b86:	88 0f       	add	r24, r24
    2b88:	99 1f       	adc	r25, r25
    2b8a:	82 0f       	add	r24, r18
    2b8c:	93 1f       	adc	r25, r19
    2b8e:	ac 01       	movw	r20, r24
    2b90:	49 59       	subi	r20, 0x99	; 153
    2b92:	5b 4f       	sbci	r21, 0xFB	; 251
    2b94:	89 81       	ldd	r24, Y+1	; 0x01
    2b96:	9a 81       	ldd	r25, Y+2	; 0x02
    2b98:	9c 01       	movw	r18, r24
    2b9a:	2e 5f       	subi	r18, 0xFE	; 254
    2b9c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b9e:	ca 01       	movw	r24, r20
    2ba0:	b9 01       	movw	r22, r18
    2ba2:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    2ba6:	0f 90       	pop	r0
    2ba8:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    2baa:	80 91 5c 04 	lds	r24, 0x045C
    2bae:	88 23       	and	r24, r24
    2bb0:	61 f0       	breq	.+24     	; 0x2bca <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    2bb2:	e0 91 55 04 	lds	r30, 0x0455
    2bb6:	f0 91 56 04 	lds	r31, 0x0456
    2bba:	96 89       	ldd	r25, Z+22	; 0x16
    2bbc:	e9 81       	ldd	r30, Y+1	; 0x01
    2bbe:	fa 81       	ldd	r31, Y+2	; 0x02
    2bc0:	86 89       	ldd	r24, Z+22	; 0x16
    2bc2:	98 17       	cp	r25, r24
    2bc4:	10 f4       	brcc	.+4      	; 0x2bca <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    2bc6:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2bca:	0f 90       	pop	r0
    2bcc:	0f 90       	pop	r0
    2bce:	cf 91       	pop	r28
    2bd0:	df 91       	pop	r29
    2bd2:	08 95       	ret

00002bd4 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    2bd4:	df 93       	push	r29
    2bd6:	cf 93       	push	r28
    2bd8:	00 d0       	rcall	.+0      	; 0x2bda <vTaskDelete+0x6>
    2bda:	00 d0       	rcall	.+0      	; 0x2bdc <vTaskDelete+0x8>
    2bdc:	00 d0       	rcall	.+0      	; 0x2bde <vTaskDelete+0xa>
    2bde:	cd b7       	in	r28, 0x3d	; 61
    2be0:	de b7       	in	r29, 0x3e	; 62
    2be2:	9c 83       	std	Y+4, r25	; 0x04
    2be4:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2be6:	0f b6       	in	r0, 0x3f	; 63
    2be8:	f8 94       	cli
    2bea:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2bec:	8b 81       	ldd	r24, Y+3	; 0x03
    2bee:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf0:	00 97       	sbiw	r24, 0x00	; 0
    2bf2:	39 f4       	brne	.+14     	; 0x2c02 <vTaskDelete+0x2e>
    2bf4:	80 91 55 04 	lds	r24, 0x0455
    2bf8:	90 91 56 04 	lds	r25, 0x0456
    2bfc:	9e 83       	std	Y+6, r25	; 0x06
    2bfe:	8d 83       	std	Y+5, r24	; 0x05
    2c00:	04 c0       	rjmp	.+8      	; 0x2c0a <vTaskDelete+0x36>
    2c02:	8b 81       	ldd	r24, Y+3	; 0x03
    2c04:	9c 81       	ldd	r25, Y+4	; 0x04
    2c06:	9e 83       	std	Y+6, r25	; 0x06
    2c08:	8d 83       	std	Y+5, r24	; 0x05
    2c0a:	8d 81       	ldd	r24, Y+5	; 0x05
    2c0c:	9e 81       	ldd	r25, Y+6	; 0x06
    2c0e:	9a 83       	std	Y+2, r25	; 0x02
    2c10:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2c12:	89 81       	ldd	r24, Y+1	; 0x01
    2c14:	9a 81       	ldd	r25, Y+2	; 0x02
    2c16:	02 96       	adiw	r24, 0x02	; 2
    2c18:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2c1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2c1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2c20:	84 89       	ldd	r24, Z+20	; 0x14
    2c22:	95 89       	ldd	r25, Z+21	; 0x15
    2c24:	00 97       	sbiw	r24, 0x00	; 0
    2c26:	29 f0       	breq	.+10     	; 0x2c32 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2c28:	89 81       	ldd	r24, Y+1	; 0x01
    2c2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c2c:	0c 96       	adiw	r24, 0x0c	; 12
    2c2e:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    2c32:	80 91 61 04 	lds	r24, 0x0461
    2c36:	8f 5f       	subi	r24, 0xFF	; 255
    2c38:	80 93 61 04 	sts	0x0461, r24

			if( pxTCB == pxCurrentTCB )
    2c3c:	20 91 55 04 	lds	r18, 0x0455
    2c40:	30 91 56 04 	lds	r19, 0x0456
    2c44:	89 81       	ldd	r24, Y+1	; 0x01
    2c46:	9a 81       	ldd	r25, Y+2	; 0x02
    2c48:	82 17       	cp	r24, r18
    2c4a:	93 07       	cpc	r25, r19
    2c4c:	81 f4       	brne	.+32     	; 0x2c6e <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2c4e:	89 81       	ldd	r24, Y+1	; 0x01
    2c50:	9a 81       	ldd	r25, Y+2	; 0x02
    2c52:	9c 01       	movw	r18, r24
    2c54:	2e 5f       	subi	r18, 0xFE	; 254
    2c56:	3f 4f       	sbci	r19, 0xFF	; 255
    2c58:	83 eb       	ldi	r24, 0xB3	; 179
    2c5a:	94 e0       	ldi	r25, 0x04	; 4
    2c5c:	b9 01       	movw	r22, r18
    2c5e:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    2c62:	80 91 57 04 	lds	r24, 0x0457
    2c66:	8f 5f       	subi	r24, 0xFF	; 255
    2c68:	80 93 57 04 	sts	0x0457, r24
    2c6c:	0b c0       	rjmp	.+22     	; 0x2c84 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    2c6e:	80 91 58 04 	lds	r24, 0x0458
    2c72:	81 50       	subi	r24, 0x01	; 1
    2c74:	80 93 58 04 	sts	0x0458, r24
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
    2c78:	89 81       	ldd	r24, Y+1	; 0x01
    2c7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c7c:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    2c80:	0e 94 8f 1e 	call	0x3d1e	; 0x3d1e <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
    2c84:	0f 90       	pop	r0
    2c86:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2c88:	80 91 5c 04 	lds	r24, 0x045C
    2c8c:	88 23       	and	r24, r24
    2c8e:	59 f0       	breq	.+22     	; 0x2ca6 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    2c90:	20 91 55 04 	lds	r18, 0x0455
    2c94:	30 91 56 04 	lds	r19, 0x0456
    2c98:	89 81       	ldd	r24, Y+1	; 0x01
    2c9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c9c:	82 17       	cp	r24, r18
    2c9e:	93 07       	cpc	r25, r19
    2ca0:	11 f4       	brne	.+4      	; 0x2ca6 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2ca2:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2ca6:	26 96       	adiw	r28, 0x06	; 6
    2ca8:	0f b6       	in	r0, 0x3f	; 63
    2caa:	f8 94       	cli
    2cac:	de bf       	out	0x3e, r29	; 62
    2cae:	0f be       	out	0x3f, r0	; 63
    2cb0:	cd bf       	out	0x3d, r28	; 61
    2cb2:	cf 91       	pop	r28
    2cb4:	df 91       	pop	r29
    2cb6:	08 95       	ret

00002cb8 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2cb8:	df 93       	push	r29
    2cba:	cf 93       	push	r28
    2cbc:	cd b7       	in	r28, 0x3d	; 61
    2cbe:	de b7       	in	r29, 0x3e	; 62
    2cc0:	2a 97       	sbiw	r28, 0x0a	; 10
    2cc2:	0f b6       	in	r0, 0x3f	; 63
    2cc4:	f8 94       	cli
    2cc6:	de bf       	out	0x3e, r29	; 62
    2cc8:	0f be       	out	0x3f, r0	; 63
    2cca:	cd bf       	out	0x3d, r28	; 61
    2ccc:	98 87       	std	Y+8, r25	; 0x08
    2cce:	8f 83       	std	Y+7, r24	; 0x07
    2cd0:	7a 87       	std	Y+10, r23	; 0x0a
    2cd2:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2cd4:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2cd6:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2cda:	80 91 59 04 	lds	r24, 0x0459
    2cde:	90 91 5a 04 	lds	r25, 0x045A
    2ce2:	9a 83       	std	Y+2, r25	; 0x02
    2ce4:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2ce6:	ef 81       	ldd	r30, Y+7	; 0x07
    2ce8:	f8 85       	ldd	r31, Y+8	; 0x08
    2cea:	20 81       	ld	r18, Z
    2cec:	31 81       	ldd	r19, Z+1	; 0x01
    2cee:	89 85       	ldd	r24, Y+9	; 0x09
    2cf0:	9a 85       	ldd	r25, Y+10	; 0x0a
    2cf2:	82 0f       	add	r24, r18
    2cf4:	93 1f       	adc	r25, r19
    2cf6:	9e 83       	std	Y+6, r25	; 0x06
    2cf8:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2cfa:	ef 81       	ldd	r30, Y+7	; 0x07
    2cfc:	f8 85       	ldd	r31, Y+8	; 0x08
    2cfe:	20 81       	ld	r18, Z
    2d00:	31 81       	ldd	r19, Z+1	; 0x01
    2d02:	89 81       	ldd	r24, Y+1	; 0x01
    2d04:	9a 81       	ldd	r25, Y+2	; 0x02
    2d06:	82 17       	cp	r24, r18
    2d08:	93 07       	cpc	r25, r19
    2d0a:	98 f4       	brcc	.+38     	; 0x2d32 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2d0c:	ef 81       	ldd	r30, Y+7	; 0x07
    2d0e:	f8 85       	ldd	r31, Y+8	; 0x08
    2d10:	20 81       	ld	r18, Z
    2d12:	31 81       	ldd	r19, Z+1	; 0x01
    2d14:	8d 81       	ldd	r24, Y+5	; 0x05
    2d16:	9e 81       	ldd	r25, Y+6	; 0x06
    2d18:	82 17       	cp	r24, r18
    2d1a:	93 07       	cpc	r25, r19
    2d1c:	e0 f4       	brcc	.+56     	; 0x2d56 <vTaskDelayUntil+0x9e>
    2d1e:	2d 81       	ldd	r18, Y+5	; 0x05
    2d20:	3e 81       	ldd	r19, Y+6	; 0x06
    2d22:	89 81       	ldd	r24, Y+1	; 0x01
    2d24:	9a 81       	ldd	r25, Y+2	; 0x02
    2d26:	82 17       	cp	r24, r18
    2d28:	93 07       	cpc	r25, r19
    2d2a:	a8 f4       	brcc	.+42     	; 0x2d56 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2d2c:	81 e0       	ldi	r24, 0x01	; 1
    2d2e:	8b 83       	std	Y+3, r24	; 0x03
    2d30:	12 c0       	rjmp	.+36     	; 0x2d56 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2d32:	ef 81       	ldd	r30, Y+7	; 0x07
    2d34:	f8 85       	ldd	r31, Y+8	; 0x08
    2d36:	20 81       	ld	r18, Z
    2d38:	31 81       	ldd	r19, Z+1	; 0x01
    2d3a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d3c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d3e:	82 17       	cp	r24, r18
    2d40:	93 07       	cpc	r25, r19
    2d42:	38 f0       	brcs	.+14     	; 0x2d52 <vTaskDelayUntil+0x9a>
    2d44:	2d 81       	ldd	r18, Y+5	; 0x05
    2d46:	3e 81       	ldd	r19, Y+6	; 0x06
    2d48:	89 81       	ldd	r24, Y+1	; 0x01
    2d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d4c:	82 17       	cp	r24, r18
    2d4e:	93 07       	cpc	r25, r19
    2d50:	10 f4       	brcc	.+4      	; 0x2d56 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2d52:	81 e0       	ldi	r24, 0x01	; 1
    2d54:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2d56:	ef 81       	ldd	r30, Y+7	; 0x07
    2d58:	f8 85       	ldd	r31, Y+8	; 0x08
    2d5a:	8d 81       	ldd	r24, Y+5	; 0x05
    2d5c:	9e 81       	ldd	r25, Y+6	; 0x06
    2d5e:	91 83       	std	Z+1, r25	; 0x01
    2d60:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2d62:	8b 81       	ldd	r24, Y+3	; 0x03
    2d64:	88 23       	and	r24, r24
    2d66:	49 f0       	breq	.+18     	; 0x2d7a <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2d68:	8d 81       	ldd	r24, Y+5	; 0x05
    2d6a:	9e 81       	ldd	r25, Y+6	; 0x06
    2d6c:	29 81       	ldd	r18, Y+1	; 0x01
    2d6e:	3a 81       	ldd	r19, Y+2	; 0x02
    2d70:	82 1b       	sub	r24, r18
    2d72:	93 0b       	sbc	r25, r19
    2d74:	60 e0       	ldi	r22, 0x00	; 0
    2d76:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2d7a:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    2d7e:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2d80:	8c 81       	ldd	r24, Y+4	; 0x04
    2d82:	88 23       	and	r24, r24
    2d84:	11 f4       	brne	.+4      	; 0x2d8a <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    2d86:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2d8a:	2a 96       	adiw	r28, 0x0a	; 10
    2d8c:	0f b6       	in	r0, 0x3f	; 63
    2d8e:	f8 94       	cli
    2d90:	de bf       	out	0x3e, r29	; 62
    2d92:	0f be       	out	0x3f, r0	; 63
    2d94:	cd bf       	out	0x3d, r28	; 61
    2d96:	cf 91       	pop	r28
    2d98:	df 91       	pop	r29
    2d9a:	08 95       	ret

00002d9c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2d9c:	df 93       	push	r29
    2d9e:	cf 93       	push	r28
    2da0:	00 d0       	rcall	.+0      	; 0x2da2 <vTaskDelay+0x6>
    2da2:	0f 92       	push	r0
    2da4:	cd b7       	in	r28, 0x3d	; 61
    2da6:	de b7       	in	r29, 0x3e	; 62
    2da8:	9b 83       	std	Y+3, r25	; 0x03
    2daa:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    2dac:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2dae:	8a 81       	ldd	r24, Y+2	; 0x02
    2db0:	9b 81       	ldd	r25, Y+3	; 0x03
    2db2:	00 97       	sbiw	r24, 0x00	; 0
    2db4:	51 f0       	breq	.+20     	; 0x2dca <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    2db6:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2dba:	8a 81       	ldd	r24, Y+2	; 0x02
    2dbc:	9b 81       	ldd	r25, Y+3	; 0x03
    2dbe:	60 e0       	ldi	r22, 0x00	; 0
    2dc0:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2dc4:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    2dc8:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2dca:	89 81       	ldd	r24, Y+1	; 0x01
    2dcc:	88 23       	and	r24, r24
    2dce:	11 f4       	brne	.+4      	; 0x2dd4 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    2dd0:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2dd4:	0f 90       	pop	r0
    2dd6:	0f 90       	pop	r0
    2dd8:	0f 90       	pop	r0
    2dda:	cf 91       	pop	r28
    2ddc:	df 91       	pop	r29
    2dde:	08 95       	ret

00002de0 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
    2de0:	df 93       	push	r29
    2de2:	cf 93       	push	r28
    2de4:	cd b7       	in	r28, 0x3d	; 61
    2de6:	de b7       	in	r29, 0x3e	; 62
    2de8:	27 97       	sbiw	r28, 0x07	; 7
    2dea:	0f b6       	in	r0, 0x3f	; 63
    2dec:	f8 94       	cli
    2dee:	de bf       	out	0x3e, r29	; 62
    2df0:	0f be       	out	0x3f, r0	; 63
    2df2:	cd bf       	out	0x3d, r28	; 61
    2df4:	9d 83       	std	Y+5, r25	; 0x05
    2df6:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    2df8:	0f b6       	in	r0, 0x3f	; 63
    2dfa:	f8 94       	cli
    2dfc:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    2dfe:	8c 81       	ldd	r24, Y+4	; 0x04
    2e00:	9d 81       	ldd	r25, Y+5	; 0x05
    2e02:	00 97       	sbiw	r24, 0x00	; 0
    2e04:	39 f4       	brne	.+14     	; 0x2e14 <uxTaskPriorityGet+0x34>
    2e06:	80 91 55 04 	lds	r24, 0x0455
    2e0a:	90 91 56 04 	lds	r25, 0x0456
    2e0e:	9f 83       	std	Y+7, r25	; 0x07
    2e10:	8e 83       	std	Y+6, r24	; 0x06
    2e12:	04 c0       	rjmp	.+8      	; 0x2e1c <uxTaskPriorityGet+0x3c>
    2e14:	8c 81       	ldd	r24, Y+4	; 0x04
    2e16:	9d 81       	ldd	r25, Y+5	; 0x05
    2e18:	9f 83       	std	Y+7, r25	; 0x07
    2e1a:	8e 83       	std	Y+6, r24	; 0x06
    2e1c:	8e 81       	ldd	r24, Y+6	; 0x06
    2e1e:	9f 81       	ldd	r25, Y+7	; 0x07
    2e20:	9b 83       	std	Y+3, r25	; 0x03
    2e22:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    2e24:	ea 81       	ldd	r30, Y+2	; 0x02
    2e26:	fb 81       	ldd	r31, Y+3	; 0x03
    2e28:	86 89       	ldd	r24, Z+22	; 0x16
    2e2a:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    2e2c:	0f 90       	pop	r0
    2e2e:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    2e30:	89 81       	ldd	r24, Y+1	; 0x01
	}
    2e32:	27 96       	adiw	r28, 0x07	; 7
    2e34:	0f b6       	in	r0, 0x3f	; 63
    2e36:	f8 94       	cli
    2e38:	de bf       	out	0x3e, r29	; 62
    2e3a:	0f be       	out	0x3f, r0	; 63
    2e3c:	cd bf       	out	0x3d, r28	; 61
    2e3e:	cf 91       	pop	r28
    2e40:	df 91       	pop	r29
    2e42:	08 95       	ret

00002e44 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
    2e44:	df 93       	push	r29
    2e46:	cf 93       	push	r28
    2e48:	cd b7       	in	r28, 0x3d	; 61
    2e4a:	de b7       	in	r29, 0x3e	; 62
    2e4c:	28 97       	sbiw	r28, 0x08	; 8
    2e4e:	0f b6       	in	r0, 0x3f	; 63
    2e50:	f8 94       	cli
    2e52:	de bf       	out	0x3e, r29	; 62
    2e54:	0f be       	out	0x3f, r0	; 63
    2e56:	cd bf       	out	0x3d, r28	; 61
    2e58:	9e 83       	std	Y+6, r25	; 0x06
    2e5a:	8d 83       	std	Y+5, r24	; 0x05
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    2e5c:	19 82       	std	Y+1, r1	; 0x01
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    2e5e:	8d 81       	ldd	r24, Y+5	; 0x05
    2e60:	9e 81       	ldd	r25, Y+6	; 0x06
    2e62:	00 97       	sbiw	r24, 0x00	; 0
    2e64:	39 f4       	brne	.+14     	; 0x2e74 <uxTaskPriorityGetFromISR+0x30>
    2e66:	80 91 55 04 	lds	r24, 0x0455
    2e6a:	90 91 56 04 	lds	r25, 0x0456
    2e6e:	98 87       	std	Y+8, r25	; 0x08
    2e70:	8f 83       	std	Y+7, r24	; 0x07
    2e72:	04 c0       	rjmp	.+8      	; 0x2e7c <uxTaskPriorityGetFromISR+0x38>
    2e74:	8d 81       	ldd	r24, Y+5	; 0x05
    2e76:	9e 81       	ldd	r25, Y+6	; 0x06
    2e78:	98 87       	std	Y+8, r25	; 0x08
    2e7a:	8f 83       	std	Y+7, r24	; 0x07
    2e7c:	8f 81       	ldd	r24, Y+7	; 0x07
    2e7e:	98 85       	ldd	r25, Y+8	; 0x08
    2e80:	9c 83       	std	Y+4, r25	; 0x04
    2e82:	8b 83       	std	Y+3, r24	; 0x03
			uxReturn = pxTCB->uxPriority;
    2e84:	eb 81       	ldd	r30, Y+3	; 0x03
    2e86:	fc 81       	ldd	r31, Y+4	; 0x04
    2e88:	86 89       	ldd	r24, Z+22	; 0x16
    2e8a:	8a 83       	std	Y+2, r24	; 0x02
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    2e8c:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    2e8e:	28 96       	adiw	r28, 0x08	; 8
    2e90:	0f b6       	in	r0, 0x3f	; 63
    2e92:	f8 94       	cli
    2e94:	de bf       	out	0x3e, r29	; 62
    2e96:	0f be       	out	0x3f, r0	; 63
    2e98:	cd bf       	out	0x3d, r28	; 61
    2e9a:	cf 91       	pop	r28
    2e9c:	df 91       	pop	r29
    2e9e:	08 95       	ret

00002ea0 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    2ea0:	df 93       	push	r29
    2ea2:	cf 93       	push	r28
    2ea4:	cd b7       	in	r28, 0x3d	; 61
    2ea6:	de b7       	in	r29, 0x3e	; 62
    2ea8:	2a 97       	sbiw	r28, 0x0a	; 10
    2eaa:	0f b6       	in	r0, 0x3f	; 63
    2eac:	f8 94       	cli
    2eae:	de bf       	out	0x3e, r29	; 62
    2eb0:	0f be       	out	0x3f, r0	; 63
    2eb2:	cd bf       	out	0x3d, r28	; 61
    2eb4:	9f 83       	std	Y+7, r25	; 0x07
    2eb6:	8e 83       	std	Y+6, r24	; 0x06
    2eb8:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    2eba:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2ebc:	88 85       	ldd	r24, Y+8	; 0x08
    2ebe:	85 30       	cpi	r24, 0x05	; 5
    2ec0:	10 f0       	brcs	.+4      	; 0x2ec6 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2ec2:	84 e0       	ldi	r24, 0x04	; 4
    2ec4:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    2ec6:	0f b6       	in	r0, 0x3f	; 63
    2ec8:	f8 94       	cli
    2eca:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    2ecc:	8e 81       	ldd	r24, Y+6	; 0x06
    2ece:	9f 81       	ldd	r25, Y+7	; 0x07
    2ed0:	00 97       	sbiw	r24, 0x00	; 0
    2ed2:	39 f4       	brne	.+14     	; 0x2ee2 <vTaskPrioritySet+0x42>
    2ed4:	80 91 55 04 	lds	r24, 0x0455
    2ed8:	90 91 56 04 	lds	r25, 0x0456
    2edc:	9a 87       	std	Y+10, r25	; 0x0a
    2ede:	89 87       	std	Y+9, r24	; 0x09
    2ee0:	04 c0       	rjmp	.+8      	; 0x2eea <vTaskPrioritySet+0x4a>
    2ee2:	8e 81       	ldd	r24, Y+6	; 0x06
    2ee4:	9f 81       	ldd	r25, Y+7	; 0x07
    2ee6:	9a 87       	std	Y+10, r25	; 0x0a
    2ee8:	89 87       	std	Y+9, r24	; 0x09
    2eea:	89 85       	ldd	r24, Y+9	; 0x09
    2eec:	9a 85       	ldd	r25, Y+10	; 0x0a
    2eee:	9d 83       	std	Y+5, r25	; 0x05
    2ef0:	8c 83       	std	Y+4, r24	; 0x04
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
    2ef2:	ec 81       	ldd	r30, Y+4	; 0x04
    2ef4:	fd 81       	ldd	r31, Y+5	; 0x05
    2ef6:	86 89       	ldd	r24, Z+22	; 0x16
    2ef8:	8b 83       	std	Y+3, r24	; 0x03
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    2efa:	9b 81       	ldd	r25, Y+3	; 0x03
    2efc:	88 85       	ldd	r24, Y+8	; 0x08
    2efe:	98 17       	cp	r25, r24
    2f00:	09 f4       	brne	.+2      	; 0x2f04 <vTaskPrioritySet+0x64>
    2f02:	81 c0       	rjmp	.+258    	; 0x3006 <vTaskPrioritySet+0x166>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    2f04:	98 85       	ldd	r25, Y+8	; 0x08
    2f06:	8b 81       	ldd	r24, Y+3	; 0x03
    2f08:	89 17       	cp	r24, r25
    2f0a:	a0 f4       	brcc	.+40     	; 0x2f34 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    2f0c:	20 91 55 04 	lds	r18, 0x0455
    2f10:	30 91 56 04 	lds	r19, 0x0456
    2f14:	8c 81       	ldd	r24, Y+4	; 0x04
    2f16:	9d 81       	ldd	r25, Y+5	; 0x05
    2f18:	82 17       	cp	r24, r18
    2f1a:	93 07       	cpc	r25, r19
    2f1c:	b1 f0       	breq	.+44     	; 0x2f4a <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    2f1e:	e0 91 55 04 	lds	r30, 0x0455
    2f22:	f0 91 56 04 	lds	r31, 0x0456
    2f26:	96 89       	ldd	r25, Z+22	; 0x16
    2f28:	88 85       	ldd	r24, Y+8	; 0x08
    2f2a:	89 17       	cp	r24, r25
    2f2c:	70 f0       	brcs	.+28     	; 0x2f4a <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    2f2e:	81 e0       	ldi	r24, 0x01	; 1
    2f30:	89 83       	std	Y+1, r24	; 0x01
    2f32:	0b c0       	rjmp	.+22     	; 0x2f4a <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    2f34:	20 91 55 04 	lds	r18, 0x0455
    2f38:	30 91 56 04 	lds	r19, 0x0456
    2f3c:	8c 81       	ldd	r24, Y+4	; 0x04
    2f3e:	9d 81       	ldd	r25, Y+5	; 0x05
    2f40:	82 17       	cp	r24, r18
    2f42:	93 07       	cpc	r25, r19
    2f44:	11 f4       	brne	.+4      	; 0x2f4a <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    2f46:	81 e0       	ldi	r24, 0x01	; 1
    2f48:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    2f4a:	ec 81       	ldd	r30, Y+4	; 0x04
    2f4c:	fd 81       	ldd	r31, Y+5	; 0x05
    2f4e:	86 89       	ldd	r24, Z+22	; 0x16
    2f50:	8a 83       	std	Y+2, r24	; 0x02
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    2f52:	ec 81       	ldd	r30, Y+4	; 0x04
    2f54:	fd 81       	ldd	r31, Y+5	; 0x05
    2f56:	88 85       	ldd	r24, Y+8	; 0x08
    2f58:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    2f5a:	ec 81       	ldd	r30, Y+4	; 0x04
    2f5c:	fd 81       	ldd	r31, Y+5	; 0x05
    2f5e:	84 85       	ldd	r24, Z+12	; 0x0c
    2f60:	95 85       	ldd	r25, Z+13	; 0x0d
    2f62:	99 23       	and	r25, r25
    2f64:	5c f0       	brlt	.+22     	; 0x2f7c <vTaskPrioritySet+0xdc>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2f66:	88 85       	ldd	r24, Y+8	; 0x08
    2f68:	28 2f       	mov	r18, r24
    2f6a:	30 e0       	ldi	r19, 0x00	; 0
    2f6c:	85 e0       	ldi	r24, 0x05	; 5
    2f6e:	90 e0       	ldi	r25, 0x00	; 0
    2f70:	82 1b       	sub	r24, r18
    2f72:	93 0b       	sbc	r25, r19
    2f74:	ec 81       	ldd	r30, Y+4	; 0x04
    2f76:	fd 81       	ldd	r31, Y+5	; 0x05
    2f78:	95 87       	std	Z+13, r25	; 0x0d
    2f7a:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    2f7c:	ec 81       	ldd	r30, Y+4	; 0x04
    2f7e:	fd 81       	ldd	r31, Y+5	; 0x05
    2f80:	42 85       	ldd	r20, Z+10	; 0x0a
    2f82:	53 85       	ldd	r21, Z+11	; 0x0b
    2f84:	8a 81       	ldd	r24, Y+2	; 0x02
    2f86:	28 2f       	mov	r18, r24
    2f88:	30 e0       	ldi	r19, 0x00	; 0
    2f8a:	c9 01       	movw	r24, r18
    2f8c:	88 0f       	add	r24, r24
    2f8e:	99 1f       	adc	r25, r25
    2f90:	88 0f       	add	r24, r24
    2f92:	99 1f       	adc	r25, r25
    2f94:	88 0f       	add	r24, r24
    2f96:	99 1f       	adc	r25, r25
    2f98:	82 0f       	add	r24, r18
    2f9a:	93 1f       	adc	r25, r19
    2f9c:	89 59       	subi	r24, 0x99	; 153
    2f9e:	9b 4f       	sbci	r25, 0xFB	; 251
    2fa0:	48 17       	cp	r20, r24
    2fa2:	59 07       	cpc	r21, r25
    2fa4:	59 f5       	brne	.+86     	; 0x2ffc <vTaskPrioritySet+0x15c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2fa6:	8c 81       	ldd	r24, Y+4	; 0x04
    2fa8:	9d 81       	ldd	r25, Y+5	; 0x05
    2faa:	02 96       	adiw	r24, 0x02	; 2
    2fac:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    2fb0:	ec 81       	ldd	r30, Y+4	; 0x04
    2fb2:	fd 81       	ldd	r31, Y+5	; 0x05
    2fb4:	96 89       	ldd	r25, Z+22	; 0x16
    2fb6:	80 91 5b 04 	lds	r24, 0x045B
    2fba:	89 17       	cp	r24, r25
    2fbc:	28 f4       	brcc	.+10     	; 0x2fc8 <vTaskPrioritySet+0x128>
    2fbe:	ec 81       	ldd	r30, Y+4	; 0x04
    2fc0:	fd 81       	ldd	r31, Y+5	; 0x05
    2fc2:	86 89       	ldd	r24, Z+22	; 0x16
    2fc4:	80 93 5b 04 	sts	0x045B, r24
    2fc8:	ec 81       	ldd	r30, Y+4	; 0x04
    2fca:	fd 81       	ldd	r31, Y+5	; 0x05
    2fcc:	86 89       	ldd	r24, Z+22	; 0x16
    2fce:	28 2f       	mov	r18, r24
    2fd0:	30 e0       	ldi	r19, 0x00	; 0
    2fd2:	c9 01       	movw	r24, r18
    2fd4:	88 0f       	add	r24, r24
    2fd6:	99 1f       	adc	r25, r25
    2fd8:	88 0f       	add	r24, r24
    2fda:	99 1f       	adc	r25, r25
    2fdc:	88 0f       	add	r24, r24
    2fde:	99 1f       	adc	r25, r25
    2fe0:	82 0f       	add	r24, r18
    2fe2:	93 1f       	adc	r25, r19
    2fe4:	ac 01       	movw	r20, r24
    2fe6:	49 59       	subi	r20, 0x99	; 153
    2fe8:	5b 4f       	sbci	r21, 0xFB	; 251
    2fea:	8c 81       	ldd	r24, Y+4	; 0x04
    2fec:	9d 81       	ldd	r25, Y+5	; 0x05
    2fee:	9c 01       	movw	r18, r24
    2ff0:	2e 5f       	subi	r18, 0xFE	; 254
    2ff2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ff4:	ca 01       	movw	r24, r20
    2ff6:	b9 01       	movw	r22, r18
    2ff8:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    2ffc:	89 81       	ldd	r24, Y+1	; 0x01
    2ffe:	88 23       	and	r24, r24
    3000:	11 f0       	breq	.+4      	; 0x3006 <vTaskPrioritySet+0x166>
				{
					taskYIELD_IF_USING_PREEMPTION();
    3002:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    3006:	0f 90       	pop	r0
    3008:	0f be       	out	0x3f, r0	; 63
	}
    300a:	2a 96       	adiw	r28, 0x0a	; 10
    300c:	0f b6       	in	r0, 0x3f	; 63
    300e:	f8 94       	cli
    3010:	de bf       	out	0x3e, r29	; 62
    3012:	0f be       	out	0x3f, r0	; 63
    3014:	cd bf       	out	0x3d, r28	; 61
    3016:	cf 91       	pop	r28
    3018:	df 91       	pop	r29
    301a:	08 95       	ret

0000301c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    301c:	df 93       	push	r29
    301e:	cf 93       	push	r28
    3020:	00 d0       	rcall	.+0      	; 0x3022 <vTaskSuspend+0x6>
    3022:	00 d0       	rcall	.+0      	; 0x3024 <vTaskSuspend+0x8>
    3024:	00 d0       	rcall	.+0      	; 0x3026 <vTaskSuspend+0xa>
    3026:	cd b7       	in	r28, 0x3d	; 61
    3028:	de b7       	in	r29, 0x3e	; 62
    302a:	9c 83       	std	Y+4, r25	; 0x04
    302c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    302e:	0f b6       	in	r0, 0x3f	; 63
    3030:	f8 94       	cli
    3032:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    3034:	8b 81       	ldd	r24, Y+3	; 0x03
    3036:	9c 81       	ldd	r25, Y+4	; 0x04
    3038:	00 97       	sbiw	r24, 0x00	; 0
    303a:	39 f4       	brne	.+14     	; 0x304a <vTaskSuspend+0x2e>
    303c:	80 91 55 04 	lds	r24, 0x0455
    3040:	90 91 56 04 	lds	r25, 0x0456
    3044:	9e 83       	std	Y+6, r25	; 0x06
    3046:	8d 83       	std	Y+5, r24	; 0x05
    3048:	04 c0       	rjmp	.+8      	; 0x3052 <vTaskSuspend+0x36>
    304a:	8b 81       	ldd	r24, Y+3	; 0x03
    304c:	9c 81       	ldd	r25, Y+4	; 0x04
    304e:	9e 83       	std	Y+6, r25	; 0x06
    3050:	8d 83       	std	Y+5, r24	; 0x05
    3052:	8d 81       	ldd	r24, Y+5	; 0x05
    3054:	9e 81       	ldd	r25, Y+6	; 0x06
    3056:	9a 83       	std	Y+2, r25	; 0x02
    3058:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    305a:	89 81       	ldd	r24, Y+1	; 0x01
    305c:	9a 81       	ldd	r25, Y+2	; 0x02
    305e:	02 96       	adiw	r24, 0x02	; 2
    3060:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3064:	e9 81       	ldd	r30, Y+1	; 0x01
    3066:	fa 81       	ldd	r31, Y+2	; 0x02
    3068:	84 89       	ldd	r24, Z+20	; 0x14
    306a:	95 89       	ldd	r25, Z+21	; 0x15
    306c:	00 97       	sbiw	r24, 0x00	; 0
    306e:	29 f0       	breq	.+10     	; 0x307a <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3070:	89 81       	ldd	r24, Y+1	; 0x01
    3072:	9a 81       	ldd	r25, Y+2	; 0x02
    3074:	0c 96       	adiw	r24, 0x0c	; 12
    3076:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    307a:	89 81       	ldd	r24, Y+1	; 0x01
    307c:	9a 81       	ldd	r25, Y+2	; 0x02
    307e:	9c 01       	movw	r18, r24
    3080:	2e 5f       	subi	r18, 0xFE	; 254
    3082:	3f 4f       	sbci	r19, 0xFF	; 255
    3084:	8c eb       	ldi	r24, 0xBC	; 188
    3086:	94 e0       	ldi	r25, 0x04	; 4
    3088:	b9 01       	movw	r22, r18
    308a:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    308e:	e9 81       	ldd	r30, Y+1	; 0x01
    3090:	fa 81       	ldd	r31, Y+2	; 0x02
    3092:	85 a1       	ldd	r24, Z+37	; 0x25
    3094:	81 30       	cpi	r24, 0x01	; 1
    3096:	19 f4       	brne	.+6      	; 0x309e <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3098:	e9 81       	ldd	r30, Y+1	; 0x01
    309a:	fa 81       	ldd	r31, Y+2	; 0x02
    309c:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    309e:	0f 90       	pop	r0
    30a0:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    30a2:	80 91 5c 04 	lds	r24, 0x045C
    30a6:	88 23       	and	r24, r24
    30a8:	39 f0       	breq	.+14     	; 0x30b8 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    30aa:	0f b6       	in	r0, 0x3f	; 63
    30ac:	f8 94       	cli
    30ae:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    30b0:	0e 94 8f 1e 	call	0x3d1e	; 0x3d1e <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    30b4:	0f 90       	pop	r0
    30b6:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    30b8:	20 91 55 04 	lds	r18, 0x0455
    30bc:	30 91 56 04 	lds	r19, 0x0456
    30c0:	89 81       	ldd	r24, Y+1	; 0x01
    30c2:	9a 81       	ldd	r25, Y+2	; 0x02
    30c4:	82 17       	cp	r24, r18
    30c6:	93 07       	cpc	r25, r19
    30c8:	a1 f4       	brne	.+40     	; 0x30f2 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    30ca:	80 91 5c 04 	lds	r24, 0x045C
    30ce:	88 23       	and	r24, r24
    30d0:	19 f0       	breq	.+6      	; 0x30d8 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    30d2:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
    30d6:	0d c0       	rjmp	.+26     	; 0x30f2 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    30d8:	90 91 bc 04 	lds	r25, 0x04BC
    30dc:	80 91 58 04 	lds	r24, 0x0458
    30e0:	98 17       	cp	r25, r24
    30e2:	29 f4       	brne	.+10     	; 0x30ee <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    30e4:	10 92 56 04 	sts	0x0456, r1
    30e8:	10 92 55 04 	sts	0x0455, r1
    30ec:	02 c0       	rjmp	.+4      	; 0x30f2 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    30ee:	0e 94 ca 1b 	call	0x3794	; 0x3794 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    30f2:	26 96       	adiw	r28, 0x06	; 6
    30f4:	0f b6       	in	r0, 0x3f	; 63
    30f6:	f8 94       	cli
    30f8:	de bf       	out	0x3e, r29	; 62
    30fa:	0f be       	out	0x3f, r0	; 63
    30fc:	cd bf       	out	0x3d, r28	; 61
    30fe:	cf 91       	pop	r28
    3100:	df 91       	pop	r29
    3102:	08 95       	ret

00003104 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    3104:	df 93       	push	r29
    3106:	cf 93       	push	r28
    3108:	00 d0       	rcall	.+0      	; 0x310a <prvTaskIsTaskSuspended+0x6>
    310a:	00 d0       	rcall	.+0      	; 0x310c <prvTaskIsTaskSuspended+0x8>
    310c:	0f 92       	push	r0
    310e:	cd b7       	in	r28, 0x3d	; 61
    3110:	de b7       	in	r29, 0x3e	; 62
    3112:	9d 83       	std	Y+5, r25	; 0x05
    3114:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3116:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3118:	8c 81       	ldd	r24, Y+4	; 0x04
    311a:	9d 81       	ldd	r25, Y+5	; 0x05
    311c:	9a 83       	std	Y+2, r25	; 0x02
    311e:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    3120:	e9 81       	ldd	r30, Y+1	; 0x01
    3122:	fa 81       	ldd	r31, Y+2	; 0x02
    3124:	82 85       	ldd	r24, Z+10	; 0x0a
    3126:	93 85       	ldd	r25, Z+11	; 0x0b
    3128:	24 e0       	ldi	r18, 0x04	; 4
    312a:	8c 3b       	cpi	r24, 0xBC	; 188
    312c:	92 07       	cpc	r25, r18
    312e:	81 f4       	brne	.+32     	; 0x3150 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    3130:	e9 81       	ldd	r30, Y+1	; 0x01
    3132:	fa 81       	ldd	r31, Y+2	; 0x02
    3134:	84 89       	ldd	r24, Z+20	; 0x14
    3136:	95 89       	ldd	r25, Z+21	; 0x15
    3138:	24 e0       	ldi	r18, 0x04	; 4
    313a:	8a 3a       	cpi	r24, 0xAA	; 170
    313c:	92 07       	cpc	r25, r18
    313e:	41 f0       	breq	.+16     	; 0x3150 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    3140:	e9 81       	ldd	r30, Y+1	; 0x01
    3142:	fa 81       	ldd	r31, Y+2	; 0x02
    3144:	84 89       	ldd	r24, Z+20	; 0x14
    3146:	95 89       	ldd	r25, Z+21	; 0x15
    3148:	00 97       	sbiw	r24, 0x00	; 0
    314a:	11 f4       	brne	.+4      	; 0x3150 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    314c:	81 e0       	ldi	r24, 0x01	; 1
    314e:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    3150:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    3152:	0f 90       	pop	r0
    3154:	0f 90       	pop	r0
    3156:	0f 90       	pop	r0
    3158:	0f 90       	pop	r0
    315a:	0f 90       	pop	r0
    315c:	cf 91       	pop	r28
    315e:	df 91       	pop	r29
    3160:	08 95       	ret

00003162 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    3162:	df 93       	push	r29
    3164:	cf 93       	push	r28
    3166:	00 d0       	rcall	.+0      	; 0x3168 <vTaskResume+0x6>
    3168:	00 d0       	rcall	.+0      	; 0x316a <vTaskResume+0x8>
    316a:	cd b7       	in	r28, 0x3d	; 61
    316c:	de b7       	in	r29, 0x3e	; 62
    316e:	9c 83       	std	Y+4, r25	; 0x04
    3170:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    3172:	8b 81       	ldd	r24, Y+3	; 0x03
    3174:	9c 81       	ldd	r25, Y+4	; 0x04
    3176:	9a 83       	std	Y+2, r25	; 0x02
    3178:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    317a:	20 91 55 04 	lds	r18, 0x0455
    317e:	30 91 56 04 	lds	r19, 0x0456
    3182:	89 81       	ldd	r24, Y+1	; 0x01
    3184:	9a 81       	ldd	r25, Y+2	; 0x02
    3186:	82 17       	cp	r24, r18
    3188:	93 07       	cpc	r25, r19
    318a:	09 f4       	brne	.+2      	; 0x318e <vTaskResume+0x2c>
    318c:	47 c0       	rjmp	.+142    	; 0x321c <vTaskResume+0xba>
    318e:	89 81       	ldd	r24, Y+1	; 0x01
    3190:	9a 81       	ldd	r25, Y+2	; 0x02
    3192:	00 97       	sbiw	r24, 0x00	; 0
    3194:	09 f4       	brne	.+2      	; 0x3198 <vTaskResume+0x36>
    3196:	42 c0       	rjmp	.+132    	; 0x321c <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3198:	0f b6       	in	r0, 0x3f	; 63
    319a:	f8 94       	cli
    319c:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    319e:	89 81       	ldd	r24, Y+1	; 0x01
    31a0:	9a 81       	ldd	r25, Y+2	; 0x02
    31a2:	0e 94 82 18 	call	0x3104	; 0x3104 <prvTaskIsTaskSuspended>
    31a6:	88 23       	and	r24, r24
    31a8:	b9 f1       	breq	.+110    	; 0x3218 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    31aa:	89 81       	ldd	r24, Y+1	; 0x01
    31ac:	9a 81       	ldd	r25, Y+2	; 0x02
    31ae:	02 96       	adiw	r24, 0x02	; 2
    31b0:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    31b4:	e9 81       	ldd	r30, Y+1	; 0x01
    31b6:	fa 81       	ldd	r31, Y+2	; 0x02
    31b8:	96 89       	ldd	r25, Z+22	; 0x16
    31ba:	80 91 5b 04 	lds	r24, 0x045B
    31be:	89 17       	cp	r24, r25
    31c0:	28 f4       	brcc	.+10     	; 0x31cc <vTaskResume+0x6a>
    31c2:	e9 81       	ldd	r30, Y+1	; 0x01
    31c4:	fa 81       	ldd	r31, Y+2	; 0x02
    31c6:	86 89       	ldd	r24, Z+22	; 0x16
    31c8:	80 93 5b 04 	sts	0x045B, r24
    31cc:	e9 81       	ldd	r30, Y+1	; 0x01
    31ce:	fa 81       	ldd	r31, Y+2	; 0x02
    31d0:	86 89       	ldd	r24, Z+22	; 0x16
    31d2:	28 2f       	mov	r18, r24
    31d4:	30 e0       	ldi	r19, 0x00	; 0
    31d6:	c9 01       	movw	r24, r18
    31d8:	88 0f       	add	r24, r24
    31da:	99 1f       	adc	r25, r25
    31dc:	88 0f       	add	r24, r24
    31de:	99 1f       	adc	r25, r25
    31e0:	88 0f       	add	r24, r24
    31e2:	99 1f       	adc	r25, r25
    31e4:	82 0f       	add	r24, r18
    31e6:	93 1f       	adc	r25, r19
    31e8:	ac 01       	movw	r20, r24
    31ea:	49 59       	subi	r20, 0x99	; 153
    31ec:	5b 4f       	sbci	r21, 0xFB	; 251
    31ee:	89 81       	ldd	r24, Y+1	; 0x01
    31f0:	9a 81       	ldd	r25, Y+2	; 0x02
    31f2:	9c 01       	movw	r18, r24
    31f4:	2e 5f       	subi	r18, 0xFE	; 254
    31f6:	3f 4f       	sbci	r19, 0xFF	; 255
    31f8:	ca 01       	movw	r24, r20
    31fa:	b9 01       	movw	r22, r18
    31fc:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3200:	e9 81       	ldd	r30, Y+1	; 0x01
    3202:	fa 81       	ldd	r31, Y+2	; 0x02
    3204:	96 89       	ldd	r25, Z+22	; 0x16
    3206:	e0 91 55 04 	lds	r30, 0x0455
    320a:	f0 91 56 04 	lds	r31, 0x0456
    320e:	86 89       	ldd	r24, Z+22	; 0x16
    3210:	98 17       	cp	r25, r24
    3212:	10 f0       	brcs	.+4      	; 0x3218 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    3214:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3218:	0f 90       	pop	r0
    321a:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    321c:	0f 90       	pop	r0
    321e:	0f 90       	pop	r0
    3220:	0f 90       	pop	r0
    3222:	0f 90       	pop	r0
    3224:	cf 91       	pop	r28
    3226:	df 91       	pop	r29
    3228:	08 95       	ret

0000322a <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    322a:	df 93       	push	r29
    322c:	cf 93       	push	r28
    322e:	00 d0       	rcall	.+0      	; 0x3230 <xTaskResumeFromISR+0x6>
    3230:	00 d0       	rcall	.+0      	; 0x3232 <xTaskResumeFromISR+0x8>
    3232:	00 d0       	rcall	.+0      	; 0x3234 <xTaskResumeFromISR+0xa>
    3234:	cd b7       	in	r28, 0x3d	; 61
    3236:	de b7       	in	r29, 0x3e	; 62
    3238:	9e 83       	std	Y+6, r25	; 0x06
    323a:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    323c:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    323e:	8d 81       	ldd	r24, Y+5	; 0x05
    3240:	9e 81       	ldd	r25, Y+6	; 0x06
    3242:	9b 83       	std	Y+3, r25	; 0x03
    3244:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3246:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    3248:	8a 81       	ldd	r24, Y+2	; 0x02
    324a:	9b 81       	ldd	r25, Y+3	; 0x03
    324c:	0e 94 82 18 	call	0x3104	; 0x3104 <prvTaskIsTaskSuspended>
    3250:	88 23       	and	r24, r24
    3252:	09 f4       	brne	.+2      	; 0x3256 <xTaskResumeFromISR+0x2c>
    3254:	46 c0       	rjmp	.+140    	; 0x32e2 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3256:	80 91 66 04 	lds	r24, 0x0466
    325a:	88 23       	and	r24, r24
    325c:	c1 f5       	brne	.+112    	; 0x32ce <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    325e:	ea 81       	ldd	r30, Y+2	; 0x02
    3260:	fb 81       	ldd	r31, Y+3	; 0x03
    3262:	96 89       	ldd	r25, Z+22	; 0x16
    3264:	e0 91 55 04 	lds	r30, 0x0455
    3268:	f0 91 56 04 	lds	r31, 0x0456
    326c:	86 89       	ldd	r24, Z+22	; 0x16
    326e:	98 17       	cp	r25, r24
    3270:	10 f0       	brcs	.+4      	; 0x3276 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    3272:	81 e0       	ldi	r24, 0x01	; 1
    3274:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3276:	8a 81       	ldd	r24, Y+2	; 0x02
    3278:	9b 81       	ldd	r25, Y+3	; 0x03
    327a:	02 96       	adiw	r24, 0x02	; 2
    327c:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3280:	ea 81       	ldd	r30, Y+2	; 0x02
    3282:	fb 81       	ldd	r31, Y+3	; 0x03
    3284:	96 89       	ldd	r25, Z+22	; 0x16
    3286:	80 91 5b 04 	lds	r24, 0x045B
    328a:	89 17       	cp	r24, r25
    328c:	28 f4       	brcc	.+10     	; 0x3298 <xTaskResumeFromISR+0x6e>
    328e:	ea 81       	ldd	r30, Y+2	; 0x02
    3290:	fb 81       	ldd	r31, Y+3	; 0x03
    3292:	86 89       	ldd	r24, Z+22	; 0x16
    3294:	80 93 5b 04 	sts	0x045B, r24
    3298:	ea 81       	ldd	r30, Y+2	; 0x02
    329a:	fb 81       	ldd	r31, Y+3	; 0x03
    329c:	86 89       	ldd	r24, Z+22	; 0x16
    329e:	28 2f       	mov	r18, r24
    32a0:	30 e0       	ldi	r19, 0x00	; 0
    32a2:	c9 01       	movw	r24, r18
    32a4:	88 0f       	add	r24, r24
    32a6:	99 1f       	adc	r25, r25
    32a8:	88 0f       	add	r24, r24
    32aa:	99 1f       	adc	r25, r25
    32ac:	88 0f       	add	r24, r24
    32ae:	99 1f       	adc	r25, r25
    32b0:	82 0f       	add	r24, r18
    32b2:	93 1f       	adc	r25, r19
    32b4:	ac 01       	movw	r20, r24
    32b6:	49 59       	subi	r20, 0x99	; 153
    32b8:	5b 4f       	sbci	r21, 0xFB	; 251
    32ba:	8a 81       	ldd	r24, Y+2	; 0x02
    32bc:	9b 81       	ldd	r25, Y+3	; 0x03
    32be:	9c 01       	movw	r18, r24
    32c0:	2e 5f       	subi	r18, 0xFE	; 254
    32c2:	3f 4f       	sbci	r19, 0xFF	; 255
    32c4:	ca 01       	movw	r24, r20
    32c6:	b9 01       	movw	r22, r18
    32c8:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
    32cc:	0a c0       	rjmp	.+20     	; 0x32e2 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    32ce:	8a 81       	ldd	r24, Y+2	; 0x02
    32d0:	9b 81       	ldd	r25, Y+3	; 0x03
    32d2:	9c 01       	movw	r18, r24
    32d4:	24 5f       	subi	r18, 0xF4	; 244
    32d6:	3f 4f       	sbci	r19, 0xFF	; 255
    32d8:	8a ea       	ldi	r24, 0xAA	; 170
    32da:	94 e0       	ldi	r25, 0x04	; 4
    32dc:	b9 01       	movw	r22, r18
    32de:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    32e2:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    32e4:	26 96       	adiw	r28, 0x06	; 6
    32e6:	0f b6       	in	r0, 0x3f	; 63
    32e8:	f8 94       	cli
    32ea:	de bf       	out	0x3e, r29	; 62
    32ec:	0f be       	out	0x3f, r0	; 63
    32ee:	cd bf       	out	0x3d, r28	; 61
    32f0:	cf 91       	pop	r28
    32f2:	df 91       	pop	r29
    32f4:	08 95       	ret

000032f6 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    32f6:	ef 92       	push	r14
    32f8:	ff 92       	push	r15
    32fa:	0f 93       	push	r16
    32fc:	df 93       	push	r29
    32fe:	cf 93       	push	r28
    3300:	0f 92       	push	r0
    3302:	cd b7       	in	r28, 0x3d	; 61
    3304:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    3306:	8f ef       	ldi	r24, 0xFF	; 255
    3308:	9d e1       	ldi	r25, 0x1D	; 29
    330a:	20 e6       	ldi	r18, 0x60	; 96
    330c:	30 e0       	ldi	r19, 0x00	; 0
    330e:	e4 e6       	ldi	r30, 0x64	; 100
    3310:	f4 e0       	ldi	r31, 0x04	; 4
    3312:	b9 01       	movw	r22, r18
    3314:	45 e5       	ldi	r20, 0x55	; 85
    3316:	50 e0       	ldi	r21, 0x00	; 0
    3318:	20 e0       	ldi	r18, 0x00	; 0
    331a:	30 e0       	ldi	r19, 0x00	; 0
    331c:	00 e0       	ldi	r16, 0x00	; 0
    331e:	7f 01       	movw	r14, r30
    3320:	0e 94 3e 14 	call	0x287c	; 0x287c <xTaskCreate>
    3324:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3326:	89 81       	ldd	r24, Y+1	; 0x01
    3328:	81 30       	cpi	r24, 0x01	; 1
    332a:	81 f4       	brne	.+32     	; 0x334c <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    332c:	f8 94       	cli
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    332e:	8f ef       	ldi	r24, 0xFF	; 255
    3330:	9f ef       	ldi	r25, 0xFF	; 255
    3332:	90 93 63 04 	sts	0x0463, r25
    3336:	80 93 62 04 	sts	0x0462, r24
		xSchedulerRunning = pdTRUE;
    333a:	81 e0       	ldi	r24, 0x01	; 1
    333c:	80 93 5c 04 	sts	0x045C, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3340:	10 92 5a 04 	sts	0x045A, r1
    3344:	10 92 59 04 	sts	0x0459, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3348:	0e 94 cd 0b 	call	0x179a	; 0x179a <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    334c:	0f 90       	pop	r0
    334e:	cf 91       	pop	r28
    3350:	df 91       	pop	r29
    3352:	0f 91       	pop	r16
    3354:	ff 90       	pop	r15
    3356:	ef 90       	pop	r14
    3358:	08 95       	ret

0000335a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    335a:	df 93       	push	r29
    335c:	cf 93       	push	r28
    335e:	cd b7       	in	r28, 0x3d	; 61
    3360:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3362:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3364:	10 92 5c 04 	sts	0x045C, r1
	vPortEndScheduler();
    3368:	0e 94 02 0c 	call	0x1804	; 0x1804 <vPortEndScheduler>
}
    336c:	cf 91       	pop	r28
    336e:	df 91       	pop	r29
    3370:	08 95       	ret

00003372 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3372:	df 93       	push	r29
    3374:	cf 93       	push	r28
    3376:	cd b7       	in	r28, 0x3d	; 61
    3378:	de b7       	in	r29, 0x3e	; 62
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
    337a:	80 91 66 04 	lds	r24, 0x0466
    337e:	8f 5f       	subi	r24, 0xFF	; 255
    3380:	80 93 66 04 	sts	0x0466, r24

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
    3384:	cf 91       	pop	r28
    3386:	df 91       	pop	r29
    3388:	08 95       	ret

0000338a <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    338a:	df 93       	push	r29
    338c:	cf 93       	push	r28
    338e:	00 d0       	rcall	.+0      	; 0x3390 <xTaskResumeAll+0x6>
    3390:	00 d0       	rcall	.+0      	; 0x3392 <xTaskResumeAll+0x8>
    3392:	0f 92       	push	r0
    3394:	cd b7       	in	r28, 0x3d	; 61
    3396:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    3398:	1d 82       	std	Y+5, r1	; 0x05
    339a:	1c 82       	std	Y+4, r1	; 0x04
BaseType_t xAlreadyYielded = pdFALSE;
    339c:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    339e:	0f b6       	in	r0, 0x3f	; 63
    33a0:	f8 94       	cli
    33a2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    33a4:	80 91 66 04 	lds	r24, 0x0466
    33a8:	81 50       	subi	r24, 0x01	; 1
    33aa:	80 93 66 04 	sts	0x0466, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    33ae:	80 91 66 04 	lds	r24, 0x0466
    33b2:	88 23       	and	r24, r24
    33b4:	09 f0       	breq	.+2      	; 0x33b8 <xTaskResumeAll+0x2e>
    33b6:	7c c0       	rjmp	.+248    	; 0x34b0 <xTaskResumeAll+0x126>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    33b8:	80 91 58 04 	lds	r24, 0x0458
    33bc:	88 23       	and	r24, r24
    33be:	09 f4       	brne	.+2      	; 0x33c2 <xTaskResumeAll+0x38>
    33c0:	77 c0       	rjmp	.+238    	; 0x34b0 <xTaskResumeAll+0x126>
    33c2:	45 c0       	rjmp	.+138    	; 0x344e <xTaskResumeAll+0xc4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    33c4:	e0 91 af 04 	lds	r30, 0x04AF
    33c8:	f0 91 b0 04 	lds	r31, 0x04B0
    33cc:	86 81       	ldd	r24, Z+6	; 0x06
    33ce:	97 81       	ldd	r25, Z+7	; 0x07
    33d0:	9d 83       	std	Y+5, r25	; 0x05
    33d2:	8c 83       	std	Y+4, r24	; 0x04
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    33d4:	8c 81       	ldd	r24, Y+4	; 0x04
    33d6:	9d 81       	ldd	r25, Y+5	; 0x05
    33d8:	0c 96       	adiw	r24, 0x0c	; 12
    33da:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    33de:	8c 81       	ldd	r24, Y+4	; 0x04
    33e0:	9d 81       	ldd	r25, Y+5	; 0x05
    33e2:	02 96       	adiw	r24, 0x02	; 2
    33e4:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    33e8:	ec 81       	ldd	r30, Y+4	; 0x04
    33ea:	fd 81       	ldd	r31, Y+5	; 0x05
    33ec:	96 89       	ldd	r25, Z+22	; 0x16
    33ee:	80 91 5b 04 	lds	r24, 0x045B
    33f2:	89 17       	cp	r24, r25
    33f4:	28 f4       	brcc	.+10     	; 0x3400 <xTaskResumeAll+0x76>
    33f6:	ec 81       	ldd	r30, Y+4	; 0x04
    33f8:	fd 81       	ldd	r31, Y+5	; 0x05
    33fa:	86 89       	ldd	r24, Z+22	; 0x16
    33fc:	80 93 5b 04 	sts	0x045B, r24
    3400:	ec 81       	ldd	r30, Y+4	; 0x04
    3402:	fd 81       	ldd	r31, Y+5	; 0x05
    3404:	86 89       	ldd	r24, Z+22	; 0x16
    3406:	28 2f       	mov	r18, r24
    3408:	30 e0       	ldi	r19, 0x00	; 0
    340a:	c9 01       	movw	r24, r18
    340c:	88 0f       	add	r24, r24
    340e:	99 1f       	adc	r25, r25
    3410:	88 0f       	add	r24, r24
    3412:	99 1f       	adc	r25, r25
    3414:	88 0f       	add	r24, r24
    3416:	99 1f       	adc	r25, r25
    3418:	82 0f       	add	r24, r18
    341a:	93 1f       	adc	r25, r19
    341c:	ac 01       	movw	r20, r24
    341e:	49 59       	subi	r20, 0x99	; 153
    3420:	5b 4f       	sbci	r21, 0xFB	; 251
    3422:	8c 81       	ldd	r24, Y+4	; 0x04
    3424:	9d 81       	ldd	r25, Y+5	; 0x05
    3426:	9c 01       	movw	r18, r24
    3428:	2e 5f       	subi	r18, 0xFE	; 254
    342a:	3f 4f       	sbci	r19, 0xFF	; 255
    342c:	ca 01       	movw	r24, r20
    342e:	b9 01       	movw	r22, r18
    3430:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3434:	ec 81       	ldd	r30, Y+4	; 0x04
    3436:	fd 81       	ldd	r31, Y+5	; 0x05
    3438:	96 89       	ldd	r25, Z+22	; 0x16
    343a:	e0 91 55 04 	lds	r30, 0x0455
    343e:	f0 91 56 04 	lds	r31, 0x0456
    3442:	86 89       	ldd	r24, Z+22	; 0x16
    3444:	98 17       	cp	r25, r24
    3446:	18 f0       	brcs	.+6      	; 0x344e <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    3448:	81 e0       	ldi	r24, 0x01	; 1
    344a:	80 93 5f 04 	sts	0x045F, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    344e:	80 91 aa 04 	lds	r24, 0x04AA
    3452:	88 23       	and	r24, r24
    3454:	09 f0       	breq	.+2      	; 0x3458 <xTaskResumeAll+0xce>
    3456:	b6 cf       	rjmp	.-148    	; 0x33c4 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    3458:	8c 81       	ldd	r24, Y+4	; 0x04
    345a:	9d 81       	ldd	r25, Y+5	; 0x05
    345c:	00 97       	sbiw	r24, 0x00	; 0
    345e:	11 f0       	breq	.+4      	; 0x3464 <xTaskResumeAll+0xda>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    3460:	0e 94 8f 1e 	call	0x3d1e	; 0x3d1e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3464:	80 91 5d 04 	lds	r24, 0x045D
    3468:	90 91 5e 04 	lds	r25, 0x045E
    346c:	9a 83       	std	Y+2, r25	; 0x02
    346e:	89 83       	std	Y+1, r24	; 0x01

					if( xPendedCounts > ( TickType_t ) 0U )
    3470:	89 81       	ldd	r24, Y+1	; 0x01
    3472:	9a 81       	ldd	r25, Y+2	; 0x02
    3474:	00 97       	sbiw	r24, 0x00	; 0
    3476:	a1 f0       	breq	.+40     	; 0x34a0 <xTaskResumeAll+0x116>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    3478:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <xTaskIncrementTick>
    347c:	88 23       	and	r24, r24
    347e:	19 f0       	breq	.+6      	; 0x3486 <xTaskResumeAll+0xfc>
							{
								xYieldPending = pdTRUE;
    3480:	81 e0       	ldi	r24, 0x01	; 1
    3482:	80 93 5f 04 	sts	0x045F, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
    3486:	89 81       	ldd	r24, Y+1	; 0x01
    3488:	9a 81       	ldd	r25, Y+2	; 0x02
    348a:	01 97       	sbiw	r24, 0x01	; 1
    348c:	9a 83       	std	Y+2, r25	; 0x02
    348e:	89 83       	std	Y+1, r24	; 0x01
						} while( xPendedCounts > ( TickType_t ) 0U );
    3490:	89 81       	ldd	r24, Y+1	; 0x01
    3492:	9a 81       	ldd	r25, Y+2	; 0x02
    3494:	00 97       	sbiw	r24, 0x00	; 0
    3496:	81 f7       	brne	.-32     	; 0x3478 <xTaskResumeAll+0xee>

						xPendedTicks = 0;
    3498:	10 92 5e 04 	sts	0x045E, r1
    349c:	10 92 5d 04 	sts	0x045D, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    34a0:	80 91 5f 04 	lds	r24, 0x045F
    34a4:	88 23       	and	r24, r24
    34a6:	21 f0       	breq	.+8      	; 0x34b0 <xTaskResumeAll+0x126>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    34a8:	81 e0       	ldi	r24, 0x01	; 1
    34aa:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    34ac:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    34b0:	0f 90       	pop	r0
    34b2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    34b4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    34b6:	0f 90       	pop	r0
    34b8:	0f 90       	pop	r0
    34ba:	0f 90       	pop	r0
    34bc:	0f 90       	pop	r0
    34be:	0f 90       	pop	r0
    34c0:	cf 91       	pop	r28
    34c2:	df 91       	pop	r29
    34c4:	08 95       	ret

000034c6 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    34c6:	df 93       	push	r29
    34c8:	cf 93       	push	r28
    34ca:	00 d0       	rcall	.+0      	; 0x34cc <xTaskGetTickCount+0x6>
    34cc:	cd b7       	in	r28, 0x3d	; 61
    34ce:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    34d0:	0f b6       	in	r0, 0x3f	; 63
    34d2:	f8 94       	cli
    34d4:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    34d6:	80 91 59 04 	lds	r24, 0x0459
    34da:	90 91 5a 04 	lds	r25, 0x045A
    34de:	9a 83       	std	Y+2, r25	; 0x02
    34e0:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    34e2:	0f 90       	pop	r0
    34e4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    34e6:	89 81       	ldd	r24, Y+1	; 0x01
    34e8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    34ea:	0f 90       	pop	r0
    34ec:	0f 90       	pop	r0
    34ee:	cf 91       	pop	r28
    34f0:	df 91       	pop	r29
    34f2:	08 95       	ret

000034f4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    34f4:	df 93       	push	r29
    34f6:	cf 93       	push	r28
    34f8:	00 d0       	rcall	.+0      	; 0x34fa <xTaskGetTickCountFromISR+0x6>
    34fa:	0f 92       	push	r0
    34fc:	cd b7       	in	r28, 0x3d	; 61
    34fe:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3500:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3502:	80 91 59 04 	lds	r24, 0x0459
    3506:	90 91 5a 04 	lds	r25, 0x045A
    350a:	9b 83       	std	Y+3, r25	; 0x03
    350c:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    350e:	8a 81       	ldd	r24, Y+2	; 0x02
    3510:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3512:	0f 90       	pop	r0
    3514:	0f 90       	pop	r0
    3516:	0f 90       	pop	r0
    3518:	cf 91       	pop	r28
    351a:	df 91       	pop	r29
    351c:	08 95       	ret

0000351e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    351e:	df 93       	push	r29
    3520:	cf 93       	push	r28
    3522:	cd b7       	in	r28, 0x3d	; 61
    3524:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    3526:	80 91 58 04 	lds	r24, 0x0458
}
    352a:	cf 91       	pop	r28
    352c:	df 91       	pop	r29
    352e:	08 95       	ret

00003530 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3530:	df 93       	push	r29
    3532:	cf 93       	push	r28
    3534:	00 d0       	rcall	.+0      	; 0x3536 <pcTaskGetName+0x6>
    3536:	00 d0       	rcall	.+0      	; 0x3538 <pcTaskGetName+0x8>
    3538:	00 d0       	rcall	.+0      	; 0x353a <pcTaskGetName+0xa>
    353a:	cd b7       	in	r28, 0x3d	; 61
    353c:	de b7       	in	r29, 0x3e	; 62
    353e:	9c 83       	std	Y+4, r25	; 0x04
    3540:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3542:	8b 81       	ldd	r24, Y+3	; 0x03
    3544:	9c 81       	ldd	r25, Y+4	; 0x04
    3546:	00 97       	sbiw	r24, 0x00	; 0
    3548:	39 f4       	brne	.+14     	; 0x3558 <pcTaskGetName+0x28>
    354a:	80 91 55 04 	lds	r24, 0x0455
    354e:	90 91 56 04 	lds	r25, 0x0456
    3552:	9e 83       	std	Y+6, r25	; 0x06
    3554:	8d 83       	std	Y+5, r24	; 0x05
    3556:	04 c0       	rjmp	.+8      	; 0x3560 <pcTaskGetName+0x30>
    3558:	8b 81       	ldd	r24, Y+3	; 0x03
    355a:	9c 81       	ldd	r25, Y+4	; 0x04
    355c:	9e 83       	std	Y+6, r25	; 0x06
    355e:	8d 83       	std	Y+5, r24	; 0x05
    3560:	8d 81       	ldd	r24, Y+5	; 0x05
    3562:	9e 81       	ldd	r25, Y+6	; 0x06
    3564:	9a 83       	std	Y+2, r25	; 0x02
    3566:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    3568:	89 81       	ldd	r24, Y+1	; 0x01
    356a:	9a 81       	ldd	r25, Y+2	; 0x02
    356c:	49 96       	adiw	r24, 0x19	; 25
}
    356e:	26 96       	adiw	r28, 0x06	; 6
    3570:	0f b6       	in	r0, 0x3f	; 63
    3572:	f8 94       	cli
    3574:	de bf       	out	0x3e, r29	; 62
    3576:	0f be       	out	0x3f, r0	; 63
    3578:	cd bf       	out	0x3d, r28	; 61
    357a:	cf 91       	pop	r28
    357c:	df 91       	pop	r29
    357e:	08 95       	ret

00003580 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3580:	df 93       	push	r29
    3582:	cf 93       	push	r28
    3584:	00 d0       	rcall	.+0      	; 0x3586 <xTaskCatchUpTicks+0x6>
    3586:	0f 92       	push	r0
    3588:	cd b7       	in	r28, 0x3d	; 61
    358a:	de b7       	in	r29, 0x3e	; 62
    358c:	9b 83       	std	Y+3, r25	; 0x03
    358e:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xYieldRequired = pdFALSE;
    3590:	19 82       	std	Y+1, r1	; 0x01
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
    3592:	0e 94 b9 19 	call	0x3372	; 0x3372 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
    3596:	20 91 5d 04 	lds	r18, 0x045D
    359a:	30 91 5e 04 	lds	r19, 0x045E
    359e:	8a 81       	ldd	r24, Y+2	; 0x02
    35a0:	9b 81       	ldd	r25, Y+3	; 0x03
    35a2:	82 0f       	add	r24, r18
    35a4:	93 1f       	adc	r25, r19
    35a6:	90 93 5e 04 	sts	0x045E, r25
    35aa:	80 93 5d 04 	sts	0x045D, r24
	xYieldRequired = xTaskResumeAll();
    35ae:	0e 94 c5 19 	call	0x338a	; 0x338a <xTaskResumeAll>
    35b2:	89 83       	std	Y+1, r24	; 0x01

	return xYieldRequired;
    35b4:	89 81       	ldd	r24, Y+1	; 0x01
}
    35b6:	0f 90       	pop	r0
    35b8:	0f 90       	pop	r0
    35ba:	0f 90       	pop	r0
    35bc:	cf 91       	pop	r28
    35be:	df 91       	pop	r29
    35c0:	08 95       	ret

000035c2 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    35c2:	df 93       	push	r29
    35c4:	cf 93       	push	r28
    35c6:	cd b7       	in	r28, 0x3d	; 61
    35c8:	de b7       	in	r29, 0x3e	; 62
    35ca:	29 97       	sbiw	r28, 0x09	; 9
    35cc:	0f b6       	in	r0, 0x3f	; 63
    35ce:	f8 94       	cli
    35d0:	de bf       	out	0x3e, r29	; 62
    35d2:	0f be       	out	0x3f, r0	; 63
    35d4:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    35d6:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35d8:	80 91 66 04 	lds	r24, 0x0466
    35dc:	88 23       	and	r24, r24
    35de:	09 f0       	breq	.+2      	; 0x35e2 <xTaskIncrementTick+0x20>
    35e0:	c6 c0       	rjmp	.+396    	; 0x376e <xTaskIncrementTick+0x1ac>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    35e2:	80 91 59 04 	lds	r24, 0x0459
    35e6:	90 91 5a 04 	lds	r25, 0x045A
    35ea:	01 96       	adiw	r24, 0x01	; 1
    35ec:	9c 83       	std	Y+4, r25	; 0x04
    35ee:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    35f0:	8b 81       	ldd	r24, Y+3	; 0x03
    35f2:	9c 81       	ldd	r25, Y+4	; 0x04
    35f4:	90 93 5a 04 	sts	0x045A, r25
    35f8:	80 93 59 04 	sts	0x0459, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    35fc:	8b 81       	ldd	r24, Y+3	; 0x03
    35fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3600:	00 97       	sbiw	r24, 0x00	; 0
    3602:	d9 f4       	brne	.+54     	; 0x363a <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    3604:	80 91 a6 04 	lds	r24, 0x04A6
    3608:	90 91 a7 04 	lds	r25, 0x04A7
    360c:	9a 83       	std	Y+2, r25	; 0x02
    360e:	89 83       	std	Y+1, r24	; 0x01
    3610:	80 91 a8 04 	lds	r24, 0x04A8
    3614:	90 91 a9 04 	lds	r25, 0x04A9
    3618:	90 93 a7 04 	sts	0x04A7, r25
    361c:	80 93 a6 04 	sts	0x04A6, r24
    3620:	89 81       	ldd	r24, Y+1	; 0x01
    3622:	9a 81       	ldd	r25, Y+2	; 0x02
    3624:	90 93 a9 04 	sts	0x04A9, r25
    3628:	80 93 a8 04 	sts	0x04A8, r24
    362c:	80 91 60 04 	lds	r24, 0x0460
    3630:	8f 5f       	subi	r24, 0xFF	; 255
    3632:	80 93 60 04 	sts	0x0460, r24
    3636:	0e 94 8f 1e 	call	0x3d1e	; 0x3d1e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    363a:	20 91 62 04 	lds	r18, 0x0462
    363e:	30 91 63 04 	lds	r19, 0x0463
    3642:	8b 81       	ldd	r24, Y+3	; 0x03
    3644:	9c 81       	ldd	r25, Y+4	; 0x04
    3646:	82 17       	cp	r24, r18
    3648:	93 07       	cpc	r25, r19
    364a:	08 f4       	brcc	.+2      	; 0x364e <xTaskIncrementTick+0x8c>
    364c:	71 c0       	rjmp	.+226    	; 0x3730 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    364e:	e0 91 a6 04 	lds	r30, 0x04A6
    3652:	f0 91 a7 04 	lds	r31, 0x04A7
    3656:	80 81       	ld	r24, Z
    3658:	88 23       	and	r24, r24
    365a:	39 f4       	brne	.+14     	; 0x366a <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    365c:	8f ef       	ldi	r24, 0xFF	; 255
    365e:	9f ef       	ldi	r25, 0xFF	; 255
    3660:	90 93 63 04 	sts	0x0463, r25
    3664:	80 93 62 04 	sts	0x0462, r24
    3668:	63 c0       	rjmp	.+198    	; 0x3730 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    366a:	e0 91 a6 04 	lds	r30, 0x04A6
    366e:	f0 91 a7 04 	lds	r31, 0x04A7
    3672:	05 80       	ldd	r0, Z+5	; 0x05
    3674:	f6 81       	ldd	r31, Z+6	; 0x06
    3676:	e0 2d       	mov	r30, r0
    3678:	86 81       	ldd	r24, Z+6	; 0x06
    367a:	97 81       	ldd	r25, Z+7	; 0x07
    367c:	99 87       	std	Y+9, r25	; 0x09
    367e:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3680:	e8 85       	ldd	r30, Y+8	; 0x08
    3682:	f9 85       	ldd	r31, Y+9	; 0x09
    3684:	82 81       	ldd	r24, Z+2	; 0x02
    3686:	93 81       	ldd	r25, Z+3	; 0x03
    3688:	9f 83       	std	Y+7, r25	; 0x07
    368a:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    368c:	2b 81       	ldd	r18, Y+3	; 0x03
    368e:	3c 81       	ldd	r19, Y+4	; 0x04
    3690:	8e 81       	ldd	r24, Y+6	; 0x06
    3692:	9f 81       	ldd	r25, Y+7	; 0x07
    3694:	28 17       	cp	r18, r24
    3696:	39 07       	cpc	r19, r25
    3698:	38 f4       	brcc	.+14     	; 0x36a8 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    369a:	8e 81       	ldd	r24, Y+6	; 0x06
    369c:	9f 81       	ldd	r25, Y+7	; 0x07
    369e:	90 93 63 04 	sts	0x0463, r25
    36a2:	80 93 62 04 	sts	0x0462, r24
    36a6:	44 c0       	rjmp	.+136    	; 0x3730 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    36a8:	88 85       	ldd	r24, Y+8	; 0x08
    36aa:	99 85       	ldd	r25, Y+9	; 0x09
    36ac:	02 96       	adiw	r24, 0x02	; 2
    36ae:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    36b2:	e8 85       	ldd	r30, Y+8	; 0x08
    36b4:	f9 85       	ldd	r31, Y+9	; 0x09
    36b6:	84 89       	ldd	r24, Z+20	; 0x14
    36b8:	95 89       	ldd	r25, Z+21	; 0x15
    36ba:	00 97       	sbiw	r24, 0x00	; 0
    36bc:	29 f0       	breq	.+10     	; 0x36c8 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    36be:	88 85       	ldd	r24, Y+8	; 0x08
    36c0:	99 85       	ldd	r25, Y+9	; 0x09
    36c2:	0c 96       	adiw	r24, 0x0c	; 12
    36c4:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    36c8:	e8 85       	ldd	r30, Y+8	; 0x08
    36ca:	f9 85       	ldd	r31, Y+9	; 0x09
    36cc:	96 89       	ldd	r25, Z+22	; 0x16
    36ce:	80 91 5b 04 	lds	r24, 0x045B
    36d2:	89 17       	cp	r24, r25
    36d4:	28 f4       	brcc	.+10     	; 0x36e0 <xTaskIncrementTick+0x11e>
    36d6:	e8 85       	ldd	r30, Y+8	; 0x08
    36d8:	f9 85       	ldd	r31, Y+9	; 0x09
    36da:	86 89       	ldd	r24, Z+22	; 0x16
    36dc:	80 93 5b 04 	sts	0x045B, r24
    36e0:	e8 85       	ldd	r30, Y+8	; 0x08
    36e2:	f9 85       	ldd	r31, Y+9	; 0x09
    36e4:	86 89       	ldd	r24, Z+22	; 0x16
    36e6:	28 2f       	mov	r18, r24
    36e8:	30 e0       	ldi	r19, 0x00	; 0
    36ea:	c9 01       	movw	r24, r18
    36ec:	88 0f       	add	r24, r24
    36ee:	99 1f       	adc	r25, r25
    36f0:	88 0f       	add	r24, r24
    36f2:	99 1f       	adc	r25, r25
    36f4:	88 0f       	add	r24, r24
    36f6:	99 1f       	adc	r25, r25
    36f8:	82 0f       	add	r24, r18
    36fa:	93 1f       	adc	r25, r19
    36fc:	ac 01       	movw	r20, r24
    36fe:	49 59       	subi	r20, 0x99	; 153
    3700:	5b 4f       	sbci	r21, 0xFB	; 251
    3702:	88 85       	ldd	r24, Y+8	; 0x08
    3704:	99 85       	ldd	r25, Y+9	; 0x09
    3706:	9c 01       	movw	r18, r24
    3708:	2e 5f       	subi	r18, 0xFE	; 254
    370a:	3f 4f       	sbci	r19, 0xFF	; 255
    370c:	ca 01       	movw	r24, r20
    370e:	b9 01       	movw	r22, r18
    3710:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3714:	e8 85       	ldd	r30, Y+8	; 0x08
    3716:	f9 85       	ldd	r31, Y+9	; 0x09
    3718:	96 89       	ldd	r25, Z+22	; 0x16
    371a:	e0 91 55 04 	lds	r30, 0x0455
    371e:	f0 91 56 04 	lds	r31, 0x0456
    3722:	86 89       	ldd	r24, Z+22	; 0x16
    3724:	98 17       	cp	r25, r24
    3726:	08 f4       	brcc	.+2      	; 0x372a <xTaskIncrementTick+0x168>
    3728:	92 cf       	rjmp	.-220    	; 0x364e <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    372a:	81 e0       	ldi	r24, 0x01	; 1
    372c:	8d 83       	std	Y+5, r24	; 0x05
    372e:	8f cf       	rjmp	.-226    	; 0x364e <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3730:	e0 91 55 04 	lds	r30, 0x0455
    3734:	f0 91 56 04 	lds	r31, 0x0456
    3738:	86 89       	ldd	r24, Z+22	; 0x16
    373a:	28 2f       	mov	r18, r24
    373c:	30 e0       	ldi	r19, 0x00	; 0
    373e:	c9 01       	movw	r24, r18
    3740:	88 0f       	add	r24, r24
    3742:	99 1f       	adc	r25, r25
    3744:	88 0f       	add	r24, r24
    3746:	99 1f       	adc	r25, r25
    3748:	88 0f       	add	r24, r24
    374a:	99 1f       	adc	r25, r25
    374c:	82 0f       	add	r24, r18
    374e:	93 1f       	adc	r25, r19
    3750:	fc 01       	movw	r30, r24
    3752:	e9 59       	subi	r30, 0x99	; 153
    3754:	fb 4f       	sbci	r31, 0xFB	; 251
    3756:	80 81       	ld	r24, Z
    3758:	82 30       	cpi	r24, 0x02	; 2
    375a:	10 f0       	brcs	.+4      	; 0x3760 <xTaskIncrementTick+0x19e>
			{
				xSwitchRequired = pdTRUE;
    375c:	81 e0       	ldi	r24, 0x01	; 1
    375e:	8d 83       	std	Y+5, r24	; 0x05
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
    3760:	80 91 5f 04 	lds	r24, 0x045F
    3764:	88 23       	and	r24, r24
    3766:	61 f0       	breq	.+24     	; 0x3780 <xTaskIncrementTick+0x1be>
			{
				xSwitchRequired = pdTRUE;
    3768:	81 e0       	ldi	r24, 0x01	; 1
    376a:	8d 83       	std	Y+5, r24	; 0x05
    376c:	09 c0       	rjmp	.+18     	; 0x3780 <xTaskIncrementTick+0x1be>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
    376e:	80 91 5d 04 	lds	r24, 0x045D
    3772:	90 91 5e 04 	lds	r25, 0x045E
    3776:	01 96       	adiw	r24, 0x01	; 1
    3778:	90 93 5e 04 	sts	0x045E, r25
    377c:	80 93 5d 04 	sts	0x045D, r24
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
    3780:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3782:	29 96       	adiw	r28, 0x09	; 9
    3784:	0f b6       	in	r0, 0x3f	; 63
    3786:	f8 94       	cli
    3788:	de bf       	out	0x3e, r29	; 62
    378a:	0f be       	out	0x3f, r0	; 63
    378c:	cd bf       	out	0x3d, r28	; 61
    378e:	cf 91       	pop	r28
    3790:	df 91       	pop	r29
    3792:	08 95       	ret

00003794 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3794:	df 93       	push	r29
    3796:	cf 93       	push	r28
    3798:	00 d0       	rcall	.+0      	; 0x379a <vTaskSwitchContext+0x6>
    379a:	0f 92       	push	r0
    379c:	cd b7       	in	r28, 0x3d	; 61
    379e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    37a0:	80 91 66 04 	lds	r24, 0x0466
    37a4:	88 23       	and	r24, r24
    37a6:	21 f0       	breq	.+8      	; 0x37b0 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    37a8:	81 e0       	ldi	r24, 0x01	; 1
    37aa:	80 93 5f 04 	sts	0x045F, r24
    37ae:	59 c0       	rjmp	.+178    	; 0x3862 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    37b0:	10 92 5f 04 	sts	0x045F, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    37b4:	80 91 5b 04 	lds	r24, 0x045B
    37b8:	8b 83       	std	Y+3, r24	; 0x03
    37ba:	03 c0       	rjmp	.+6      	; 0x37c2 <vTaskSwitchContext+0x2e>
    37bc:	8b 81       	ldd	r24, Y+3	; 0x03
    37be:	81 50       	subi	r24, 0x01	; 1
    37c0:	8b 83       	std	Y+3, r24	; 0x03
    37c2:	8b 81       	ldd	r24, Y+3	; 0x03
    37c4:	28 2f       	mov	r18, r24
    37c6:	30 e0       	ldi	r19, 0x00	; 0
    37c8:	c9 01       	movw	r24, r18
    37ca:	88 0f       	add	r24, r24
    37cc:	99 1f       	adc	r25, r25
    37ce:	88 0f       	add	r24, r24
    37d0:	99 1f       	adc	r25, r25
    37d2:	88 0f       	add	r24, r24
    37d4:	99 1f       	adc	r25, r25
    37d6:	82 0f       	add	r24, r18
    37d8:	93 1f       	adc	r25, r19
    37da:	fc 01       	movw	r30, r24
    37dc:	e9 59       	subi	r30, 0x99	; 153
    37de:	fb 4f       	sbci	r31, 0xFB	; 251
    37e0:	80 81       	ld	r24, Z
    37e2:	88 23       	and	r24, r24
    37e4:	59 f3       	breq	.-42     	; 0x37bc <vTaskSwitchContext+0x28>
    37e6:	8b 81       	ldd	r24, Y+3	; 0x03
    37e8:	28 2f       	mov	r18, r24
    37ea:	30 e0       	ldi	r19, 0x00	; 0
    37ec:	c9 01       	movw	r24, r18
    37ee:	88 0f       	add	r24, r24
    37f0:	99 1f       	adc	r25, r25
    37f2:	88 0f       	add	r24, r24
    37f4:	99 1f       	adc	r25, r25
    37f6:	88 0f       	add	r24, r24
    37f8:	99 1f       	adc	r25, r25
    37fa:	82 0f       	add	r24, r18
    37fc:	93 1f       	adc	r25, r19
    37fe:	89 59       	subi	r24, 0x99	; 153
    3800:	9b 4f       	sbci	r25, 0xFB	; 251
    3802:	9a 83       	std	Y+2, r25	; 0x02
    3804:	89 83       	std	Y+1, r24	; 0x01
    3806:	e9 81       	ldd	r30, Y+1	; 0x01
    3808:	fa 81       	ldd	r31, Y+2	; 0x02
    380a:	01 80       	ldd	r0, Z+1	; 0x01
    380c:	f2 81       	ldd	r31, Z+2	; 0x02
    380e:	e0 2d       	mov	r30, r0
    3810:	82 81       	ldd	r24, Z+2	; 0x02
    3812:	93 81       	ldd	r25, Z+3	; 0x03
    3814:	e9 81       	ldd	r30, Y+1	; 0x01
    3816:	fa 81       	ldd	r31, Y+2	; 0x02
    3818:	92 83       	std	Z+2, r25	; 0x02
    381a:	81 83       	std	Z+1, r24	; 0x01
    381c:	e9 81       	ldd	r30, Y+1	; 0x01
    381e:	fa 81       	ldd	r31, Y+2	; 0x02
    3820:	21 81       	ldd	r18, Z+1	; 0x01
    3822:	32 81       	ldd	r19, Z+2	; 0x02
    3824:	89 81       	ldd	r24, Y+1	; 0x01
    3826:	9a 81       	ldd	r25, Y+2	; 0x02
    3828:	03 96       	adiw	r24, 0x03	; 3
    382a:	28 17       	cp	r18, r24
    382c:	39 07       	cpc	r19, r25
    382e:	59 f4       	brne	.+22     	; 0x3846 <vTaskSwitchContext+0xb2>
    3830:	e9 81       	ldd	r30, Y+1	; 0x01
    3832:	fa 81       	ldd	r31, Y+2	; 0x02
    3834:	01 80       	ldd	r0, Z+1	; 0x01
    3836:	f2 81       	ldd	r31, Z+2	; 0x02
    3838:	e0 2d       	mov	r30, r0
    383a:	82 81       	ldd	r24, Z+2	; 0x02
    383c:	93 81       	ldd	r25, Z+3	; 0x03
    383e:	e9 81       	ldd	r30, Y+1	; 0x01
    3840:	fa 81       	ldd	r31, Y+2	; 0x02
    3842:	92 83       	std	Z+2, r25	; 0x02
    3844:	81 83       	std	Z+1, r24	; 0x01
    3846:	e9 81       	ldd	r30, Y+1	; 0x01
    3848:	fa 81       	ldd	r31, Y+2	; 0x02
    384a:	01 80       	ldd	r0, Z+1	; 0x01
    384c:	f2 81       	ldd	r31, Z+2	; 0x02
    384e:	e0 2d       	mov	r30, r0
    3850:	86 81       	ldd	r24, Z+6	; 0x06
    3852:	97 81       	ldd	r25, Z+7	; 0x07
    3854:	90 93 56 04 	sts	0x0456, r25
    3858:	80 93 55 04 	sts	0x0455, r24
    385c:	8b 81       	ldd	r24, Y+3	; 0x03
    385e:	80 93 5b 04 	sts	0x045B, r24
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3862:	0f 90       	pop	r0
    3864:	0f 90       	pop	r0
    3866:	0f 90       	pop	r0
    3868:	cf 91       	pop	r28
    386a:	df 91       	pop	r29
    386c:	08 95       	ret

0000386e <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    386e:	df 93       	push	r29
    3870:	cf 93       	push	r28
    3872:	00 d0       	rcall	.+0      	; 0x3874 <vTaskPlaceOnEventList+0x6>
    3874:	00 d0       	rcall	.+0      	; 0x3876 <vTaskPlaceOnEventList+0x8>
    3876:	cd b7       	in	r28, 0x3d	; 61
    3878:	de b7       	in	r29, 0x3e	; 62
    387a:	9a 83       	std	Y+2, r25	; 0x02
    387c:	89 83       	std	Y+1, r24	; 0x01
    387e:	7c 83       	std	Y+4, r23	; 0x04
    3880:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3882:	80 91 55 04 	lds	r24, 0x0455
    3886:	90 91 56 04 	lds	r25, 0x0456
    388a:	9c 01       	movw	r18, r24
    388c:	24 5f       	subi	r18, 0xF4	; 244
    388e:	3f 4f       	sbci	r19, 0xFF	; 255
    3890:	89 81       	ldd	r24, Y+1	; 0x01
    3892:	9a 81       	ldd	r25, Y+2	; 0x02
    3894:	b9 01       	movw	r22, r18
    3896:	0e 94 ff 08 	call	0x11fe	; 0x11fe <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    389a:	8b 81       	ldd	r24, Y+3	; 0x03
    389c:	9c 81       	ldd	r25, Y+4	; 0x04
    389e:	61 e0       	ldi	r22, 0x01	; 1
    38a0:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <prvAddCurrentTaskToDelayedList>
}
    38a4:	0f 90       	pop	r0
    38a6:	0f 90       	pop	r0
    38a8:	0f 90       	pop	r0
    38aa:	0f 90       	pop	r0
    38ac:	cf 91       	pop	r28
    38ae:	df 91       	pop	r29
    38b0:	08 95       	ret

000038b2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    38b2:	df 93       	push	r29
    38b4:	cf 93       	push	r28
    38b6:	00 d0       	rcall	.+0      	; 0x38b8 <vTaskPlaceOnUnorderedEventList+0x6>
    38b8:	00 d0       	rcall	.+0      	; 0x38ba <vTaskPlaceOnUnorderedEventList+0x8>
    38ba:	00 d0       	rcall	.+0      	; 0x38bc <vTaskPlaceOnUnorderedEventList+0xa>
    38bc:	cd b7       	in	r28, 0x3d	; 61
    38be:	de b7       	in	r29, 0x3e	; 62
    38c0:	9a 83       	std	Y+2, r25	; 0x02
    38c2:	89 83       	std	Y+1, r24	; 0x01
    38c4:	7c 83       	std	Y+4, r23	; 0x04
    38c6:	6b 83       	std	Y+3, r22	; 0x03
    38c8:	5e 83       	std	Y+6, r21	; 0x06
    38ca:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    38cc:	e0 91 55 04 	lds	r30, 0x0455
    38d0:	f0 91 56 04 	lds	r31, 0x0456
    38d4:	8b 81       	ldd	r24, Y+3	; 0x03
    38d6:	9c 81       	ldd	r25, Y+4	; 0x04
    38d8:	90 68       	ori	r25, 0x80	; 128
    38da:	95 87       	std	Z+13, r25	; 0x0d
    38dc:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    38de:	80 91 55 04 	lds	r24, 0x0455
    38e2:	90 91 56 04 	lds	r25, 0x0456
    38e6:	9c 01       	movw	r18, r24
    38e8:	24 5f       	subi	r18, 0xF4	; 244
    38ea:	3f 4f       	sbci	r19, 0xFF	; 255
    38ec:	89 81       	ldd	r24, Y+1	; 0x01
    38ee:	9a 81       	ldd	r25, Y+2	; 0x02
    38f0:	b9 01       	movw	r22, r18
    38f2:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    38f6:	8d 81       	ldd	r24, Y+5	; 0x05
    38f8:	9e 81       	ldd	r25, Y+6	; 0x06
    38fa:	61 e0       	ldi	r22, 0x01	; 1
    38fc:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <prvAddCurrentTaskToDelayedList>
}
    3900:	26 96       	adiw	r28, 0x06	; 6
    3902:	0f b6       	in	r0, 0x3f	; 63
    3904:	f8 94       	cli
    3906:	de bf       	out	0x3e, r29	; 62
    3908:	0f be       	out	0x3f, r0	; 63
    390a:	cd bf       	out	0x3d, r28	; 61
    390c:	cf 91       	pop	r28
    390e:	df 91       	pop	r29
    3910:	08 95       	ret

00003912 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3912:	df 93       	push	r29
    3914:	cf 93       	push	r28
    3916:	00 d0       	rcall	.+0      	; 0x3918 <xTaskRemoveFromEventList+0x6>
    3918:	00 d0       	rcall	.+0      	; 0x391a <xTaskRemoveFromEventList+0x8>
    391a:	0f 92       	push	r0
    391c:	cd b7       	in	r28, 0x3d	; 61
    391e:	de b7       	in	r29, 0x3e	; 62
    3920:	9d 83       	std	Y+5, r25	; 0x05
    3922:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3924:	ec 81       	ldd	r30, Y+4	; 0x04
    3926:	fd 81       	ldd	r31, Y+5	; 0x05
    3928:	05 80       	ldd	r0, Z+5	; 0x05
    392a:	f6 81       	ldd	r31, Z+6	; 0x06
    392c:	e0 2d       	mov	r30, r0
    392e:	86 81       	ldd	r24, Z+6	; 0x06
    3930:	97 81       	ldd	r25, Z+7	; 0x07
    3932:	9b 83       	std	Y+3, r25	; 0x03
    3934:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3936:	8a 81       	ldd	r24, Y+2	; 0x02
    3938:	9b 81       	ldd	r25, Y+3	; 0x03
    393a:	0c 96       	adiw	r24, 0x0c	; 12
    393c:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3940:	80 91 66 04 	lds	r24, 0x0466
    3944:	88 23       	and	r24, r24
    3946:	61 f5       	brne	.+88     	; 0x39a0 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3948:	8a 81       	ldd	r24, Y+2	; 0x02
    394a:	9b 81       	ldd	r25, Y+3	; 0x03
    394c:	02 96       	adiw	r24, 0x02	; 2
    394e:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3952:	ea 81       	ldd	r30, Y+2	; 0x02
    3954:	fb 81       	ldd	r31, Y+3	; 0x03
    3956:	96 89       	ldd	r25, Z+22	; 0x16
    3958:	80 91 5b 04 	lds	r24, 0x045B
    395c:	89 17       	cp	r24, r25
    395e:	28 f4       	brcc	.+10     	; 0x396a <xTaskRemoveFromEventList+0x58>
    3960:	ea 81       	ldd	r30, Y+2	; 0x02
    3962:	fb 81       	ldd	r31, Y+3	; 0x03
    3964:	86 89       	ldd	r24, Z+22	; 0x16
    3966:	80 93 5b 04 	sts	0x045B, r24
    396a:	ea 81       	ldd	r30, Y+2	; 0x02
    396c:	fb 81       	ldd	r31, Y+3	; 0x03
    396e:	86 89       	ldd	r24, Z+22	; 0x16
    3970:	28 2f       	mov	r18, r24
    3972:	30 e0       	ldi	r19, 0x00	; 0
    3974:	c9 01       	movw	r24, r18
    3976:	88 0f       	add	r24, r24
    3978:	99 1f       	adc	r25, r25
    397a:	88 0f       	add	r24, r24
    397c:	99 1f       	adc	r25, r25
    397e:	88 0f       	add	r24, r24
    3980:	99 1f       	adc	r25, r25
    3982:	82 0f       	add	r24, r18
    3984:	93 1f       	adc	r25, r19
    3986:	ac 01       	movw	r20, r24
    3988:	49 59       	subi	r20, 0x99	; 153
    398a:	5b 4f       	sbci	r21, 0xFB	; 251
    398c:	8a 81       	ldd	r24, Y+2	; 0x02
    398e:	9b 81       	ldd	r25, Y+3	; 0x03
    3990:	9c 01       	movw	r18, r24
    3992:	2e 5f       	subi	r18, 0xFE	; 254
    3994:	3f 4f       	sbci	r19, 0xFF	; 255
    3996:	ca 01       	movw	r24, r20
    3998:	b9 01       	movw	r22, r18
    399a:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
    399e:	0a c0       	rjmp	.+20     	; 0x39b4 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    39a0:	8a 81       	ldd	r24, Y+2	; 0x02
    39a2:	9b 81       	ldd	r25, Y+3	; 0x03
    39a4:	9c 01       	movw	r18, r24
    39a6:	24 5f       	subi	r18, 0xF4	; 244
    39a8:	3f 4f       	sbci	r19, 0xFF	; 255
    39aa:	8a ea       	ldi	r24, 0xAA	; 170
    39ac:	94 e0       	ldi	r25, 0x04	; 4
    39ae:	b9 01       	movw	r22, r18
    39b0:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    39b4:	ea 81       	ldd	r30, Y+2	; 0x02
    39b6:	fb 81       	ldd	r31, Y+3	; 0x03
    39b8:	96 89       	ldd	r25, Z+22	; 0x16
    39ba:	e0 91 55 04 	lds	r30, 0x0455
    39be:	f0 91 56 04 	lds	r31, 0x0456
    39c2:	86 89       	ldd	r24, Z+22	; 0x16
    39c4:	89 17       	cp	r24, r25
    39c6:	30 f4       	brcc	.+12     	; 0x39d4 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    39c8:	81 e0       	ldi	r24, 0x01	; 1
    39ca:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    39cc:	81 e0       	ldi	r24, 0x01	; 1
    39ce:	80 93 5f 04 	sts	0x045F, r24
    39d2:	01 c0       	rjmp	.+2      	; 0x39d6 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    39d4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    39d6:	89 81       	ldd	r24, Y+1	; 0x01
}
    39d8:	0f 90       	pop	r0
    39da:	0f 90       	pop	r0
    39dc:	0f 90       	pop	r0
    39de:	0f 90       	pop	r0
    39e0:	0f 90       	pop	r0
    39e2:	cf 91       	pop	r28
    39e4:	df 91       	pop	r29
    39e6:	08 95       	ret

000039e8 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    39e8:	df 93       	push	r29
    39ea:	cf 93       	push	r28
    39ec:	00 d0       	rcall	.+0      	; 0x39ee <vTaskRemoveFromUnorderedEventList+0x6>
    39ee:	00 d0       	rcall	.+0      	; 0x39f0 <vTaskRemoveFromUnorderedEventList+0x8>
    39f0:	00 d0       	rcall	.+0      	; 0x39f2 <vTaskRemoveFromUnorderedEventList+0xa>
    39f2:	cd b7       	in	r28, 0x3d	; 61
    39f4:	de b7       	in	r29, 0x3e	; 62
    39f6:	9c 83       	std	Y+4, r25	; 0x04
    39f8:	8b 83       	std	Y+3, r24	; 0x03
    39fa:	7e 83       	std	Y+6, r23	; 0x06
    39fc:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    39fe:	8d 81       	ldd	r24, Y+5	; 0x05
    3a00:	9e 81       	ldd	r25, Y+6	; 0x06
    3a02:	90 68       	ori	r25, 0x80	; 128
    3a04:	eb 81       	ldd	r30, Y+3	; 0x03
    3a06:	fc 81       	ldd	r31, Y+4	; 0x04
    3a08:	91 83       	std	Z+1, r25	; 0x01
    3a0a:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3a0c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a0e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a10:	86 81       	ldd	r24, Z+6	; 0x06
    3a12:	97 81       	ldd	r25, Z+7	; 0x07
    3a14:	9a 83       	std	Y+2, r25	; 0x02
    3a16:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3a18:	8b 81       	ldd	r24, Y+3	; 0x03
    3a1a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a1c:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3a20:	89 81       	ldd	r24, Y+1	; 0x01
    3a22:	9a 81       	ldd	r25, Y+2	; 0x02
    3a24:	02 96       	adiw	r24, 0x02	; 2
    3a26:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3a2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3a2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3a2e:	96 89       	ldd	r25, Z+22	; 0x16
    3a30:	80 91 5b 04 	lds	r24, 0x045B
    3a34:	89 17       	cp	r24, r25
    3a36:	28 f4       	brcc	.+10     	; 0x3a42 <vTaskRemoveFromUnorderedEventList+0x5a>
    3a38:	e9 81       	ldd	r30, Y+1	; 0x01
    3a3a:	fa 81       	ldd	r31, Y+2	; 0x02
    3a3c:	86 89       	ldd	r24, Z+22	; 0x16
    3a3e:	80 93 5b 04 	sts	0x045B, r24
    3a42:	e9 81       	ldd	r30, Y+1	; 0x01
    3a44:	fa 81       	ldd	r31, Y+2	; 0x02
    3a46:	86 89       	ldd	r24, Z+22	; 0x16
    3a48:	28 2f       	mov	r18, r24
    3a4a:	30 e0       	ldi	r19, 0x00	; 0
    3a4c:	c9 01       	movw	r24, r18
    3a4e:	88 0f       	add	r24, r24
    3a50:	99 1f       	adc	r25, r25
    3a52:	88 0f       	add	r24, r24
    3a54:	99 1f       	adc	r25, r25
    3a56:	88 0f       	add	r24, r24
    3a58:	99 1f       	adc	r25, r25
    3a5a:	82 0f       	add	r24, r18
    3a5c:	93 1f       	adc	r25, r19
    3a5e:	ac 01       	movw	r20, r24
    3a60:	49 59       	subi	r20, 0x99	; 153
    3a62:	5b 4f       	sbci	r21, 0xFB	; 251
    3a64:	89 81       	ldd	r24, Y+1	; 0x01
    3a66:	9a 81       	ldd	r25, Y+2	; 0x02
    3a68:	9c 01       	movw	r18, r24
    3a6a:	2e 5f       	subi	r18, 0xFE	; 254
    3a6c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a6e:	ca 01       	movw	r24, r20
    3a70:	b9 01       	movw	r22, r18
    3a72:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3a76:	e9 81       	ldd	r30, Y+1	; 0x01
    3a78:	fa 81       	ldd	r31, Y+2	; 0x02
    3a7a:	96 89       	ldd	r25, Z+22	; 0x16
    3a7c:	e0 91 55 04 	lds	r30, 0x0455
    3a80:	f0 91 56 04 	lds	r31, 0x0456
    3a84:	86 89       	ldd	r24, Z+22	; 0x16
    3a86:	89 17       	cp	r24, r25
    3a88:	18 f4       	brcc	.+6      	; 0x3a90 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3a8a:	81 e0       	ldi	r24, 0x01	; 1
    3a8c:	80 93 5f 04 	sts	0x045F, r24
	}
}
    3a90:	26 96       	adiw	r28, 0x06	; 6
    3a92:	0f b6       	in	r0, 0x3f	; 63
    3a94:	f8 94       	cli
    3a96:	de bf       	out	0x3e, r29	; 62
    3a98:	0f be       	out	0x3f, r0	; 63
    3a9a:	cd bf       	out	0x3d, r28	; 61
    3a9c:	cf 91       	pop	r28
    3a9e:	df 91       	pop	r29
    3aa0:	08 95       	ret

00003aa2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3aa2:	df 93       	push	r29
    3aa4:	cf 93       	push	r28
    3aa6:	00 d0       	rcall	.+0      	; 0x3aa8 <vTaskSetTimeOutState+0x6>
    3aa8:	cd b7       	in	r28, 0x3d	; 61
    3aaa:	de b7       	in	r29, 0x3e	; 62
    3aac:	9a 83       	std	Y+2, r25	; 0x02
    3aae:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3ab0:	0f b6       	in	r0, 0x3f	; 63
    3ab2:	f8 94       	cli
    3ab4:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3ab6:	80 91 60 04 	lds	r24, 0x0460
    3aba:	e9 81       	ldd	r30, Y+1	; 0x01
    3abc:	fa 81       	ldd	r31, Y+2	; 0x02
    3abe:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3ac0:	80 91 59 04 	lds	r24, 0x0459
    3ac4:	90 91 5a 04 	lds	r25, 0x045A
    3ac8:	e9 81       	ldd	r30, Y+1	; 0x01
    3aca:	fa 81       	ldd	r31, Y+2	; 0x02
    3acc:	92 83       	std	Z+2, r25	; 0x02
    3ace:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3ad0:	0f 90       	pop	r0
    3ad2:	0f be       	out	0x3f, r0	; 63
}
    3ad4:	0f 90       	pop	r0
    3ad6:	0f 90       	pop	r0
    3ad8:	cf 91       	pop	r28
    3ada:	df 91       	pop	r29
    3adc:	08 95       	ret

00003ade <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3ade:	df 93       	push	r29
    3ae0:	cf 93       	push	r28
    3ae2:	00 d0       	rcall	.+0      	; 0x3ae4 <vTaskInternalSetTimeOutState+0x6>
    3ae4:	cd b7       	in	r28, 0x3d	; 61
    3ae6:	de b7       	in	r29, 0x3e	; 62
    3ae8:	9a 83       	std	Y+2, r25	; 0x02
    3aea:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3aec:	80 91 60 04 	lds	r24, 0x0460
    3af0:	e9 81       	ldd	r30, Y+1	; 0x01
    3af2:	fa 81       	ldd	r31, Y+2	; 0x02
    3af4:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3af6:	80 91 59 04 	lds	r24, 0x0459
    3afa:	90 91 5a 04 	lds	r25, 0x045A
    3afe:	e9 81       	ldd	r30, Y+1	; 0x01
    3b00:	fa 81       	ldd	r31, Y+2	; 0x02
    3b02:	92 83       	std	Z+2, r25	; 0x02
    3b04:	81 83       	std	Z+1, r24	; 0x01
}
    3b06:	0f 90       	pop	r0
    3b08:	0f 90       	pop	r0
    3b0a:	cf 91       	pop	r28
    3b0c:	df 91       	pop	r29
    3b0e:	08 95       	ret

00003b10 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3b10:	df 93       	push	r29
    3b12:	cf 93       	push	r28
    3b14:	cd b7       	in	r28, 0x3d	; 61
    3b16:	de b7       	in	r29, 0x3e	; 62
    3b18:	29 97       	sbiw	r28, 0x09	; 9
    3b1a:	0f b6       	in	r0, 0x3f	; 63
    3b1c:	f8 94       	cli
    3b1e:	de bf       	out	0x3e, r29	; 62
    3b20:	0f be       	out	0x3f, r0	; 63
    3b22:	cd bf       	out	0x3d, r28	; 61
    3b24:	9f 83       	std	Y+7, r25	; 0x07
    3b26:	8e 83       	std	Y+6, r24	; 0x06
    3b28:	79 87       	std	Y+9, r23	; 0x09
    3b2a:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3b2c:	0f b6       	in	r0, 0x3f	; 63
    3b2e:	f8 94       	cli
    3b30:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3b32:	80 91 59 04 	lds	r24, 0x0459
    3b36:	90 91 5a 04 	lds	r25, 0x045A
    3b3a:	9c 83       	std	Y+4, r25	; 0x04
    3b3c:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3b3e:	ee 81       	ldd	r30, Y+6	; 0x06
    3b40:	ff 81       	ldd	r31, Y+7	; 0x07
    3b42:	21 81       	ldd	r18, Z+1	; 0x01
    3b44:	32 81       	ldd	r19, Z+2	; 0x02
    3b46:	8b 81       	ldd	r24, Y+3	; 0x03
    3b48:	9c 81       	ldd	r25, Y+4	; 0x04
    3b4a:	82 1b       	sub	r24, r18
    3b4c:	93 0b       	sbc	r25, r19
    3b4e:	9a 83       	std	Y+2, r25	; 0x02
    3b50:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    3b52:	e8 85       	ldd	r30, Y+8	; 0x08
    3b54:	f9 85       	ldd	r31, Y+9	; 0x09
    3b56:	80 81       	ld	r24, Z
    3b58:	91 81       	ldd	r25, Z+1	; 0x01
    3b5a:	2f ef       	ldi	r18, 0xFF	; 255
    3b5c:	8f 3f       	cpi	r24, 0xFF	; 255
    3b5e:	92 07       	cpc	r25, r18
    3b60:	11 f4       	brne	.+4      	; 0x3b66 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    3b62:	1d 82       	std	Y+5, r1	; 0x05
    3b64:	36 c0       	rjmp	.+108    	; 0x3bd2 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3b66:	ee 81       	ldd	r30, Y+6	; 0x06
    3b68:	ff 81       	ldd	r31, Y+7	; 0x07
    3b6a:	90 81       	ld	r25, Z
    3b6c:	80 91 60 04 	lds	r24, 0x0460
    3b70:	98 17       	cp	r25, r24
    3b72:	61 f0       	breq	.+24     	; 0x3b8c <xTaskCheckForTimeOut+0x7c>
    3b74:	ee 81       	ldd	r30, Y+6	; 0x06
    3b76:	ff 81       	ldd	r31, Y+7	; 0x07
    3b78:	21 81       	ldd	r18, Z+1	; 0x01
    3b7a:	32 81       	ldd	r19, Z+2	; 0x02
    3b7c:	8b 81       	ldd	r24, Y+3	; 0x03
    3b7e:	9c 81       	ldd	r25, Y+4	; 0x04
    3b80:	82 17       	cp	r24, r18
    3b82:	93 07       	cpc	r25, r19
    3b84:	18 f0       	brcs	.+6      	; 0x3b8c <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3b86:	81 e0       	ldi	r24, 0x01	; 1
    3b88:	8d 83       	std	Y+5, r24	; 0x05
    3b8a:	23 c0       	rjmp	.+70     	; 0x3bd2 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3b8c:	e8 85       	ldd	r30, Y+8	; 0x08
    3b8e:	f9 85       	ldd	r31, Y+9	; 0x09
    3b90:	20 81       	ld	r18, Z
    3b92:	31 81       	ldd	r19, Z+1	; 0x01
    3b94:	89 81       	ldd	r24, Y+1	; 0x01
    3b96:	9a 81       	ldd	r25, Y+2	; 0x02
    3b98:	82 17       	cp	r24, r18
    3b9a:	93 07       	cpc	r25, r19
    3b9c:	a0 f4       	brcc	.+40     	; 0x3bc6 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3b9e:	e8 85       	ldd	r30, Y+8	; 0x08
    3ba0:	f9 85       	ldd	r31, Y+9	; 0x09
    3ba2:	20 81       	ld	r18, Z
    3ba4:	31 81       	ldd	r19, Z+1	; 0x01
    3ba6:	89 81       	ldd	r24, Y+1	; 0x01
    3ba8:	9a 81       	ldd	r25, Y+2	; 0x02
    3baa:	a9 01       	movw	r20, r18
    3bac:	48 1b       	sub	r20, r24
    3bae:	59 0b       	sbc	r21, r25
    3bb0:	ca 01       	movw	r24, r20
    3bb2:	e8 85       	ldd	r30, Y+8	; 0x08
    3bb4:	f9 85       	ldd	r31, Y+9	; 0x09
    3bb6:	91 83       	std	Z+1, r25	; 0x01
    3bb8:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3bba:	8e 81       	ldd	r24, Y+6	; 0x06
    3bbc:	9f 81       	ldd	r25, Y+7	; 0x07
    3bbe:	0e 94 6f 1d 	call	0x3ade	; 0x3ade <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3bc2:	1d 82       	std	Y+5, r1	; 0x05
    3bc4:	06 c0       	rjmp	.+12     	; 0x3bd2 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    3bc6:	e8 85       	ldd	r30, Y+8	; 0x08
    3bc8:	f9 85       	ldd	r31, Y+9	; 0x09
    3bca:	11 82       	std	Z+1, r1	; 0x01
    3bcc:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    3bce:	81 e0       	ldi	r24, 0x01	; 1
    3bd0:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    3bd2:	0f 90       	pop	r0
    3bd4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3bd6:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3bd8:	29 96       	adiw	r28, 0x09	; 9
    3bda:	0f b6       	in	r0, 0x3f	; 63
    3bdc:	f8 94       	cli
    3bde:	de bf       	out	0x3e, r29	; 62
    3be0:	0f be       	out	0x3f, r0	; 63
    3be2:	cd bf       	out	0x3d, r28	; 61
    3be4:	cf 91       	pop	r28
    3be6:	df 91       	pop	r29
    3be8:	08 95       	ret

00003bea <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3bea:	df 93       	push	r29
    3bec:	cf 93       	push	r28
    3bee:	cd b7       	in	r28, 0x3d	; 61
    3bf0:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3bf2:	81 e0       	ldi	r24, 0x01	; 1
    3bf4:	80 93 5f 04 	sts	0x045F, r24
}
    3bf8:	cf 91       	pop	r28
    3bfa:	df 91       	pop	r29
    3bfc:	08 95       	ret

00003bfe <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3bfe:	df 93       	push	r29
    3c00:	cf 93       	push	r28
    3c02:	00 d0       	rcall	.+0      	; 0x3c04 <prvIdleTask+0x6>
    3c04:	cd b7       	in	r28, 0x3d	; 61
    3c06:	de b7       	in	r29, 0x3e	; 62
    3c08:	9a 83       	std	Y+2, r25	; 0x02
    3c0a:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    3c0c:	0e 94 4a 1e 	call	0x3c94	; 0x3c94 <prvCheckTasksWaitingTermination>
    3c10:	fd cf       	rjmp	.-6      	; 0x3c0c <prvIdleTask+0xe>

00003c12 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3c12:	df 93       	push	r29
    3c14:	cf 93       	push	r28
    3c16:	0f 92       	push	r0
    3c18:	cd b7       	in	r28, 0x3d	; 61
    3c1a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3c1c:	19 82       	std	Y+1, r1	; 0x01
    3c1e:	13 c0       	rjmp	.+38     	; 0x3c46 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3c20:	89 81       	ldd	r24, Y+1	; 0x01
    3c22:	28 2f       	mov	r18, r24
    3c24:	30 e0       	ldi	r19, 0x00	; 0
    3c26:	c9 01       	movw	r24, r18
    3c28:	88 0f       	add	r24, r24
    3c2a:	99 1f       	adc	r25, r25
    3c2c:	88 0f       	add	r24, r24
    3c2e:	99 1f       	adc	r25, r25
    3c30:	88 0f       	add	r24, r24
    3c32:	99 1f       	adc	r25, r25
    3c34:	82 0f       	add	r24, r18
    3c36:	93 1f       	adc	r25, r19
    3c38:	89 59       	subi	r24, 0x99	; 153
    3c3a:	9b 4f       	sbci	r25, 0xFB	; 251
    3c3c:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3c40:	89 81       	ldd	r24, Y+1	; 0x01
    3c42:	8f 5f       	subi	r24, 0xFF	; 255
    3c44:	89 83       	std	Y+1, r24	; 0x01
    3c46:	89 81       	ldd	r24, Y+1	; 0x01
    3c48:	85 30       	cpi	r24, 0x05	; 5
    3c4a:	50 f3       	brcs	.-44     	; 0x3c20 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3c4c:	84 e9       	ldi	r24, 0x94	; 148
    3c4e:	94 e0       	ldi	r25, 0x04	; 4
    3c50:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3c54:	8d e9       	ldi	r24, 0x9D	; 157
    3c56:	94 e0       	ldi	r25, 0x04	; 4
    3c58:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3c5c:	8a ea       	ldi	r24, 0xAA	; 170
    3c5e:	94 e0       	ldi	r25, 0x04	; 4
    3c60:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3c64:	83 eb       	ldi	r24, 0xB3	; 179
    3c66:	94 e0       	ldi	r25, 0x04	; 4
    3c68:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    3c6c:	8c eb       	ldi	r24, 0xBC	; 188
    3c6e:	94 e0       	ldi	r25, 0x04	; 4
    3c70:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3c74:	84 e9       	ldi	r24, 0x94	; 148
    3c76:	94 e0       	ldi	r25, 0x04	; 4
    3c78:	90 93 a7 04 	sts	0x04A7, r25
    3c7c:	80 93 a6 04 	sts	0x04A6, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3c80:	8d e9       	ldi	r24, 0x9D	; 157
    3c82:	94 e0       	ldi	r25, 0x04	; 4
    3c84:	90 93 a9 04 	sts	0x04A9, r25
    3c88:	80 93 a8 04 	sts	0x04A8, r24
}
    3c8c:	0f 90       	pop	r0
    3c8e:	cf 91       	pop	r28
    3c90:	df 91       	pop	r29
    3c92:	08 95       	ret

00003c94 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3c94:	df 93       	push	r29
    3c96:	cf 93       	push	r28
    3c98:	00 d0       	rcall	.+0      	; 0x3c9a <prvCheckTasksWaitingTermination+0x6>
    3c9a:	cd b7       	in	r28, 0x3d	; 61
    3c9c:	de b7       	in	r29, 0x3e	; 62
    3c9e:	20 c0       	rjmp	.+64     	; 0x3ce0 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    3ca0:	0f b6       	in	r0, 0x3f	; 63
    3ca2:	f8 94       	cli
    3ca4:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ca6:	e0 91 b8 04 	lds	r30, 0x04B8
    3caa:	f0 91 b9 04 	lds	r31, 0x04B9
    3cae:	86 81       	ldd	r24, Z+6	; 0x06
    3cb0:	97 81       	ldd	r25, Z+7	; 0x07
    3cb2:	9a 83       	std	Y+2, r25	; 0x02
    3cb4:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3cb6:	89 81       	ldd	r24, Y+1	; 0x01
    3cb8:	9a 81       	ldd	r25, Y+2	; 0x02
    3cba:	02 96       	adiw	r24, 0x02	; 2
    3cbc:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
				--uxCurrentNumberOfTasks;
    3cc0:	80 91 58 04 	lds	r24, 0x0458
    3cc4:	81 50       	subi	r24, 0x01	; 1
    3cc6:	80 93 58 04 	sts	0x0458, r24
				--uxDeletedTasksWaitingCleanUp;
    3cca:	80 91 57 04 	lds	r24, 0x0457
    3cce:	81 50       	subi	r24, 0x01	; 1
    3cd0:	80 93 57 04 	sts	0x0457, r24
			}
			taskEXIT_CRITICAL();
    3cd4:	0f 90       	pop	r0
    3cd6:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    3cd8:	89 81       	ldd	r24, Y+1	; 0x01
    3cda:	9a 81       	ldd	r25, Y+2	; 0x02
    3cdc:	0e 94 79 1e 	call	0x3cf2	; 0x3cf2 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3ce0:	80 91 57 04 	lds	r24, 0x0457
    3ce4:	88 23       	and	r24, r24
    3ce6:	e1 f6       	brne	.-72     	; 0x3ca0 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    3ce8:	0f 90       	pop	r0
    3cea:	0f 90       	pop	r0
    3cec:	cf 91       	pop	r28
    3cee:	df 91       	pop	r29
    3cf0:	08 95       	ret

00003cf2 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    3cf2:	df 93       	push	r29
    3cf4:	cf 93       	push	r28
    3cf6:	00 d0       	rcall	.+0      	; 0x3cf8 <prvDeleteTCB+0x6>
    3cf8:	cd b7       	in	r28, 0x3d	; 61
    3cfa:	de b7       	in	r29, 0x3e	; 62
    3cfc:	9a 83       	std	Y+2, r25	; 0x02
    3cfe:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    3d00:	e9 81       	ldd	r30, Y+1	; 0x01
    3d02:	fa 81       	ldd	r31, Y+2	; 0x02
    3d04:	87 89       	ldd	r24, Z+23	; 0x17
    3d06:	90 8d       	ldd	r25, Z+24	; 0x18
    3d08:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <vPortFree>
			vPortFree( pxTCB );
    3d0c:	89 81       	ldd	r24, Y+1	; 0x01
    3d0e:	9a 81       	ldd	r25, Y+2	; 0x02
    3d10:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    3d14:	0f 90       	pop	r0
    3d16:	0f 90       	pop	r0
    3d18:	cf 91       	pop	r28
    3d1a:	df 91       	pop	r29
    3d1c:	08 95       	ret

00003d1e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3d1e:	df 93       	push	r29
    3d20:	cf 93       	push	r28
    3d22:	00 d0       	rcall	.+0      	; 0x3d24 <prvResetNextTaskUnblockTime+0x6>
    3d24:	cd b7       	in	r28, 0x3d	; 61
    3d26:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3d28:	e0 91 a6 04 	lds	r30, 0x04A6
    3d2c:	f0 91 a7 04 	lds	r31, 0x04A7
    3d30:	80 81       	ld	r24, Z
    3d32:	88 23       	and	r24, r24
    3d34:	39 f4       	brne	.+14     	; 0x3d44 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3d36:	8f ef       	ldi	r24, 0xFF	; 255
    3d38:	9f ef       	ldi	r25, 0xFF	; 255
    3d3a:	90 93 63 04 	sts	0x0463, r25
    3d3e:	80 93 62 04 	sts	0x0462, r24
    3d42:	13 c0       	rjmp	.+38     	; 0x3d6a <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d44:	e0 91 a6 04 	lds	r30, 0x04A6
    3d48:	f0 91 a7 04 	lds	r31, 0x04A7
    3d4c:	05 80       	ldd	r0, Z+5	; 0x05
    3d4e:	f6 81       	ldd	r31, Z+6	; 0x06
    3d50:	e0 2d       	mov	r30, r0
    3d52:	86 81       	ldd	r24, Z+6	; 0x06
    3d54:	97 81       	ldd	r25, Z+7	; 0x07
    3d56:	9a 83       	std	Y+2, r25	; 0x02
    3d58:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    3d5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d5e:	82 81       	ldd	r24, Z+2	; 0x02
    3d60:	93 81       	ldd	r25, Z+3	; 0x03
    3d62:	90 93 63 04 	sts	0x0463, r25
    3d66:	80 93 62 04 	sts	0x0462, r24
	}
}
    3d6a:	0f 90       	pop	r0
    3d6c:	0f 90       	pop	r0
    3d6e:	cf 91       	pop	r28
    3d70:	df 91       	pop	r29
    3d72:	08 95       	ret

00003d74 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    3d74:	df 93       	push	r29
    3d76:	cf 93       	push	r28
    3d78:	00 d0       	rcall	.+0      	; 0x3d7a <uxTaskResetEventItemValue+0x6>
    3d7a:	cd b7       	in	r28, 0x3d	; 61
    3d7c:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    3d7e:	e0 91 55 04 	lds	r30, 0x0455
    3d82:	f0 91 56 04 	lds	r31, 0x0456
    3d86:	84 85       	ldd	r24, Z+12	; 0x0c
    3d88:	95 85       	ldd	r25, Z+13	; 0x0d
    3d8a:	9a 83       	std	Y+2, r25	; 0x02
    3d8c:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3d8e:	a0 91 55 04 	lds	r26, 0x0455
    3d92:	b0 91 56 04 	lds	r27, 0x0456
    3d96:	e0 91 55 04 	lds	r30, 0x0455
    3d9a:	f0 91 56 04 	lds	r31, 0x0456
    3d9e:	86 89       	ldd	r24, Z+22	; 0x16
    3da0:	28 2f       	mov	r18, r24
    3da2:	30 e0       	ldi	r19, 0x00	; 0
    3da4:	85 e0       	ldi	r24, 0x05	; 5
    3da6:	90 e0       	ldi	r25, 0x00	; 0
    3da8:	82 1b       	sub	r24, r18
    3daa:	93 0b       	sbc	r25, r19
    3dac:	1d 96       	adiw	r26, 0x0d	; 13
    3dae:	9c 93       	st	X, r25
    3db0:	8e 93       	st	-X, r24
    3db2:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    3db4:	89 81       	ldd	r24, Y+1	; 0x01
    3db6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3db8:	0f 90       	pop	r0
    3dba:	0f 90       	pop	r0
    3dbc:	cf 91       	pop	r28
    3dbe:	df 91       	pop	r29
    3dc0:	08 95       	ret

00003dc2 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    3dc2:	df 93       	push	r29
    3dc4:	cf 93       	push	r28
    3dc6:	cd b7       	in	r28, 0x3d	; 61
    3dc8:	de b7       	in	r29, 0x3e	; 62
    3dca:	27 97       	sbiw	r28, 0x07	; 7
    3dcc:	0f b6       	in	r0, 0x3f	; 63
    3dce:	f8 94       	cli
    3dd0:	de bf       	out	0x3e, r29	; 62
    3dd2:	0f be       	out	0x3f, r0	; 63
    3dd4:	cd bf       	out	0x3d, r28	; 61
    3dd6:	8d 83       	std	Y+5, r24	; 0x05
    3dd8:	7f 83       	std	Y+7, r23	; 0x07
    3dda:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    3ddc:	0f b6       	in	r0, 0x3f	; 63
    3dde:	f8 94       	cli
    3de0:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    3de2:	e0 91 55 04 	lds	r30, 0x0455
    3de6:	f0 91 56 04 	lds	r31, 0x0456
    3dea:	81 a1       	ldd	r24, Z+33	; 0x21
    3dec:	92 a1       	ldd	r25, Z+34	; 0x22
    3dee:	a3 a1       	ldd	r26, Z+35	; 0x23
    3df0:	b4 a1       	ldd	r27, Z+36	; 0x24
    3df2:	00 97       	sbiw	r24, 0x00	; 0
    3df4:	a1 05       	cpc	r26, r1
    3df6:	b1 05       	cpc	r27, r1
    3df8:	89 f4       	brne	.+34     	; 0x3e1c <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3dfa:	e0 91 55 04 	lds	r30, 0x0455
    3dfe:	f0 91 56 04 	lds	r31, 0x0456
    3e02:	81 e0       	ldi	r24, 0x01	; 1
    3e04:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    3e06:	8e 81       	ldd	r24, Y+6	; 0x06
    3e08:	9f 81       	ldd	r25, Y+7	; 0x07
    3e0a:	00 97       	sbiw	r24, 0x00	; 0
    3e0c:	39 f0       	breq	.+14     	; 0x3e1c <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3e0e:	8e 81       	ldd	r24, Y+6	; 0x06
    3e10:	9f 81       	ldd	r25, Y+7	; 0x07
    3e12:	61 e0       	ldi	r22, 0x01	; 1
    3e14:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3e18:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3e1c:	0f 90       	pop	r0
    3e1e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3e20:	0f b6       	in	r0, 0x3f	; 63
    3e22:	f8 94       	cli
    3e24:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    3e26:	e0 91 55 04 	lds	r30, 0x0455
    3e2a:	f0 91 56 04 	lds	r31, 0x0456
    3e2e:	81 a1       	ldd	r24, Z+33	; 0x21
    3e30:	92 a1       	ldd	r25, Z+34	; 0x22
    3e32:	a3 a1       	ldd	r26, Z+35	; 0x23
    3e34:	b4 a1       	ldd	r27, Z+36	; 0x24
    3e36:	89 83       	std	Y+1, r24	; 0x01
    3e38:	9a 83       	std	Y+2, r25	; 0x02
    3e3a:	ab 83       	std	Y+3, r26	; 0x03
    3e3c:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    3e3e:	89 81       	ldd	r24, Y+1	; 0x01
    3e40:	9a 81       	ldd	r25, Y+2	; 0x02
    3e42:	ab 81       	ldd	r26, Y+3	; 0x03
    3e44:	bc 81       	ldd	r27, Y+4	; 0x04
    3e46:	00 97       	sbiw	r24, 0x00	; 0
    3e48:	a1 05       	cpc	r26, r1
    3e4a:	b1 05       	cpc	r27, r1
    3e4c:	d9 f0       	breq	.+54     	; 0x3e84 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    3e4e:	8d 81       	ldd	r24, Y+5	; 0x05
    3e50:	88 23       	and	r24, r24
    3e52:	49 f0       	breq	.+18     	; 0x3e66 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    3e54:	e0 91 55 04 	lds	r30, 0x0455
    3e58:	f0 91 56 04 	lds	r31, 0x0456
    3e5c:	11 a2       	std	Z+33, r1	; 0x21
    3e5e:	12 a2       	std	Z+34, r1	; 0x22
    3e60:	13 a2       	std	Z+35, r1	; 0x23
    3e62:	14 a2       	std	Z+36, r1	; 0x24
    3e64:	0f c0       	rjmp	.+30     	; 0x3e84 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    3e66:	e0 91 55 04 	lds	r30, 0x0455
    3e6a:	f0 91 56 04 	lds	r31, 0x0456
    3e6e:	89 81       	ldd	r24, Y+1	; 0x01
    3e70:	9a 81       	ldd	r25, Y+2	; 0x02
    3e72:	ab 81       	ldd	r26, Y+3	; 0x03
    3e74:	bc 81       	ldd	r27, Y+4	; 0x04
    3e76:	01 97       	sbiw	r24, 0x01	; 1
    3e78:	a1 09       	sbc	r26, r1
    3e7a:	b1 09       	sbc	r27, r1
    3e7c:	81 a3       	std	Z+33, r24	; 0x21
    3e7e:	92 a3       	std	Z+34, r25	; 0x22
    3e80:	a3 a3       	std	Z+35, r26	; 0x23
    3e82:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3e84:	e0 91 55 04 	lds	r30, 0x0455
    3e88:	f0 91 56 04 	lds	r31, 0x0456
    3e8c:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3e8e:	0f 90       	pop	r0
    3e90:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    3e92:	89 81       	ldd	r24, Y+1	; 0x01
    3e94:	9a 81       	ldd	r25, Y+2	; 0x02
    3e96:	ab 81       	ldd	r26, Y+3	; 0x03
    3e98:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3e9a:	bc 01       	movw	r22, r24
    3e9c:	cd 01       	movw	r24, r26
    3e9e:	27 96       	adiw	r28, 0x07	; 7
    3ea0:	0f b6       	in	r0, 0x3f	; 63
    3ea2:	f8 94       	cli
    3ea4:	de bf       	out	0x3e, r29	; 62
    3ea6:	0f be       	out	0x3f, r0	; 63
    3ea8:	cd bf       	out	0x3d, r28	; 61
    3eaa:	cf 91       	pop	r28
    3eac:	df 91       	pop	r29
    3eae:	08 95       	ret

00003eb0 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    3eb0:	ef 92       	push	r14
    3eb2:	ff 92       	push	r15
    3eb4:	0f 93       	push	r16
    3eb6:	1f 93       	push	r17
    3eb8:	df 93       	push	r29
    3eba:	cf 93       	push	r28
    3ebc:	cd b7       	in	r28, 0x3d	; 61
    3ebe:	de b7       	in	r29, 0x3e	; 62
    3ec0:	2d 97       	sbiw	r28, 0x0d	; 13
    3ec2:	0f b6       	in	r0, 0x3f	; 63
    3ec4:	f8 94       	cli
    3ec6:	de bf       	out	0x3e, r29	; 62
    3ec8:	0f be       	out	0x3f, r0	; 63
    3eca:	cd bf       	out	0x3d, r28	; 61
    3ecc:	6a 83       	std	Y+2, r22	; 0x02
    3ece:	7b 83       	std	Y+3, r23	; 0x03
    3ed0:	8c 83       	std	Y+4, r24	; 0x04
    3ed2:	9d 83       	std	Y+5, r25	; 0x05
    3ed4:	2e 83       	std	Y+6, r18	; 0x06
    3ed6:	3f 83       	std	Y+7, r19	; 0x07
    3ed8:	48 87       	std	Y+8, r20	; 0x08
    3eda:	59 87       	std	Y+9, r21	; 0x09
    3edc:	1b 87       	std	Y+11, r17	; 0x0b
    3ede:	0a 87       	std	Y+10, r16	; 0x0a
    3ee0:	fd 86       	std	Y+13, r15	; 0x0d
    3ee2:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    3ee4:	0f b6       	in	r0, 0x3f	; 63
    3ee6:	f8 94       	cli
    3ee8:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3eea:	e0 91 55 04 	lds	r30, 0x0455
    3eee:	f0 91 56 04 	lds	r31, 0x0456
    3ef2:	85 a1       	ldd	r24, Z+37	; 0x25
    3ef4:	82 30       	cpi	r24, 0x02	; 2
    3ef6:	49 f1       	breq	.+82     	; 0x3f4a <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    3ef8:	e0 91 55 04 	lds	r30, 0x0455
    3efc:	f0 91 56 04 	lds	r31, 0x0456
    3f00:	21 a1       	ldd	r18, Z+33	; 0x21
    3f02:	32 a1       	ldd	r19, Z+34	; 0x22
    3f04:	43 a1       	ldd	r20, Z+35	; 0x23
    3f06:	54 a1       	ldd	r21, Z+36	; 0x24
    3f08:	8a 81       	ldd	r24, Y+2	; 0x02
    3f0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3f0c:	ac 81       	ldd	r26, Y+4	; 0x04
    3f0e:	bd 81       	ldd	r27, Y+5	; 0x05
    3f10:	80 95       	com	r24
    3f12:	90 95       	com	r25
    3f14:	a0 95       	com	r26
    3f16:	b0 95       	com	r27
    3f18:	82 23       	and	r24, r18
    3f1a:	93 23       	and	r25, r19
    3f1c:	a4 23       	and	r26, r20
    3f1e:	b5 23       	and	r27, r21
    3f20:	81 a3       	std	Z+33, r24	; 0x21
    3f22:	92 a3       	std	Z+34, r25	; 0x22
    3f24:	a3 a3       	std	Z+35, r26	; 0x23
    3f26:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    3f28:	e0 91 55 04 	lds	r30, 0x0455
    3f2c:	f0 91 56 04 	lds	r31, 0x0456
    3f30:	81 e0       	ldi	r24, 0x01	; 1
    3f32:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    3f34:	8c 85       	ldd	r24, Y+12	; 0x0c
    3f36:	9d 85       	ldd	r25, Y+13	; 0x0d
    3f38:	00 97       	sbiw	r24, 0x00	; 0
    3f3a:	39 f0       	breq	.+14     	; 0x3f4a <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3f3c:	8c 85       	ldd	r24, Y+12	; 0x0c
    3f3e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3f40:	61 e0       	ldi	r22, 0x01	; 1
    3f42:	0e 94 e4 22 	call	0x45c8	; 0x45c8 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3f46:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3f4a:	0f 90       	pop	r0
    3f4c:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3f4e:	0f b6       	in	r0, 0x3f	; 63
    3f50:	f8 94       	cli
    3f52:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    3f54:	8a 85       	ldd	r24, Y+10	; 0x0a
    3f56:	9b 85       	ldd	r25, Y+11	; 0x0b
    3f58:	00 97       	sbiw	r24, 0x00	; 0
    3f5a:	71 f0       	breq	.+28     	; 0x3f78 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    3f5c:	e0 91 55 04 	lds	r30, 0x0455
    3f60:	f0 91 56 04 	lds	r31, 0x0456
    3f64:	81 a1       	ldd	r24, Z+33	; 0x21
    3f66:	92 a1       	ldd	r25, Z+34	; 0x22
    3f68:	a3 a1       	ldd	r26, Z+35	; 0x23
    3f6a:	b4 a1       	ldd	r27, Z+36	; 0x24
    3f6c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3f6e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3f70:	80 83       	st	Z, r24
    3f72:	91 83       	std	Z+1, r25	; 0x01
    3f74:	a2 83       	std	Z+2, r26	; 0x02
    3f76:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    3f78:	e0 91 55 04 	lds	r30, 0x0455
    3f7c:	f0 91 56 04 	lds	r31, 0x0456
    3f80:	85 a1       	ldd	r24, Z+37	; 0x25
    3f82:	82 30       	cpi	r24, 0x02	; 2
    3f84:	11 f0       	breq	.+4      	; 0x3f8a <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    3f86:	19 82       	std	Y+1, r1	; 0x01
    3f88:	1a c0       	rjmp	.+52     	; 0x3fbe <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3f8a:	e0 91 55 04 	lds	r30, 0x0455
    3f8e:	f0 91 56 04 	lds	r31, 0x0456
    3f92:	21 a1       	ldd	r18, Z+33	; 0x21
    3f94:	32 a1       	ldd	r19, Z+34	; 0x22
    3f96:	43 a1       	ldd	r20, Z+35	; 0x23
    3f98:	54 a1       	ldd	r21, Z+36	; 0x24
    3f9a:	8e 81       	ldd	r24, Y+6	; 0x06
    3f9c:	9f 81       	ldd	r25, Y+7	; 0x07
    3f9e:	a8 85       	ldd	r26, Y+8	; 0x08
    3fa0:	b9 85       	ldd	r27, Y+9	; 0x09
    3fa2:	80 95       	com	r24
    3fa4:	90 95       	com	r25
    3fa6:	a0 95       	com	r26
    3fa8:	b0 95       	com	r27
    3faa:	82 23       	and	r24, r18
    3fac:	93 23       	and	r25, r19
    3fae:	a4 23       	and	r26, r20
    3fb0:	b5 23       	and	r27, r21
    3fb2:	81 a3       	std	Z+33, r24	; 0x21
    3fb4:	92 a3       	std	Z+34, r25	; 0x22
    3fb6:	a3 a3       	std	Z+35, r26	; 0x23
    3fb8:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    3fba:	81 e0       	ldi	r24, 0x01	; 1
    3fbc:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3fbe:	e0 91 55 04 	lds	r30, 0x0455
    3fc2:	f0 91 56 04 	lds	r31, 0x0456
    3fc6:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3fc8:	0f 90       	pop	r0
    3fca:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3fcc:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3fce:	2d 96       	adiw	r28, 0x0d	; 13
    3fd0:	0f b6       	in	r0, 0x3f	; 63
    3fd2:	f8 94       	cli
    3fd4:	de bf       	out	0x3e, r29	; 62
    3fd6:	0f be       	out	0x3f, r0	; 63
    3fd8:	cd bf       	out	0x3d, r28	; 61
    3fda:	cf 91       	pop	r28
    3fdc:	df 91       	pop	r29
    3fde:	1f 91       	pop	r17
    3fe0:	0f 91       	pop	r16
    3fe2:	ff 90       	pop	r15
    3fe4:	ef 90       	pop	r14
    3fe6:	08 95       	ret

00003fe8 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    3fe8:	0f 93       	push	r16
    3fea:	1f 93       	push	r17
    3fec:	df 93       	push	r29
    3fee:	cf 93       	push	r28
    3ff0:	cd b7       	in	r28, 0x3d	; 61
    3ff2:	de b7       	in	r29, 0x3e	; 62
    3ff4:	2f 97       	sbiw	r28, 0x0f	; 15
    3ff6:	0f b6       	in	r0, 0x3f	; 63
    3ff8:	f8 94       	cli
    3ffa:	de bf       	out	0x3e, r29	; 62
    3ffc:	0f be       	out	0x3f, r0	; 63
    3ffe:	cd bf       	out	0x3d, r28	; 61
    4000:	9e 83       	std	Y+6, r25	; 0x06
    4002:	8d 83       	std	Y+5, r24	; 0x05
    4004:	4f 83       	std	Y+7, r20	; 0x07
    4006:	58 87       	std	Y+8, r21	; 0x08
    4008:	69 87       	std	Y+9, r22	; 0x09
    400a:	7a 87       	std	Y+10, r23	; 0x0a
    400c:	2b 87       	std	Y+11, r18	; 0x0b
    400e:	1d 87       	std	Y+13, r17	; 0x0d
    4010:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    4012:	81 e0       	ldi	r24, 0x01	; 1
    4014:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    4016:	8d 81       	ldd	r24, Y+5	; 0x05
    4018:	9e 81       	ldd	r25, Y+6	; 0x06
    401a:	9c 83       	std	Y+4, r25	; 0x04
    401c:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    401e:	0f b6       	in	r0, 0x3f	; 63
    4020:	f8 94       	cli
    4022:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    4024:	8c 85       	ldd	r24, Y+12	; 0x0c
    4026:	9d 85       	ldd	r25, Y+13	; 0x0d
    4028:	00 97       	sbiw	r24, 0x00	; 0
    402a:	61 f0       	breq	.+24     	; 0x4044 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    402c:	eb 81       	ldd	r30, Y+3	; 0x03
    402e:	fc 81       	ldd	r31, Y+4	; 0x04
    4030:	81 a1       	ldd	r24, Z+33	; 0x21
    4032:	92 a1       	ldd	r25, Z+34	; 0x22
    4034:	a3 a1       	ldd	r26, Z+35	; 0x23
    4036:	b4 a1       	ldd	r27, Z+36	; 0x24
    4038:	ec 85       	ldd	r30, Y+12	; 0x0c
    403a:	fd 85       	ldd	r31, Y+13	; 0x0d
    403c:	80 83       	st	Z, r24
    403e:	91 83       	std	Z+1, r25	; 0x01
    4040:	a2 83       	std	Z+2, r26	; 0x02
    4042:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4044:	eb 81       	ldd	r30, Y+3	; 0x03
    4046:	fc 81       	ldd	r31, Y+4	; 0x04
    4048:	85 a1       	ldd	r24, Z+37	; 0x25
    404a:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    404c:	eb 81       	ldd	r30, Y+3	; 0x03
    404e:	fc 81       	ldd	r31, Y+4	; 0x04
    4050:	82 e0       	ldi	r24, 0x02	; 2
    4052:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    4054:	8b 85       	ldd	r24, Y+11	; 0x0b
    4056:	28 2f       	mov	r18, r24
    4058:	30 e0       	ldi	r19, 0x00	; 0
    405a:	3f 87       	std	Y+15, r19	; 0x0f
    405c:	2e 87       	std	Y+14, r18	; 0x0e
    405e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4060:	9f 85       	ldd	r25, Y+15	; 0x0f
    4062:	82 30       	cpi	r24, 0x02	; 2
    4064:	91 05       	cpc	r25, r1
    4066:	59 f1       	breq	.+86     	; 0x40be <xTaskGenericNotify+0xd6>
    4068:	2e 85       	ldd	r18, Y+14	; 0x0e
    406a:	3f 85       	ldd	r19, Y+15	; 0x0f
    406c:	23 30       	cpi	r18, 0x03	; 3
    406e:	31 05       	cpc	r19, r1
    4070:	34 f4       	brge	.+12     	; 0x407e <xTaskGenericNotify+0x96>
    4072:	8e 85       	ldd	r24, Y+14	; 0x0e
    4074:	9f 85       	ldd	r25, Y+15	; 0x0f
    4076:	81 30       	cpi	r24, 0x01	; 1
    4078:	91 05       	cpc	r25, r1
    407a:	61 f0       	breq	.+24     	; 0x4094 <xTaskGenericNotify+0xac>
    407c:	4a c0       	rjmp	.+148    	; 0x4112 <xTaskGenericNotify+0x12a>
    407e:	2e 85       	ldd	r18, Y+14	; 0x0e
    4080:	3f 85       	ldd	r19, Y+15	; 0x0f
    4082:	23 30       	cpi	r18, 0x03	; 3
    4084:	31 05       	cpc	r19, r1
    4086:	59 f1       	breq	.+86     	; 0x40de <xTaskGenericNotify+0xf6>
    4088:	8e 85       	ldd	r24, Y+14	; 0x0e
    408a:	9f 85       	ldd	r25, Y+15	; 0x0f
    408c:	84 30       	cpi	r24, 0x04	; 4
    408e:	91 05       	cpc	r25, r1
    4090:	89 f1       	breq	.+98     	; 0x40f4 <xTaskGenericNotify+0x10c>
    4092:	3f c0       	rjmp	.+126    	; 0x4112 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4094:	eb 81       	ldd	r30, Y+3	; 0x03
    4096:	fc 81       	ldd	r31, Y+4	; 0x04
    4098:	21 a1       	ldd	r18, Z+33	; 0x21
    409a:	32 a1       	ldd	r19, Z+34	; 0x22
    409c:	43 a1       	ldd	r20, Z+35	; 0x23
    409e:	54 a1       	ldd	r21, Z+36	; 0x24
    40a0:	8f 81       	ldd	r24, Y+7	; 0x07
    40a2:	98 85       	ldd	r25, Y+8	; 0x08
    40a4:	a9 85       	ldd	r26, Y+9	; 0x09
    40a6:	ba 85       	ldd	r27, Y+10	; 0x0a
    40a8:	82 2b       	or	r24, r18
    40aa:	93 2b       	or	r25, r19
    40ac:	a4 2b       	or	r26, r20
    40ae:	b5 2b       	or	r27, r21
    40b0:	eb 81       	ldd	r30, Y+3	; 0x03
    40b2:	fc 81       	ldd	r31, Y+4	; 0x04
    40b4:	81 a3       	std	Z+33, r24	; 0x21
    40b6:	92 a3       	std	Z+34, r25	; 0x22
    40b8:	a3 a3       	std	Z+35, r26	; 0x23
    40ba:	b4 a3       	std	Z+36, r27	; 0x24
    40bc:	2a c0       	rjmp	.+84     	; 0x4112 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    40be:	eb 81       	ldd	r30, Y+3	; 0x03
    40c0:	fc 81       	ldd	r31, Y+4	; 0x04
    40c2:	81 a1       	ldd	r24, Z+33	; 0x21
    40c4:	92 a1       	ldd	r25, Z+34	; 0x22
    40c6:	a3 a1       	ldd	r26, Z+35	; 0x23
    40c8:	b4 a1       	ldd	r27, Z+36	; 0x24
    40ca:	01 96       	adiw	r24, 0x01	; 1
    40cc:	a1 1d       	adc	r26, r1
    40ce:	b1 1d       	adc	r27, r1
    40d0:	eb 81       	ldd	r30, Y+3	; 0x03
    40d2:	fc 81       	ldd	r31, Y+4	; 0x04
    40d4:	81 a3       	std	Z+33, r24	; 0x21
    40d6:	92 a3       	std	Z+34, r25	; 0x22
    40d8:	a3 a3       	std	Z+35, r26	; 0x23
    40da:	b4 a3       	std	Z+36, r27	; 0x24
    40dc:	1a c0       	rjmp	.+52     	; 0x4112 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    40de:	eb 81       	ldd	r30, Y+3	; 0x03
    40e0:	fc 81       	ldd	r31, Y+4	; 0x04
    40e2:	8f 81       	ldd	r24, Y+7	; 0x07
    40e4:	98 85       	ldd	r25, Y+8	; 0x08
    40e6:	a9 85       	ldd	r26, Y+9	; 0x09
    40e8:	ba 85       	ldd	r27, Y+10	; 0x0a
    40ea:	81 a3       	std	Z+33, r24	; 0x21
    40ec:	92 a3       	std	Z+34, r25	; 0x22
    40ee:	a3 a3       	std	Z+35, r26	; 0x23
    40f0:	b4 a3       	std	Z+36, r27	; 0x24
    40f2:	0f c0       	rjmp	.+30     	; 0x4112 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    40f4:	89 81       	ldd	r24, Y+1	; 0x01
    40f6:	82 30       	cpi	r24, 0x02	; 2
    40f8:	59 f0       	breq	.+22     	; 0x4110 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    40fa:	eb 81       	ldd	r30, Y+3	; 0x03
    40fc:	fc 81       	ldd	r31, Y+4	; 0x04
    40fe:	8f 81       	ldd	r24, Y+7	; 0x07
    4100:	98 85       	ldd	r25, Y+8	; 0x08
    4102:	a9 85       	ldd	r26, Y+9	; 0x09
    4104:	ba 85       	ldd	r27, Y+10	; 0x0a
    4106:	81 a3       	std	Z+33, r24	; 0x21
    4108:	92 a3       	std	Z+34, r25	; 0x22
    410a:	a3 a3       	std	Z+35, r26	; 0x23
    410c:	b4 a3       	std	Z+36, r27	; 0x24
    410e:	01 c0       	rjmp	.+2      	; 0x4112 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4110:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4112:	89 81       	ldd	r24, Y+1	; 0x01
    4114:	81 30       	cpi	r24, 0x01	; 1
    4116:	b9 f5       	brne	.+110    	; 0x4186 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4118:	8b 81       	ldd	r24, Y+3	; 0x03
    411a:	9c 81       	ldd	r25, Y+4	; 0x04
    411c:	02 96       	adiw	r24, 0x02	; 2
    411e:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    4122:	eb 81       	ldd	r30, Y+3	; 0x03
    4124:	fc 81       	ldd	r31, Y+4	; 0x04
    4126:	96 89       	ldd	r25, Z+22	; 0x16
    4128:	80 91 5b 04 	lds	r24, 0x045B
    412c:	89 17       	cp	r24, r25
    412e:	28 f4       	brcc	.+10     	; 0x413a <xTaskGenericNotify+0x152>
    4130:	eb 81       	ldd	r30, Y+3	; 0x03
    4132:	fc 81       	ldd	r31, Y+4	; 0x04
    4134:	86 89       	ldd	r24, Z+22	; 0x16
    4136:	80 93 5b 04 	sts	0x045B, r24
    413a:	eb 81       	ldd	r30, Y+3	; 0x03
    413c:	fc 81       	ldd	r31, Y+4	; 0x04
    413e:	86 89       	ldd	r24, Z+22	; 0x16
    4140:	28 2f       	mov	r18, r24
    4142:	30 e0       	ldi	r19, 0x00	; 0
    4144:	c9 01       	movw	r24, r18
    4146:	88 0f       	add	r24, r24
    4148:	99 1f       	adc	r25, r25
    414a:	88 0f       	add	r24, r24
    414c:	99 1f       	adc	r25, r25
    414e:	88 0f       	add	r24, r24
    4150:	99 1f       	adc	r25, r25
    4152:	82 0f       	add	r24, r18
    4154:	93 1f       	adc	r25, r19
    4156:	ac 01       	movw	r20, r24
    4158:	49 59       	subi	r20, 0x99	; 153
    415a:	5b 4f       	sbci	r21, 0xFB	; 251
    415c:	8b 81       	ldd	r24, Y+3	; 0x03
    415e:	9c 81       	ldd	r25, Y+4	; 0x04
    4160:	9c 01       	movw	r18, r24
    4162:	2e 5f       	subi	r18, 0xFE	; 254
    4164:	3f 4f       	sbci	r19, 0xFF	; 255
    4166:	ca 01       	movw	r24, r20
    4168:	b9 01       	movw	r22, r18
    416a:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    416e:	eb 81       	ldd	r30, Y+3	; 0x03
    4170:	fc 81       	ldd	r31, Y+4	; 0x04
    4172:	96 89       	ldd	r25, Z+22	; 0x16
    4174:	e0 91 55 04 	lds	r30, 0x0455
    4178:	f0 91 56 04 	lds	r31, 0x0456
    417c:	86 89       	ldd	r24, Z+22	; 0x16
    417e:	89 17       	cp	r24, r25
    4180:	10 f4       	brcc	.+4      	; 0x4186 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    4182:	0e 94 09 0c 	call	0x1812	; 0x1812 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4186:	0f 90       	pop	r0
    4188:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    418a:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    418c:	2f 96       	adiw	r28, 0x0f	; 15
    418e:	0f b6       	in	r0, 0x3f	; 63
    4190:	f8 94       	cli
    4192:	de bf       	out	0x3e, r29	; 62
    4194:	0f be       	out	0x3f, r0	; 63
    4196:	cd bf       	out	0x3d, r28	; 61
    4198:	cf 91       	pop	r28
    419a:	df 91       	pop	r29
    419c:	1f 91       	pop	r17
    419e:	0f 91       	pop	r16
    41a0:	08 95       	ret

000041a2 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    41a2:	ef 92       	push	r14
    41a4:	ff 92       	push	r15
    41a6:	0f 93       	push	r16
    41a8:	1f 93       	push	r17
    41aa:	df 93       	push	r29
    41ac:	cf 93       	push	r28
    41ae:	cd b7       	in	r28, 0x3d	; 61
    41b0:	de b7       	in	r29, 0x3e	; 62
    41b2:	62 97       	sbiw	r28, 0x12	; 18
    41b4:	0f b6       	in	r0, 0x3f	; 63
    41b6:	f8 94       	cli
    41b8:	de bf       	out	0x3e, r29	; 62
    41ba:	0f be       	out	0x3f, r0	; 63
    41bc:	cd bf       	out	0x3d, r28	; 61
    41be:	9f 83       	std	Y+7, r25	; 0x07
    41c0:	8e 83       	std	Y+6, r24	; 0x06
    41c2:	48 87       	std	Y+8, r20	; 0x08
    41c4:	59 87       	std	Y+9, r21	; 0x09
    41c6:	6a 87       	std	Y+10, r22	; 0x0a
    41c8:	7b 87       	std	Y+11, r23	; 0x0b
    41ca:	2c 87       	std	Y+12, r18	; 0x0c
    41cc:	1e 87       	std	Y+14, r17	; 0x0e
    41ce:	0d 87       	std	Y+13, r16	; 0x0d
    41d0:	f8 8a       	std	Y+16, r15	; 0x10
    41d2:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    41d4:	81 e0       	ldi	r24, 0x01	; 1
    41d6:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    41d8:	8e 81       	ldd	r24, Y+6	; 0x06
    41da:	9f 81       	ldd	r25, Y+7	; 0x07
    41dc:	9d 83       	std	Y+5, r25	; 0x05
    41de:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    41e0:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    41e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    41e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    41e6:	00 97       	sbiw	r24, 0x00	; 0
    41e8:	61 f0       	breq	.+24     	; 0x4202 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    41ea:	ec 81       	ldd	r30, Y+4	; 0x04
    41ec:	fd 81       	ldd	r31, Y+5	; 0x05
    41ee:	81 a1       	ldd	r24, Z+33	; 0x21
    41f0:	92 a1       	ldd	r25, Z+34	; 0x22
    41f2:	a3 a1       	ldd	r26, Z+35	; 0x23
    41f4:	b4 a1       	ldd	r27, Z+36	; 0x24
    41f6:	ed 85       	ldd	r30, Y+13	; 0x0d
    41f8:	fe 85       	ldd	r31, Y+14	; 0x0e
    41fa:	80 83       	st	Z, r24
    41fc:	91 83       	std	Z+1, r25	; 0x01
    41fe:	a2 83       	std	Z+2, r26	; 0x02
    4200:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4202:	ec 81       	ldd	r30, Y+4	; 0x04
    4204:	fd 81       	ldd	r31, Y+5	; 0x05
    4206:	85 a1       	ldd	r24, Z+37	; 0x25
    4208:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    420a:	ec 81       	ldd	r30, Y+4	; 0x04
    420c:	fd 81       	ldd	r31, Y+5	; 0x05
    420e:	82 e0       	ldi	r24, 0x02	; 2
    4210:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    4212:	8c 85       	ldd	r24, Y+12	; 0x0c
    4214:	28 2f       	mov	r18, r24
    4216:	30 e0       	ldi	r19, 0x00	; 0
    4218:	3a 8b       	std	Y+18, r19	; 0x12
    421a:	29 8b       	std	Y+17, r18	; 0x11
    421c:	89 89       	ldd	r24, Y+17	; 0x11
    421e:	9a 89       	ldd	r25, Y+18	; 0x12
    4220:	82 30       	cpi	r24, 0x02	; 2
    4222:	91 05       	cpc	r25, r1
    4224:	59 f1       	breq	.+86     	; 0x427c <xTaskGenericNotifyFromISR+0xda>
    4226:	29 89       	ldd	r18, Y+17	; 0x11
    4228:	3a 89       	ldd	r19, Y+18	; 0x12
    422a:	23 30       	cpi	r18, 0x03	; 3
    422c:	31 05       	cpc	r19, r1
    422e:	34 f4       	brge	.+12     	; 0x423c <xTaskGenericNotifyFromISR+0x9a>
    4230:	89 89       	ldd	r24, Y+17	; 0x11
    4232:	9a 89       	ldd	r25, Y+18	; 0x12
    4234:	81 30       	cpi	r24, 0x01	; 1
    4236:	91 05       	cpc	r25, r1
    4238:	61 f0       	breq	.+24     	; 0x4252 <xTaskGenericNotifyFromISR+0xb0>
    423a:	4a c0       	rjmp	.+148    	; 0x42d0 <xTaskGenericNotifyFromISR+0x12e>
    423c:	29 89       	ldd	r18, Y+17	; 0x11
    423e:	3a 89       	ldd	r19, Y+18	; 0x12
    4240:	23 30       	cpi	r18, 0x03	; 3
    4242:	31 05       	cpc	r19, r1
    4244:	59 f1       	breq	.+86     	; 0x429c <xTaskGenericNotifyFromISR+0xfa>
    4246:	89 89       	ldd	r24, Y+17	; 0x11
    4248:	9a 89       	ldd	r25, Y+18	; 0x12
    424a:	84 30       	cpi	r24, 0x04	; 4
    424c:	91 05       	cpc	r25, r1
    424e:	89 f1       	breq	.+98     	; 0x42b2 <xTaskGenericNotifyFromISR+0x110>
    4250:	3f c0       	rjmp	.+126    	; 0x42d0 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4252:	ec 81       	ldd	r30, Y+4	; 0x04
    4254:	fd 81       	ldd	r31, Y+5	; 0x05
    4256:	21 a1       	ldd	r18, Z+33	; 0x21
    4258:	32 a1       	ldd	r19, Z+34	; 0x22
    425a:	43 a1       	ldd	r20, Z+35	; 0x23
    425c:	54 a1       	ldd	r21, Z+36	; 0x24
    425e:	88 85       	ldd	r24, Y+8	; 0x08
    4260:	99 85       	ldd	r25, Y+9	; 0x09
    4262:	aa 85       	ldd	r26, Y+10	; 0x0a
    4264:	bb 85       	ldd	r27, Y+11	; 0x0b
    4266:	82 2b       	or	r24, r18
    4268:	93 2b       	or	r25, r19
    426a:	a4 2b       	or	r26, r20
    426c:	b5 2b       	or	r27, r21
    426e:	ec 81       	ldd	r30, Y+4	; 0x04
    4270:	fd 81       	ldd	r31, Y+5	; 0x05
    4272:	81 a3       	std	Z+33, r24	; 0x21
    4274:	92 a3       	std	Z+34, r25	; 0x22
    4276:	a3 a3       	std	Z+35, r26	; 0x23
    4278:	b4 a3       	std	Z+36, r27	; 0x24
    427a:	2a c0       	rjmp	.+84     	; 0x42d0 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    427c:	ec 81       	ldd	r30, Y+4	; 0x04
    427e:	fd 81       	ldd	r31, Y+5	; 0x05
    4280:	81 a1       	ldd	r24, Z+33	; 0x21
    4282:	92 a1       	ldd	r25, Z+34	; 0x22
    4284:	a3 a1       	ldd	r26, Z+35	; 0x23
    4286:	b4 a1       	ldd	r27, Z+36	; 0x24
    4288:	01 96       	adiw	r24, 0x01	; 1
    428a:	a1 1d       	adc	r26, r1
    428c:	b1 1d       	adc	r27, r1
    428e:	ec 81       	ldd	r30, Y+4	; 0x04
    4290:	fd 81       	ldd	r31, Y+5	; 0x05
    4292:	81 a3       	std	Z+33, r24	; 0x21
    4294:	92 a3       	std	Z+34, r25	; 0x22
    4296:	a3 a3       	std	Z+35, r26	; 0x23
    4298:	b4 a3       	std	Z+36, r27	; 0x24
    429a:	1a c0       	rjmp	.+52     	; 0x42d0 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    429c:	ec 81       	ldd	r30, Y+4	; 0x04
    429e:	fd 81       	ldd	r31, Y+5	; 0x05
    42a0:	88 85       	ldd	r24, Y+8	; 0x08
    42a2:	99 85       	ldd	r25, Y+9	; 0x09
    42a4:	aa 85       	ldd	r26, Y+10	; 0x0a
    42a6:	bb 85       	ldd	r27, Y+11	; 0x0b
    42a8:	81 a3       	std	Z+33, r24	; 0x21
    42aa:	92 a3       	std	Z+34, r25	; 0x22
    42ac:	a3 a3       	std	Z+35, r26	; 0x23
    42ae:	b4 a3       	std	Z+36, r27	; 0x24
    42b0:	0f c0       	rjmp	.+30     	; 0x42d0 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    42b2:	8b 81       	ldd	r24, Y+3	; 0x03
    42b4:	82 30       	cpi	r24, 0x02	; 2
    42b6:	59 f0       	breq	.+22     	; 0x42ce <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    42b8:	ec 81       	ldd	r30, Y+4	; 0x04
    42ba:	fd 81       	ldd	r31, Y+5	; 0x05
    42bc:	88 85       	ldd	r24, Y+8	; 0x08
    42be:	99 85       	ldd	r25, Y+9	; 0x09
    42c0:	aa 85       	ldd	r26, Y+10	; 0x0a
    42c2:	bb 85       	ldd	r27, Y+11	; 0x0b
    42c4:	81 a3       	std	Z+33, r24	; 0x21
    42c6:	92 a3       	std	Z+34, r25	; 0x22
    42c8:	a3 a3       	std	Z+35, r26	; 0x23
    42ca:	b4 a3       	std	Z+36, r27	; 0x24
    42cc:	01 c0       	rjmp	.+2      	; 0x42d0 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    42ce:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    42d0:	8b 81       	ldd	r24, Y+3	; 0x03
    42d2:	81 30       	cpi	r24, 0x01	; 1
    42d4:	09 f0       	breq	.+2      	; 0x42d8 <xTaskGenericNotifyFromISR+0x136>
    42d6:	4f c0       	rjmp	.+158    	; 0x4376 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    42d8:	80 91 66 04 	lds	r24, 0x0466
    42dc:	88 23       	and	r24, r24
    42de:	61 f5       	brne	.+88     	; 0x4338 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    42e0:	8c 81       	ldd	r24, Y+4	; 0x04
    42e2:	9d 81       	ldd	r25, Y+5	; 0x05
    42e4:	02 96       	adiw	r24, 0x02	; 2
    42e6:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    42ea:	ec 81       	ldd	r30, Y+4	; 0x04
    42ec:	fd 81       	ldd	r31, Y+5	; 0x05
    42ee:	96 89       	ldd	r25, Z+22	; 0x16
    42f0:	80 91 5b 04 	lds	r24, 0x045B
    42f4:	89 17       	cp	r24, r25
    42f6:	28 f4       	brcc	.+10     	; 0x4302 <xTaskGenericNotifyFromISR+0x160>
    42f8:	ec 81       	ldd	r30, Y+4	; 0x04
    42fa:	fd 81       	ldd	r31, Y+5	; 0x05
    42fc:	86 89       	ldd	r24, Z+22	; 0x16
    42fe:	80 93 5b 04 	sts	0x045B, r24
    4302:	ec 81       	ldd	r30, Y+4	; 0x04
    4304:	fd 81       	ldd	r31, Y+5	; 0x05
    4306:	86 89       	ldd	r24, Z+22	; 0x16
    4308:	28 2f       	mov	r18, r24
    430a:	30 e0       	ldi	r19, 0x00	; 0
    430c:	c9 01       	movw	r24, r18
    430e:	88 0f       	add	r24, r24
    4310:	99 1f       	adc	r25, r25
    4312:	88 0f       	add	r24, r24
    4314:	99 1f       	adc	r25, r25
    4316:	88 0f       	add	r24, r24
    4318:	99 1f       	adc	r25, r25
    431a:	82 0f       	add	r24, r18
    431c:	93 1f       	adc	r25, r19
    431e:	ac 01       	movw	r20, r24
    4320:	49 59       	subi	r20, 0x99	; 153
    4322:	5b 4f       	sbci	r21, 0xFB	; 251
    4324:	8c 81       	ldd	r24, Y+4	; 0x04
    4326:	9d 81       	ldd	r25, Y+5	; 0x05
    4328:	9c 01       	movw	r18, r24
    432a:	2e 5f       	subi	r18, 0xFE	; 254
    432c:	3f 4f       	sbci	r19, 0xFF	; 255
    432e:	ca 01       	movw	r24, r20
    4330:	b9 01       	movw	r22, r18
    4332:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
    4336:	0a c0       	rjmp	.+20     	; 0x434c <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4338:	8c 81       	ldd	r24, Y+4	; 0x04
    433a:	9d 81       	ldd	r25, Y+5	; 0x05
    433c:	9c 01       	movw	r18, r24
    433e:	24 5f       	subi	r18, 0xF4	; 244
    4340:	3f 4f       	sbci	r19, 0xFF	; 255
    4342:	8a ea       	ldi	r24, 0xAA	; 170
    4344:	94 e0       	ldi	r25, 0x04	; 4
    4346:	b9 01       	movw	r22, r18
    4348:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    434c:	ec 81       	ldd	r30, Y+4	; 0x04
    434e:	fd 81       	ldd	r31, Y+5	; 0x05
    4350:	96 89       	ldd	r25, Z+22	; 0x16
    4352:	e0 91 55 04 	lds	r30, 0x0455
    4356:	f0 91 56 04 	lds	r31, 0x0456
    435a:	86 89       	ldd	r24, Z+22	; 0x16
    435c:	89 17       	cp	r24, r25
    435e:	58 f4       	brcc	.+22     	; 0x4376 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4360:	8f 85       	ldd	r24, Y+15	; 0x0f
    4362:	98 89       	ldd	r25, Y+16	; 0x10
    4364:	00 97       	sbiw	r24, 0x00	; 0
    4366:	21 f0       	breq	.+8      	; 0x4370 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4368:	ef 85       	ldd	r30, Y+15	; 0x0f
    436a:	f8 89       	ldd	r31, Y+16	; 0x10
    436c:	81 e0       	ldi	r24, 0x01	; 1
    436e:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4370:	81 e0       	ldi	r24, 0x01	; 1
    4372:	80 93 5f 04 	sts	0x045F, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4376:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4378:	62 96       	adiw	r28, 0x12	; 18
    437a:	0f b6       	in	r0, 0x3f	; 63
    437c:	f8 94       	cli
    437e:	de bf       	out	0x3e, r29	; 62
    4380:	0f be       	out	0x3f, r0	; 63
    4382:	cd bf       	out	0x3d, r28	; 61
    4384:	cf 91       	pop	r28
    4386:	df 91       	pop	r29
    4388:	1f 91       	pop	r17
    438a:	0f 91       	pop	r16
    438c:	ff 90       	pop	r15
    438e:	ef 90       	pop	r14
    4390:	08 95       	ret

00004392 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4392:	df 93       	push	r29
    4394:	cf 93       	push	r28
    4396:	cd b7       	in	r28, 0x3d	; 61
    4398:	de b7       	in	r29, 0x3e	; 62
    439a:	28 97       	sbiw	r28, 0x08	; 8
    439c:	0f b6       	in	r0, 0x3f	; 63
    439e:	f8 94       	cli
    43a0:	de bf       	out	0x3e, r29	; 62
    43a2:	0f be       	out	0x3f, r0	; 63
    43a4:	cd bf       	out	0x3d, r28	; 61
    43a6:	9e 83       	std	Y+6, r25	; 0x06
    43a8:	8d 83       	std	Y+5, r24	; 0x05
    43aa:	78 87       	std	Y+8, r23	; 0x08
    43ac:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    43ae:	8d 81       	ldd	r24, Y+5	; 0x05
    43b0:	9e 81       	ldd	r25, Y+6	; 0x06
    43b2:	9c 83       	std	Y+4, r25	; 0x04
    43b4:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    43b6:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    43b8:	eb 81       	ldd	r30, Y+3	; 0x03
    43ba:	fc 81       	ldd	r31, Y+4	; 0x04
    43bc:	85 a1       	ldd	r24, Z+37	; 0x25
    43be:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    43c0:	eb 81       	ldd	r30, Y+3	; 0x03
    43c2:	fc 81       	ldd	r31, Y+4	; 0x04
    43c4:	82 e0       	ldi	r24, 0x02	; 2
    43c6:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    43c8:	eb 81       	ldd	r30, Y+3	; 0x03
    43ca:	fc 81       	ldd	r31, Y+4	; 0x04
    43cc:	81 a1       	ldd	r24, Z+33	; 0x21
    43ce:	92 a1       	ldd	r25, Z+34	; 0x22
    43d0:	a3 a1       	ldd	r26, Z+35	; 0x23
    43d2:	b4 a1       	ldd	r27, Z+36	; 0x24
    43d4:	01 96       	adiw	r24, 0x01	; 1
    43d6:	a1 1d       	adc	r26, r1
    43d8:	b1 1d       	adc	r27, r1
    43da:	eb 81       	ldd	r30, Y+3	; 0x03
    43dc:	fc 81       	ldd	r31, Y+4	; 0x04
    43de:	81 a3       	std	Z+33, r24	; 0x21
    43e0:	92 a3       	std	Z+34, r25	; 0x22
    43e2:	a3 a3       	std	Z+35, r26	; 0x23
    43e4:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    43e6:	8a 81       	ldd	r24, Y+2	; 0x02
    43e8:	81 30       	cpi	r24, 0x01	; 1
    43ea:	09 f0       	breq	.+2      	; 0x43ee <vTaskNotifyGiveFromISR+0x5c>
    43ec:	4f c0       	rjmp	.+158    	; 0x448c <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    43ee:	80 91 66 04 	lds	r24, 0x0466
    43f2:	88 23       	and	r24, r24
    43f4:	61 f5       	brne	.+88     	; 0x444e <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    43f6:	8b 81       	ldd	r24, Y+3	; 0x03
    43f8:	9c 81       	ldd	r25, Y+4	; 0x04
    43fa:	02 96       	adiw	r24, 0x02	; 2
    43fc:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4400:	eb 81       	ldd	r30, Y+3	; 0x03
    4402:	fc 81       	ldd	r31, Y+4	; 0x04
    4404:	96 89       	ldd	r25, Z+22	; 0x16
    4406:	80 91 5b 04 	lds	r24, 0x045B
    440a:	89 17       	cp	r24, r25
    440c:	28 f4       	brcc	.+10     	; 0x4418 <vTaskNotifyGiveFromISR+0x86>
    440e:	eb 81       	ldd	r30, Y+3	; 0x03
    4410:	fc 81       	ldd	r31, Y+4	; 0x04
    4412:	86 89       	ldd	r24, Z+22	; 0x16
    4414:	80 93 5b 04 	sts	0x045B, r24
    4418:	eb 81       	ldd	r30, Y+3	; 0x03
    441a:	fc 81       	ldd	r31, Y+4	; 0x04
    441c:	86 89       	ldd	r24, Z+22	; 0x16
    441e:	28 2f       	mov	r18, r24
    4420:	30 e0       	ldi	r19, 0x00	; 0
    4422:	c9 01       	movw	r24, r18
    4424:	88 0f       	add	r24, r24
    4426:	99 1f       	adc	r25, r25
    4428:	88 0f       	add	r24, r24
    442a:	99 1f       	adc	r25, r25
    442c:	88 0f       	add	r24, r24
    442e:	99 1f       	adc	r25, r25
    4430:	82 0f       	add	r24, r18
    4432:	93 1f       	adc	r25, r19
    4434:	ac 01       	movw	r20, r24
    4436:	49 59       	subi	r20, 0x99	; 153
    4438:	5b 4f       	sbci	r21, 0xFB	; 251
    443a:	8b 81       	ldd	r24, Y+3	; 0x03
    443c:	9c 81       	ldd	r25, Y+4	; 0x04
    443e:	9c 01       	movw	r18, r24
    4440:	2e 5f       	subi	r18, 0xFE	; 254
    4442:	3f 4f       	sbci	r19, 0xFF	; 255
    4444:	ca 01       	movw	r24, r20
    4446:	b9 01       	movw	r22, r18
    4448:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
    444c:	0a c0       	rjmp	.+20     	; 0x4462 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    444e:	8b 81       	ldd	r24, Y+3	; 0x03
    4450:	9c 81       	ldd	r25, Y+4	; 0x04
    4452:	9c 01       	movw	r18, r24
    4454:	24 5f       	subi	r18, 0xF4	; 244
    4456:	3f 4f       	sbci	r19, 0xFF	; 255
    4458:	8a ea       	ldi	r24, 0xAA	; 170
    445a:	94 e0       	ldi	r25, 0x04	; 4
    445c:	b9 01       	movw	r22, r18
    445e:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4462:	eb 81       	ldd	r30, Y+3	; 0x03
    4464:	fc 81       	ldd	r31, Y+4	; 0x04
    4466:	96 89       	ldd	r25, Z+22	; 0x16
    4468:	e0 91 55 04 	lds	r30, 0x0455
    446c:	f0 91 56 04 	lds	r31, 0x0456
    4470:	86 89       	ldd	r24, Z+22	; 0x16
    4472:	89 17       	cp	r24, r25
    4474:	58 f4       	brcc	.+22     	; 0x448c <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4476:	8f 81       	ldd	r24, Y+7	; 0x07
    4478:	98 85       	ldd	r25, Y+8	; 0x08
    447a:	00 97       	sbiw	r24, 0x00	; 0
    447c:	21 f0       	breq	.+8      	; 0x4486 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    447e:	ef 81       	ldd	r30, Y+7	; 0x07
    4480:	f8 85       	ldd	r31, Y+8	; 0x08
    4482:	81 e0       	ldi	r24, 0x01	; 1
    4484:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4486:	81 e0       	ldi	r24, 0x01	; 1
    4488:	80 93 5f 04 	sts	0x045F, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    448c:	28 96       	adiw	r28, 0x08	; 8
    448e:	0f b6       	in	r0, 0x3f	; 63
    4490:	f8 94       	cli
    4492:	de bf       	out	0x3e, r29	; 62
    4494:	0f be       	out	0x3f, r0	; 63
    4496:	cd bf       	out	0x3d, r28	; 61
    4498:	cf 91       	pop	r28
    449a:	df 91       	pop	r29
    449c:	08 95       	ret

0000449e <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    449e:	df 93       	push	r29
    44a0:	cf 93       	push	r28
    44a2:	cd b7       	in	r28, 0x3d	; 61
    44a4:	de b7       	in	r29, 0x3e	; 62
    44a6:	27 97       	sbiw	r28, 0x07	; 7
    44a8:	0f b6       	in	r0, 0x3f	; 63
    44aa:	f8 94       	cli
    44ac:	de bf       	out	0x3e, r29	; 62
    44ae:	0f be       	out	0x3f, r0	; 63
    44b0:	cd bf       	out	0x3d, r28	; 61
    44b2:	9d 83       	std	Y+5, r25	; 0x05
    44b4:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    44b6:	8c 81       	ldd	r24, Y+4	; 0x04
    44b8:	9d 81       	ldd	r25, Y+5	; 0x05
    44ba:	00 97       	sbiw	r24, 0x00	; 0
    44bc:	39 f4       	brne	.+14     	; 0x44cc <xTaskNotifyStateClear+0x2e>
    44be:	80 91 55 04 	lds	r24, 0x0455
    44c2:	90 91 56 04 	lds	r25, 0x0456
    44c6:	9f 83       	std	Y+7, r25	; 0x07
    44c8:	8e 83       	std	Y+6, r24	; 0x06
    44ca:	04 c0       	rjmp	.+8      	; 0x44d4 <xTaskNotifyStateClear+0x36>
    44cc:	8c 81       	ldd	r24, Y+4	; 0x04
    44ce:	9d 81       	ldd	r25, Y+5	; 0x05
    44d0:	9f 83       	std	Y+7, r25	; 0x07
    44d2:	8e 83       	std	Y+6, r24	; 0x06
    44d4:	8e 81       	ldd	r24, Y+6	; 0x06
    44d6:	9f 81       	ldd	r25, Y+7	; 0x07
    44d8:	9b 83       	std	Y+3, r25	; 0x03
    44da:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    44dc:	0f b6       	in	r0, 0x3f	; 63
    44de:	f8 94       	cli
    44e0:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    44e2:	ea 81       	ldd	r30, Y+2	; 0x02
    44e4:	fb 81       	ldd	r31, Y+3	; 0x03
    44e6:	85 a1       	ldd	r24, Z+37	; 0x25
    44e8:	82 30       	cpi	r24, 0x02	; 2
    44ea:	31 f4       	brne	.+12     	; 0x44f8 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    44ec:	ea 81       	ldd	r30, Y+2	; 0x02
    44ee:	fb 81       	ldd	r31, Y+3	; 0x03
    44f0:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    44f2:	81 e0       	ldi	r24, 0x01	; 1
    44f4:	89 83       	std	Y+1, r24	; 0x01
    44f6:	01 c0       	rjmp	.+2      	; 0x44fa <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    44f8:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    44fa:	0f 90       	pop	r0
    44fc:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    44fe:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4500:	27 96       	adiw	r28, 0x07	; 7
    4502:	0f b6       	in	r0, 0x3f	; 63
    4504:	f8 94       	cli
    4506:	de bf       	out	0x3e, r29	; 62
    4508:	0f be       	out	0x3f, r0	; 63
    450a:	cd bf       	out	0x3d, r28	; 61
    450c:	cf 91       	pop	r28
    450e:	df 91       	pop	r29
    4510:	08 95       	ret

00004512 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
    4512:	df 93       	push	r29
    4514:	cf 93       	push	r28
    4516:	cd b7       	in	r28, 0x3d	; 61
    4518:	de b7       	in	r29, 0x3e	; 62
    451a:	2e 97       	sbiw	r28, 0x0e	; 14
    451c:	0f b6       	in	r0, 0x3f	; 63
    451e:	f8 94       	cli
    4520:	de bf       	out	0x3e, r29	; 62
    4522:	0f be       	out	0x3f, r0	; 63
    4524:	cd bf       	out	0x3d, r28	; 61
    4526:	98 87       	std	Y+8, r25	; 0x08
    4528:	8f 83       	std	Y+7, r24	; 0x07
    452a:	49 87       	std	Y+9, r20	; 0x09
    452c:	5a 87       	std	Y+10, r21	; 0x0a
    452e:	6b 87       	std	Y+11, r22	; 0x0b
    4530:	7c 87       	std	Y+12, r23	; 0x0c
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4532:	8f 81       	ldd	r24, Y+7	; 0x07
    4534:	98 85       	ldd	r25, Y+8	; 0x08
    4536:	00 97       	sbiw	r24, 0x00	; 0
    4538:	39 f4       	brne	.+14     	; 0x4548 <ulTaskNotifyValueClear+0x36>
    453a:	80 91 55 04 	lds	r24, 0x0455
    453e:	90 91 56 04 	lds	r25, 0x0456
    4542:	9e 87       	std	Y+14, r25	; 0x0e
    4544:	8d 87       	std	Y+13, r24	; 0x0d
    4546:	04 c0       	rjmp	.+8      	; 0x4550 <ulTaskNotifyValueClear+0x3e>
    4548:	8f 81       	ldd	r24, Y+7	; 0x07
    454a:	98 85       	ldd	r25, Y+8	; 0x08
    454c:	9e 87       	std	Y+14, r25	; 0x0e
    454e:	8d 87       	std	Y+13, r24	; 0x0d
    4550:	8d 85       	ldd	r24, Y+13	; 0x0d
    4552:	9e 85       	ldd	r25, Y+14	; 0x0e
    4554:	9e 83       	std	Y+6, r25	; 0x06
    4556:	8d 83       	std	Y+5, r24	; 0x05

		taskENTER_CRITICAL();
    4558:	0f b6       	in	r0, 0x3f	; 63
    455a:	f8 94       	cli
    455c:	0f 92       	push	r0
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    455e:	e0 91 55 04 	lds	r30, 0x0455
    4562:	f0 91 56 04 	lds	r31, 0x0456
    4566:	81 a1       	ldd	r24, Z+33	; 0x21
    4568:	92 a1       	ldd	r25, Z+34	; 0x22
    456a:	a3 a1       	ldd	r26, Z+35	; 0x23
    456c:	b4 a1       	ldd	r27, Z+36	; 0x24
    456e:	89 83       	std	Y+1, r24	; 0x01
    4570:	9a 83       	std	Y+2, r25	; 0x02
    4572:	ab 83       	std	Y+3, r26	; 0x03
    4574:	bc 83       	std	Y+4, r27	; 0x04
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
    4576:	ed 81       	ldd	r30, Y+5	; 0x05
    4578:	fe 81       	ldd	r31, Y+6	; 0x06
    457a:	21 a1       	ldd	r18, Z+33	; 0x21
    457c:	32 a1       	ldd	r19, Z+34	; 0x22
    457e:	43 a1       	ldd	r20, Z+35	; 0x23
    4580:	54 a1       	ldd	r21, Z+36	; 0x24
    4582:	89 85       	ldd	r24, Y+9	; 0x09
    4584:	9a 85       	ldd	r25, Y+10	; 0x0a
    4586:	ab 85       	ldd	r26, Y+11	; 0x0b
    4588:	bc 85       	ldd	r27, Y+12	; 0x0c
    458a:	80 95       	com	r24
    458c:	90 95       	com	r25
    458e:	a0 95       	com	r26
    4590:	b0 95       	com	r27
    4592:	82 23       	and	r24, r18
    4594:	93 23       	and	r25, r19
    4596:	a4 23       	and	r26, r20
    4598:	b5 23       	and	r27, r21
    459a:	ed 81       	ldd	r30, Y+5	; 0x05
    459c:	fe 81       	ldd	r31, Y+6	; 0x06
    459e:	81 a3       	std	Z+33, r24	; 0x21
    45a0:	92 a3       	std	Z+34, r25	; 0x22
    45a2:	a3 a3       	std	Z+35, r26	; 0x23
    45a4:	b4 a3       	std	Z+36, r27	; 0x24
		}
		taskEXIT_CRITICAL();
    45a6:	0f 90       	pop	r0
    45a8:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    45aa:	89 81       	ldd	r24, Y+1	; 0x01
    45ac:	9a 81       	ldd	r25, Y+2	; 0x02
    45ae:	ab 81       	ldd	r26, Y+3	; 0x03
    45b0:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    45b2:	bc 01       	movw	r22, r24
    45b4:	cd 01       	movw	r24, r26
    45b6:	2e 96       	adiw	r28, 0x0e	; 14
    45b8:	0f b6       	in	r0, 0x3f	; 63
    45ba:	f8 94       	cli
    45bc:	de bf       	out	0x3e, r29	; 62
    45be:	0f be       	out	0x3f, r0	; 63
    45c0:	cd bf       	out	0x3d, r28	; 61
    45c2:	cf 91       	pop	r28
    45c4:	df 91       	pop	r29
    45c6:	08 95       	ret

000045c8 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    45c8:	df 93       	push	r29
    45ca:	cf 93       	push	r28
    45cc:	cd b7       	in	r28, 0x3d	; 61
    45ce:	de b7       	in	r29, 0x3e	; 62
    45d0:	27 97       	sbiw	r28, 0x07	; 7
    45d2:	0f b6       	in	r0, 0x3f	; 63
    45d4:	f8 94       	cli
    45d6:	de bf       	out	0x3e, r29	; 62
    45d8:	0f be       	out	0x3f, r0	; 63
    45da:	cd bf       	out	0x3d, r28	; 61
    45dc:	9e 83       	std	Y+6, r25	; 0x06
    45de:	8d 83       	std	Y+5, r24	; 0x05
    45e0:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    45e2:	80 91 59 04 	lds	r24, 0x0459
    45e6:	90 91 5a 04 	lds	r25, 0x045A
    45ea:	9a 83       	std	Y+2, r25	; 0x02
    45ec:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    45ee:	80 91 55 04 	lds	r24, 0x0455
    45f2:	90 91 56 04 	lds	r25, 0x0456
    45f6:	02 96       	adiw	r24, 0x02	; 2
    45f8:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    45fc:	8d 81       	ldd	r24, Y+5	; 0x05
    45fe:	9e 81       	ldd	r25, Y+6	; 0x06
    4600:	2f ef       	ldi	r18, 0xFF	; 255
    4602:	8f 3f       	cpi	r24, 0xFF	; 255
    4604:	92 07       	cpc	r25, r18
    4606:	81 f4       	brne	.+32     	; 0x4628 <prvAddCurrentTaskToDelayedList+0x60>
    4608:	8f 81       	ldd	r24, Y+7	; 0x07
    460a:	88 23       	and	r24, r24
    460c:	69 f0       	breq	.+26     	; 0x4628 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    460e:	80 91 55 04 	lds	r24, 0x0455
    4612:	90 91 56 04 	lds	r25, 0x0456
    4616:	9c 01       	movw	r18, r24
    4618:	2e 5f       	subi	r18, 0xFE	; 254
    461a:	3f 4f       	sbci	r19, 0xFF	; 255
    461c:	8c eb       	ldi	r24, 0xBC	; 188
    461e:	94 e0       	ldi	r25, 0x04	; 4
    4620:	b9 01       	movw	r22, r18
    4622:	0e 94 bb 08 	call	0x1176	; 0x1176 <vListInsertEnd>
    4626:	43 c0       	rjmp	.+134    	; 0x46ae <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    4628:	29 81       	ldd	r18, Y+1	; 0x01
    462a:	3a 81       	ldd	r19, Y+2	; 0x02
    462c:	8d 81       	ldd	r24, Y+5	; 0x05
    462e:	9e 81       	ldd	r25, Y+6	; 0x06
    4630:	82 0f       	add	r24, r18
    4632:	93 1f       	adc	r25, r19
    4634:	9c 83       	std	Y+4, r25	; 0x04
    4636:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4638:	e0 91 55 04 	lds	r30, 0x0455
    463c:	f0 91 56 04 	lds	r31, 0x0456
    4640:	8b 81       	ldd	r24, Y+3	; 0x03
    4642:	9c 81       	ldd	r25, Y+4	; 0x04
    4644:	93 83       	std	Z+3, r25	; 0x03
    4646:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    4648:	2b 81       	ldd	r18, Y+3	; 0x03
    464a:	3c 81       	ldd	r19, Y+4	; 0x04
    464c:	89 81       	ldd	r24, Y+1	; 0x01
    464e:	9a 81       	ldd	r25, Y+2	; 0x02
    4650:	28 17       	cp	r18, r24
    4652:	39 07       	cpc	r19, r25
    4654:	70 f4       	brcc	.+28     	; 0x4672 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4656:	80 91 a8 04 	lds	r24, 0x04A8
    465a:	90 91 a9 04 	lds	r25, 0x04A9
    465e:	20 91 55 04 	lds	r18, 0x0455
    4662:	30 91 56 04 	lds	r19, 0x0456
    4666:	2e 5f       	subi	r18, 0xFE	; 254
    4668:	3f 4f       	sbci	r19, 0xFF	; 255
    466a:	b9 01       	movw	r22, r18
    466c:	0e 94 ff 08 	call	0x11fe	; 0x11fe <vListInsert>
    4670:	1e c0       	rjmp	.+60     	; 0x46ae <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4672:	40 91 a6 04 	lds	r20, 0x04A6
    4676:	50 91 a7 04 	lds	r21, 0x04A7
    467a:	80 91 55 04 	lds	r24, 0x0455
    467e:	90 91 56 04 	lds	r25, 0x0456
    4682:	9c 01       	movw	r18, r24
    4684:	2e 5f       	subi	r18, 0xFE	; 254
    4686:	3f 4f       	sbci	r19, 0xFF	; 255
    4688:	ca 01       	movw	r24, r20
    468a:	b9 01       	movw	r22, r18
    468c:	0e 94 ff 08 	call	0x11fe	; 0x11fe <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    4690:	20 91 62 04 	lds	r18, 0x0462
    4694:	30 91 63 04 	lds	r19, 0x0463
    4698:	8b 81       	ldd	r24, Y+3	; 0x03
    469a:	9c 81       	ldd	r25, Y+4	; 0x04
    469c:	82 17       	cp	r24, r18
    469e:	93 07       	cpc	r25, r19
    46a0:	30 f4       	brcc	.+12     	; 0x46ae <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    46a2:	8b 81       	ldd	r24, Y+3	; 0x03
    46a4:	9c 81       	ldd	r25, Y+4	; 0x04
    46a6:	90 93 63 04 	sts	0x0463, r25
    46aa:	80 93 62 04 	sts	0x0462, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    46ae:	27 96       	adiw	r28, 0x07	; 7
    46b0:	0f b6       	in	r0, 0x3f	; 63
    46b2:	f8 94       	cli
    46b4:	de bf       	out	0x3e, r29	; 62
    46b6:	0f be       	out	0x3f, r0	; 63
    46b8:	cd bf       	out	0x3d, r28	; 61
    46ba:	cf 91       	pop	r28
    46bc:	df 91       	pop	r29
    46be:	08 95       	ret

000046c0 <memcpy>:
    46c0:	fb 01       	movw	r30, r22
    46c2:	dc 01       	movw	r26, r24
    46c4:	02 c0       	rjmp	.+4      	; 0x46ca <memcpy+0xa>
    46c6:	01 90       	ld	r0, Z+
    46c8:	0d 92       	st	X+, r0
    46ca:	41 50       	subi	r20, 0x01	; 1
    46cc:	50 40       	sbci	r21, 0x00	; 0
    46ce:	d8 f7       	brcc	.-10     	; 0x46c6 <memcpy+0x6>
    46d0:	08 95       	ret

000046d2 <_exit>:
    46d2:	f8 94       	cli

000046d4 <__stop_program>:
    46d4:	ff cf       	rjmp	.-2      	; 0x46d4 <__stop_program>
