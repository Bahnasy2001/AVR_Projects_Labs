
Free_RTOS_Lab3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006ac8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000026  00800060  00006ac8  00006b5c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000461  00800086  00800086  00006b82  2**0
                  ALLOC
  3 .stab         0000897c  00000000  00000000  00006b84  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004861  00000000  00000000  0000f500  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00013d61  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  00013ec1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002045  00000000  00000000  00014050  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001101  00000000  00000000  00016095  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f82  00000000  00000000  00017196  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  00018118  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002c2  00000000  00000000  00018298  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000088e  00000000  00000000  0001855a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00018de8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 bb 1e 	jmp	0x3d76	; 0x3d76 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ec       	ldi	r30, 0xC8	; 200
      68:	fa e6       	ldi	r31, 0x6A	; 106
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 38       	cpi	r26, 0x86	; 134
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a6 e8       	ldi	r26, 0x86	; 134
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 3e       	cpi	r26, 0xE7	; 231
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 1b 1a 	call	0x3436	; 0x3436 <main>
      8a:	0c 94 62 35 	jmp	0x6ac4	; 0x6ac4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 22 35 	jmp	0x6a44	; 0x6a44 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ad e7       	ldi	r26, 0x7D	; 125
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 3e 35 	jmp	0x6a7c	; 0x6a7c <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 2e 35 	jmp	0x6a5c	; 0x6a5c <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 4a 35 	jmp	0x6a94	; 0x6a94 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 2e 35 	jmp	0x6a5c	; 0x6a5c <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 4a 35 	jmp	0x6a94	; 0x6a94 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 22 35 	jmp	0x6a44	; 0x6a44 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8d e7       	ldi	r24, 0x7D	; 125
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 3e 35 	jmp	0x6a7c	; 0x6a7c <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 2a 35 	jmp	0x6a54	; 0x6a54 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6d e7       	ldi	r22, 0x7D	; 125
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 46 35 	jmp	0x6a8c	; 0x6a8c <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 2e 35 	jmp	0x6a5c	; 0x6a5c <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 4a 35 	jmp	0x6a94	; 0x6a94 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 2e 35 	jmp	0x6a5c	; 0x6a5c <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 4a 35 	jmp	0x6a94	; 0x6a94 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 2e 35 	jmp	0x6a5c	; 0x6a5c <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 4a 35 	jmp	0x6a94	; 0x6a94 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 32 35 	jmp	0x6a64	; 0x6a64 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 4e 35 	jmp	0x6a9c	; 0x6a9c <__epilogue_restores__+0x20>

00000952 <__pack_f>:
     952:	df 92       	push	r13
     954:	ef 92       	push	r14
     956:	ff 92       	push	r15
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	fc 01       	movw	r30, r24
     95e:	e4 80       	ldd	r14, Z+4	; 0x04
     960:	f5 80       	ldd	r15, Z+5	; 0x05
     962:	06 81       	ldd	r16, Z+6	; 0x06
     964:	17 81       	ldd	r17, Z+7	; 0x07
     966:	d1 80       	ldd	r13, Z+1	; 0x01
     968:	80 81       	ld	r24, Z
     96a:	82 30       	cpi	r24, 0x02	; 2
     96c:	48 f4       	brcc	.+18     	; 0x980 <__pack_f+0x2e>
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	a0 e1       	ldi	r26, 0x10	; 16
     974:	b0 e0       	ldi	r27, 0x00	; 0
     976:	e8 2a       	or	r14, r24
     978:	f9 2a       	or	r15, r25
     97a:	0a 2b       	or	r16, r26
     97c:	1b 2b       	or	r17, r27
     97e:	a5 c0       	rjmp	.+330    	; 0xaca <__pack_f+0x178>
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	09 f4       	brne	.+2      	; 0x986 <__pack_f+0x34>
     984:	9f c0       	rjmp	.+318    	; 0xac4 <__pack_f+0x172>
     986:	82 30       	cpi	r24, 0x02	; 2
     988:	21 f4       	brne	.+8      	; 0x992 <__pack_f+0x40>
     98a:	ee 24       	eor	r14, r14
     98c:	ff 24       	eor	r15, r15
     98e:	87 01       	movw	r16, r14
     990:	05 c0       	rjmp	.+10     	; 0x99c <__pack_f+0x4a>
     992:	e1 14       	cp	r14, r1
     994:	f1 04       	cpc	r15, r1
     996:	01 05       	cpc	r16, r1
     998:	11 05       	cpc	r17, r1
     99a:	19 f4       	brne	.+6      	; 0x9a2 <__pack_f+0x50>
     99c:	e0 e0       	ldi	r30, 0x00	; 0
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	96 c0       	rjmp	.+300    	; 0xace <__pack_f+0x17c>
     9a2:	62 81       	ldd	r22, Z+2	; 0x02
     9a4:	73 81       	ldd	r23, Z+3	; 0x03
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
     9a8:	62 38       	cpi	r22, 0x82	; 130
     9aa:	79 07       	cpc	r23, r25
     9ac:	0c f0       	brlt	.+2      	; 0x9b0 <__pack_f+0x5e>
     9ae:	5b c0       	rjmp	.+182    	; 0xa66 <__pack_f+0x114>
     9b0:	22 e8       	ldi	r18, 0x82	; 130
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	26 1b       	sub	r18, r22
     9b6:	37 0b       	sbc	r19, r23
     9b8:	2a 31       	cpi	r18, 0x1A	; 26
     9ba:	31 05       	cpc	r19, r1
     9bc:	2c f0       	brlt	.+10     	; 0x9c8 <__pack_f+0x76>
     9be:	20 e0       	ldi	r18, 0x00	; 0
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	2a c0       	rjmp	.+84     	; 0xa1c <__pack_f+0xca>
     9c8:	b8 01       	movw	r22, r16
     9ca:	a7 01       	movw	r20, r14
     9cc:	02 2e       	mov	r0, r18
     9ce:	04 c0       	rjmp	.+8      	; 0x9d8 <__pack_f+0x86>
     9d0:	76 95       	lsr	r23
     9d2:	67 95       	ror	r22
     9d4:	57 95       	ror	r21
     9d6:	47 95       	ror	r20
     9d8:	0a 94       	dec	r0
     9da:	d2 f7       	brpl	.-12     	; 0x9d0 <__pack_f+0x7e>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	a0 e0       	ldi	r26, 0x00	; 0
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <__pack_f+0x9c>
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	aa 1f       	adc	r26, r26
     9ec:	bb 1f       	adc	r27, r27
     9ee:	2a 95       	dec	r18
     9f0:	d2 f7       	brpl	.-12     	; 0x9e6 <__pack_f+0x94>
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	a1 09       	sbc	r26, r1
     9f6:	b1 09       	sbc	r27, r1
     9f8:	8e 21       	and	r24, r14
     9fa:	9f 21       	and	r25, r15
     9fc:	a0 23       	and	r26, r16
     9fe:	b1 23       	and	r27, r17
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	a1 05       	cpc	r26, r1
     a04:	b1 05       	cpc	r27, r1
     a06:	21 f0       	breq	.+8      	; 0xa10 <__pack_f+0xbe>
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e0       	ldi	r26, 0x00	; 0
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	9a 01       	movw	r18, r20
     a12:	ab 01       	movw	r20, r22
     a14:	28 2b       	or	r18, r24
     a16:	39 2b       	or	r19, r25
     a18:	4a 2b       	or	r20, r26
     a1a:	5b 2b       	or	r21, r27
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	90 70       	andi	r25, 0x00	; 0
     a24:	a0 70       	andi	r26, 0x00	; 0
     a26:	b0 70       	andi	r27, 0x00	; 0
     a28:	80 34       	cpi	r24, 0x40	; 64
     a2a:	91 05       	cpc	r25, r1
     a2c:	a1 05       	cpc	r26, r1
     a2e:	b1 05       	cpc	r27, r1
     a30:	39 f4       	brne	.+14     	; 0xa40 <__pack_f+0xee>
     a32:	27 ff       	sbrs	r18, 7
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__pack_f+0xf6>
     a36:	20 5c       	subi	r18, 0xC0	; 192
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	4f 4f       	sbci	r20, 0xFF	; 255
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <__pack_f+0xf6>
     a40:	21 5c       	subi	r18, 0xC1	; 193
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	4f 4f       	sbci	r20, 0xFF	; 255
     a46:	5f 4f       	sbci	r21, 0xFF	; 255
     a48:	e0 e0       	ldi	r30, 0x00	; 0
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	20 30       	cpi	r18, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	3a 07       	cpc	r19, r26
     a52:	a0 e0       	ldi	r26, 0x00	; 0
     a54:	4a 07       	cpc	r20, r26
     a56:	a0 e4       	ldi	r26, 0x40	; 64
     a58:	5a 07       	cpc	r21, r26
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <__pack_f+0x10e>
     a5c:	e1 e0       	ldi	r30, 0x01	; 1
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	79 01       	movw	r14, r18
     a62:	8a 01       	movw	r16, r20
     a64:	27 c0       	rjmp	.+78     	; 0xab4 <__pack_f+0x162>
     a66:	60 38       	cpi	r22, 0x80	; 128
     a68:	71 05       	cpc	r23, r1
     a6a:	64 f5       	brge	.+88     	; 0xac4 <__pack_f+0x172>
     a6c:	fb 01       	movw	r30, r22
     a6e:	e1 58       	subi	r30, 0x81	; 129
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
     a72:	d8 01       	movw	r26, r16
     a74:	c7 01       	movw	r24, r14
     a76:	8f 77       	andi	r24, 0x7F	; 127
     a78:	90 70       	andi	r25, 0x00	; 0
     a7a:	a0 70       	andi	r26, 0x00	; 0
     a7c:	b0 70       	andi	r27, 0x00	; 0
     a7e:	80 34       	cpi	r24, 0x40	; 64
     a80:	91 05       	cpc	r25, r1
     a82:	a1 05       	cpc	r26, r1
     a84:	b1 05       	cpc	r27, r1
     a86:	39 f4       	brne	.+14     	; 0xa96 <__pack_f+0x144>
     a88:	e7 fe       	sbrs	r14, 7
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <__pack_f+0x154>
     a8c:	80 e4       	ldi	r24, 0x40	; 64
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	a0 e0       	ldi	r26, 0x00	; 0
     a92:	b0 e0       	ldi	r27, 0x00	; 0
     a94:	04 c0       	rjmp	.+8      	; 0xa9e <__pack_f+0x14c>
     a96:	8f e3       	ldi	r24, 0x3F	; 63
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	e8 0e       	add	r14, r24
     aa0:	f9 1e       	adc	r15, r25
     aa2:	0a 1f       	adc	r16, r26
     aa4:	1b 1f       	adc	r17, r27
     aa6:	17 ff       	sbrs	r17, 7
     aa8:	05 c0       	rjmp	.+10     	; 0xab4 <__pack_f+0x162>
     aaa:	16 95       	lsr	r17
     aac:	07 95       	ror	r16
     aae:	f7 94       	ror	r15
     ab0:	e7 94       	ror	r14
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	87 e0       	ldi	r24, 0x07	; 7
     ab6:	16 95       	lsr	r17
     ab8:	07 95       	ror	r16
     aba:	f7 94       	ror	r15
     abc:	e7 94       	ror	r14
     abe:	8a 95       	dec	r24
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <__pack_f+0x164>
     ac2:	05 c0       	rjmp	.+10     	; 0xace <__pack_f+0x17c>
     ac4:	ee 24       	eor	r14, r14
     ac6:	ff 24       	eor	r15, r15
     ac8:	87 01       	movw	r16, r14
     aca:	ef ef       	ldi	r30, 0xFF	; 255
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	6e 2f       	mov	r22, r30
     ad0:	67 95       	ror	r22
     ad2:	66 27       	eor	r22, r22
     ad4:	67 95       	ror	r22
     ad6:	90 2f       	mov	r25, r16
     ad8:	9f 77       	andi	r25, 0x7F	; 127
     ada:	d7 94       	ror	r13
     adc:	dd 24       	eor	r13, r13
     ade:	d7 94       	ror	r13
     ae0:	8e 2f       	mov	r24, r30
     ae2:	86 95       	lsr	r24
     ae4:	49 2f       	mov	r20, r25
     ae6:	46 2b       	or	r20, r22
     ae8:	58 2f       	mov	r21, r24
     aea:	5d 29       	or	r21, r13
     aec:	b7 01       	movw	r22, r14
     aee:	ca 01       	movw	r24, r20
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	08 95       	ret

00000afc <__unpack_f>:
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22
     b00:	40 81       	ld	r20, Z
     b02:	51 81       	ldd	r21, Z+1	; 0x01
     b04:	22 81       	ldd	r18, Z+2	; 0x02
     b06:	62 2f       	mov	r22, r18
     b08:	6f 77       	andi	r22, 0x7F	; 127
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	22 1f       	adc	r18, r18
     b0e:	22 27       	eor	r18, r18
     b10:	22 1f       	adc	r18, r18
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	89 2f       	mov	r24, r25
     b16:	88 0f       	add	r24, r24
     b18:	82 2b       	or	r24, r18
     b1a:	28 2f       	mov	r18, r24
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	99 1f       	adc	r25, r25
     b20:	99 27       	eor	r25, r25
     b22:	99 1f       	adc	r25, r25
     b24:	11 96       	adiw	r26, 0x01	; 1
     b26:	9c 93       	st	X, r25
     b28:	11 97       	sbiw	r26, 0x01	; 1
     b2a:	21 15       	cp	r18, r1
     b2c:	31 05       	cpc	r19, r1
     b2e:	a9 f5       	brne	.+106    	; 0xb9a <__unpack_f+0x9e>
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	61 05       	cpc	r22, r1
     b36:	71 05       	cpc	r23, r1
     b38:	11 f4       	brne	.+4      	; 0xb3e <__unpack_f+0x42>
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	37 c0       	rjmp	.+110    	; 0xbac <__unpack_f+0xb0>
     b3e:	82 e8       	ldi	r24, 0x82	; 130
     b40:	9f ef       	ldi	r25, 0xFF	; 255
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	9c 93       	st	X, r25
     b46:	8e 93       	st	-X, r24
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	9a 01       	movw	r18, r20
     b4c:	ab 01       	movw	r20, r22
     b4e:	67 e0       	ldi	r22, 0x07	; 7
     b50:	22 0f       	add	r18, r18
     b52:	33 1f       	adc	r19, r19
     b54:	44 1f       	adc	r20, r20
     b56:	55 1f       	adc	r21, r21
     b58:	6a 95       	dec	r22
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__unpack_f+0x54>
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	8c 93       	st	X, r24
     b60:	0d c0       	rjmp	.+26     	; 0xb7c <__unpack_f+0x80>
     b62:	22 0f       	add	r18, r18
     b64:	33 1f       	adc	r19, r19
     b66:	44 1f       	adc	r20, r20
     b68:	55 1f       	adc	r21, r21
     b6a:	12 96       	adiw	r26, 0x02	; 2
     b6c:	8d 91       	ld	r24, X+
     b6e:	9c 91       	ld	r25, X
     b70:	13 97       	sbiw	r26, 0x03	; 3
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	13 96       	adiw	r26, 0x03	; 3
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	20 30       	cpi	r18, 0x00	; 0
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	38 07       	cpc	r19, r24
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	48 07       	cpc	r20, r24
     b86:	80 e4       	ldi	r24, 0x40	; 64
     b88:	58 07       	cpc	r21, r24
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <__unpack_f+0x66>
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	2d 93       	st	X+, r18
     b90:	3d 93       	st	X+, r19
     b92:	4d 93       	st	X+, r20
     b94:	5c 93       	st	X, r21
     b96:	17 97       	sbiw	r26, 0x07	; 7
     b98:	08 95       	ret
     b9a:	2f 3f       	cpi	r18, 0xFF	; 255
     b9c:	31 05       	cpc	r19, r1
     b9e:	79 f4       	brne	.+30     	; 0xbbe <__unpack_f+0xc2>
     ba0:	41 15       	cp	r20, r1
     ba2:	51 05       	cpc	r21, r1
     ba4:	61 05       	cpc	r22, r1
     ba6:	71 05       	cpc	r23, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <__unpack_f+0xb4>
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	8c 93       	st	X, r24
     bae:	08 95       	ret
     bb0:	64 ff       	sbrs	r22, 4
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <__unpack_f+0xbe>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	12 c0       	rjmp	.+36     	; 0xbde <__unpack_f+0xe2>
     bba:	1c 92       	st	X, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <__unpack_f+0xe2>
     bbe:	2f 57       	subi	r18, 0x7F	; 127
     bc0:	30 40       	sbci	r19, 0x00	; 0
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	3c 93       	st	X, r19
     bc6:	2e 93       	st	-X, r18
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	8c 93       	st	X, r24
     bce:	87 e0       	ldi	r24, 0x07	; 7
     bd0:	44 0f       	add	r20, r20
     bd2:	55 1f       	adc	r21, r21
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	8a 95       	dec	r24
     bda:	d1 f7       	brne	.-12     	; 0xbd0 <__unpack_f+0xd4>
     bdc:	70 64       	ori	r23, 0x40	; 64
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	4d 93       	st	X+, r20
     be2:	5d 93       	st	X+, r21
     be4:	6d 93       	st	X+, r22
     be6:	7c 93       	st	X, r23
     be8:	17 97       	sbiw	r26, 0x07	; 7
     bea:	08 95       	ret

00000bec <__fpcmp_parts_f>:
     bec:	1f 93       	push	r17
     bee:	dc 01       	movw	r26, r24
     bf0:	fb 01       	movw	r30, r22
     bf2:	9c 91       	ld	r25, X
     bf4:	92 30       	cpi	r25, 0x02	; 2
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <__fpcmp_parts_f+0xe>
     bf8:	47 c0       	rjmp	.+142    	; 0xc88 <__fpcmp_parts_f+0x9c>
     bfa:	80 81       	ld	r24, Z
     bfc:	82 30       	cpi	r24, 0x02	; 2
     bfe:	08 f4       	brcc	.+2      	; 0xc02 <__fpcmp_parts_f+0x16>
     c00:	43 c0       	rjmp	.+134    	; 0xc88 <__fpcmp_parts_f+0x9c>
     c02:	94 30       	cpi	r25, 0x04	; 4
     c04:	51 f4       	brne	.+20     	; 0xc1a <__fpcmp_parts_f+0x2e>
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	1c 91       	ld	r17, X
     c0a:	84 30       	cpi	r24, 0x04	; 4
     c0c:	99 f5       	brne	.+102    	; 0xc74 <__fpcmp_parts_f+0x88>
     c0e:	81 81       	ldd	r24, Z+1	; 0x01
     c10:	68 2f       	mov	r22, r24
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	61 1b       	sub	r22, r17
     c16:	71 09       	sbc	r23, r1
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <__fpcmp_parts_f+0xac>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	21 f0       	breq	.+8      	; 0xc26 <__fpcmp_parts_f+0x3a>
     c1e:	92 30       	cpi	r25, 0x02	; 2
     c20:	31 f4       	brne	.+12     	; 0xc2e <__fpcmp_parts_f+0x42>
     c22:	82 30       	cpi	r24, 0x02	; 2
     c24:	b9 f1       	breq	.+110    	; 0xc94 <__fpcmp_parts_f+0xa8>
     c26:	81 81       	ldd	r24, Z+1	; 0x01
     c28:	88 23       	and	r24, r24
     c2a:	89 f1       	breq	.+98     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c2c:	2d c0       	rjmp	.+90     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	1c 91       	ld	r17, X
     c32:	11 97       	sbiw	r26, 0x01	; 1
     c34:	82 30       	cpi	r24, 0x02	; 2
     c36:	f1 f0       	breq	.+60     	; 0xc74 <__fpcmp_parts_f+0x88>
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	18 17       	cp	r17, r24
     c3c:	d9 f4       	brne	.+54     	; 0xc74 <__fpcmp_parts_f+0x88>
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	2d 91       	ld	r18, X+
     c42:	3c 91       	ld	r19, X
     c44:	13 97       	sbiw	r26, 0x03	; 3
     c46:	82 81       	ldd	r24, Z+2	; 0x02
     c48:	93 81       	ldd	r25, Z+3	; 0x03
     c4a:	82 17       	cp	r24, r18
     c4c:	93 07       	cpc	r25, r19
     c4e:	94 f0       	brlt	.+36     	; 0xc74 <__fpcmp_parts_f+0x88>
     c50:	28 17       	cp	r18, r24
     c52:	39 07       	cpc	r19, r25
     c54:	bc f0       	brlt	.+46     	; 0xc84 <__fpcmp_parts_f+0x98>
     c56:	14 96       	adiw	r26, 0x04	; 4
     c58:	8d 91       	ld	r24, X+
     c5a:	9d 91       	ld	r25, X+
     c5c:	0d 90       	ld	r0, X+
     c5e:	bc 91       	ld	r27, X
     c60:	a0 2d       	mov	r26, r0
     c62:	24 81       	ldd	r18, Z+4	; 0x04
     c64:	35 81       	ldd	r19, Z+5	; 0x05
     c66:	46 81       	ldd	r20, Z+6	; 0x06
     c68:	57 81       	ldd	r21, Z+7	; 0x07
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	4a 07       	cpc	r20, r26
     c70:	5b 07       	cpc	r21, r27
     c72:	18 f4       	brcc	.+6      	; 0xc7a <__fpcmp_parts_f+0x8e>
     c74:	11 23       	and	r17, r17
     c76:	41 f0       	breq	.+16     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c78:	0a c0       	rjmp	.+20     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c7a:	82 17       	cp	r24, r18
     c7c:	93 07       	cpc	r25, r19
     c7e:	a4 07       	cpc	r26, r20
     c80:	b5 07       	cpc	r27, r21
     c82:	40 f4       	brcc	.+16     	; 0xc94 <__fpcmp_parts_f+0xa8>
     c84:	11 23       	and	r17, r17
     c86:	19 f0       	breq	.+6      	; 0xc8e <__fpcmp_parts_f+0xa2>
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	70 e0       	ldi	r23, 0x00	; 0
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <__fpcmp_parts_f+0xac>
     c8e:	6f ef       	ldi	r22, 0xFF	; 255
     c90:	7f ef       	ldi	r23, 0xFF	; 255
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <__fpcmp_parts_f+0xac>
     c94:	60 e0       	ldi	r22, 0x00	; 0
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	cb 01       	movw	r24, r22
     c9a:	1f 91       	pop	r17
     c9c:	08 95       	ret

00000c9e <DIO_voidInit>:
#include "DIO_interface.h"
#include "DIO_private.h"
#include "DIO_config.h"

void DIO_voidInit(void)
{
     c9e:	df 93       	push	r29
     ca0:	cf 93       	push	r28
     ca2:	cd b7       	in	r28, 0x3d	; 61
     ca4:	de b7       	in	r29, 0x3e	; 62
	DIO_u8_DDRA_REG = Conc(DIO_u8_PA7_INTIAL_DIRECTION, DIO_u8_PA6_INTIAL_DIRECTION, DIO_u8_PA5_INTIAL_DIRECTION, DIO_u8_PA4_INTIAL_DIRECTION,DIO_u8_PA3_INTIAL_DIRECTION, DIO_u8_PA2_INTIAL_DIRECTION, DIO_u8_PA1_INTIAL_DIRECTION, DIO_u8_PA0_INTIAL_DIRECTION);
     ca6:	ea e3       	ldi	r30, 0x3A	; 58
     ca8:	f0 e0       	ldi	r31, 0x00	; 0
     caa:	87 e0       	ldi	r24, 0x07	; 7
     cac:	80 83       	st	Z, r24

	DIO_u8_DDRB_REG = Conc(DIO_u8_PB7_INTIAL_DIRECTION, DIO_u8_PB6_INTIAL_DIRECTION, DIO_u8_PB5_INTIAL_DIRECTION, DIO_u8_PB4_INTIAL_DIRECTION,DIO_u8_PB3_INTIAL_DIRECTION, DIO_u8_PB2_INTIAL_DIRECTION, DIO_u8_PB1_INTIAL_DIRECTION, DIO_u8_PB0_INTIAL_DIRECTION);
     cae:	e7 e3       	ldi	r30, 0x37	; 55
     cb0:	f0 e0       	ldi	r31, 0x00	; 0
     cb2:	10 82       	st	Z, r1

	DIO_u8_DDRC_REG = Conc(DIO_u8_PC7_INTIAL_DIRECTION, DIO_u8_PC6_INTIAL_DIRECTION, DIO_u8_PC5_INTIAL_DIRECTION, DIO_u8_PC4_INTIAL_DIRECTION,DIO_u8_PC3_INTIAL_DIRECTION, DIO_u8_PC2_INTIAL_DIRECTION, DIO_u8_PC1_INTIAL_DIRECTION, DIO_u8_PC0_INTIAL_DIRECTION);
     cb4:	e4 e3       	ldi	r30, 0x34	; 52
     cb6:	f0 e0       	ldi	r31, 0x00	; 0
     cb8:	8f ef       	ldi	r24, 0xFF	; 255
     cba:	80 83       	st	Z, r24

	DIO_u8_DDRD_REG = Conc(DIO_u8_PD7_INTIAL_DIRECTION, DIO_u8_PD6_INTIAL_DIRECTION, DIO_u8_PD5_INTIAL_DIRECTION, DIO_u8_PD4_INTIAL_DIRECTION,DIO_u8_PD3_INTIAL_DIRECTION, DIO_u8_PD2_INTIAL_DIRECTION, DIO_u8_PD1_INTIAL_DIRECTION, DIO_u8_PD0_INTIAL_DIRECTION);
     cbc:	e1 e3       	ldi	r30, 0x31	; 49
     cbe:	f0 e0       	ldi	r31, 0x00	; 0
     cc0:	10 82       	st	Z, r1


	DIO_u8_PORTA_REG = Conc(DIO_u8_PA7_INTIAL_VALUE, DIO_u8_PA6_INTIAL_VALUE, DIO_u8_PA5_INTIAL_VALUE, DIO_u8_PA4_INTIAL_VALUE,DIO_u8_PA3_INTIAL_VALUE, DIO_u8_PA2_INTIAL_VALUE, DIO_u8_PA1_INTIAL_VALUE, DIO_u8_PA0_INTIAL_VALUE);
     cc2:	eb e3       	ldi	r30, 0x3B	; 59
     cc4:	f0 e0       	ldi	r31, 0x00	; 0
     cc6:	10 82       	st	Z, r1

	DIO_u8_PORTB_REG = Conc(DIO_u8_PB7_INTIAL_VALUE, DIO_u8_PB6_INTIAL_VALUE, DIO_u8_PB5_INTIAL_VALUE, DIO_u8_PB4_INTIAL_VALUE,DIO_u8_PB3_INTIAL_VALUE, DIO_u8_PB2_INTIAL_VALUE, DIO_u8_PB1_INTIAL_VALUE, DIO_u8_PB0_INTIAL_VALUE);
     cc8:	e8 e3       	ldi	r30, 0x38	; 56
     cca:	f0 e0       	ldi	r31, 0x00	; 0
     ccc:	81 e0       	ldi	r24, 0x01	; 1
     cce:	80 83       	st	Z, r24

	DIO_u8_PORTC_REG = Conc(DIO_u8_PC7_INTIAL_VALUE, DIO_u8_PC6_INTIAL_VALUE, DIO_u8_PC5_INTIAL_VALUE, DIO_u8_PC4_INTIAL_VALUE,DIO_u8_PC3_INTIAL_VALUE, DIO_u8_PC2_INTIAL_VALUE, DIO_u8_PC1_INTIAL_VALUE, DIO_u8_PC0_INTIAL_VALUE);
     cd0:	e5 e3       	ldi	r30, 0x35	; 53
     cd2:	f0 e0       	ldi	r31, 0x00	; 0
     cd4:	10 82       	st	Z, r1

	DIO_u8_PORTD_REG = Conc(DIO_u8_PD7_INTIAL_VALUE, DIO_u8_PD6_INTIAL_VALUE, DIO_u8_PD5_INTIAL_VALUE, DIO_u8_PD4_INTIAL_VALUE,DIO_u8_PD3_INTIAL_VALUE, DIO_u8_PD2_INTIAL_VALUE, DIO_u8_PD1_INTIAL_VALUE, DIO_u8_PD0_INTIAL_VALUE);
     cd6:	e2 e3       	ldi	r30, 0x32	; 50
     cd8:	f0 e0       	ldi	r31, 0x00	; 0
     cda:	10 82       	st	Z, r1

}
     cdc:	cf 91       	pop	r28
     cde:	df 91       	pop	r29
     ce0:	08 95       	ret

00000ce2 <DIO_u8SetPinDirection>:


u8 DIO_u8SetPinDirection(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8PinDirection)
{
     ce2:	df 93       	push	r29
     ce4:	cf 93       	push	r28
     ce6:	cd b7       	in	r28, 0x3d	; 61
     ce8:	de b7       	in	r29, 0x3e	; 62
     cea:	2e 97       	sbiw	r28, 0x0e	; 14
     cec:	0f b6       	in	r0, 0x3f	; 63
     cee:	f8 94       	cli
     cf0:	de bf       	out	0x3e, r29	; 62
     cf2:	0f be       	out	0x3f, r0	; 63
     cf4:	cd bf       	out	0x3d, r28	; 61
     cf6:	8a 83       	std	Y+2, r24	; 0x02
     cf8:	6b 83       	std	Y+3, r22	; 0x03
     cfa:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState = STD_TYPES_OK;
     cfc:	81 e0       	ldi	r24, 0x01	; 1
     cfe:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortId <= DIO_u8_PORTD) && (Copy_u8PinId <= DIO_u8_PIN7)&&((Copy_u8PinDirection == DIO_u8_INPUT)||(Copy_u8PinDirection == DIO_u8_OUTPUT)))
     d00:	8a 81       	ldd	r24, Y+2	; 0x02
     d02:	84 30       	cpi	r24, 0x04	; 4
     d04:	08 f0       	brcs	.+2      	; 0xd08 <DIO_u8SetPinDirection+0x26>
     d06:	0d c1       	rjmp	.+538    	; 0xf22 <DIO_u8SetPinDirection+0x240>
     d08:	8b 81       	ldd	r24, Y+3	; 0x03
     d0a:	88 30       	cpi	r24, 0x08	; 8
     d0c:	08 f0       	brcs	.+2      	; 0xd10 <DIO_u8SetPinDirection+0x2e>
     d0e:	09 c1       	rjmp	.+530    	; 0xf22 <DIO_u8SetPinDirection+0x240>
     d10:	8c 81       	ldd	r24, Y+4	; 0x04
     d12:	88 23       	and	r24, r24
     d14:	21 f0       	breq	.+8      	; 0xd1e <DIO_u8SetPinDirection+0x3c>
     d16:	8c 81       	ldd	r24, Y+4	; 0x04
     d18:	81 30       	cpi	r24, 0x01	; 1
     d1a:	09 f0       	breq	.+2      	; 0xd1e <DIO_u8SetPinDirection+0x3c>
     d1c:	02 c1       	rjmp	.+516    	; 0xf22 <DIO_u8SetPinDirection+0x240>
	{
		switch(Copy_u8PortId)
     d1e:	8a 81       	ldd	r24, Y+2	; 0x02
     d20:	28 2f       	mov	r18, r24
     d22:	30 e0       	ldi	r19, 0x00	; 0
     d24:	3e 87       	std	Y+14, r19	; 0x0e
     d26:	2d 87       	std	Y+13, r18	; 0x0d
     d28:	8d 85       	ldd	r24, Y+13	; 0x0d
     d2a:	9e 85       	ldd	r25, Y+14	; 0x0e
     d2c:	81 30       	cpi	r24, 0x01	; 1
     d2e:	91 05       	cpc	r25, r1
     d30:	09 f4       	brne	.+2      	; 0xd34 <DIO_u8SetPinDirection+0x52>
     d32:	4f c0       	rjmp	.+158    	; 0xdd2 <DIO_u8SetPinDirection+0xf0>
     d34:	2d 85       	ldd	r18, Y+13	; 0x0d
     d36:	3e 85       	ldd	r19, Y+14	; 0x0e
     d38:	22 30       	cpi	r18, 0x02	; 2
     d3a:	31 05       	cpc	r19, r1
     d3c:	2c f4       	brge	.+10     	; 0xd48 <DIO_u8SetPinDirection+0x66>
     d3e:	8d 85       	ldd	r24, Y+13	; 0x0d
     d40:	9e 85       	ldd	r25, Y+14	; 0x0e
     d42:	00 97       	sbiw	r24, 0x00	; 0
     d44:	71 f0       	breq	.+28     	; 0xd62 <DIO_u8SetPinDirection+0x80>
     d46:	ee c0       	rjmp	.+476    	; 0xf24 <DIO_u8SetPinDirection+0x242>
     d48:	2d 85       	ldd	r18, Y+13	; 0x0d
     d4a:	3e 85       	ldd	r19, Y+14	; 0x0e
     d4c:	22 30       	cpi	r18, 0x02	; 2
     d4e:	31 05       	cpc	r19, r1
     d50:	09 f4       	brne	.+2      	; 0xd54 <DIO_u8SetPinDirection+0x72>
     d52:	77 c0       	rjmp	.+238    	; 0xe42 <DIO_u8SetPinDirection+0x160>
     d54:	8d 85       	ldd	r24, Y+13	; 0x0d
     d56:	9e 85       	ldd	r25, Y+14	; 0x0e
     d58:	83 30       	cpi	r24, 0x03	; 3
     d5a:	91 05       	cpc	r25, r1
     d5c:	09 f4       	brne	.+2      	; 0xd60 <DIO_u8SetPinDirection+0x7e>
     d5e:	a9 c0       	rjmp	.+338    	; 0xeb2 <DIO_u8SetPinDirection+0x1d0>
     d60:	e1 c0       	rjmp	.+450    	; 0xf24 <DIO_u8SetPinDirection+0x242>
		{
			case DIO_u8_PORTA:
				switch(Copy_u8PinId)
     d62:	8b 81       	ldd	r24, Y+3	; 0x03
     d64:	28 2f       	mov	r18, r24
     d66:	30 e0       	ldi	r19, 0x00	; 0
     d68:	3c 87       	std	Y+12, r19	; 0x0c
     d6a:	2b 87       	std	Y+11, r18	; 0x0b
     d6c:	8b 85       	ldd	r24, Y+11	; 0x0b
     d6e:	9c 85       	ldd	r25, Y+12	; 0x0c
     d70:	00 97       	sbiw	r24, 0x00	; 0
     d72:	31 f0       	breq	.+12     	; 0xd80 <DIO_u8SetPinDirection+0x9e>
     d74:	2b 85       	ldd	r18, Y+11	; 0x0b
     d76:	3c 85       	ldd	r19, Y+12	; 0x0c
     d78:	21 30       	cpi	r18, 0x01	; 1
     d7a:	31 05       	cpc	r19, r1
     d7c:	b1 f0       	breq	.+44     	; 0xdaa <DIO_u8SetPinDirection+0xc8>
     d7e:	d2 c0       	rjmp	.+420    	; 0xf24 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRA_REG,Copy_u8PinId);break;
     d80:	aa e3       	ldi	r26, 0x3A	; 58
     d82:	b0 e0       	ldi	r27, 0x00	; 0
     d84:	ea e3       	ldi	r30, 0x3A	; 58
     d86:	f0 e0       	ldi	r31, 0x00	; 0
     d88:	80 81       	ld	r24, Z
     d8a:	48 2f       	mov	r20, r24
     d8c:	8b 81       	ldd	r24, Y+3	; 0x03
     d8e:	28 2f       	mov	r18, r24
     d90:	30 e0       	ldi	r19, 0x00	; 0
     d92:	81 e0       	ldi	r24, 0x01	; 1
     d94:	90 e0       	ldi	r25, 0x00	; 0
     d96:	02 2e       	mov	r0, r18
     d98:	02 c0       	rjmp	.+4      	; 0xd9e <DIO_u8SetPinDirection+0xbc>
     d9a:	88 0f       	add	r24, r24
     d9c:	99 1f       	adc	r25, r25
     d9e:	0a 94       	dec	r0
     da0:	e2 f7       	brpl	.-8      	; 0xd9a <DIO_u8SetPinDirection+0xb8>
     da2:	80 95       	com	r24
     da4:	84 23       	and	r24, r20
     da6:	8c 93       	st	X, r24
     da8:	bd c0       	rjmp	.+378    	; 0xf24 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRA_REG,Copy_u8PinId);break;
     daa:	aa e3       	ldi	r26, 0x3A	; 58
     dac:	b0 e0       	ldi	r27, 0x00	; 0
     dae:	ea e3       	ldi	r30, 0x3A	; 58
     db0:	f0 e0       	ldi	r31, 0x00	; 0
     db2:	80 81       	ld	r24, Z
     db4:	48 2f       	mov	r20, r24
     db6:	8b 81       	ldd	r24, Y+3	; 0x03
     db8:	28 2f       	mov	r18, r24
     dba:	30 e0       	ldi	r19, 0x00	; 0
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	02 2e       	mov	r0, r18
     dc2:	02 c0       	rjmp	.+4      	; 0xdc8 <DIO_u8SetPinDirection+0xe6>
     dc4:	88 0f       	add	r24, r24
     dc6:	99 1f       	adc	r25, r25
     dc8:	0a 94       	dec	r0
     dca:	e2 f7       	brpl	.-8      	; 0xdc4 <DIO_u8SetPinDirection+0xe2>
     dcc:	84 2b       	or	r24, r20
     dce:	8c 93       	st	X, r24
     dd0:	a9 c0       	rjmp	.+338    	; 0xf24 <DIO_u8SetPinDirection+0x242>
				}
			break;
			case DIO_u8_PORTB:
				switch(Copy_u8PinId)
     dd2:	8b 81       	ldd	r24, Y+3	; 0x03
     dd4:	28 2f       	mov	r18, r24
     dd6:	30 e0       	ldi	r19, 0x00	; 0
     dd8:	3a 87       	std	Y+10, r19	; 0x0a
     dda:	29 87       	std	Y+9, r18	; 0x09
     ddc:	89 85       	ldd	r24, Y+9	; 0x09
     dde:	9a 85       	ldd	r25, Y+10	; 0x0a
     de0:	00 97       	sbiw	r24, 0x00	; 0
     de2:	31 f0       	breq	.+12     	; 0xdf0 <DIO_u8SetPinDirection+0x10e>
     de4:	29 85       	ldd	r18, Y+9	; 0x09
     de6:	3a 85       	ldd	r19, Y+10	; 0x0a
     de8:	21 30       	cpi	r18, 0x01	; 1
     dea:	31 05       	cpc	r19, r1
     dec:	b1 f0       	breq	.+44     	; 0xe1a <DIO_u8SetPinDirection+0x138>
     dee:	9a c0       	rjmp	.+308    	; 0xf24 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRB_REG,Copy_u8PinId);break;
     df0:	a7 e3       	ldi	r26, 0x37	; 55
     df2:	b0 e0       	ldi	r27, 0x00	; 0
     df4:	e7 e3       	ldi	r30, 0x37	; 55
     df6:	f0 e0       	ldi	r31, 0x00	; 0
     df8:	80 81       	ld	r24, Z
     dfa:	48 2f       	mov	r20, r24
     dfc:	8b 81       	ldd	r24, Y+3	; 0x03
     dfe:	28 2f       	mov	r18, r24
     e00:	30 e0       	ldi	r19, 0x00	; 0
     e02:	81 e0       	ldi	r24, 0x01	; 1
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	02 2e       	mov	r0, r18
     e08:	02 c0       	rjmp	.+4      	; 0xe0e <DIO_u8SetPinDirection+0x12c>
     e0a:	88 0f       	add	r24, r24
     e0c:	99 1f       	adc	r25, r25
     e0e:	0a 94       	dec	r0
     e10:	e2 f7       	brpl	.-8      	; 0xe0a <DIO_u8SetPinDirection+0x128>
     e12:	80 95       	com	r24
     e14:	84 23       	and	r24, r20
     e16:	8c 93       	st	X, r24
     e18:	85 c0       	rjmp	.+266    	; 0xf24 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRB_REG,Copy_u8PinId);break;
     e1a:	a7 e3       	ldi	r26, 0x37	; 55
     e1c:	b0 e0       	ldi	r27, 0x00	; 0
     e1e:	e7 e3       	ldi	r30, 0x37	; 55
     e20:	f0 e0       	ldi	r31, 0x00	; 0
     e22:	80 81       	ld	r24, Z
     e24:	48 2f       	mov	r20, r24
     e26:	8b 81       	ldd	r24, Y+3	; 0x03
     e28:	28 2f       	mov	r18, r24
     e2a:	30 e0       	ldi	r19, 0x00	; 0
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	90 e0       	ldi	r25, 0x00	; 0
     e30:	02 2e       	mov	r0, r18
     e32:	02 c0       	rjmp	.+4      	; 0xe38 <DIO_u8SetPinDirection+0x156>
     e34:	88 0f       	add	r24, r24
     e36:	99 1f       	adc	r25, r25
     e38:	0a 94       	dec	r0
     e3a:	e2 f7       	brpl	.-8      	; 0xe34 <DIO_u8SetPinDirection+0x152>
     e3c:	84 2b       	or	r24, r20
     e3e:	8c 93       	st	X, r24
     e40:	71 c0       	rjmp	.+226    	; 0xf24 <DIO_u8SetPinDirection+0x242>
				}
			break;
			case DIO_u8_PORTC:
				switch(Copy_u8PinId)
     e42:	8b 81       	ldd	r24, Y+3	; 0x03
     e44:	28 2f       	mov	r18, r24
     e46:	30 e0       	ldi	r19, 0x00	; 0
     e48:	38 87       	std	Y+8, r19	; 0x08
     e4a:	2f 83       	std	Y+7, r18	; 0x07
     e4c:	8f 81       	ldd	r24, Y+7	; 0x07
     e4e:	98 85       	ldd	r25, Y+8	; 0x08
     e50:	00 97       	sbiw	r24, 0x00	; 0
     e52:	31 f0       	breq	.+12     	; 0xe60 <DIO_u8SetPinDirection+0x17e>
     e54:	2f 81       	ldd	r18, Y+7	; 0x07
     e56:	38 85       	ldd	r19, Y+8	; 0x08
     e58:	21 30       	cpi	r18, 0x01	; 1
     e5a:	31 05       	cpc	r19, r1
     e5c:	b1 f0       	breq	.+44     	; 0xe8a <DIO_u8SetPinDirection+0x1a8>
     e5e:	62 c0       	rjmp	.+196    	; 0xf24 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRC_REG,Copy_u8PinId);break;
     e60:	a4 e3       	ldi	r26, 0x34	; 52
     e62:	b0 e0       	ldi	r27, 0x00	; 0
     e64:	e4 e3       	ldi	r30, 0x34	; 52
     e66:	f0 e0       	ldi	r31, 0x00	; 0
     e68:	80 81       	ld	r24, Z
     e6a:	48 2f       	mov	r20, r24
     e6c:	8b 81       	ldd	r24, Y+3	; 0x03
     e6e:	28 2f       	mov	r18, r24
     e70:	30 e0       	ldi	r19, 0x00	; 0
     e72:	81 e0       	ldi	r24, 0x01	; 1
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	02 2e       	mov	r0, r18
     e78:	02 c0       	rjmp	.+4      	; 0xe7e <DIO_u8SetPinDirection+0x19c>
     e7a:	88 0f       	add	r24, r24
     e7c:	99 1f       	adc	r25, r25
     e7e:	0a 94       	dec	r0
     e80:	e2 f7       	brpl	.-8      	; 0xe7a <DIO_u8SetPinDirection+0x198>
     e82:	80 95       	com	r24
     e84:	84 23       	and	r24, r20
     e86:	8c 93       	st	X, r24
     e88:	4d c0       	rjmp	.+154    	; 0xf24 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRC_REG,Copy_u8PinId);break;
     e8a:	a4 e3       	ldi	r26, 0x34	; 52
     e8c:	b0 e0       	ldi	r27, 0x00	; 0
     e8e:	e4 e3       	ldi	r30, 0x34	; 52
     e90:	f0 e0       	ldi	r31, 0x00	; 0
     e92:	80 81       	ld	r24, Z
     e94:	48 2f       	mov	r20, r24
     e96:	8b 81       	ldd	r24, Y+3	; 0x03
     e98:	28 2f       	mov	r18, r24
     e9a:	30 e0       	ldi	r19, 0x00	; 0
     e9c:	81 e0       	ldi	r24, 0x01	; 1
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	02 2e       	mov	r0, r18
     ea2:	02 c0       	rjmp	.+4      	; 0xea8 <DIO_u8SetPinDirection+0x1c6>
     ea4:	88 0f       	add	r24, r24
     ea6:	99 1f       	adc	r25, r25
     ea8:	0a 94       	dec	r0
     eaa:	e2 f7       	brpl	.-8      	; 0xea4 <DIO_u8SetPinDirection+0x1c2>
     eac:	84 2b       	or	r24, r20
     eae:	8c 93       	st	X, r24
     eb0:	39 c0       	rjmp	.+114    	; 0xf24 <DIO_u8SetPinDirection+0x242>
				}
			break;
			case DIO_u8_PORTD:
				switch(Copy_u8PinId)
     eb2:	8b 81       	ldd	r24, Y+3	; 0x03
     eb4:	28 2f       	mov	r18, r24
     eb6:	30 e0       	ldi	r19, 0x00	; 0
     eb8:	3e 83       	std	Y+6, r19	; 0x06
     eba:	2d 83       	std	Y+5, r18	; 0x05
     ebc:	8d 81       	ldd	r24, Y+5	; 0x05
     ebe:	9e 81       	ldd	r25, Y+6	; 0x06
     ec0:	00 97       	sbiw	r24, 0x00	; 0
     ec2:	31 f0       	breq	.+12     	; 0xed0 <DIO_u8SetPinDirection+0x1ee>
     ec4:	2d 81       	ldd	r18, Y+5	; 0x05
     ec6:	3e 81       	ldd	r19, Y+6	; 0x06
     ec8:	21 30       	cpi	r18, 0x01	; 1
     eca:	31 05       	cpc	r19, r1
     ecc:	b1 f0       	breq	.+44     	; 0xefa <DIO_u8SetPinDirection+0x218>
     ece:	2a c0       	rjmp	.+84     	; 0xf24 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRD_REG,Copy_u8PinId);break;
     ed0:	a1 e3       	ldi	r26, 0x31	; 49
     ed2:	b0 e0       	ldi	r27, 0x00	; 0
     ed4:	e1 e3       	ldi	r30, 0x31	; 49
     ed6:	f0 e0       	ldi	r31, 0x00	; 0
     ed8:	80 81       	ld	r24, Z
     eda:	48 2f       	mov	r20, r24
     edc:	8b 81       	ldd	r24, Y+3	; 0x03
     ede:	28 2f       	mov	r18, r24
     ee0:	30 e0       	ldi	r19, 0x00	; 0
     ee2:	81 e0       	ldi	r24, 0x01	; 1
     ee4:	90 e0       	ldi	r25, 0x00	; 0
     ee6:	02 2e       	mov	r0, r18
     ee8:	02 c0       	rjmp	.+4      	; 0xeee <DIO_u8SetPinDirection+0x20c>
     eea:	88 0f       	add	r24, r24
     eec:	99 1f       	adc	r25, r25
     eee:	0a 94       	dec	r0
     ef0:	e2 f7       	brpl	.-8      	; 0xeea <DIO_u8SetPinDirection+0x208>
     ef2:	80 95       	com	r24
     ef4:	84 23       	and	r24, r20
     ef6:	8c 93       	st	X, r24
     ef8:	15 c0       	rjmp	.+42     	; 0xf24 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRD_REG,Copy_u8PinId);break;
     efa:	a1 e3       	ldi	r26, 0x31	; 49
     efc:	b0 e0       	ldi	r27, 0x00	; 0
     efe:	e1 e3       	ldi	r30, 0x31	; 49
     f00:	f0 e0       	ldi	r31, 0x00	; 0
     f02:	80 81       	ld	r24, Z
     f04:	48 2f       	mov	r20, r24
     f06:	8b 81       	ldd	r24, Y+3	; 0x03
     f08:	28 2f       	mov	r18, r24
     f0a:	30 e0       	ldi	r19, 0x00	; 0
     f0c:	81 e0       	ldi	r24, 0x01	; 1
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	02 2e       	mov	r0, r18
     f12:	02 c0       	rjmp	.+4      	; 0xf18 <DIO_u8SetPinDirection+0x236>
     f14:	88 0f       	add	r24, r24
     f16:	99 1f       	adc	r25, r25
     f18:	0a 94       	dec	r0
     f1a:	e2 f7       	brpl	.-8      	; 0xf14 <DIO_u8SetPinDirection+0x232>
     f1c:	84 2b       	or	r24, r20
     f1e:	8c 93       	st	X, r24
     f20:	01 c0       	rjmp	.+2      	; 0xf24 <DIO_u8SetPinDirection+0x242>
			break;
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
     f22:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
     f24:	89 81       	ldd	r24, Y+1	; 0x01
}
     f26:	2e 96       	adiw	r28, 0x0e	; 14
     f28:	0f b6       	in	r0, 0x3f	; 63
     f2a:	f8 94       	cli
     f2c:	de bf       	out	0x3e, r29	; 62
     f2e:	0f be       	out	0x3f, r0	; 63
     f30:	cd bf       	out	0x3d, r28	; 61
     f32:	cf 91       	pop	r28
     f34:	df 91       	pop	r29
     f36:	08 95       	ret

00000f38 <DIO_u8SetPinValue>:

u8 DIO_u8SetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8PinValue)
{
     f38:	df 93       	push	r29
     f3a:	cf 93       	push	r28
     f3c:	cd b7       	in	r28, 0x3d	; 61
     f3e:	de b7       	in	r29, 0x3e	; 62
     f40:	2e 97       	sbiw	r28, 0x0e	; 14
     f42:	0f b6       	in	r0, 0x3f	; 63
     f44:	f8 94       	cli
     f46:	de bf       	out	0x3e, r29	; 62
     f48:	0f be       	out	0x3f, r0	; 63
     f4a:	cd bf       	out	0x3d, r28	; 61
     f4c:	8a 83       	std	Y+2, r24	; 0x02
     f4e:	6b 83       	std	Y+3, r22	; 0x03
     f50:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState = STD_TYPES_OK;
     f52:	81 e0       	ldi	r24, 0x01	; 1
     f54:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinId <= DIO_u8_PIN7)
     f56:	8b 81       	ldd	r24, Y+3	; 0x03
     f58:	88 30       	cpi	r24, 0x08	; 8
     f5a:	08 f0       	brcs	.+2      	; 0xf5e <DIO_u8SetPinValue+0x26>
     f5c:	0c c1       	rjmp	.+536    	; 0x1176 <DIO_u8SetPinValue+0x23e>
	{
		switch(Copy_u8PortId)
     f5e:	8a 81       	ldd	r24, Y+2	; 0x02
     f60:	28 2f       	mov	r18, r24
     f62:	30 e0       	ldi	r19, 0x00	; 0
     f64:	3e 87       	std	Y+14, r19	; 0x0e
     f66:	2d 87       	std	Y+13, r18	; 0x0d
     f68:	8d 85       	ldd	r24, Y+13	; 0x0d
     f6a:	9e 85       	ldd	r25, Y+14	; 0x0e
     f6c:	81 30       	cpi	r24, 0x01	; 1
     f6e:	91 05       	cpc	r25, r1
     f70:	09 f4       	brne	.+2      	; 0xf74 <DIO_u8SetPinValue+0x3c>
     f72:	51 c0       	rjmp	.+162    	; 0x1016 <DIO_u8SetPinValue+0xde>
     f74:	2d 85       	ldd	r18, Y+13	; 0x0d
     f76:	3e 85       	ldd	r19, Y+14	; 0x0e
     f78:	22 30       	cpi	r18, 0x02	; 2
     f7a:	31 05       	cpc	r19, r1
     f7c:	2c f4       	brge	.+10     	; 0xf88 <DIO_u8SetPinValue+0x50>
     f7e:	8d 85       	ldd	r24, Y+13	; 0x0d
     f80:	9e 85       	ldd	r25, Y+14	; 0x0e
     f82:	00 97       	sbiw	r24, 0x00	; 0
     f84:	71 f0       	breq	.+28     	; 0xfa2 <DIO_u8SetPinValue+0x6a>
     f86:	f5 c0       	rjmp	.+490    	; 0x1172 <DIO_u8SetPinValue+0x23a>
     f88:	2d 85       	ldd	r18, Y+13	; 0x0d
     f8a:	3e 85       	ldd	r19, Y+14	; 0x0e
     f8c:	22 30       	cpi	r18, 0x02	; 2
     f8e:	31 05       	cpc	r19, r1
     f90:	09 f4       	brne	.+2      	; 0xf94 <DIO_u8SetPinValue+0x5c>
     f92:	7b c0       	rjmp	.+246    	; 0x108a <DIO_u8SetPinValue+0x152>
     f94:	8d 85       	ldd	r24, Y+13	; 0x0d
     f96:	9e 85       	ldd	r25, Y+14	; 0x0e
     f98:	83 30       	cpi	r24, 0x03	; 3
     f9a:	91 05       	cpc	r25, r1
     f9c:	09 f4       	brne	.+2      	; 0xfa0 <DIO_u8SetPinValue+0x68>
     f9e:	af c0       	rjmp	.+350    	; 0x10fe <DIO_u8SetPinValue+0x1c6>
     fa0:	e8 c0       	rjmp	.+464    	; 0x1172 <DIO_u8SetPinValue+0x23a>
		{
			case DIO_u8_PORTA:
				switch(Copy_u8PinValue)
     fa2:	8c 81       	ldd	r24, Y+4	; 0x04
     fa4:	28 2f       	mov	r18, r24
     fa6:	30 e0       	ldi	r19, 0x00	; 0
     fa8:	3c 87       	std	Y+12, r19	; 0x0c
     faa:	2b 87       	std	Y+11, r18	; 0x0b
     fac:	8b 85       	ldd	r24, Y+11	; 0x0b
     fae:	9c 85       	ldd	r25, Y+12	; 0x0c
     fb0:	00 97       	sbiw	r24, 0x00	; 0
     fb2:	31 f0       	breq	.+12     	; 0xfc0 <DIO_u8SetPinValue+0x88>
     fb4:	2b 85       	ldd	r18, Y+11	; 0x0b
     fb6:	3c 85       	ldd	r19, Y+12	; 0x0c
     fb8:	21 30       	cpi	r18, 0x01	; 1
     fba:	31 05       	cpc	r19, r1
     fbc:	b1 f0       	breq	.+44     	; 0xfea <DIO_u8SetPinValue+0xb2>
     fbe:	29 c0       	rjmp	.+82     	; 0x1012 <DIO_u8SetPinValue+0xda>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTA_REG,Copy_u8PinId);break;
     fc0:	ab e3       	ldi	r26, 0x3B	; 59
     fc2:	b0 e0       	ldi	r27, 0x00	; 0
     fc4:	eb e3       	ldi	r30, 0x3B	; 59
     fc6:	f0 e0       	ldi	r31, 0x00	; 0
     fc8:	80 81       	ld	r24, Z
     fca:	48 2f       	mov	r20, r24
     fcc:	8b 81       	ldd	r24, Y+3	; 0x03
     fce:	28 2f       	mov	r18, r24
     fd0:	30 e0       	ldi	r19, 0x00	; 0
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	02 2e       	mov	r0, r18
     fd8:	02 c0       	rjmp	.+4      	; 0xfde <DIO_u8SetPinValue+0xa6>
     fda:	88 0f       	add	r24, r24
     fdc:	99 1f       	adc	r25, r25
     fde:	0a 94       	dec	r0
     fe0:	e2 f7       	brpl	.-8      	; 0xfda <DIO_u8SetPinValue+0xa2>
     fe2:	80 95       	com	r24
     fe4:	84 23       	and	r24, r20
     fe6:	8c 93       	st	X, r24
     fe8:	c7 c0       	rjmp	.+398    	; 0x1178 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTA_REG,Copy_u8PinId);break;
     fea:	ab e3       	ldi	r26, 0x3B	; 59
     fec:	b0 e0       	ldi	r27, 0x00	; 0
     fee:	eb e3       	ldi	r30, 0x3B	; 59
     ff0:	f0 e0       	ldi	r31, 0x00	; 0
     ff2:	80 81       	ld	r24, Z
     ff4:	48 2f       	mov	r20, r24
     ff6:	8b 81       	ldd	r24, Y+3	; 0x03
     ff8:	28 2f       	mov	r18, r24
     ffa:	30 e0       	ldi	r19, 0x00	; 0
     ffc:	81 e0       	ldi	r24, 0x01	; 1
     ffe:	90 e0       	ldi	r25, 0x00	; 0
    1000:	02 2e       	mov	r0, r18
    1002:	02 c0       	rjmp	.+4      	; 0x1008 <DIO_u8SetPinValue+0xd0>
    1004:	88 0f       	add	r24, r24
    1006:	99 1f       	adc	r25, r25
    1008:	0a 94       	dec	r0
    100a:	e2 f7       	brpl	.-8      	; 0x1004 <DIO_u8SetPinValue+0xcc>
    100c:	84 2b       	or	r24, r20
    100e:	8c 93       	st	X, r24
    1010:	b3 c0       	rjmp	.+358    	; 0x1178 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
    1012:	19 82       	std	Y+1, r1	; 0x01
    1014:	b1 c0       	rjmp	.+354    	; 0x1178 <DIO_u8SetPinValue+0x240>
				}
			break;
			case DIO_u8_PORTB:
				switch(Copy_u8PinValue)
    1016:	8c 81       	ldd	r24, Y+4	; 0x04
    1018:	28 2f       	mov	r18, r24
    101a:	30 e0       	ldi	r19, 0x00	; 0
    101c:	3a 87       	std	Y+10, r19	; 0x0a
    101e:	29 87       	std	Y+9, r18	; 0x09
    1020:	89 85       	ldd	r24, Y+9	; 0x09
    1022:	9a 85       	ldd	r25, Y+10	; 0x0a
    1024:	00 97       	sbiw	r24, 0x00	; 0
    1026:	31 f0       	breq	.+12     	; 0x1034 <DIO_u8SetPinValue+0xfc>
    1028:	29 85       	ldd	r18, Y+9	; 0x09
    102a:	3a 85       	ldd	r19, Y+10	; 0x0a
    102c:	21 30       	cpi	r18, 0x01	; 1
    102e:	31 05       	cpc	r19, r1
    1030:	b1 f0       	breq	.+44     	; 0x105e <DIO_u8SetPinValue+0x126>
    1032:	29 c0       	rjmp	.+82     	; 0x1086 <DIO_u8SetPinValue+0x14e>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTB_REG,Copy_u8PinId);break;
    1034:	a8 e3       	ldi	r26, 0x38	; 56
    1036:	b0 e0       	ldi	r27, 0x00	; 0
    1038:	e8 e3       	ldi	r30, 0x38	; 56
    103a:	f0 e0       	ldi	r31, 0x00	; 0
    103c:	80 81       	ld	r24, Z
    103e:	48 2f       	mov	r20, r24
    1040:	8b 81       	ldd	r24, Y+3	; 0x03
    1042:	28 2f       	mov	r18, r24
    1044:	30 e0       	ldi	r19, 0x00	; 0
    1046:	81 e0       	ldi	r24, 0x01	; 1
    1048:	90 e0       	ldi	r25, 0x00	; 0
    104a:	02 2e       	mov	r0, r18
    104c:	02 c0       	rjmp	.+4      	; 0x1052 <DIO_u8SetPinValue+0x11a>
    104e:	88 0f       	add	r24, r24
    1050:	99 1f       	adc	r25, r25
    1052:	0a 94       	dec	r0
    1054:	e2 f7       	brpl	.-8      	; 0x104e <DIO_u8SetPinValue+0x116>
    1056:	80 95       	com	r24
    1058:	84 23       	and	r24, r20
    105a:	8c 93       	st	X, r24
    105c:	8d c0       	rjmp	.+282    	; 0x1178 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTB_REG,Copy_u8PinId);break;
    105e:	a8 e3       	ldi	r26, 0x38	; 56
    1060:	b0 e0       	ldi	r27, 0x00	; 0
    1062:	e8 e3       	ldi	r30, 0x38	; 56
    1064:	f0 e0       	ldi	r31, 0x00	; 0
    1066:	80 81       	ld	r24, Z
    1068:	48 2f       	mov	r20, r24
    106a:	8b 81       	ldd	r24, Y+3	; 0x03
    106c:	28 2f       	mov	r18, r24
    106e:	30 e0       	ldi	r19, 0x00	; 0
    1070:	81 e0       	ldi	r24, 0x01	; 1
    1072:	90 e0       	ldi	r25, 0x00	; 0
    1074:	02 2e       	mov	r0, r18
    1076:	02 c0       	rjmp	.+4      	; 0x107c <DIO_u8SetPinValue+0x144>
    1078:	88 0f       	add	r24, r24
    107a:	99 1f       	adc	r25, r25
    107c:	0a 94       	dec	r0
    107e:	e2 f7       	brpl	.-8      	; 0x1078 <DIO_u8SetPinValue+0x140>
    1080:	84 2b       	or	r24, r20
    1082:	8c 93       	st	X, r24
    1084:	79 c0       	rjmp	.+242    	; 0x1178 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
    1086:	19 82       	std	Y+1, r1	; 0x01
    1088:	77 c0       	rjmp	.+238    	; 0x1178 <DIO_u8SetPinValue+0x240>
				}
			break;
			case DIO_u8_PORTC:
				switch(Copy_u8PinValue)
    108a:	8c 81       	ldd	r24, Y+4	; 0x04
    108c:	28 2f       	mov	r18, r24
    108e:	30 e0       	ldi	r19, 0x00	; 0
    1090:	38 87       	std	Y+8, r19	; 0x08
    1092:	2f 83       	std	Y+7, r18	; 0x07
    1094:	8f 81       	ldd	r24, Y+7	; 0x07
    1096:	98 85       	ldd	r25, Y+8	; 0x08
    1098:	00 97       	sbiw	r24, 0x00	; 0
    109a:	31 f0       	breq	.+12     	; 0x10a8 <DIO_u8SetPinValue+0x170>
    109c:	2f 81       	ldd	r18, Y+7	; 0x07
    109e:	38 85       	ldd	r19, Y+8	; 0x08
    10a0:	21 30       	cpi	r18, 0x01	; 1
    10a2:	31 05       	cpc	r19, r1
    10a4:	b1 f0       	breq	.+44     	; 0x10d2 <DIO_u8SetPinValue+0x19a>
    10a6:	29 c0       	rjmp	.+82     	; 0x10fa <DIO_u8SetPinValue+0x1c2>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTC_REG,Copy_u8PinId);break;
    10a8:	a5 e3       	ldi	r26, 0x35	; 53
    10aa:	b0 e0       	ldi	r27, 0x00	; 0
    10ac:	e5 e3       	ldi	r30, 0x35	; 53
    10ae:	f0 e0       	ldi	r31, 0x00	; 0
    10b0:	80 81       	ld	r24, Z
    10b2:	48 2f       	mov	r20, r24
    10b4:	8b 81       	ldd	r24, Y+3	; 0x03
    10b6:	28 2f       	mov	r18, r24
    10b8:	30 e0       	ldi	r19, 0x00	; 0
    10ba:	81 e0       	ldi	r24, 0x01	; 1
    10bc:	90 e0       	ldi	r25, 0x00	; 0
    10be:	02 2e       	mov	r0, r18
    10c0:	02 c0       	rjmp	.+4      	; 0x10c6 <DIO_u8SetPinValue+0x18e>
    10c2:	88 0f       	add	r24, r24
    10c4:	99 1f       	adc	r25, r25
    10c6:	0a 94       	dec	r0
    10c8:	e2 f7       	brpl	.-8      	; 0x10c2 <DIO_u8SetPinValue+0x18a>
    10ca:	80 95       	com	r24
    10cc:	84 23       	and	r24, r20
    10ce:	8c 93       	st	X, r24
    10d0:	53 c0       	rjmp	.+166    	; 0x1178 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTC_REG,Copy_u8PinId);break;
    10d2:	a5 e3       	ldi	r26, 0x35	; 53
    10d4:	b0 e0       	ldi	r27, 0x00	; 0
    10d6:	e5 e3       	ldi	r30, 0x35	; 53
    10d8:	f0 e0       	ldi	r31, 0x00	; 0
    10da:	80 81       	ld	r24, Z
    10dc:	48 2f       	mov	r20, r24
    10de:	8b 81       	ldd	r24, Y+3	; 0x03
    10e0:	28 2f       	mov	r18, r24
    10e2:	30 e0       	ldi	r19, 0x00	; 0
    10e4:	81 e0       	ldi	r24, 0x01	; 1
    10e6:	90 e0       	ldi	r25, 0x00	; 0
    10e8:	02 2e       	mov	r0, r18
    10ea:	02 c0       	rjmp	.+4      	; 0x10f0 <DIO_u8SetPinValue+0x1b8>
    10ec:	88 0f       	add	r24, r24
    10ee:	99 1f       	adc	r25, r25
    10f0:	0a 94       	dec	r0
    10f2:	e2 f7       	brpl	.-8      	; 0x10ec <DIO_u8SetPinValue+0x1b4>
    10f4:	84 2b       	or	r24, r20
    10f6:	8c 93       	st	X, r24
    10f8:	3f c0       	rjmp	.+126    	; 0x1178 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
    10fa:	19 82       	std	Y+1, r1	; 0x01
    10fc:	3d c0       	rjmp	.+122    	; 0x1178 <DIO_u8SetPinValue+0x240>
				}
			break;
			case DIO_u8_PORTD:
				switch(Copy_u8PinValue)
    10fe:	8c 81       	ldd	r24, Y+4	; 0x04
    1100:	28 2f       	mov	r18, r24
    1102:	30 e0       	ldi	r19, 0x00	; 0
    1104:	3e 83       	std	Y+6, r19	; 0x06
    1106:	2d 83       	std	Y+5, r18	; 0x05
    1108:	8d 81       	ldd	r24, Y+5	; 0x05
    110a:	9e 81       	ldd	r25, Y+6	; 0x06
    110c:	00 97       	sbiw	r24, 0x00	; 0
    110e:	31 f0       	breq	.+12     	; 0x111c <DIO_u8SetPinValue+0x1e4>
    1110:	2d 81       	ldd	r18, Y+5	; 0x05
    1112:	3e 81       	ldd	r19, Y+6	; 0x06
    1114:	21 30       	cpi	r18, 0x01	; 1
    1116:	31 05       	cpc	r19, r1
    1118:	b1 f0       	breq	.+44     	; 0x1146 <DIO_u8SetPinValue+0x20e>
    111a:	29 c0       	rjmp	.+82     	; 0x116e <DIO_u8SetPinValue+0x236>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTD_REG,Copy_u8PinId);break;
    111c:	a2 e3       	ldi	r26, 0x32	; 50
    111e:	b0 e0       	ldi	r27, 0x00	; 0
    1120:	e2 e3       	ldi	r30, 0x32	; 50
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	80 81       	ld	r24, Z
    1126:	48 2f       	mov	r20, r24
    1128:	8b 81       	ldd	r24, Y+3	; 0x03
    112a:	28 2f       	mov	r18, r24
    112c:	30 e0       	ldi	r19, 0x00	; 0
    112e:	81 e0       	ldi	r24, 0x01	; 1
    1130:	90 e0       	ldi	r25, 0x00	; 0
    1132:	02 2e       	mov	r0, r18
    1134:	02 c0       	rjmp	.+4      	; 0x113a <DIO_u8SetPinValue+0x202>
    1136:	88 0f       	add	r24, r24
    1138:	99 1f       	adc	r25, r25
    113a:	0a 94       	dec	r0
    113c:	e2 f7       	brpl	.-8      	; 0x1136 <DIO_u8SetPinValue+0x1fe>
    113e:	80 95       	com	r24
    1140:	84 23       	and	r24, r20
    1142:	8c 93       	st	X, r24
    1144:	19 c0       	rjmp	.+50     	; 0x1178 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTD_REG,Copy_u8PinId);break;
    1146:	a2 e3       	ldi	r26, 0x32	; 50
    1148:	b0 e0       	ldi	r27, 0x00	; 0
    114a:	e2 e3       	ldi	r30, 0x32	; 50
    114c:	f0 e0       	ldi	r31, 0x00	; 0
    114e:	80 81       	ld	r24, Z
    1150:	48 2f       	mov	r20, r24
    1152:	8b 81       	ldd	r24, Y+3	; 0x03
    1154:	28 2f       	mov	r18, r24
    1156:	30 e0       	ldi	r19, 0x00	; 0
    1158:	81 e0       	ldi	r24, 0x01	; 1
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	02 2e       	mov	r0, r18
    115e:	02 c0       	rjmp	.+4      	; 0x1164 <DIO_u8SetPinValue+0x22c>
    1160:	88 0f       	add	r24, r24
    1162:	99 1f       	adc	r25, r25
    1164:	0a 94       	dec	r0
    1166:	e2 f7       	brpl	.-8      	; 0x1160 <DIO_u8SetPinValue+0x228>
    1168:	84 2b       	or	r24, r20
    116a:	8c 93       	st	X, r24
    116c:	05 c0       	rjmp	.+10     	; 0x1178 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
    116e:	19 82       	std	Y+1, r1	; 0x01
    1170:	03 c0       	rjmp	.+6      	; 0x1178 <DIO_u8SetPinValue+0x240>
				}
			break;
			default:
				Local_u8ErrorState = STD_TYPES_NOK;
    1172:	19 82       	std	Y+1, r1	; 0x01
    1174:	01 c0       	rjmp	.+2      	; 0x1178 <DIO_u8SetPinValue+0x240>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
    1176:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
    1178:	89 81       	ldd	r24, Y+1	; 0x01
}
    117a:	2e 96       	adiw	r28, 0x0e	; 14
    117c:	0f b6       	in	r0, 0x3f	; 63
    117e:	f8 94       	cli
    1180:	de bf       	out	0x3e, r29	; 62
    1182:	0f be       	out	0x3f, r0	; 63
    1184:	cd bf       	out	0x3d, r28	; 61
    1186:	cf 91       	pop	r28
    1188:	df 91       	pop	r29
    118a:	08 95       	ret

0000118c <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 *Copy_pu8ReturnedPinValue)
{
    118c:	df 93       	push	r29
    118e:	cf 93       	push	r28
    1190:	cd b7       	in	r28, 0x3d	; 61
    1192:	de b7       	in	r29, 0x3e	; 62
    1194:	28 97       	sbiw	r28, 0x08	; 8
    1196:	0f b6       	in	r0, 0x3f	; 63
    1198:	f8 94       	cli
    119a:	de bf       	out	0x3e, r29	; 62
    119c:	0f be       	out	0x3f, r0	; 63
    119e:	cd bf       	out	0x3d, r28	; 61
    11a0:	8b 83       	std	Y+3, r24	; 0x03
    11a2:	6c 83       	std	Y+4, r22	; 0x04
    11a4:	5e 83       	std	Y+6, r21	; 0x06
    11a6:	4d 83       	std	Y+5, r20	; 0x05
	u8 Local_u8ErrorState = STD_TYPES_OK;
    11a8:	81 e0       	ldi	r24, 0x01	; 1
    11aa:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8PinValue;
	if((Copy_u8PortId <= DIO_u8_PORTD ) && (Copy_u8PinId <= DIO_u8_PIN7) && (Copy_pu8ReturnedPinValue != NULL))
    11ac:	8b 81       	ldd	r24, Y+3	; 0x03
    11ae:	84 30       	cpi	r24, 0x04	; 4
    11b0:	08 f0       	brcs	.+2      	; 0x11b4 <DIO_u8GetPinValue+0x28>
    11b2:	a1 c0       	rjmp	.+322    	; 0x12f6 <DIO_u8GetPinValue+0x16a>
    11b4:	8c 81       	ldd	r24, Y+4	; 0x04
    11b6:	88 30       	cpi	r24, 0x08	; 8
    11b8:	08 f0       	brcs	.+2      	; 0x11bc <DIO_u8GetPinValue+0x30>
    11ba:	9d c0       	rjmp	.+314    	; 0x12f6 <DIO_u8GetPinValue+0x16a>
    11bc:	8d 81       	ldd	r24, Y+5	; 0x05
    11be:	9e 81       	ldd	r25, Y+6	; 0x06
    11c0:	00 97       	sbiw	r24, 0x00	; 0
    11c2:	09 f4       	brne	.+2      	; 0x11c6 <DIO_u8GetPinValue+0x3a>
    11c4:	98 c0       	rjmp	.+304    	; 0x12f6 <DIO_u8GetPinValue+0x16a>
	{
		switch(Copy_u8PortId)
    11c6:	8b 81       	ldd	r24, Y+3	; 0x03
    11c8:	28 2f       	mov	r18, r24
    11ca:	30 e0       	ldi	r19, 0x00	; 0
    11cc:	38 87       	std	Y+8, r19	; 0x08
    11ce:	2f 83       	std	Y+7, r18	; 0x07
    11d0:	4f 81       	ldd	r20, Y+7	; 0x07
    11d2:	58 85       	ldd	r21, Y+8	; 0x08
    11d4:	41 30       	cpi	r20, 0x01	; 1
    11d6:	51 05       	cpc	r21, r1
    11d8:	a9 f1       	breq	.+106    	; 0x1244 <DIO_u8GetPinValue+0xb8>
    11da:	8f 81       	ldd	r24, Y+7	; 0x07
    11dc:	98 85       	ldd	r25, Y+8	; 0x08
    11de:	82 30       	cpi	r24, 0x02	; 2
    11e0:	91 05       	cpc	r25, r1
    11e2:	34 f4       	brge	.+12     	; 0x11f0 <DIO_u8GetPinValue+0x64>
    11e4:	2f 81       	ldd	r18, Y+7	; 0x07
    11e6:	38 85       	ldd	r19, Y+8	; 0x08
    11e8:	21 15       	cp	r18, r1
    11ea:	31 05       	cpc	r19, r1
    11ec:	71 f0       	breq	.+28     	; 0x120a <DIO_u8GetPinValue+0x7e>
    11ee:	81 c0       	rjmp	.+258    	; 0x12f2 <DIO_u8GetPinValue+0x166>
    11f0:	4f 81       	ldd	r20, Y+7	; 0x07
    11f2:	58 85       	ldd	r21, Y+8	; 0x08
    11f4:	42 30       	cpi	r20, 0x02	; 2
    11f6:	51 05       	cpc	r21, r1
    11f8:	09 f4       	brne	.+2      	; 0x11fc <DIO_u8GetPinValue+0x70>
    11fa:	41 c0       	rjmp	.+130    	; 0x127e <DIO_u8GetPinValue+0xf2>
    11fc:	8f 81       	ldd	r24, Y+7	; 0x07
    11fe:	98 85       	ldd	r25, Y+8	; 0x08
    1200:	83 30       	cpi	r24, 0x03	; 3
    1202:	91 05       	cpc	r25, r1
    1204:	09 f4       	brne	.+2      	; 0x1208 <DIO_u8GetPinValue+0x7c>
    1206:	58 c0       	rjmp	.+176    	; 0x12b8 <DIO_u8GetPinValue+0x12c>
    1208:	74 c0       	rjmp	.+232    	; 0x12f2 <DIO_u8GetPinValue+0x166>
		{
			case DIO_u8_PORTA: Local_u8PinValue = GET_BIT(DIO_u8_PINA_REG,Copy_u8PinId);
    120a:	e9 e3       	ldi	r30, 0x39	; 57
    120c:	f0 e0       	ldi	r31, 0x00	; 0
    120e:	80 81       	ld	r24, Z
    1210:	28 2f       	mov	r18, r24
    1212:	30 e0       	ldi	r19, 0x00	; 0
    1214:	8c 81       	ldd	r24, Y+4	; 0x04
    1216:	88 2f       	mov	r24, r24
    1218:	90 e0       	ldi	r25, 0x00	; 0
    121a:	a9 01       	movw	r20, r18
    121c:	02 c0       	rjmp	.+4      	; 0x1222 <DIO_u8GetPinValue+0x96>
    121e:	55 95       	asr	r21
    1220:	47 95       	ror	r20
    1222:	8a 95       	dec	r24
    1224:	e2 f7       	brpl	.-8      	; 0x121e <DIO_u8GetPinValue+0x92>
    1226:	ca 01       	movw	r24, r20
    1228:	81 70       	andi	r24, 0x01	; 1
    122a:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
    122c:	89 81       	ldd	r24, Y+1	; 0x01
    122e:	88 23       	and	r24, r24
    1230:	21 f4       	brne	.+8      	; 0x123a <DIO_u8GetPinValue+0xae>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    1232:	ed 81       	ldd	r30, Y+5	; 0x05
    1234:	fe 81       	ldd	r31, Y+6	; 0x06
    1236:	10 82       	st	Z, r1
    1238:	5f c0       	rjmp	.+190    	; 0x12f8 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
    123a:	ed 81       	ldd	r30, Y+5	; 0x05
    123c:	fe 81       	ldd	r31, Y+6	; 0x06
    123e:	81 e0       	ldi	r24, 0x01	; 1
    1240:	80 83       	st	Z, r24
    1242:	5a c0       	rjmp	.+180    	; 0x12f8 <DIO_u8GetPinValue+0x16c>
				}
			break;
			case DIO_u8_PORTB: Local_u8PinValue = GET_BIT(DIO_u8_PINB_REG,Copy_u8PinId);
    1244:	e6 e3       	ldi	r30, 0x36	; 54
    1246:	f0 e0       	ldi	r31, 0x00	; 0
    1248:	80 81       	ld	r24, Z
    124a:	28 2f       	mov	r18, r24
    124c:	30 e0       	ldi	r19, 0x00	; 0
    124e:	8c 81       	ldd	r24, Y+4	; 0x04
    1250:	88 2f       	mov	r24, r24
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	a9 01       	movw	r20, r18
    1256:	02 c0       	rjmp	.+4      	; 0x125c <DIO_u8GetPinValue+0xd0>
    1258:	55 95       	asr	r21
    125a:	47 95       	ror	r20
    125c:	8a 95       	dec	r24
    125e:	e2 f7       	brpl	.-8      	; 0x1258 <DIO_u8GetPinValue+0xcc>
    1260:	ca 01       	movw	r24, r20
    1262:	81 70       	andi	r24, 0x01	; 1
    1264:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
    1266:	89 81       	ldd	r24, Y+1	; 0x01
    1268:	88 23       	and	r24, r24
    126a:	21 f4       	brne	.+8      	; 0x1274 <DIO_u8GetPinValue+0xe8>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    126c:	ed 81       	ldd	r30, Y+5	; 0x05
    126e:	fe 81       	ldd	r31, Y+6	; 0x06
    1270:	10 82       	st	Z, r1
    1272:	42 c0       	rjmp	.+132    	; 0x12f8 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
    1274:	ed 81       	ldd	r30, Y+5	; 0x05
    1276:	fe 81       	ldd	r31, Y+6	; 0x06
    1278:	81 e0       	ldi	r24, 0x01	; 1
    127a:	80 83       	st	Z, r24
    127c:	3d c0       	rjmp	.+122    	; 0x12f8 <DIO_u8GetPinValue+0x16c>
				}
			break;
			case DIO_u8_PORTC: Local_u8PinValue = GET_BIT(DIO_u8_PINC_REG,Copy_u8PinId);
    127e:	e3 e3       	ldi	r30, 0x33	; 51
    1280:	f0 e0       	ldi	r31, 0x00	; 0
    1282:	80 81       	ld	r24, Z
    1284:	28 2f       	mov	r18, r24
    1286:	30 e0       	ldi	r19, 0x00	; 0
    1288:	8c 81       	ldd	r24, Y+4	; 0x04
    128a:	88 2f       	mov	r24, r24
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	a9 01       	movw	r20, r18
    1290:	02 c0       	rjmp	.+4      	; 0x1296 <DIO_u8GetPinValue+0x10a>
    1292:	55 95       	asr	r21
    1294:	47 95       	ror	r20
    1296:	8a 95       	dec	r24
    1298:	e2 f7       	brpl	.-8      	; 0x1292 <DIO_u8GetPinValue+0x106>
    129a:	ca 01       	movw	r24, r20
    129c:	81 70       	andi	r24, 0x01	; 1
    129e:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
    12a0:	89 81       	ldd	r24, Y+1	; 0x01
    12a2:	88 23       	and	r24, r24
    12a4:	21 f4       	brne	.+8      	; 0x12ae <DIO_u8GetPinValue+0x122>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    12a6:	ed 81       	ldd	r30, Y+5	; 0x05
    12a8:	fe 81       	ldd	r31, Y+6	; 0x06
    12aa:	10 82       	st	Z, r1
    12ac:	25 c0       	rjmp	.+74     	; 0x12f8 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
    12ae:	ed 81       	ldd	r30, Y+5	; 0x05
    12b0:	fe 81       	ldd	r31, Y+6	; 0x06
    12b2:	81 e0       	ldi	r24, 0x01	; 1
    12b4:	80 83       	st	Z, r24
    12b6:	20 c0       	rjmp	.+64     	; 0x12f8 <DIO_u8GetPinValue+0x16c>
				}
			break;
			case DIO_u8_PORTD: Local_u8PinValue = GET_BIT(DIO_u8_PIND_REG,Copy_u8PinId);
    12b8:	e0 e3       	ldi	r30, 0x30	; 48
    12ba:	f0 e0       	ldi	r31, 0x00	; 0
    12bc:	80 81       	ld	r24, Z
    12be:	28 2f       	mov	r18, r24
    12c0:	30 e0       	ldi	r19, 0x00	; 0
    12c2:	8c 81       	ldd	r24, Y+4	; 0x04
    12c4:	88 2f       	mov	r24, r24
    12c6:	90 e0       	ldi	r25, 0x00	; 0
    12c8:	a9 01       	movw	r20, r18
    12ca:	02 c0       	rjmp	.+4      	; 0x12d0 <DIO_u8GetPinValue+0x144>
    12cc:	55 95       	asr	r21
    12ce:	47 95       	ror	r20
    12d0:	8a 95       	dec	r24
    12d2:	e2 f7       	brpl	.-8      	; 0x12cc <DIO_u8GetPinValue+0x140>
    12d4:	ca 01       	movw	r24, r20
    12d6:	81 70       	andi	r24, 0x01	; 1
    12d8:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
    12da:	89 81       	ldd	r24, Y+1	; 0x01
    12dc:	88 23       	and	r24, r24
    12de:	21 f4       	brne	.+8      	; 0x12e8 <DIO_u8GetPinValue+0x15c>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    12e0:	ed 81       	ldd	r30, Y+5	; 0x05
    12e2:	fe 81       	ldd	r31, Y+6	; 0x06
    12e4:	10 82       	st	Z, r1
    12e6:	08 c0       	rjmp	.+16     	; 0x12f8 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
    12e8:	ed 81       	ldd	r30, Y+5	; 0x05
    12ea:	fe 81       	ldd	r31, Y+6	; 0x06
    12ec:	81 e0       	ldi	r24, 0x01	; 1
    12ee:	80 83       	st	Z, r24
    12f0:	03 c0       	rjmp	.+6      	; 0x12f8 <DIO_u8GetPinValue+0x16c>
				}
			break;
			default: Local_u8ErrorState = STD_TYPES_NOK;
    12f2:	1a 82       	std	Y+2, r1	; 0x02
    12f4:	01 c0       	rjmp	.+2      	; 0x12f8 <DIO_u8GetPinValue+0x16c>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
    12f6:	1a 82       	std	Y+2, r1	; 0x02
	}
	return Local_u8ErrorState;
    12f8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    12fa:	28 96       	adiw	r28, 0x08	; 8
    12fc:	0f b6       	in	r0, 0x3f	; 63
    12fe:	f8 94       	cli
    1300:	de bf       	out	0x3e, r29	; 62
    1302:	0f be       	out	0x3f, r0	; 63
    1304:	cd bf       	out	0x3d, r28	; 61
    1306:	cf 91       	pop	r28
    1308:	df 91       	pop	r29
    130a:	08 95       	ret

0000130c <DIO_u8SetPortDirection>:

u8 DIO_u8SetPortDirection(u8 Copy_u8PortId, u8 Copy_u8PortDirection)
{
    130c:	df 93       	push	r29
    130e:	cf 93       	push	r28
    1310:	cd b7       	in	r28, 0x3d	; 61
    1312:	de b7       	in	r29, 0x3e	; 62
    1314:	2d 97       	sbiw	r28, 0x0d	; 13
    1316:	0f b6       	in	r0, 0x3f	; 63
    1318:	f8 94       	cli
    131a:	de bf       	out	0x3e, r29	; 62
    131c:	0f be       	out	0x3f, r0	; 63
    131e:	cd bf       	out	0x3d, r28	; 61
    1320:	8a 83       	std	Y+2, r24	; 0x02
    1322:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection == DIO_u8_INPUT) || (Copy_u8PortDirection == DIO_u8_OUTPUT))
    1328:	8b 81       	ldd	r24, Y+3	; 0x03
    132a:	88 23       	and	r24, r24
    132c:	21 f0       	breq	.+8      	; 0x1336 <DIO_u8SetPortDirection+0x2a>
    132e:	8b 81       	ldd	r24, Y+3	; 0x03
    1330:	81 30       	cpi	r24, 0x01	; 1
    1332:	09 f0       	breq	.+2      	; 0x1336 <DIO_u8SetPortDirection+0x2a>
    1334:	82 c0       	rjmp	.+260    	; 0x143a <DIO_u8SetPortDirection+0x12e>
	{
		switch(Copy_u8PortId)
    1336:	8a 81       	ldd	r24, Y+2	; 0x02
    1338:	28 2f       	mov	r18, r24
    133a:	30 e0       	ldi	r19, 0x00	; 0
    133c:	3d 87       	std	Y+13, r19	; 0x0d
    133e:	2c 87       	std	Y+12, r18	; 0x0c
    1340:	8c 85       	ldd	r24, Y+12	; 0x0c
    1342:	9d 85       	ldd	r25, Y+13	; 0x0d
    1344:	81 30       	cpi	r24, 0x01	; 1
    1346:	91 05       	cpc	r25, r1
    1348:	71 f1       	breq	.+92     	; 0x13a6 <DIO_u8SetPortDirection+0x9a>
    134a:	2c 85       	ldd	r18, Y+12	; 0x0c
    134c:	3d 85       	ldd	r19, Y+13	; 0x0d
    134e:	22 30       	cpi	r18, 0x02	; 2
    1350:	31 05       	cpc	r19, r1
    1352:	2c f4       	brge	.+10     	; 0x135e <DIO_u8SetPortDirection+0x52>
    1354:	8c 85       	ldd	r24, Y+12	; 0x0c
    1356:	9d 85       	ldd	r25, Y+13	; 0x0d
    1358:	00 97       	sbiw	r24, 0x00	; 0
    135a:	69 f0       	breq	.+26     	; 0x1376 <DIO_u8SetPortDirection+0x6a>
    135c:	6c c0       	rjmp	.+216    	; 0x1436 <DIO_u8SetPortDirection+0x12a>
    135e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1360:	3d 85       	ldd	r19, Y+13	; 0x0d
    1362:	22 30       	cpi	r18, 0x02	; 2
    1364:	31 05       	cpc	r19, r1
    1366:	b9 f1       	breq	.+110    	; 0x13d6 <DIO_u8SetPortDirection+0xca>
    1368:	8c 85       	ldd	r24, Y+12	; 0x0c
    136a:	9d 85       	ldd	r25, Y+13	; 0x0d
    136c:	83 30       	cpi	r24, 0x03	; 3
    136e:	91 05       	cpc	r25, r1
    1370:	09 f4       	brne	.+2      	; 0x1374 <DIO_u8SetPortDirection+0x68>
    1372:	49 c0       	rjmp	.+146    	; 0x1406 <DIO_u8SetPortDirection+0xfa>
    1374:	60 c0       	rjmp	.+192    	; 0x1436 <DIO_u8SetPortDirection+0x12a>
		{
			case DIO_u8_PORTA:
				switch(Copy_u8PortDirection)
    1376:	8b 81       	ldd	r24, Y+3	; 0x03
    1378:	28 2f       	mov	r18, r24
    137a:	30 e0       	ldi	r19, 0x00	; 0
    137c:	3b 87       	std	Y+11, r19	; 0x0b
    137e:	2a 87       	std	Y+10, r18	; 0x0a
    1380:	8a 85       	ldd	r24, Y+10	; 0x0a
    1382:	9b 85       	ldd	r25, Y+11	; 0x0b
    1384:	00 97       	sbiw	r24, 0x00	; 0
    1386:	31 f0       	breq	.+12     	; 0x1394 <DIO_u8SetPortDirection+0x88>
    1388:	2a 85       	ldd	r18, Y+10	; 0x0a
    138a:	3b 85       	ldd	r19, Y+11	; 0x0b
    138c:	21 30       	cpi	r18, 0x01	; 1
    138e:	31 05       	cpc	r19, r1
    1390:	29 f0       	breq	.+10     	; 0x139c <DIO_u8SetPortDirection+0x90>
    1392:	54 c0       	rjmp	.+168    	; 0x143c <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRA_REG = 0x00;break;
    1394:	ea e3       	ldi	r30, 0x3A	; 58
    1396:	f0 e0       	ldi	r31, 0x00	; 0
    1398:	10 82       	st	Z, r1
    139a:	50 c0       	rjmp	.+160    	; 0x143c <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRA_REG = 0xFF;break;
    139c:	ea e3       	ldi	r30, 0x3A	; 58
    139e:	f0 e0       	ldi	r31, 0x00	; 0
    13a0:	8f ef       	ldi	r24, 0xFF	; 255
    13a2:	80 83       	st	Z, r24
    13a4:	4b c0       	rjmp	.+150    	; 0x143c <DIO_u8SetPortDirection+0x130>
				}
			break;
			case DIO_u8_PORTB:
				switch(Copy_u8PortDirection)
    13a6:	8b 81       	ldd	r24, Y+3	; 0x03
    13a8:	28 2f       	mov	r18, r24
    13aa:	30 e0       	ldi	r19, 0x00	; 0
    13ac:	39 87       	std	Y+9, r19	; 0x09
    13ae:	28 87       	std	Y+8, r18	; 0x08
    13b0:	88 85       	ldd	r24, Y+8	; 0x08
    13b2:	99 85       	ldd	r25, Y+9	; 0x09
    13b4:	00 97       	sbiw	r24, 0x00	; 0
    13b6:	31 f0       	breq	.+12     	; 0x13c4 <DIO_u8SetPortDirection+0xb8>
    13b8:	28 85       	ldd	r18, Y+8	; 0x08
    13ba:	39 85       	ldd	r19, Y+9	; 0x09
    13bc:	21 30       	cpi	r18, 0x01	; 1
    13be:	31 05       	cpc	r19, r1
    13c0:	29 f0       	breq	.+10     	; 0x13cc <DIO_u8SetPortDirection+0xc0>
    13c2:	3c c0       	rjmp	.+120    	; 0x143c <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRB_REG = 0x00;break;
    13c4:	e7 e3       	ldi	r30, 0x37	; 55
    13c6:	f0 e0       	ldi	r31, 0x00	; 0
    13c8:	10 82       	st	Z, r1
    13ca:	38 c0       	rjmp	.+112    	; 0x143c <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRB_REG = 0xFF;break;
    13cc:	e7 e3       	ldi	r30, 0x37	; 55
    13ce:	f0 e0       	ldi	r31, 0x00	; 0
    13d0:	8f ef       	ldi	r24, 0xFF	; 255
    13d2:	80 83       	st	Z, r24
    13d4:	33 c0       	rjmp	.+102    	; 0x143c <DIO_u8SetPortDirection+0x130>
				}
			break;
			case DIO_u8_PORTC:
				switch(Copy_u8PortDirection)
    13d6:	8b 81       	ldd	r24, Y+3	; 0x03
    13d8:	28 2f       	mov	r18, r24
    13da:	30 e0       	ldi	r19, 0x00	; 0
    13dc:	3f 83       	std	Y+7, r19	; 0x07
    13de:	2e 83       	std	Y+6, r18	; 0x06
    13e0:	8e 81       	ldd	r24, Y+6	; 0x06
    13e2:	9f 81       	ldd	r25, Y+7	; 0x07
    13e4:	00 97       	sbiw	r24, 0x00	; 0
    13e6:	31 f0       	breq	.+12     	; 0x13f4 <DIO_u8SetPortDirection+0xe8>
    13e8:	2e 81       	ldd	r18, Y+6	; 0x06
    13ea:	3f 81       	ldd	r19, Y+7	; 0x07
    13ec:	21 30       	cpi	r18, 0x01	; 1
    13ee:	31 05       	cpc	r19, r1
    13f0:	29 f0       	breq	.+10     	; 0x13fc <DIO_u8SetPortDirection+0xf0>
    13f2:	24 c0       	rjmp	.+72     	; 0x143c <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRC_REG = 0x00;break;
    13f4:	e4 e3       	ldi	r30, 0x34	; 52
    13f6:	f0 e0       	ldi	r31, 0x00	; 0
    13f8:	10 82       	st	Z, r1
    13fa:	20 c0       	rjmp	.+64     	; 0x143c <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRC_REG = 0xFF;break;
    13fc:	e4 e3       	ldi	r30, 0x34	; 52
    13fe:	f0 e0       	ldi	r31, 0x00	; 0
    1400:	8f ef       	ldi	r24, 0xFF	; 255
    1402:	80 83       	st	Z, r24
    1404:	1b c0       	rjmp	.+54     	; 0x143c <DIO_u8SetPortDirection+0x130>
				}
			break;
			case DIO_u8_PORTD:
				switch(Copy_u8PortDirection)
    1406:	8b 81       	ldd	r24, Y+3	; 0x03
    1408:	28 2f       	mov	r18, r24
    140a:	30 e0       	ldi	r19, 0x00	; 0
    140c:	3d 83       	std	Y+5, r19	; 0x05
    140e:	2c 83       	std	Y+4, r18	; 0x04
    1410:	8c 81       	ldd	r24, Y+4	; 0x04
    1412:	9d 81       	ldd	r25, Y+5	; 0x05
    1414:	00 97       	sbiw	r24, 0x00	; 0
    1416:	31 f0       	breq	.+12     	; 0x1424 <DIO_u8SetPortDirection+0x118>
    1418:	2c 81       	ldd	r18, Y+4	; 0x04
    141a:	3d 81       	ldd	r19, Y+5	; 0x05
    141c:	21 30       	cpi	r18, 0x01	; 1
    141e:	31 05       	cpc	r19, r1
    1420:	29 f0       	breq	.+10     	; 0x142c <DIO_u8SetPortDirection+0x120>
    1422:	0c c0       	rjmp	.+24     	; 0x143c <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRD_REG = 0x00;break;
    1424:	e1 e3       	ldi	r30, 0x31	; 49
    1426:	f0 e0       	ldi	r31, 0x00	; 0
    1428:	10 82       	st	Z, r1
    142a:	08 c0       	rjmp	.+16     	; 0x143c <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRD_REG = 0xFF;break;
    142c:	e1 e3       	ldi	r30, 0x31	; 49
    142e:	f0 e0       	ldi	r31, 0x00	; 0
    1430:	8f ef       	ldi	r24, 0xFF	; 255
    1432:	80 83       	st	Z, r24
    1434:	03 c0       	rjmp	.+6      	; 0x143c <DIO_u8SetPortDirection+0x130>
				}
			break;
			default:Local_u8ErrorState = STD_TYPES_NOK;
    1436:	19 82       	std	Y+1, r1	; 0x01
    1438:	01 c0       	rjmp	.+2      	; 0x143c <DIO_u8SetPortDirection+0x130>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
    143a:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
    143c:	89 81       	ldd	r24, Y+1	; 0x01
}
    143e:	2d 96       	adiw	r28, 0x0d	; 13
    1440:	0f b6       	in	r0, 0x3f	; 63
    1442:	f8 94       	cli
    1444:	de bf       	out	0x3e, r29	; 62
    1446:	0f be       	out	0x3f, r0	; 63
    1448:	cd bf       	out	0x3d, r28	; 61
    144a:	cf 91       	pop	r28
    144c:	df 91       	pop	r29
    144e:	08 95       	ret

00001450 <DIO_u8SetPortValue>:

u8 DIO_u8SetPortValue(u8 Copy_u8PortId, u8 Copy_u8PortValue)
{
    1450:	df 93       	push	r29
    1452:	cf 93       	push	r28
    1454:	00 d0       	rcall	.+0      	; 0x1456 <DIO_u8SetPortValue+0x6>
    1456:	00 d0       	rcall	.+0      	; 0x1458 <DIO_u8SetPortValue+0x8>
    1458:	0f 92       	push	r0
    145a:	cd b7       	in	r28, 0x3d	; 61
    145c:	de b7       	in	r29, 0x3e	; 62
    145e:	8a 83       	std	Y+2, r24	; 0x02
    1460:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortId)
    1466:	8a 81       	ldd	r24, Y+2	; 0x02
    1468:	28 2f       	mov	r18, r24
    146a:	30 e0       	ldi	r19, 0x00	; 0
    146c:	3d 83       	std	Y+5, r19	; 0x05
    146e:	2c 83       	std	Y+4, r18	; 0x04
    1470:	8c 81       	ldd	r24, Y+4	; 0x04
    1472:	9d 81       	ldd	r25, Y+5	; 0x05
    1474:	81 30       	cpi	r24, 0x01	; 1
    1476:	91 05       	cpc	r25, r1
    1478:	d1 f0       	breq	.+52     	; 0x14ae <DIO_u8SetPortValue+0x5e>
    147a:	2c 81       	ldd	r18, Y+4	; 0x04
    147c:	3d 81       	ldd	r19, Y+5	; 0x05
    147e:	22 30       	cpi	r18, 0x02	; 2
    1480:	31 05       	cpc	r19, r1
    1482:	2c f4       	brge	.+10     	; 0x148e <DIO_u8SetPortValue+0x3e>
    1484:	8c 81       	ldd	r24, Y+4	; 0x04
    1486:	9d 81       	ldd	r25, Y+5	; 0x05
    1488:	00 97       	sbiw	r24, 0x00	; 0
    148a:	61 f0       	breq	.+24     	; 0x14a4 <DIO_u8SetPortValue+0x54>
    148c:	1f c0       	rjmp	.+62     	; 0x14cc <DIO_u8SetPortValue+0x7c>
    148e:	2c 81       	ldd	r18, Y+4	; 0x04
    1490:	3d 81       	ldd	r19, Y+5	; 0x05
    1492:	22 30       	cpi	r18, 0x02	; 2
    1494:	31 05       	cpc	r19, r1
    1496:	81 f0       	breq	.+32     	; 0x14b8 <DIO_u8SetPortValue+0x68>
    1498:	8c 81       	ldd	r24, Y+4	; 0x04
    149a:	9d 81       	ldd	r25, Y+5	; 0x05
    149c:	83 30       	cpi	r24, 0x03	; 3
    149e:	91 05       	cpc	r25, r1
    14a0:	81 f0       	breq	.+32     	; 0x14c2 <DIO_u8SetPortValue+0x72>
    14a2:	14 c0       	rjmp	.+40     	; 0x14cc <DIO_u8SetPortValue+0x7c>
	{
		case DIO_u8_PORTA:DIO_u8_PORTA_REG = Copy_u8PortValue; break;
    14a4:	eb e3       	ldi	r30, 0x3B	; 59
    14a6:	f0 e0       	ldi	r31, 0x00	; 0
    14a8:	8b 81       	ldd	r24, Y+3	; 0x03
    14aa:	80 83       	st	Z, r24
    14ac:	10 c0       	rjmp	.+32     	; 0x14ce <DIO_u8SetPortValue+0x7e>
		case DIO_u8_PORTB:DIO_u8_PORTB_REG = Copy_u8PortValue; break;
    14ae:	e8 e3       	ldi	r30, 0x38	; 56
    14b0:	f0 e0       	ldi	r31, 0x00	; 0
    14b2:	8b 81       	ldd	r24, Y+3	; 0x03
    14b4:	80 83       	st	Z, r24
    14b6:	0b c0       	rjmp	.+22     	; 0x14ce <DIO_u8SetPortValue+0x7e>
		case DIO_u8_PORTC:DIO_u8_PORTC_REG = Copy_u8PortValue; break;
    14b8:	e5 e3       	ldi	r30, 0x35	; 53
    14ba:	f0 e0       	ldi	r31, 0x00	; 0
    14bc:	8b 81       	ldd	r24, Y+3	; 0x03
    14be:	80 83       	st	Z, r24
    14c0:	06 c0       	rjmp	.+12     	; 0x14ce <DIO_u8SetPortValue+0x7e>
		case DIO_u8_PORTD:DIO_u8_PORTD_REG = Copy_u8PortValue; break;
    14c2:	e2 e3       	ldi	r30, 0x32	; 50
    14c4:	f0 e0       	ldi	r31, 0x00	; 0
    14c6:	8b 81       	ldd	r24, Y+3	; 0x03
    14c8:	80 83       	st	Z, r24
    14ca:	01 c0       	rjmp	.+2      	; 0x14ce <DIO_u8SetPortValue+0x7e>
		default:Local_u8ErrorState = STD_TYPES_NOK;
    14cc:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
    14ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    14d0:	0f 90       	pop	r0
    14d2:	0f 90       	pop	r0
    14d4:	0f 90       	pop	r0
    14d6:	0f 90       	pop	r0
    14d8:	0f 90       	pop	r0
    14da:	cf 91       	pop	r28
    14dc:	df 91       	pop	r29
    14de:	08 95       	ret

000014e0 <DIO_u8GetPortValue>:

u8 DIO_u8GetPortValue(u8 Copy_u8PortId, u8 *Copy_pu8ReturnedPortValue)
{
    14e0:	df 93       	push	r29
    14e2:	cf 93       	push	r28
    14e4:	00 d0       	rcall	.+0      	; 0x14e6 <DIO_u8GetPortValue+0x6>
    14e6:	00 d0       	rcall	.+0      	; 0x14e8 <DIO_u8GetPortValue+0x8>
    14e8:	00 d0       	rcall	.+0      	; 0x14ea <DIO_u8GetPortValue+0xa>
    14ea:	cd b7       	in	r28, 0x3d	; 61
    14ec:	de b7       	in	r29, 0x3e	; 62
    14ee:	8a 83       	std	Y+2, r24	; 0x02
    14f0:	7c 83       	std	Y+4, r23	; 0x04
    14f2:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
    14f4:	81 e0       	ldi	r24, 0x01	; 1
    14f6:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_pu8ReturnedPortValue != NULL)
    14f8:	8b 81       	ldd	r24, Y+3	; 0x03
    14fa:	9c 81       	ldd	r25, Y+4	; 0x04
    14fc:	00 97       	sbiw	r24, 0x00	; 0
    14fe:	e9 f1       	breq	.+122    	; 0x157a <DIO_u8GetPortValue+0x9a>
	{
		switch(Copy_u8PortId)
    1500:	8a 81       	ldd	r24, Y+2	; 0x02
    1502:	28 2f       	mov	r18, r24
    1504:	30 e0       	ldi	r19, 0x00	; 0
    1506:	3e 83       	std	Y+6, r19	; 0x06
    1508:	2d 83       	std	Y+5, r18	; 0x05
    150a:	8d 81       	ldd	r24, Y+5	; 0x05
    150c:	9e 81       	ldd	r25, Y+6	; 0x06
    150e:	81 30       	cpi	r24, 0x01	; 1
    1510:	91 05       	cpc	r25, r1
    1512:	e1 f0       	breq	.+56     	; 0x154c <DIO_u8GetPortValue+0x6c>
    1514:	2d 81       	ldd	r18, Y+5	; 0x05
    1516:	3e 81       	ldd	r19, Y+6	; 0x06
    1518:	22 30       	cpi	r18, 0x02	; 2
    151a:	31 05       	cpc	r19, r1
    151c:	2c f4       	brge	.+10     	; 0x1528 <DIO_u8GetPortValue+0x48>
    151e:	8d 81       	ldd	r24, Y+5	; 0x05
    1520:	9e 81       	ldd	r25, Y+6	; 0x06
    1522:	00 97       	sbiw	r24, 0x00	; 0
    1524:	61 f0       	breq	.+24     	; 0x153e <DIO_u8GetPortValue+0x5e>
    1526:	27 c0       	rjmp	.+78     	; 0x1576 <DIO_u8GetPortValue+0x96>
    1528:	2d 81       	ldd	r18, Y+5	; 0x05
    152a:	3e 81       	ldd	r19, Y+6	; 0x06
    152c:	22 30       	cpi	r18, 0x02	; 2
    152e:	31 05       	cpc	r19, r1
    1530:	a1 f0       	breq	.+40     	; 0x155a <DIO_u8GetPortValue+0x7a>
    1532:	8d 81       	ldd	r24, Y+5	; 0x05
    1534:	9e 81       	ldd	r25, Y+6	; 0x06
    1536:	83 30       	cpi	r24, 0x03	; 3
    1538:	91 05       	cpc	r25, r1
    153a:	b1 f0       	breq	.+44     	; 0x1568 <DIO_u8GetPortValue+0x88>
    153c:	1c c0       	rjmp	.+56     	; 0x1576 <DIO_u8GetPortValue+0x96>
		{
			case DIO_u8_PORTA: *Copy_pu8ReturnedPortValue = DIO_u8_PINA_REG;break;
    153e:	e9 e3       	ldi	r30, 0x39	; 57
    1540:	f0 e0       	ldi	r31, 0x00	; 0
    1542:	80 81       	ld	r24, Z
    1544:	eb 81       	ldd	r30, Y+3	; 0x03
    1546:	fc 81       	ldd	r31, Y+4	; 0x04
    1548:	80 83       	st	Z, r24
    154a:	18 c0       	rjmp	.+48     	; 0x157c <DIO_u8GetPortValue+0x9c>
			case DIO_u8_PORTB: *Copy_pu8ReturnedPortValue = DIO_u8_PINB_REG;break;
    154c:	e6 e3       	ldi	r30, 0x36	; 54
    154e:	f0 e0       	ldi	r31, 0x00	; 0
    1550:	80 81       	ld	r24, Z
    1552:	eb 81       	ldd	r30, Y+3	; 0x03
    1554:	fc 81       	ldd	r31, Y+4	; 0x04
    1556:	80 83       	st	Z, r24
    1558:	11 c0       	rjmp	.+34     	; 0x157c <DIO_u8GetPortValue+0x9c>
			case DIO_u8_PORTC: *Copy_pu8ReturnedPortValue = DIO_u8_PINC_REG;break;
    155a:	e3 e3       	ldi	r30, 0x33	; 51
    155c:	f0 e0       	ldi	r31, 0x00	; 0
    155e:	80 81       	ld	r24, Z
    1560:	eb 81       	ldd	r30, Y+3	; 0x03
    1562:	fc 81       	ldd	r31, Y+4	; 0x04
    1564:	80 83       	st	Z, r24
    1566:	0a c0       	rjmp	.+20     	; 0x157c <DIO_u8GetPortValue+0x9c>
			case DIO_u8_PORTD: *Copy_pu8ReturnedPortValue = DIO_u8_PIND_REG;break;
    1568:	e0 e3       	ldi	r30, 0x30	; 48
    156a:	f0 e0       	ldi	r31, 0x00	; 0
    156c:	80 81       	ld	r24, Z
    156e:	eb 81       	ldd	r30, Y+3	; 0x03
    1570:	fc 81       	ldd	r31, Y+4	; 0x04
    1572:	80 83       	st	Z, r24
    1574:	03 c0       	rjmp	.+6      	; 0x157c <DIO_u8GetPortValue+0x9c>
			default:Local_u8ErrorState = STD_TYPES_NOK;
    1576:	19 82       	std	Y+1, r1	; 0x01
    1578:	01 c0       	rjmp	.+2      	; 0x157c <DIO_u8GetPortValue+0x9c>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
    157a:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
    157c:	89 81       	ldd	r24, Y+1	; 0x01
    157e:	26 96       	adiw	r28, 0x06	; 6
    1580:	0f b6       	in	r0, 0x3f	; 63
    1582:	f8 94       	cli
    1584:	de bf       	out	0x3e, r29	; 62
    1586:	0f be       	out	0x3f, r0	; 63
    1588:	cd bf       	out	0x3d, r28	; 61
    158a:	cf 91       	pop	r28
    158c:	df 91       	pop	r29
    158e:	08 95       	ret

00001590 <LCD_voidInit>:
#include "LCD_config.h"
#include "LCD_private.h"

/************** APIs *************************/
void LCD_voidInit(void) 
{
    1590:	0f 93       	push	r16
    1592:	1f 93       	push	r17
    1594:	df 93       	push	r29
    1596:	cf 93       	push	r28
    1598:	cd b7       	in	r28, 0x3d	; 61
    159a:	de b7       	in	r29, 0x3e	; 62
    159c:	cc 54       	subi	r28, 0x4C	; 76
    159e:	d0 40       	sbci	r29, 0x00	; 0
    15a0:	0f b6       	in	r0, 0x3f	; 63
    15a2:	f8 94       	cli
    15a4:	de bf       	out	0x3e, r29	; 62
    15a6:	0f be       	out	0x3f, r0	; 63
    15a8:	cd bf       	out	0x3d, r28	; 61
    15aa:	fe 01       	movw	r30, r28
    15ac:	e7 5b       	subi	r30, 0xB7	; 183
    15ae:	ff 4f       	sbci	r31, 0xFF	; 255
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	ac e0       	ldi	r26, 0x0C	; 12
    15b6:	b2 e4       	ldi	r27, 0x42	; 66
    15b8:	80 83       	st	Z, r24
    15ba:	91 83       	std	Z+1, r25	; 0x01
    15bc:	a2 83       	std	Z+2, r26	; 0x02
    15be:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    15c0:	8e 01       	movw	r16, r28
    15c2:	0b 5b       	subi	r16, 0xBB	; 187
    15c4:	1f 4f       	sbci	r17, 0xFF	; 255
    15c6:	fe 01       	movw	r30, r28
    15c8:	e7 5b       	subi	r30, 0xB7	; 183
    15ca:	ff 4f       	sbci	r31, 0xFF	; 255
    15cc:	60 81       	ld	r22, Z
    15ce:	71 81       	ldd	r23, Z+1	; 0x01
    15d0:	82 81       	ldd	r24, Z+2	; 0x02
    15d2:	93 81       	ldd	r25, Z+3	; 0x03
    15d4:	20 e0       	ldi	r18, 0x00	; 0
    15d6:	30 e0       	ldi	r19, 0x00	; 0
    15d8:	4a ef       	ldi	r20, 0xFA	; 250
    15da:	54 e4       	ldi	r21, 0x44	; 68
    15dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    15e0:	dc 01       	movw	r26, r24
    15e2:	cb 01       	movw	r24, r22
    15e4:	f8 01       	movw	r30, r16
    15e6:	80 83       	st	Z, r24
    15e8:	91 83       	std	Z+1, r25	; 0x01
    15ea:	a2 83       	std	Z+2, r26	; 0x02
    15ec:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    15ee:	fe 01       	movw	r30, r28
    15f0:	eb 5b       	subi	r30, 0xBB	; 187
    15f2:	ff 4f       	sbci	r31, 0xFF	; 255
    15f4:	60 81       	ld	r22, Z
    15f6:	71 81       	ldd	r23, Z+1	; 0x01
    15f8:	82 81       	ldd	r24, Z+2	; 0x02
    15fa:	93 81       	ldd	r25, Z+3	; 0x03
    15fc:	20 e0       	ldi	r18, 0x00	; 0
    15fe:	30 e0       	ldi	r19, 0x00	; 0
    1600:	40 e8       	ldi	r20, 0x80	; 128
    1602:	5f e3       	ldi	r21, 0x3F	; 63
    1604:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1608:	88 23       	and	r24, r24
    160a:	44 f4       	brge	.+16     	; 0x161c <LCD_voidInit+0x8c>
		__ticks = 1;
    160c:	fe 01       	movw	r30, r28
    160e:	ed 5b       	subi	r30, 0xBD	; 189
    1610:	ff 4f       	sbci	r31, 0xFF	; 255
    1612:	81 e0       	ldi	r24, 0x01	; 1
    1614:	90 e0       	ldi	r25, 0x00	; 0
    1616:	91 83       	std	Z+1, r25	; 0x01
    1618:	80 83       	st	Z, r24
    161a:	64 c0       	rjmp	.+200    	; 0x16e4 <LCD_voidInit+0x154>
	else if (__tmp > 65535)
    161c:	fe 01       	movw	r30, r28
    161e:	eb 5b       	subi	r30, 0xBB	; 187
    1620:	ff 4f       	sbci	r31, 0xFF	; 255
    1622:	60 81       	ld	r22, Z
    1624:	71 81       	ldd	r23, Z+1	; 0x01
    1626:	82 81       	ldd	r24, Z+2	; 0x02
    1628:	93 81       	ldd	r25, Z+3	; 0x03
    162a:	20 e0       	ldi	r18, 0x00	; 0
    162c:	3f ef       	ldi	r19, 0xFF	; 255
    162e:	4f e7       	ldi	r20, 0x7F	; 127
    1630:	57 e4       	ldi	r21, 0x47	; 71
    1632:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1636:	18 16       	cp	r1, r24
    1638:	0c f0       	brlt	.+2      	; 0x163c <LCD_voidInit+0xac>
    163a:	43 c0       	rjmp	.+134    	; 0x16c2 <LCD_voidInit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    163c:	fe 01       	movw	r30, r28
    163e:	e7 5b       	subi	r30, 0xB7	; 183
    1640:	ff 4f       	sbci	r31, 0xFF	; 255
    1642:	60 81       	ld	r22, Z
    1644:	71 81       	ldd	r23, Z+1	; 0x01
    1646:	82 81       	ldd	r24, Z+2	; 0x02
    1648:	93 81       	ldd	r25, Z+3	; 0x03
    164a:	20 e0       	ldi	r18, 0x00	; 0
    164c:	30 e0       	ldi	r19, 0x00	; 0
    164e:	40 e2       	ldi	r20, 0x20	; 32
    1650:	51 e4       	ldi	r21, 0x41	; 65
    1652:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1656:	dc 01       	movw	r26, r24
    1658:	cb 01       	movw	r24, r22
    165a:	8e 01       	movw	r16, r28
    165c:	0d 5b       	subi	r16, 0xBD	; 189
    165e:	1f 4f       	sbci	r17, 0xFF	; 255
    1660:	bc 01       	movw	r22, r24
    1662:	cd 01       	movw	r24, r26
    1664:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1668:	dc 01       	movw	r26, r24
    166a:	cb 01       	movw	r24, r22
    166c:	f8 01       	movw	r30, r16
    166e:	91 83       	std	Z+1, r25	; 0x01
    1670:	80 83       	st	Z, r24
    1672:	1f c0       	rjmp	.+62     	; 0x16b2 <LCD_voidInit+0x122>
    1674:	fe 01       	movw	r30, r28
    1676:	ef 5b       	subi	r30, 0xBF	; 191
    1678:	ff 4f       	sbci	r31, 0xFF	; 255
    167a:	88 ec       	ldi	r24, 0xC8	; 200
    167c:	90 e0       	ldi	r25, 0x00	; 0
    167e:	91 83       	std	Z+1, r25	; 0x01
    1680:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1682:	fe 01       	movw	r30, r28
    1684:	ef 5b       	subi	r30, 0xBF	; 191
    1686:	ff 4f       	sbci	r31, 0xFF	; 255
    1688:	80 81       	ld	r24, Z
    168a:	91 81       	ldd	r25, Z+1	; 0x01
    168c:	01 97       	sbiw	r24, 0x01	; 1
    168e:	f1 f7       	brne	.-4      	; 0x168c <LCD_voidInit+0xfc>
    1690:	fe 01       	movw	r30, r28
    1692:	ef 5b       	subi	r30, 0xBF	; 191
    1694:	ff 4f       	sbci	r31, 0xFF	; 255
    1696:	91 83       	std	Z+1, r25	; 0x01
    1698:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    169a:	de 01       	movw	r26, r28
    169c:	ad 5b       	subi	r26, 0xBD	; 189
    169e:	bf 4f       	sbci	r27, 0xFF	; 255
    16a0:	fe 01       	movw	r30, r28
    16a2:	ed 5b       	subi	r30, 0xBD	; 189
    16a4:	ff 4f       	sbci	r31, 0xFF	; 255
    16a6:	80 81       	ld	r24, Z
    16a8:	91 81       	ldd	r25, Z+1	; 0x01
    16aa:	01 97       	sbiw	r24, 0x01	; 1
    16ac:	11 96       	adiw	r26, 0x01	; 1
    16ae:	9c 93       	st	X, r25
    16b0:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16b2:	fe 01       	movw	r30, r28
    16b4:	ed 5b       	subi	r30, 0xBD	; 189
    16b6:	ff 4f       	sbci	r31, 0xFF	; 255
    16b8:	80 81       	ld	r24, Z
    16ba:	91 81       	ldd	r25, Z+1	; 0x01
    16bc:	00 97       	sbiw	r24, 0x00	; 0
    16be:	d1 f6       	brne	.-76     	; 0x1674 <LCD_voidInit+0xe4>
    16c0:	24 c0       	rjmp	.+72     	; 0x170a <LCD_voidInit+0x17a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16c2:	8e 01       	movw	r16, r28
    16c4:	0d 5b       	subi	r16, 0xBD	; 189
    16c6:	1f 4f       	sbci	r17, 0xFF	; 255
    16c8:	fe 01       	movw	r30, r28
    16ca:	eb 5b       	subi	r30, 0xBB	; 187
    16cc:	ff 4f       	sbci	r31, 0xFF	; 255
    16ce:	60 81       	ld	r22, Z
    16d0:	71 81       	ldd	r23, Z+1	; 0x01
    16d2:	82 81       	ldd	r24, Z+2	; 0x02
    16d4:	93 81       	ldd	r25, Z+3	; 0x03
    16d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16da:	dc 01       	movw	r26, r24
    16dc:	cb 01       	movw	r24, r22
    16de:	f8 01       	movw	r30, r16
    16e0:	91 83       	std	Z+1, r25	; 0x01
    16e2:	80 83       	st	Z, r24
    16e4:	fe 01       	movw	r30, r28
    16e6:	ed 5b       	subi	r30, 0xBD	; 189
    16e8:	ff 4f       	sbci	r31, 0xFF	; 255
    16ea:	80 81       	ld	r24, Z
    16ec:	91 81       	ldd	r25, Z+1	; 0x01
    16ee:	fe 01       	movw	r30, r28
    16f0:	ff 96       	adiw	r30, 0x3f	; 63
    16f2:	91 83       	std	Z+1, r25	; 0x01
    16f4:	80 83       	st	Z, r24
    16f6:	fe 01       	movw	r30, r28
    16f8:	ff 96       	adiw	r30, 0x3f	; 63
    16fa:	80 81       	ld	r24, Z
    16fc:	91 81       	ldd	r25, Z+1	; 0x01
    16fe:	01 97       	sbiw	r24, 0x01	; 1
    1700:	f1 f7       	brne	.-4      	; 0x16fe <LCD_voidInit+0x16e>
    1702:	fe 01       	movw	r30, r28
    1704:	ff 96       	adiw	r30, 0x3f	; 63
    1706:	91 83       	std	Z+1, r25	; 0x01
    1708:	80 83       	st	Z, r24
	/* Step 2: Function Set Command
	1- DL: 1 --> 8 bit-mode
	2- N:  1 --> 2 lines
	3- F:  0 --> 5 * 7 dots */
#if LCD_u8_MODE == LCD_u8_MODE_8_BIT
	LCD_voidSendCmnd(LCD_u8_FUNCTION_SET_CMND);
    170a:	88 e3       	ldi	r24, 0x38	; 56
    170c:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
    1710:	80 e0       	ldi	r24, 0x00	; 0
    1712:	90 e0       	ldi	r25, 0x00	; 0
    1714:	a0 e2       	ldi	r26, 0x20	; 32
    1716:	b2 e4       	ldi	r27, 0x42	; 66
    1718:	8b af       	std	Y+59, r24	; 0x3b
    171a:	9c af       	std	Y+60, r25	; 0x3c
    171c:	ad af       	std	Y+61, r26	; 0x3d
    171e:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1720:	6b ad       	ldd	r22, Y+59	; 0x3b
    1722:	7c ad       	ldd	r23, Y+60	; 0x3c
    1724:	8d ad       	ldd	r24, Y+61	; 0x3d
    1726:	9e ad       	ldd	r25, Y+62	; 0x3e
    1728:	2b ea       	ldi	r18, 0xAB	; 171
    172a:	3a ea       	ldi	r19, 0xAA	; 170
    172c:	4a e2       	ldi	r20, 0x2A	; 42
    172e:	50 e4       	ldi	r21, 0x40	; 64
    1730:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1734:	dc 01       	movw	r26, r24
    1736:	cb 01       	movw	r24, r22
    1738:	8f ab       	std	Y+55, r24	; 0x37
    173a:	98 af       	std	Y+56, r25	; 0x38
    173c:	a9 af       	std	Y+57, r26	; 0x39
    173e:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    1740:	6f a9       	ldd	r22, Y+55	; 0x37
    1742:	78 ad       	ldd	r23, Y+56	; 0x38
    1744:	89 ad       	ldd	r24, Y+57	; 0x39
    1746:	9a ad       	ldd	r25, Y+58	; 0x3a
    1748:	20 e0       	ldi	r18, 0x00	; 0
    174a:	30 e0       	ldi	r19, 0x00	; 0
    174c:	40 e8       	ldi	r20, 0x80	; 128
    174e:	5f e3       	ldi	r21, 0x3F	; 63
    1750:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1754:	88 23       	and	r24, r24
    1756:	1c f4       	brge	.+6      	; 0x175e <LCD_voidInit+0x1ce>
		__ticks = 1;
    1758:	81 e0       	ldi	r24, 0x01	; 1
    175a:	8e ab       	std	Y+54, r24	; 0x36
    175c:	91 c0       	rjmp	.+290    	; 0x1880 <LCD_voidInit+0x2f0>
	else if (__tmp > 255)
    175e:	6f a9       	ldd	r22, Y+55	; 0x37
    1760:	78 ad       	ldd	r23, Y+56	; 0x38
    1762:	89 ad       	ldd	r24, Y+57	; 0x39
    1764:	9a ad       	ldd	r25, Y+58	; 0x3a
    1766:	20 e0       	ldi	r18, 0x00	; 0
    1768:	30 e0       	ldi	r19, 0x00	; 0
    176a:	4f e7       	ldi	r20, 0x7F	; 127
    176c:	53 e4       	ldi	r21, 0x43	; 67
    176e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1772:	18 16       	cp	r1, r24
    1774:	0c f0       	brlt	.+2      	; 0x1778 <LCD_voidInit+0x1e8>
    1776:	7b c0       	rjmp	.+246    	; 0x186e <LCD_voidInit+0x2de>
	{
		_delay_ms(__us / 1000.0);
    1778:	6b ad       	ldd	r22, Y+59	; 0x3b
    177a:	7c ad       	ldd	r23, Y+60	; 0x3c
    177c:	8d ad       	ldd	r24, Y+61	; 0x3d
    177e:	9e ad       	ldd	r25, Y+62	; 0x3e
    1780:	20 e0       	ldi	r18, 0x00	; 0
    1782:	30 e0       	ldi	r19, 0x00	; 0
    1784:	4a e7       	ldi	r20, 0x7A	; 122
    1786:	54 e4       	ldi	r21, 0x44	; 68
    1788:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    178c:	dc 01       	movw	r26, r24
    178e:	cb 01       	movw	r24, r22
    1790:	8a ab       	std	Y+50, r24	; 0x32
    1792:	9b ab       	std	Y+51, r25	; 0x33
    1794:	ac ab       	std	Y+52, r26	; 0x34
    1796:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1798:	6a a9       	ldd	r22, Y+50	; 0x32
    179a:	7b a9       	ldd	r23, Y+51	; 0x33
    179c:	8c a9       	ldd	r24, Y+52	; 0x34
    179e:	9d a9       	ldd	r25, Y+53	; 0x35
    17a0:	20 e0       	ldi	r18, 0x00	; 0
    17a2:	30 e0       	ldi	r19, 0x00	; 0
    17a4:	4a ef       	ldi	r20, 0xFA	; 250
    17a6:	54 e4       	ldi	r21, 0x44	; 68
    17a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17ac:	dc 01       	movw	r26, r24
    17ae:	cb 01       	movw	r24, r22
    17b0:	8e a7       	std	Y+46, r24	; 0x2e
    17b2:	9f a7       	std	Y+47, r25	; 0x2f
    17b4:	a8 ab       	std	Y+48, r26	; 0x30
    17b6:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    17b8:	6e a5       	ldd	r22, Y+46	; 0x2e
    17ba:	7f a5       	ldd	r23, Y+47	; 0x2f
    17bc:	88 a9       	ldd	r24, Y+48	; 0x30
    17be:	99 a9       	ldd	r25, Y+49	; 0x31
    17c0:	20 e0       	ldi	r18, 0x00	; 0
    17c2:	30 e0       	ldi	r19, 0x00	; 0
    17c4:	40 e8       	ldi	r20, 0x80	; 128
    17c6:	5f e3       	ldi	r21, 0x3F	; 63
    17c8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    17cc:	88 23       	and	r24, r24
    17ce:	2c f4       	brge	.+10     	; 0x17da <LCD_voidInit+0x24a>
		__ticks = 1;
    17d0:	81 e0       	ldi	r24, 0x01	; 1
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	9d a7       	std	Y+45, r25	; 0x2d
    17d6:	8c a7       	std	Y+44, r24	; 0x2c
    17d8:	3f c0       	rjmp	.+126    	; 0x1858 <LCD_voidInit+0x2c8>
	else if (__tmp > 65535)
    17da:	6e a5       	ldd	r22, Y+46	; 0x2e
    17dc:	7f a5       	ldd	r23, Y+47	; 0x2f
    17de:	88 a9       	ldd	r24, Y+48	; 0x30
    17e0:	99 a9       	ldd	r25, Y+49	; 0x31
    17e2:	20 e0       	ldi	r18, 0x00	; 0
    17e4:	3f ef       	ldi	r19, 0xFF	; 255
    17e6:	4f e7       	ldi	r20, 0x7F	; 127
    17e8:	57 e4       	ldi	r21, 0x47	; 71
    17ea:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    17ee:	18 16       	cp	r1, r24
    17f0:	4c f5       	brge	.+82     	; 0x1844 <LCD_voidInit+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    17f2:	6a a9       	ldd	r22, Y+50	; 0x32
    17f4:	7b a9       	ldd	r23, Y+51	; 0x33
    17f6:	8c a9       	ldd	r24, Y+52	; 0x34
    17f8:	9d a9       	ldd	r25, Y+53	; 0x35
    17fa:	20 e0       	ldi	r18, 0x00	; 0
    17fc:	30 e0       	ldi	r19, 0x00	; 0
    17fe:	40 e2       	ldi	r20, 0x20	; 32
    1800:	51 e4       	ldi	r21, 0x41	; 65
    1802:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1806:	dc 01       	movw	r26, r24
    1808:	cb 01       	movw	r24, r22
    180a:	bc 01       	movw	r22, r24
    180c:	cd 01       	movw	r24, r26
    180e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1812:	dc 01       	movw	r26, r24
    1814:	cb 01       	movw	r24, r22
    1816:	9d a7       	std	Y+45, r25	; 0x2d
    1818:	8c a7       	std	Y+44, r24	; 0x2c
    181a:	0f c0       	rjmp	.+30     	; 0x183a <LCD_voidInit+0x2aa>
    181c:	88 ec       	ldi	r24, 0xC8	; 200
    181e:	90 e0       	ldi	r25, 0x00	; 0
    1820:	9b a7       	std	Y+43, r25	; 0x2b
    1822:	8a a7       	std	Y+42, r24	; 0x2a
    1824:	8a a5       	ldd	r24, Y+42	; 0x2a
    1826:	9b a5       	ldd	r25, Y+43	; 0x2b
    1828:	01 97       	sbiw	r24, 0x01	; 1
    182a:	f1 f7       	brne	.-4      	; 0x1828 <LCD_voidInit+0x298>
    182c:	9b a7       	std	Y+43, r25	; 0x2b
    182e:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1830:	8c a5       	ldd	r24, Y+44	; 0x2c
    1832:	9d a5       	ldd	r25, Y+45	; 0x2d
    1834:	01 97       	sbiw	r24, 0x01	; 1
    1836:	9d a7       	std	Y+45, r25	; 0x2d
    1838:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    183a:	8c a5       	ldd	r24, Y+44	; 0x2c
    183c:	9d a5       	ldd	r25, Y+45	; 0x2d
    183e:	00 97       	sbiw	r24, 0x00	; 0
    1840:	69 f7       	brne	.-38     	; 0x181c <LCD_voidInit+0x28c>
    1842:	24 c0       	rjmp	.+72     	; 0x188c <LCD_voidInit+0x2fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1844:	6e a5       	ldd	r22, Y+46	; 0x2e
    1846:	7f a5       	ldd	r23, Y+47	; 0x2f
    1848:	88 a9       	ldd	r24, Y+48	; 0x30
    184a:	99 a9       	ldd	r25, Y+49	; 0x31
    184c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1850:	dc 01       	movw	r26, r24
    1852:	cb 01       	movw	r24, r22
    1854:	9d a7       	std	Y+45, r25	; 0x2d
    1856:	8c a7       	std	Y+44, r24	; 0x2c
    1858:	8c a5       	ldd	r24, Y+44	; 0x2c
    185a:	9d a5       	ldd	r25, Y+45	; 0x2d
    185c:	99 a7       	std	Y+41, r25	; 0x29
    185e:	88 a7       	std	Y+40, r24	; 0x28
    1860:	88 a5       	ldd	r24, Y+40	; 0x28
    1862:	99 a5       	ldd	r25, Y+41	; 0x29
    1864:	01 97       	sbiw	r24, 0x01	; 1
    1866:	f1 f7       	brne	.-4      	; 0x1864 <LCD_voidInit+0x2d4>
    1868:	99 a7       	std	Y+41, r25	; 0x29
    186a:	88 a7       	std	Y+40, r24	; 0x28
    186c:	0f c0       	rjmp	.+30     	; 0x188c <LCD_voidInit+0x2fc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    186e:	6f a9       	ldd	r22, Y+55	; 0x37
    1870:	78 ad       	ldd	r23, Y+56	; 0x38
    1872:	89 ad       	ldd	r24, Y+57	; 0x39
    1874:	9a ad       	ldd	r25, Y+58	; 0x3a
    1876:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    187a:	dc 01       	movw	r26, r24
    187c:	cb 01       	movw	r24, r22
    187e:	8e ab       	std	Y+54, r24	; 0x36
    1880:	8e a9       	ldd	r24, Y+54	; 0x36
    1882:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1884:	8f a1       	ldd	r24, Y+39	; 0x27
    1886:	8a 95       	dec	r24
    1888:	f1 f7       	brne	.-4      	; 0x1886 <LCD_voidInit+0x2f6>
    188a:	8f a3       	std	Y+39, r24	; 0x27
	_delay_us(40); //Step 3: wait 39 us
	/* Step 4: DisplayControl Command
	1- D:  1 --> Display on
	2- C:  1 --> Cursor Display on
	3- B:  1 --> Blinking on */
	LCD_voidSendCmnd(LCD_u8_DISPLAY_CONTROL_CMND);
    188c:	8f e0       	ldi	r24, 0x0F	; 15
    188e:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
    1892:	80 e0       	ldi	r24, 0x00	; 0
    1894:	90 e0       	ldi	r25, 0x00	; 0
    1896:	a0 e2       	ldi	r26, 0x20	; 32
    1898:	b2 e4       	ldi	r27, 0x42	; 66
    189a:	8b a3       	std	Y+35, r24	; 0x23
    189c:	9c a3       	std	Y+36, r25	; 0x24
    189e:	ad a3       	std	Y+37, r26	; 0x25
    18a0:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    18a2:	6b a1       	ldd	r22, Y+35	; 0x23
    18a4:	7c a1       	ldd	r23, Y+36	; 0x24
    18a6:	8d a1       	ldd	r24, Y+37	; 0x25
    18a8:	9e a1       	ldd	r25, Y+38	; 0x26
    18aa:	2b ea       	ldi	r18, 0xAB	; 171
    18ac:	3a ea       	ldi	r19, 0xAA	; 170
    18ae:	4a e2       	ldi	r20, 0x2A	; 42
    18b0:	50 e4       	ldi	r21, 0x40	; 64
    18b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18b6:	dc 01       	movw	r26, r24
    18b8:	cb 01       	movw	r24, r22
    18ba:	8f 8f       	std	Y+31, r24	; 0x1f
    18bc:	98 a3       	std	Y+32, r25	; 0x20
    18be:	a9 a3       	std	Y+33, r26	; 0x21
    18c0:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    18c2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    18c4:	78 a1       	ldd	r23, Y+32	; 0x20
    18c6:	89 a1       	ldd	r24, Y+33	; 0x21
    18c8:	9a a1       	ldd	r25, Y+34	; 0x22
    18ca:	20 e0       	ldi	r18, 0x00	; 0
    18cc:	30 e0       	ldi	r19, 0x00	; 0
    18ce:	40 e8       	ldi	r20, 0x80	; 128
    18d0:	5f e3       	ldi	r21, 0x3F	; 63
    18d2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    18d6:	88 23       	and	r24, r24
    18d8:	1c f4       	brge	.+6      	; 0x18e0 <LCD_voidInit+0x350>
		__ticks = 1;
    18da:	81 e0       	ldi	r24, 0x01	; 1
    18dc:	8e 8f       	std	Y+30, r24	; 0x1e
    18de:	91 c0       	rjmp	.+290    	; 0x1a02 <LCD_voidInit+0x472>
	else if (__tmp > 255)
    18e0:	6f 8d       	ldd	r22, Y+31	; 0x1f
    18e2:	78 a1       	ldd	r23, Y+32	; 0x20
    18e4:	89 a1       	ldd	r24, Y+33	; 0x21
    18e6:	9a a1       	ldd	r25, Y+34	; 0x22
    18e8:	20 e0       	ldi	r18, 0x00	; 0
    18ea:	30 e0       	ldi	r19, 0x00	; 0
    18ec:	4f e7       	ldi	r20, 0x7F	; 127
    18ee:	53 e4       	ldi	r21, 0x43	; 67
    18f0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    18f4:	18 16       	cp	r1, r24
    18f6:	0c f0       	brlt	.+2      	; 0x18fa <LCD_voidInit+0x36a>
    18f8:	7b c0       	rjmp	.+246    	; 0x19f0 <LCD_voidInit+0x460>
	{
		_delay_ms(__us / 1000.0);
    18fa:	6b a1       	ldd	r22, Y+35	; 0x23
    18fc:	7c a1       	ldd	r23, Y+36	; 0x24
    18fe:	8d a1       	ldd	r24, Y+37	; 0x25
    1900:	9e a1       	ldd	r25, Y+38	; 0x26
    1902:	20 e0       	ldi	r18, 0x00	; 0
    1904:	30 e0       	ldi	r19, 0x00	; 0
    1906:	4a e7       	ldi	r20, 0x7A	; 122
    1908:	54 e4       	ldi	r21, 0x44	; 68
    190a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    190e:	dc 01       	movw	r26, r24
    1910:	cb 01       	movw	r24, r22
    1912:	8a 8f       	std	Y+26, r24	; 0x1a
    1914:	9b 8f       	std	Y+27, r25	; 0x1b
    1916:	ac 8f       	std	Y+28, r26	; 0x1c
    1918:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    191a:	6a 8d       	ldd	r22, Y+26	; 0x1a
    191c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    191e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1920:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1922:	20 e0       	ldi	r18, 0x00	; 0
    1924:	30 e0       	ldi	r19, 0x00	; 0
    1926:	4a ef       	ldi	r20, 0xFA	; 250
    1928:	54 e4       	ldi	r21, 0x44	; 68
    192a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    192e:	dc 01       	movw	r26, r24
    1930:	cb 01       	movw	r24, r22
    1932:	8e 8b       	std	Y+22, r24	; 0x16
    1934:	9f 8b       	std	Y+23, r25	; 0x17
    1936:	a8 8f       	std	Y+24, r26	; 0x18
    1938:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    193a:	6e 89       	ldd	r22, Y+22	; 0x16
    193c:	7f 89       	ldd	r23, Y+23	; 0x17
    193e:	88 8d       	ldd	r24, Y+24	; 0x18
    1940:	99 8d       	ldd	r25, Y+25	; 0x19
    1942:	20 e0       	ldi	r18, 0x00	; 0
    1944:	30 e0       	ldi	r19, 0x00	; 0
    1946:	40 e8       	ldi	r20, 0x80	; 128
    1948:	5f e3       	ldi	r21, 0x3F	; 63
    194a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    194e:	88 23       	and	r24, r24
    1950:	2c f4       	brge	.+10     	; 0x195c <LCD_voidInit+0x3cc>
		__ticks = 1;
    1952:	81 e0       	ldi	r24, 0x01	; 1
    1954:	90 e0       	ldi	r25, 0x00	; 0
    1956:	9d 8b       	std	Y+21, r25	; 0x15
    1958:	8c 8b       	std	Y+20, r24	; 0x14
    195a:	3f c0       	rjmp	.+126    	; 0x19da <LCD_voidInit+0x44a>
	else if (__tmp > 65535)
    195c:	6e 89       	ldd	r22, Y+22	; 0x16
    195e:	7f 89       	ldd	r23, Y+23	; 0x17
    1960:	88 8d       	ldd	r24, Y+24	; 0x18
    1962:	99 8d       	ldd	r25, Y+25	; 0x19
    1964:	20 e0       	ldi	r18, 0x00	; 0
    1966:	3f ef       	ldi	r19, 0xFF	; 255
    1968:	4f e7       	ldi	r20, 0x7F	; 127
    196a:	57 e4       	ldi	r21, 0x47	; 71
    196c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1970:	18 16       	cp	r1, r24
    1972:	4c f5       	brge	.+82     	; 0x19c6 <LCD_voidInit+0x436>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1974:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1976:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1978:	8c 8d       	ldd	r24, Y+28	; 0x1c
    197a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    197c:	20 e0       	ldi	r18, 0x00	; 0
    197e:	30 e0       	ldi	r19, 0x00	; 0
    1980:	40 e2       	ldi	r20, 0x20	; 32
    1982:	51 e4       	ldi	r21, 0x41	; 65
    1984:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1988:	dc 01       	movw	r26, r24
    198a:	cb 01       	movw	r24, r22
    198c:	bc 01       	movw	r22, r24
    198e:	cd 01       	movw	r24, r26
    1990:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1994:	dc 01       	movw	r26, r24
    1996:	cb 01       	movw	r24, r22
    1998:	9d 8b       	std	Y+21, r25	; 0x15
    199a:	8c 8b       	std	Y+20, r24	; 0x14
    199c:	0f c0       	rjmp	.+30     	; 0x19bc <LCD_voidInit+0x42c>
    199e:	88 ec       	ldi	r24, 0xC8	; 200
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	9b 8b       	std	Y+19, r25	; 0x13
    19a4:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    19a6:	8a 89       	ldd	r24, Y+18	; 0x12
    19a8:	9b 89       	ldd	r25, Y+19	; 0x13
    19aa:	01 97       	sbiw	r24, 0x01	; 1
    19ac:	f1 f7       	brne	.-4      	; 0x19aa <LCD_voidInit+0x41a>
    19ae:	9b 8b       	std	Y+19, r25	; 0x13
    19b0:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19b2:	8c 89       	ldd	r24, Y+20	; 0x14
    19b4:	9d 89       	ldd	r25, Y+21	; 0x15
    19b6:	01 97       	sbiw	r24, 0x01	; 1
    19b8:	9d 8b       	std	Y+21, r25	; 0x15
    19ba:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19bc:	8c 89       	ldd	r24, Y+20	; 0x14
    19be:	9d 89       	ldd	r25, Y+21	; 0x15
    19c0:	00 97       	sbiw	r24, 0x00	; 0
    19c2:	69 f7       	brne	.-38     	; 0x199e <LCD_voidInit+0x40e>
    19c4:	24 c0       	rjmp	.+72     	; 0x1a0e <LCD_voidInit+0x47e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    19c6:	6e 89       	ldd	r22, Y+22	; 0x16
    19c8:	7f 89       	ldd	r23, Y+23	; 0x17
    19ca:	88 8d       	ldd	r24, Y+24	; 0x18
    19cc:	99 8d       	ldd	r25, Y+25	; 0x19
    19ce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19d2:	dc 01       	movw	r26, r24
    19d4:	cb 01       	movw	r24, r22
    19d6:	9d 8b       	std	Y+21, r25	; 0x15
    19d8:	8c 8b       	std	Y+20, r24	; 0x14
    19da:	8c 89       	ldd	r24, Y+20	; 0x14
    19dc:	9d 89       	ldd	r25, Y+21	; 0x15
    19de:	99 8b       	std	Y+17, r25	; 0x11
    19e0:	88 8b       	std	Y+16, r24	; 0x10
    19e2:	88 89       	ldd	r24, Y+16	; 0x10
    19e4:	99 89       	ldd	r25, Y+17	; 0x11
    19e6:	01 97       	sbiw	r24, 0x01	; 1
    19e8:	f1 f7       	brne	.-4      	; 0x19e6 <LCD_voidInit+0x456>
    19ea:	99 8b       	std	Y+17, r25	; 0x11
    19ec:	88 8b       	std	Y+16, r24	; 0x10
    19ee:	0f c0       	rjmp	.+30     	; 0x1a0e <LCD_voidInit+0x47e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    19f0:	6f 8d       	ldd	r22, Y+31	; 0x1f
    19f2:	78 a1       	ldd	r23, Y+32	; 0x20
    19f4:	89 a1       	ldd	r24, Y+33	; 0x21
    19f6:	9a a1       	ldd	r25, Y+34	; 0x22
    19f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19fc:	dc 01       	movw	r26, r24
    19fe:	cb 01       	movw	r24, r22
    1a00:	8e 8f       	std	Y+30, r24	; 0x1e
    1a02:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a04:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1a06:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a08:	8a 95       	dec	r24
    1a0a:	f1 f7       	brne	.-4      	; 0x1a08 <LCD_voidInit+0x478>
    1a0c:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_us(40); //Step 5: wait 39 us
	/* Step 6: Display Clear Command*/
	LCD_voidSendCmnd(LCD_u8_DISPLAY_CLEAR_CMND);
    1a0e:	81 e0       	ldi	r24, 0x01	; 1
    1a10:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
    1a14:	80 e0       	ldi	r24, 0x00	; 0
    1a16:	90 e0       	ldi	r25, 0x00	; 0
    1a18:	a0 e0       	ldi	r26, 0x00	; 0
    1a1a:	b0 e4       	ldi	r27, 0x40	; 64
    1a1c:	8b 87       	std	Y+11, r24	; 0x0b
    1a1e:	9c 87       	std	Y+12, r25	; 0x0c
    1a20:	ad 87       	std	Y+13, r26	; 0x0d
    1a22:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1a24:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a26:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a28:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a2c:	20 e0       	ldi	r18, 0x00	; 0
    1a2e:	30 e0       	ldi	r19, 0x00	; 0
    1a30:	4a ef       	ldi	r20, 0xFA	; 250
    1a32:	54 e4       	ldi	r21, 0x44	; 68
    1a34:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a38:	dc 01       	movw	r26, r24
    1a3a:	cb 01       	movw	r24, r22
    1a3c:	8f 83       	std	Y+7, r24	; 0x07
    1a3e:	98 87       	std	Y+8, r25	; 0x08
    1a40:	a9 87       	std	Y+9, r26	; 0x09
    1a42:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1a44:	6f 81       	ldd	r22, Y+7	; 0x07
    1a46:	78 85       	ldd	r23, Y+8	; 0x08
    1a48:	89 85       	ldd	r24, Y+9	; 0x09
    1a4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a4c:	20 e0       	ldi	r18, 0x00	; 0
    1a4e:	30 e0       	ldi	r19, 0x00	; 0
    1a50:	40 e8       	ldi	r20, 0x80	; 128
    1a52:	5f e3       	ldi	r21, 0x3F	; 63
    1a54:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1a58:	88 23       	and	r24, r24
    1a5a:	2c f4       	brge	.+10     	; 0x1a66 <LCD_voidInit+0x4d6>
		__ticks = 1;
    1a5c:	81 e0       	ldi	r24, 0x01	; 1
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	9e 83       	std	Y+6, r25	; 0x06
    1a62:	8d 83       	std	Y+5, r24	; 0x05
    1a64:	3f c0       	rjmp	.+126    	; 0x1ae4 <LCD_voidInit+0x554>
	else if (__tmp > 65535)
    1a66:	6f 81       	ldd	r22, Y+7	; 0x07
    1a68:	78 85       	ldd	r23, Y+8	; 0x08
    1a6a:	89 85       	ldd	r24, Y+9	; 0x09
    1a6c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a6e:	20 e0       	ldi	r18, 0x00	; 0
    1a70:	3f ef       	ldi	r19, 0xFF	; 255
    1a72:	4f e7       	ldi	r20, 0x7F	; 127
    1a74:	57 e4       	ldi	r21, 0x47	; 71
    1a76:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1a7a:	18 16       	cp	r1, r24
    1a7c:	4c f5       	brge	.+82     	; 0x1ad0 <LCD_voidInit+0x540>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a7e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a80:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a82:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a84:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a86:	20 e0       	ldi	r18, 0x00	; 0
    1a88:	30 e0       	ldi	r19, 0x00	; 0
    1a8a:	40 e2       	ldi	r20, 0x20	; 32
    1a8c:	51 e4       	ldi	r21, 0x41	; 65
    1a8e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a92:	dc 01       	movw	r26, r24
    1a94:	cb 01       	movw	r24, r22
    1a96:	bc 01       	movw	r22, r24
    1a98:	cd 01       	movw	r24, r26
    1a9a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a9e:	dc 01       	movw	r26, r24
    1aa0:	cb 01       	movw	r24, r22
    1aa2:	9e 83       	std	Y+6, r25	; 0x06
    1aa4:	8d 83       	std	Y+5, r24	; 0x05
    1aa6:	0f c0       	rjmp	.+30     	; 0x1ac6 <LCD_voidInit+0x536>
    1aa8:	88 ec       	ldi	r24, 0xC8	; 200
    1aaa:	90 e0       	ldi	r25, 0x00	; 0
    1aac:	9c 83       	std	Y+4, r25	; 0x04
    1aae:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1ab0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab4:	01 97       	sbiw	r24, 0x01	; 1
    1ab6:	f1 f7       	brne	.-4      	; 0x1ab4 <LCD_voidInit+0x524>
    1ab8:	9c 83       	std	Y+4, r25	; 0x04
    1aba:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1abc:	8d 81       	ldd	r24, Y+5	; 0x05
    1abe:	9e 81       	ldd	r25, Y+6	; 0x06
    1ac0:	01 97       	sbiw	r24, 0x01	; 1
    1ac2:	9e 83       	std	Y+6, r25	; 0x06
    1ac4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ac6:	8d 81       	ldd	r24, Y+5	; 0x05
    1ac8:	9e 81       	ldd	r25, Y+6	; 0x06
    1aca:	00 97       	sbiw	r24, 0x00	; 0
    1acc:	69 f7       	brne	.-38     	; 0x1aa8 <LCD_voidInit+0x518>
    1ace:	14 c0       	rjmp	.+40     	; 0x1af8 <LCD_voidInit+0x568>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ad0:	6f 81       	ldd	r22, Y+7	; 0x07
    1ad2:	78 85       	ldd	r23, Y+8	; 0x08
    1ad4:	89 85       	ldd	r24, Y+9	; 0x09
    1ad6:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ad8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1adc:	dc 01       	movw	r26, r24
    1ade:	cb 01       	movw	r24, r22
    1ae0:	9e 83       	std	Y+6, r25	; 0x06
    1ae2:	8d 83       	std	Y+5, r24	; 0x05
    1ae4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ae8:	9a 83       	std	Y+2, r25	; 0x02
    1aea:	89 83       	std	Y+1, r24	; 0x01
    1aec:	89 81       	ldd	r24, Y+1	; 0x01
    1aee:	9a 81       	ldd	r25, Y+2	; 0x02
    1af0:	01 97       	sbiw	r24, 0x01	; 1
    1af2:	f1 f7       	brne	.-4      	; 0x1af0 <LCD_voidInit+0x560>
    1af4:	9a 83       	std	Y+2, r25	; 0x02
    1af6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2); //Step 7:wait more than 1.53 ms
	/* Step 8: Entry Mode Set Command
	1- I/D: 1 --> Increase
	2- SH: 0 --> no shift*/
	LCD_voidSendCmnd(LCD_u8_ENTRY_MODE_SET_CMND);
    1af8:	86 e0       	ldi	r24, 0x06	; 6
    1afa:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>


}
    1afe:	c4 5b       	subi	r28, 0xB4	; 180
    1b00:	df 4f       	sbci	r29, 0xFF	; 255
    1b02:	0f b6       	in	r0, 0x3f	; 63
    1b04:	f8 94       	cli
    1b06:	de bf       	out	0x3e, r29	; 62
    1b08:	0f be       	out	0x3f, r0	; 63
    1b0a:	cd bf       	out	0x3d, r28	; 61
    1b0c:	cf 91       	pop	r28
    1b0e:	df 91       	pop	r29
    1b10:	1f 91       	pop	r17
    1b12:	0f 91       	pop	r16
    1b14:	08 95       	ret

00001b16 <LCD_voidSendCmnd>:

void LCD_voidSendCmnd(u8 Copy_u8Cmnd)
{
    1b16:	df 93       	push	r29
    1b18:	cf 93       	push	r28
    1b1a:	cd b7       	in	r28, 0x3d	; 61
    1b1c:	de b7       	in	r29, 0x3e	; 62
    1b1e:	e1 97       	sbiw	r28, 0x31	; 49
    1b20:	0f b6       	in	r0, 0x3f	; 63
    1b22:	f8 94       	cli
    1b24:	de bf       	out	0x3e, r29	; 62
    1b26:	0f be       	out	0x3f, r0	; 63
    1b28:	cd bf       	out	0x3d, r28	; 61
    1b2a:	89 ab       	std	Y+49, r24	; 0x31
#if LCD_u8_MODE == LCD_u8_MODE_8_BIT
	/* Step 1: RS = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RS_PIN,DIO_u8_LOW);
    1b2c:	80 e0       	ldi	r24, 0x00	; 0
    1b2e:	60 e0       	ldi	r22, 0x00	; 0
    1b30:	40 e0       	ldi	r20, 0x00	; 0
    1b32:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
	/* Step 2: RW = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RW_PIN,DIO_u8_LOW);
    1b36:	80 e0       	ldi	r24, 0x00	; 0
    1b38:	61 e0       	ldi	r22, 0x01	; 1
    1b3a:	40 e0       	ldi	r20, 0x00	; 0
    1b3c:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
	/* Step 3: Write Command  */
	DIO_u8SetPortValue(LCD_u8_DATA_PORT,Copy_u8Cmnd);
    1b40:	82 e0       	ldi	r24, 0x02	; 2
    1b42:	69 a9       	ldd	r22, Y+49	; 0x31
    1b44:	0e 94 28 0a 	call	0x1450	; 0x1450 <DIO_u8SetPortValue>
	/* Step 4: E = 1 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_HIGH);
    1b48:	80 e0       	ldi	r24, 0x00	; 0
    1b4a:	62 e0       	ldi	r22, 0x02	; 2
    1b4c:	41 e0       	ldi	r20, 0x01	; 1
    1b4e:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
    1b52:	80 e0       	ldi	r24, 0x00	; 0
    1b54:	90 e0       	ldi	r25, 0x00	; 0
    1b56:	a0 e8       	ldi	r26, 0x80	; 128
    1b58:	bf e3       	ldi	r27, 0x3F	; 63
    1b5a:	8d a7       	std	Y+45, r24	; 0x2d
    1b5c:	9e a7       	std	Y+46, r25	; 0x2e
    1b5e:	af a7       	std	Y+47, r26	; 0x2f
    1b60:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1b62:	6d a5       	ldd	r22, Y+45	; 0x2d
    1b64:	7e a5       	ldd	r23, Y+46	; 0x2e
    1b66:	8f a5       	ldd	r24, Y+47	; 0x2f
    1b68:	98 a9       	ldd	r25, Y+48	; 0x30
    1b6a:	2b ea       	ldi	r18, 0xAB	; 171
    1b6c:	3a ea       	ldi	r19, 0xAA	; 170
    1b6e:	4a e2       	ldi	r20, 0x2A	; 42
    1b70:	50 e4       	ldi	r21, 0x40	; 64
    1b72:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b76:	dc 01       	movw	r26, r24
    1b78:	cb 01       	movw	r24, r22
    1b7a:	89 a7       	std	Y+41, r24	; 0x29
    1b7c:	9a a7       	std	Y+42, r25	; 0x2a
    1b7e:	ab a7       	std	Y+43, r26	; 0x2b
    1b80:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    1b82:	69 a5       	ldd	r22, Y+41	; 0x29
    1b84:	7a a5       	ldd	r23, Y+42	; 0x2a
    1b86:	8b a5       	ldd	r24, Y+43	; 0x2b
    1b88:	9c a5       	ldd	r25, Y+44	; 0x2c
    1b8a:	20 e0       	ldi	r18, 0x00	; 0
    1b8c:	30 e0       	ldi	r19, 0x00	; 0
    1b8e:	40 e8       	ldi	r20, 0x80	; 128
    1b90:	5f e3       	ldi	r21, 0x3F	; 63
    1b92:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1b96:	88 23       	and	r24, r24
    1b98:	1c f4       	brge	.+6      	; 0x1ba0 <LCD_voidSendCmnd+0x8a>
		__ticks = 1;
    1b9a:	81 e0       	ldi	r24, 0x01	; 1
    1b9c:	88 a7       	std	Y+40, r24	; 0x28
    1b9e:	91 c0       	rjmp	.+290    	; 0x1cc2 <LCD_voidSendCmnd+0x1ac>
	else if (__tmp > 255)
    1ba0:	69 a5       	ldd	r22, Y+41	; 0x29
    1ba2:	7a a5       	ldd	r23, Y+42	; 0x2a
    1ba4:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ba6:	9c a5       	ldd	r25, Y+44	; 0x2c
    1ba8:	20 e0       	ldi	r18, 0x00	; 0
    1baa:	30 e0       	ldi	r19, 0x00	; 0
    1bac:	4f e7       	ldi	r20, 0x7F	; 127
    1bae:	53 e4       	ldi	r21, 0x43	; 67
    1bb0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1bb4:	18 16       	cp	r1, r24
    1bb6:	0c f0       	brlt	.+2      	; 0x1bba <LCD_voidSendCmnd+0xa4>
    1bb8:	7b c0       	rjmp	.+246    	; 0x1cb0 <LCD_voidSendCmnd+0x19a>
	{
		_delay_ms(__us / 1000.0);
    1bba:	6d a5       	ldd	r22, Y+45	; 0x2d
    1bbc:	7e a5       	ldd	r23, Y+46	; 0x2e
    1bbe:	8f a5       	ldd	r24, Y+47	; 0x2f
    1bc0:	98 a9       	ldd	r25, Y+48	; 0x30
    1bc2:	20 e0       	ldi	r18, 0x00	; 0
    1bc4:	30 e0       	ldi	r19, 0x00	; 0
    1bc6:	4a e7       	ldi	r20, 0x7A	; 122
    1bc8:	54 e4       	ldi	r21, 0x44	; 68
    1bca:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1bce:	dc 01       	movw	r26, r24
    1bd0:	cb 01       	movw	r24, r22
    1bd2:	8c a3       	std	Y+36, r24	; 0x24
    1bd4:	9d a3       	std	Y+37, r25	; 0x25
    1bd6:	ae a3       	std	Y+38, r26	; 0x26
    1bd8:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1bda:	6c a1       	ldd	r22, Y+36	; 0x24
    1bdc:	7d a1       	ldd	r23, Y+37	; 0x25
    1bde:	8e a1       	ldd	r24, Y+38	; 0x26
    1be0:	9f a1       	ldd	r25, Y+39	; 0x27
    1be2:	20 e0       	ldi	r18, 0x00	; 0
    1be4:	30 e0       	ldi	r19, 0x00	; 0
    1be6:	4a ef       	ldi	r20, 0xFA	; 250
    1be8:	54 e4       	ldi	r21, 0x44	; 68
    1bea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bee:	dc 01       	movw	r26, r24
    1bf0:	cb 01       	movw	r24, r22
    1bf2:	88 a3       	std	Y+32, r24	; 0x20
    1bf4:	99 a3       	std	Y+33, r25	; 0x21
    1bf6:	aa a3       	std	Y+34, r26	; 0x22
    1bf8:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    1bfa:	68 a1       	ldd	r22, Y+32	; 0x20
    1bfc:	79 a1       	ldd	r23, Y+33	; 0x21
    1bfe:	8a a1       	ldd	r24, Y+34	; 0x22
    1c00:	9b a1       	ldd	r25, Y+35	; 0x23
    1c02:	20 e0       	ldi	r18, 0x00	; 0
    1c04:	30 e0       	ldi	r19, 0x00	; 0
    1c06:	40 e8       	ldi	r20, 0x80	; 128
    1c08:	5f e3       	ldi	r21, 0x3F	; 63
    1c0a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1c0e:	88 23       	and	r24, r24
    1c10:	2c f4       	brge	.+10     	; 0x1c1c <LCD_voidSendCmnd+0x106>
		__ticks = 1;
    1c12:	81 e0       	ldi	r24, 0x01	; 1
    1c14:	90 e0       	ldi	r25, 0x00	; 0
    1c16:	9f 8f       	std	Y+31, r25	; 0x1f
    1c18:	8e 8f       	std	Y+30, r24	; 0x1e
    1c1a:	3f c0       	rjmp	.+126    	; 0x1c9a <LCD_voidSendCmnd+0x184>
	else if (__tmp > 65535)
    1c1c:	68 a1       	ldd	r22, Y+32	; 0x20
    1c1e:	79 a1       	ldd	r23, Y+33	; 0x21
    1c20:	8a a1       	ldd	r24, Y+34	; 0x22
    1c22:	9b a1       	ldd	r25, Y+35	; 0x23
    1c24:	20 e0       	ldi	r18, 0x00	; 0
    1c26:	3f ef       	ldi	r19, 0xFF	; 255
    1c28:	4f e7       	ldi	r20, 0x7F	; 127
    1c2a:	57 e4       	ldi	r21, 0x47	; 71
    1c2c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1c30:	18 16       	cp	r1, r24
    1c32:	4c f5       	brge	.+82     	; 0x1c86 <LCD_voidSendCmnd+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c34:	6c a1       	ldd	r22, Y+36	; 0x24
    1c36:	7d a1       	ldd	r23, Y+37	; 0x25
    1c38:	8e a1       	ldd	r24, Y+38	; 0x26
    1c3a:	9f a1       	ldd	r25, Y+39	; 0x27
    1c3c:	20 e0       	ldi	r18, 0x00	; 0
    1c3e:	30 e0       	ldi	r19, 0x00	; 0
    1c40:	40 e2       	ldi	r20, 0x20	; 32
    1c42:	51 e4       	ldi	r21, 0x41	; 65
    1c44:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c48:	dc 01       	movw	r26, r24
    1c4a:	cb 01       	movw	r24, r22
    1c4c:	bc 01       	movw	r22, r24
    1c4e:	cd 01       	movw	r24, r26
    1c50:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c54:	dc 01       	movw	r26, r24
    1c56:	cb 01       	movw	r24, r22
    1c58:	9f 8f       	std	Y+31, r25	; 0x1f
    1c5a:	8e 8f       	std	Y+30, r24	; 0x1e
    1c5c:	0f c0       	rjmp	.+30     	; 0x1c7c <LCD_voidSendCmnd+0x166>
    1c5e:	88 ec       	ldi	r24, 0xC8	; 200
    1c60:	90 e0       	ldi	r25, 0x00	; 0
    1c62:	9d 8f       	std	Y+29, r25	; 0x1d
    1c64:	8c 8f       	std	Y+28, r24	; 0x1c
    1c66:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1c68:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1c6a:	01 97       	sbiw	r24, 0x01	; 1
    1c6c:	f1 f7       	brne	.-4      	; 0x1c6a <LCD_voidSendCmnd+0x154>
    1c6e:	9d 8f       	std	Y+29, r25	; 0x1d
    1c70:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c72:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c74:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1c76:	01 97       	sbiw	r24, 0x01	; 1
    1c78:	9f 8f       	std	Y+31, r25	; 0x1f
    1c7a:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c7c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c7e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1c80:	00 97       	sbiw	r24, 0x00	; 0
    1c82:	69 f7       	brne	.-38     	; 0x1c5e <LCD_voidSendCmnd+0x148>
    1c84:	24 c0       	rjmp	.+72     	; 0x1cce <LCD_voidSendCmnd+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c86:	68 a1       	ldd	r22, Y+32	; 0x20
    1c88:	79 a1       	ldd	r23, Y+33	; 0x21
    1c8a:	8a a1       	ldd	r24, Y+34	; 0x22
    1c8c:	9b a1       	ldd	r25, Y+35	; 0x23
    1c8e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c92:	dc 01       	movw	r26, r24
    1c94:	cb 01       	movw	r24, r22
    1c96:	9f 8f       	std	Y+31, r25	; 0x1f
    1c98:	8e 8f       	std	Y+30, r24	; 0x1e
    1c9a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c9c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1c9e:	9b 8f       	std	Y+27, r25	; 0x1b
    1ca0:	8a 8f       	std	Y+26, r24	; 0x1a
    1ca2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ca4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1ca6:	01 97       	sbiw	r24, 0x01	; 1
    1ca8:	f1 f7       	brne	.-4      	; 0x1ca6 <LCD_voidSendCmnd+0x190>
    1caa:	9b 8f       	std	Y+27, r25	; 0x1b
    1cac:	8a 8f       	std	Y+26, r24	; 0x1a
    1cae:	0f c0       	rjmp	.+30     	; 0x1cce <LCD_voidSendCmnd+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1cb0:	69 a5       	ldd	r22, Y+41	; 0x29
    1cb2:	7a a5       	ldd	r23, Y+42	; 0x2a
    1cb4:	8b a5       	ldd	r24, Y+43	; 0x2b
    1cb6:	9c a5       	ldd	r25, Y+44	; 0x2c
    1cb8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cbc:	dc 01       	movw	r26, r24
    1cbe:	cb 01       	movw	r24, r22
    1cc0:	88 a7       	std	Y+40, r24	; 0x28
    1cc2:	88 a5       	ldd	r24, Y+40	; 0x28
    1cc4:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1cc6:	89 8d       	ldd	r24, Y+25	; 0x19
    1cc8:	8a 95       	dec	r24
    1cca:	f1 f7       	brne	.-4      	; 0x1cc8 <LCD_voidSendCmnd+0x1b2>
    1ccc:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1); //wait tw = 230 ns
	/* Step 5: E = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
    1cce:	80 e0       	ldi	r24, 0x00	; 0
    1cd0:	62 e0       	ldi	r22, 0x02	; 2
    1cd2:	40 e0       	ldi	r20, 0x00	; 0
    1cd4:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
    1cd8:	80 e0       	ldi	r24, 0x00	; 0
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	a0 e8       	ldi	r26, 0x80	; 128
    1cde:	bf e3       	ldi	r27, 0x3F	; 63
    1ce0:	8d 8b       	std	Y+21, r24	; 0x15
    1ce2:	9e 8b       	std	Y+22, r25	; 0x16
    1ce4:	af 8b       	std	Y+23, r26	; 0x17
    1ce6:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1ce8:	6d 89       	ldd	r22, Y+21	; 0x15
    1cea:	7e 89       	ldd	r23, Y+22	; 0x16
    1cec:	8f 89       	ldd	r24, Y+23	; 0x17
    1cee:	98 8d       	ldd	r25, Y+24	; 0x18
    1cf0:	2b ea       	ldi	r18, 0xAB	; 171
    1cf2:	3a ea       	ldi	r19, 0xAA	; 170
    1cf4:	4a e2       	ldi	r20, 0x2A	; 42
    1cf6:	50 e4       	ldi	r21, 0x40	; 64
    1cf8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cfc:	dc 01       	movw	r26, r24
    1cfe:	cb 01       	movw	r24, r22
    1d00:	89 8b       	std	Y+17, r24	; 0x11
    1d02:	9a 8b       	std	Y+18, r25	; 0x12
    1d04:	ab 8b       	std	Y+19, r26	; 0x13
    1d06:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    1d08:	69 89       	ldd	r22, Y+17	; 0x11
    1d0a:	7a 89       	ldd	r23, Y+18	; 0x12
    1d0c:	8b 89       	ldd	r24, Y+19	; 0x13
    1d0e:	9c 89       	ldd	r25, Y+20	; 0x14
    1d10:	20 e0       	ldi	r18, 0x00	; 0
    1d12:	30 e0       	ldi	r19, 0x00	; 0
    1d14:	40 e8       	ldi	r20, 0x80	; 128
    1d16:	5f e3       	ldi	r21, 0x3F	; 63
    1d18:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1d1c:	88 23       	and	r24, r24
    1d1e:	1c f4       	brge	.+6      	; 0x1d26 <LCD_voidSendCmnd+0x210>
		__ticks = 1;
    1d20:	81 e0       	ldi	r24, 0x01	; 1
    1d22:	88 8b       	std	Y+16, r24	; 0x10
    1d24:	91 c0       	rjmp	.+290    	; 0x1e48 <LCD_voidSendCmnd+0x332>
	else if (__tmp > 255)
    1d26:	69 89       	ldd	r22, Y+17	; 0x11
    1d28:	7a 89       	ldd	r23, Y+18	; 0x12
    1d2a:	8b 89       	ldd	r24, Y+19	; 0x13
    1d2c:	9c 89       	ldd	r25, Y+20	; 0x14
    1d2e:	20 e0       	ldi	r18, 0x00	; 0
    1d30:	30 e0       	ldi	r19, 0x00	; 0
    1d32:	4f e7       	ldi	r20, 0x7F	; 127
    1d34:	53 e4       	ldi	r21, 0x43	; 67
    1d36:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1d3a:	18 16       	cp	r1, r24
    1d3c:	0c f0       	brlt	.+2      	; 0x1d40 <LCD_voidSendCmnd+0x22a>
    1d3e:	7b c0       	rjmp	.+246    	; 0x1e36 <LCD_voidSendCmnd+0x320>
	{
		_delay_ms(__us / 1000.0);
    1d40:	6d 89       	ldd	r22, Y+21	; 0x15
    1d42:	7e 89       	ldd	r23, Y+22	; 0x16
    1d44:	8f 89       	ldd	r24, Y+23	; 0x17
    1d46:	98 8d       	ldd	r25, Y+24	; 0x18
    1d48:	20 e0       	ldi	r18, 0x00	; 0
    1d4a:	30 e0       	ldi	r19, 0x00	; 0
    1d4c:	4a e7       	ldi	r20, 0x7A	; 122
    1d4e:	54 e4       	ldi	r21, 0x44	; 68
    1d50:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1d54:	dc 01       	movw	r26, r24
    1d56:	cb 01       	movw	r24, r22
    1d58:	8c 87       	std	Y+12, r24	; 0x0c
    1d5a:	9d 87       	std	Y+13, r25	; 0x0d
    1d5c:	ae 87       	std	Y+14, r26	; 0x0e
    1d5e:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d60:	6c 85       	ldd	r22, Y+12	; 0x0c
    1d62:	7d 85       	ldd	r23, Y+13	; 0x0d
    1d64:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d66:	9f 85       	ldd	r25, Y+15	; 0x0f
    1d68:	20 e0       	ldi	r18, 0x00	; 0
    1d6a:	30 e0       	ldi	r19, 0x00	; 0
    1d6c:	4a ef       	ldi	r20, 0xFA	; 250
    1d6e:	54 e4       	ldi	r21, 0x44	; 68
    1d70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d74:	dc 01       	movw	r26, r24
    1d76:	cb 01       	movw	r24, r22
    1d78:	88 87       	std	Y+8, r24	; 0x08
    1d7a:	99 87       	std	Y+9, r25	; 0x09
    1d7c:	aa 87       	std	Y+10, r26	; 0x0a
    1d7e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1d80:	68 85       	ldd	r22, Y+8	; 0x08
    1d82:	79 85       	ldd	r23, Y+9	; 0x09
    1d84:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d86:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d88:	20 e0       	ldi	r18, 0x00	; 0
    1d8a:	30 e0       	ldi	r19, 0x00	; 0
    1d8c:	40 e8       	ldi	r20, 0x80	; 128
    1d8e:	5f e3       	ldi	r21, 0x3F	; 63
    1d90:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1d94:	88 23       	and	r24, r24
    1d96:	2c f4       	brge	.+10     	; 0x1da2 <LCD_voidSendCmnd+0x28c>
		__ticks = 1;
    1d98:	81 e0       	ldi	r24, 0x01	; 1
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	9f 83       	std	Y+7, r25	; 0x07
    1d9e:	8e 83       	std	Y+6, r24	; 0x06
    1da0:	3f c0       	rjmp	.+126    	; 0x1e20 <LCD_voidSendCmnd+0x30a>
	else if (__tmp > 65535)
    1da2:	68 85       	ldd	r22, Y+8	; 0x08
    1da4:	79 85       	ldd	r23, Y+9	; 0x09
    1da6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1da8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1daa:	20 e0       	ldi	r18, 0x00	; 0
    1dac:	3f ef       	ldi	r19, 0xFF	; 255
    1dae:	4f e7       	ldi	r20, 0x7F	; 127
    1db0:	57 e4       	ldi	r21, 0x47	; 71
    1db2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1db6:	18 16       	cp	r1, r24
    1db8:	4c f5       	brge	.+82     	; 0x1e0c <LCD_voidSendCmnd+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1dba:	6c 85       	ldd	r22, Y+12	; 0x0c
    1dbc:	7d 85       	ldd	r23, Y+13	; 0x0d
    1dbe:	8e 85       	ldd	r24, Y+14	; 0x0e
    1dc0:	9f 85       	ldd	r25, Y+15	; 0x0f
    1dc2:	20 e0       	ldi	r18, 0x00	; 0
    1dc4:	30 e0       	ldi	r19, 0x00	; 0
    1dc6:	40 e2       	ldi	r20, 0x20	; 32
    1dc8:	51 e4       	ldi	r21, 0x41	; 65
    1dca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dce:	dc 01       	movw	r26, r24
    1dd0:	cb 01       	movw	r24, r22
    1dd2:	bc 01       	movw	r22, r24
    1dd4:	cd 01       	movw	r24, r26
    1dd6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dda:	dc 01       	movw	r26, r24
    1ddc:	cb 01       	movw	r24, r22
    1dde:	9f 83       	std	Y+7, r25	; 0x07
    1de0:	8e 83       	std	Y+6, r24	; 0x06
    1de2:	0f c0       	rjmp	.+30     	; 0x1e02 <LCD_voidSendCmnd+0x2ec>
    1de4:	88 ec       	ldi	r24, 0xC8	; 200
    1de6:	90 e0       	ldi	r25, 0x00	; 0
    1de8:	9d 83       	std	Y+5, r25	; 0x05
    1dea:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1dec:	8c 81       	ldd	r24, Y+4	; 0x04
    1dee:	9d 81       	ldd	r25, Y+5	; 0x05
    1df0:	01 97       	sbiw	r24, 0x01	; 1
    1df2:	f1 f7       	brne	.-4      	; 0x1df0 <LCD_voidSendCmnd+0x2da>
    1df4:	9d 83       	std	Y+5, r25	; 0x05
    1df6:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1df8:	8e 81       	ldd	r24, Y+6	; 0x06
    1dfa:	9f 81       	ldd	r25, Y+7	; 0x07
    1dfc:	01 97       	sbiw	r24, 0x01	; 1
    1dfe:	9f 83       	std	Y+7, r25	; 0x07
    1e00:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e02:	8e 81       	ldd	r24, Y+6	; 0x06
    1e04:	9f 81       	ldd	r25, Y+7	; 0x07
    1e06:	00 97       	sbiw	r24, 0x00	; 0
    1e08:	69 f7       	brne	.-38     	; 0x1de4 <LCD_voidSendCmnd+0x2ce>
    1e0a:	24 c0       	rjmp	.+72     	; 0x1e54 <LCD_voidSendCmnd+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e0c:	68 85       	ldd	r22, Y+8	; 0x08
    1e0e:	79 85       	ldd	r23, Y+9	; 0x09
    1e10:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e12:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e18:	dc 01       	movw	r26, r24
    1e1a:	cb 01       	movw	r24, r22
    1e1c:	9f 83       	std	Y+7, r25	; 0x07
    1e1e:	8e 83       	std	Y+6, r24	; 0x06
    1e20:	8e 81       	ldd	r24, Y+6	; 0x06
    1e22:	9f 81       	ldd	r25, Y+7	; 0x07
    1e24:	9b 83       	std	Y+3, r25	; 0x03
    1e26:	8a 83       	std	Y+2, r24	; 0x02
    1e28:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2a:	9b 81       	ldd	r25, Y+3	; 0x03
    1e2c:	01 97       	sbiw	r24, 0x01	; 1
    1e2e:	f1 f7       	brne	.-4      	; 0x1e2c <LCD_voidSendCmnd+0x316>
    1e30:	9b 83       	std	Y+3, r25	; 0x03
    1e32:	8a 83       	std	Y+2, r24	; 0x02
    1e34:	0f c0       	rjmp	.+30     	; 0x1e54 <LCD_voidSendCmnd+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1e36:	69 89       	ldd	r22, Y+17	; 0x11
    1e38:	7a 89       	ldd	r23, Y+18	; 0x12
    1e3a:	8b 89       	ldd	r24, Y+19	; 0x13
    1e3c:	9c 89       	ldd	r25, Y+20	; 0x14
    1e3e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e42:	dc 01       	movw	r26, r24
    1e44:	cb 01       	movw	r24, r22
    1e46:	88 8b       	std	Y+16, r24	; 0x10
    1e48:	88 89       	ldd	r24, Y+16	; 0x10
    1e4a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1e4c:	89 81       	ldd	r24, Y+1	; 0x01
    1e4e:	8a 95       	dec	r24
    1e50:	f1 f7       	brne	.-4      	; 0x1e4e <LCD_voidSendCmnd+0x338>
    1e52:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
	_delay_us(1); // wait tc = 500ns (not important because 1 us in step 4 is enough because >>> 230ns )

#endif

}
    1e54:	e1 96       	adiw	r28, 0x31	; 49
    1e56:	0f b6       	in	r0, 0x3f	; 63
    1e58:	f8 94       	cli
    1e5a:	de bf       	out	0x3e, r29	; 62
    1e5c:	0f be       	out	0x3f, r0	; 63
    1e5e:	cd bf       	out	0x3d, r28	; 61
    1e60:	cf 91       	pop	r28
    1e62:	df 91       	pop	r29
    1e64:	08 95       	ret

00001e66 <LCD_voidSendChar>:

void LCD_voidSendChar(u8 Copy_u8Char)
{
    1e66:	df 93       	push	r29
    1e68:	cf 93       	push	r28
    1e6a:	cd b7       	in	r28, 0x3d	; 61
    1e6c:	de b7       	in	r29, 0x3e	; 62
    1e6e:	e1 97       	sbiw	r28, 0x31	; 49
    1e70:	0f b6       	in	r0, 0x3f	; 63
    1e72:	f8 94       	cli
    1e74:	de bf       	out	0x3e, r29	; 62
    1e76:	0f be       	out	0x3f, r0	; 63
    1e78:	cd bf       	out	0x3d, r28	; 61
    1e7a:	89 ab       	std	Y+49, r24	; 0x31
#if LCD_u8_MODE == LCD_u8_MODE_8_BIT
	/* Step 1: RS = 1 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RS_PIN,DIO_u8_HIGH);
    1e7c:	80 e0       	ldi	r24, 0x00	; 0
    1e7e:	60 e0       	ldi	r22, 0x00	; 0
    1e80:	41 e0       	ldi	r20, 0x01	; 1
    1e82:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
	/* Step 2: RW = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RW_PIN,DIO_u8_LOW);
    1e86:	80 e0       	ldi	r24, 0x00	; 0
    1e88:	61 e0       	ldi	r22, 0x01	; 1
    1e8a:	40 e0       	ldi	r20, 0x00	; 0
    1e8c:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
	/* Step 3: Write Char  */
	DIO_u8SetPortValue(LCD_u8_DATA_PORT,Copy_u8Char);
    1e90:	82 e0       	ldi	r24, 0x02	; 2
    1e92:	69 a9       	ldd	r22, Y+49	; 0x31
    1e94:	0e 94 28 0a 	call	0x1450	; 0x1450 <DIO_u8SetPortValue>
	/* Step 4: E = 1 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_HIGH);
    1e98:	80 e0       	ldi	r24, 0x00	; 0
    1e9a:	62 e0       	ldi	r22, 0x02	; 2
    1e9c:	41 e0       	ldi	r20, 0x01	; 1
    1e9e:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
    1ea2:	80 e0       	ldi	r24, 0x00	; 0
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	a0 e8       	ldi	r26, 0x80	; 128
    1ea8:	bf e3       	ldi	r27, 0x3F	; 63
    1eaa:	8d a7       	std	Y+45, r24	; 0x2d
    1eac:	9e a7       	std	Y+46, r25	; 0x2e
    1eae:	af a7       	std	Y+47, r26	; 0x2f
    1eb0:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1eb2:	6d a5       	ldd	r22, Y+45	; 0x2d
    1eb4:	7e a5       	ldd	r23, Y+46	; 0x2e
    1eb6:	8f a5       	ldd	r24, Y+47	; 0x2f
    1eb8:	98 a9       	ldd	r25, Y+48	; 0x30
    1eba:	2b ea       	ldi	r18, 0xAB	; 171
    1ebc:	3a ea       	ldi	r19, 0xAA	; 170
    1ebe:	4a e2       	ldi	r20, 0x2A	; 42
    1ec0:	50 e4       	ldi	r21, 0x40	; 64
    1ec2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ec6:	dc 01       	movw	r26, r24
    1ec8:	cb 01       	movw	r24, r22
    1eca:	89 a7       	std	Y+41, r24	; 0x29
    1ecc:	9a a7       	std	Y+42, r25	; 0x2a
    1ece:	ab a7       	std	Y+43, r26	; 0x2b
    1ed0:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    1ed2:	69 a5       	ldd	r22, Y+41	; 0x29
    1ed4:	7a a5       	ldd	r23, Y+42	; 0x2a
    1ed6:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ed8:	9c a5       	ldd	r25, Y+44	; 0x2c
    1eda:	20 e0       	ldi	r18, 0x00	; 0
    1edc:	30 e0       	ldi	r19, 0x00	; 0
    1ede:	40 e8       	ldi	r20, 0x80	; 128
    1ee0:	5f e3       	ldi	r21, 0x3F	; 63
    1ee2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1ee6:	88 23       	and	r24, r24
    1ee8:	1c f4       	brge	.+6      	; 0x1ef0 <LCD_voidSendChar+0x8a>
		__ticks = 1;
    1eea:	81 e0       	ldi	r24, 0x01	; 1
    1eec:	88 a7       	std	Y+40, r24	; 0x28
    1eee:	91 c0       	rjmp	.+290    	; 0x2012 <LCD_voidSendChar+0x1ac>
	else if (__tmp > 255)
    1ef0:	69 a5       	ldd	r22, Y+41	; 0x29
    1ef2:	7a a5       	ldd	r23, Y+42	; 0x2a
    1ef4:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ef6:	9c a5       	ldd	r25, Y+44	; 0x2c
    1ef8:	20 e0       	ldi	r18, 0x00	; 0
    1efa:	30 e0       	ldi	r19, 0x00	; 0
    1efc:	4f e7       	ldi	r20, 0x7F	; 127
    1efe:	53 e4       	ldi	r21, 0x43	; 67
    1f00:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1f04:	18 16       	cp	r1, r24
    1f06:	0c f0       	brlt	.+2      	; 0x1f0a <LCD_voidSendChar+0xa4>
    1f08:	7b c0       	rjmp	.+246    	; 0x2000 <LCD_voidSendChar+0x19a>
	{
		_delay_ms(__us / 1000.0);
    1f0a:	6d a5       	ldd	r22, Y+45	; 0x2d
    1f0c:	7e a5       	ldd	r23, Y+46	; 0x2e
    1f0e:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f10:	98 a9       	ldd	r25, Y+48	; 0x30
    1f12:	20 e0       	ldi	r18, 0x00	; 0
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	4a e7       	ldi	r20, 0x7A	; 122
    1f18:	54 e4       	ldi	r21, 0x44	; 68
    1f1a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1f1e:	dc 01       	movw	r26, r24
    1f20:	cb 01       	movw	r24, r22
    1f22:	8c a3       	std	Y+36, r24	; 0x24
    1f24:	9d a3       	std	Y+37, r25	; 0x25
    1f26:	ae a3       	std	Y+38, r26	; 0x26
    1f28:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f2a:	6c a1       	ldd	r22, Y+36	; 0x24
    1f2c:	7d a1       	ldd	r23, Y+37	; 0x25
    1f2e:	8e a1       	ldd	r24, Y+38	; 0x26
    1f30:	9f a1       	ldd	r25, Y+39	; 0x27
    1f32:	20 e0       	ldi	r18, 0x00	; 0
    1f34:	30 e0       	ldi	r19, 0x00	; 0
    1f36:	4a ef       	ldi	r20, 0xFA	; 250
    1f38:	54 e4       	ldi	r21, 0x44	; 68
    1f3a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f3e:	dc 01       	movw	r26, r24
    1f40:	cb 01       	movw	r24, r22
    1f42:	88 a3       	std	Y+32, r24	; 0x20
    1f44:	99 a3       	std	Y+33, r25	; 0x21
    1f46:	aa a3       	std	Y+34, r26	; 0x22
    1f48:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    1f4a:	68 a1       	ldd	r22, Y+32	; 0x20
    1f4c:	79 a1       	ldd	r23, Y+33	; 0x21
    1f4e:	8a a1       	ldd	r24, Y+34	; 0x22
    1f50:	9b a1       	ldd	r25, Y+35	; 0x23
    1f52:	20 e0       	ldi	r18, 0x00	; 0
    1f54:	30 e0       	ldi	r19, 0x00	; 0
    1f56:	40 e8       	ldi	r20, 0x80	; 128
    1f58:	5f e3       	ldi	r21, 0x3F	; 63
    1f5a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1f5e:	88 23       	and	r24, r24
    1f60:	2c f4       	brge	.+10     	; 0x1f6c <LCD_voidSendChar+0x106>
		__ticks = 1;
    1f62:	81 e0       	ldi	r24, 0x01	; 1
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    1f66:	9f 8f       	std	Y+31, r25	; 0x1f
    1f68:	8e 8f       	std	Y+30, r24	; 0x1e
    1f6a:	3f c0       	rjmp	.+126    	; 0x1fea <LCD_voidSendChar+0x184>
	else if (__tmp > 65535)
    1f6c:	68 a1       	ldd	r22, Y+32	; 0x20
    1f6e:	79 a1       	ldd	r23, Y+33	; 0x21
    1f70:	8a a1       	ldd	r24, Y+34	; 0x22
    1f72:	9b a1       	ldd	r25, Y+35	; 0x23
    1f74:	20 e0       	ldi	r18, 0x00	; 0
    1f76:	3f ef       	ldi	r19, 0xFF	; 255
    1f78:	4f e7       	ldi	r20, 0x7F	; 127
    1f7a:	57 e4       	ldi	r21, 0x47	; 71
    1f7c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1f80:	18 16       	cp	r1, r24
    1f82:	4c f5       	brge	.+82     	; 0x1fd6 <LCD_voidSendChar+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f84:	6c a1       	ldd	r22, Y+36	; 0x24
    1f86:	7d a1       	ldd	r23, Y+37	; 0x25
    1f88:	8e a1       	ldd	r24, Y+38	; 0x26
    1f8a:	9f a1       	ldd	r25, Y+39	; 0x27
    1f8c:	20 e0       	ldi	r18, 0x00	; 0
    1f8e:	30 e0       	ldi	r19, 0x00	; 0
    1f90:	40 e2       	ldi	r20, 0x20	; 32
    1f92:	51 e4       	ldi	r21, 0x41	; 65
    1f94:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f98:	dc 01       	movw	r26, r24
    1f9a:	cb 01       	movw	r24, r22
    1f9c:	bc 01       	movw	r22, r24
    1f9e:	cd 01       	movw	r24, r26
    1fa0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fa4:	dc 01       	movw	r26, r24
    1fa6:	cb 01       	movw	r24, r22
    1fa8:	9f 8f       	std	Y+31, r25	; 0x1f
    1faa:	8e 8f       	std	Y+30, r24	; 0x1e
    1fac:	0f c0       	rjmp	.+30     	; 0x1fcc <LCD_voidSendChar+0x166>
    1fae:	88 ec       	ldi	r24, 0xC8	; 200
    1fb0:	90 e0       	ldi	r25, 0x00	; 0
    1fb2:	9d 8f       	std	Y+29, r25	; 0x1d
    1fb4:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1fb6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1fb8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1fba:	01 97       	sbiw	r24, 0x01	; 1
    1fbc:	f1 f7       	brne	.-4      	; 0x1fba <LCD_voidSendChar+0x154>
    1fbe:	9d 8f       	std	Y+29, r25	; 0x1d
    1fc0:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1fc2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fc4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1fc6:	01 97       	sbiw	r24, 0x01	; 1
    1fc8:	9f 8f       	std	Y+31, r25	; 0x1f
    1fca:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1fcc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fce:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1fd0:	00 97       	sbiw	r24, 0x00	; 0
    1fd2:	69 f7       	brne	.-38     	; 0x1fae <LCD_voidSendChar+0x148>
    1fd4:	24 c0       	rjmp	.+72     	; 0x201e <LCD_voidSendChar+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1fd6:	68 a1       	ldd	r22, Y+32	; 0x20
    1fd8:	79 a1       	ldd	r23, Y+33	; 0x21
    1fda:	8a a1       	ldd	r24, Y+34	; 0x22
    1fdc:	9b a1       	ldd	r25, Y+35	; 0x23
    1fde:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fe2:	dc 01       	movw	r26, r24
    1fe4:	cb 01       	movw	r24, r22
    1fe6:	9f 8f       	std	Y+31, r25	; 0x1f
    1fe8:	8e 8f       	std	Y+30, r24	; 0x1e
    1fea:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fec:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1fee:	9b 8f       	std	Y+27, r25	; 0x1b
    1ff0:	8a 8f       	std	Y+26, r24	; 0x1a
    1ff2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ff4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1ff6:	01 97       	sbiw	r24, 0x01	; 1
    1ff8:	f1 f7       	brne	.-4      	; 0x1ff6 <LCD_voidSendChar+0x190>
    1ffa:	9b 8f       	std	Y+27, r25	; 0x1b
    1ffc:	8a 8f       	std	Y+26, r24	; 0x1a
    1ffe:	0f c0       	rjmp	.+30     	; 0x201e <LCD_voidSendChar+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2000:	69 a5       	ldd	r22, Y+41	; 0x29
    2002:	7a a5       	ldd	r23, Y+42	; 0x2a
    2004:	8b a5       	ldd	r24, Y+43	; 0x2b
    2006:	9c a5       	ldd	r25, Y+44	; 0x2c
    2008:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    200c:	dc 01       	movw	r26, r24
    200e:	cb 01       	movw	r24, r22
    2010:	88 a7       	std	Y+40, r24	; 0x28
    2012:	88 a5       	ldd	r24, Y+40	; 0x28
    2014:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2016:	89 8d       	ldd	r24, Y+25	; 0x19
    2018:	8a 95       	dec	r24
    201a:	f1 f7       	brne	.-4      	; 0x2018 <LCD_voidSendChar+0x1b2>
    201c:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1); //wait tw = 230 ns
	/* Step 5: E = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
    201e:	80 e0       	ldi	r24, 0x00	; 0
    2020:	62 e0       	ldi	r22, 0x02	; 2
    2022:	40 e0       	ldi	r20, 0x00	; 0
    2024:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
    2028:	80 e0       	ldi	r24, 0x00	; 0
    202a:	90 e0       	ldi	r25, 0x00	; 0
    202c:	a0 e8       	ldi	r26, 0x80	; 128
    202e:	bf e3       	ldi	r27, 0x3F	; 63
    2030:	8d 8b       	std	Y+21, r24	; 0x15
    2032:	9e 8b       	std	Y+22, r25	; 0x16
    2034:	af 8b       	std	Y+23, r26	; 0x17
    2036:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2038:	6d 89       	ldd	r22, Y+21	; 0x15
    203a:	7e 89       	ldd	r23, Y+22	; 0x16
    203c:	8f 89       	ldd	r24, Y+23	; 0x17
    203e:	98 8d       	ldd	r25, Y+24	; 0x18
    2040:	2b ea       	ldi	r18, 0xAB	; 171
    2042:	3a ea       	ldi	r19, 0xAA	; 170
    2044:	4a e2       	ldi	r20, 0x2A	; 42
    2046:	50 e4       	ldi	r21, 0x40	; 64
    2048:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    204c:	dc 01       	movw	r26, r24
    204e:	cb 01       	movw	r24, r22
    2050:	89 8b       	std	Y+17, r24	; 0x11
    2052:	9a 8b       	std	Y+18, r25	; 0x12
    2054:	ab 8b       	std	Y+19, r26	; 0x13
    2056:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    2058:	69 89       	ldd	r22, Y+17	; 0x11
    205a:	7a 89       	ldd	r23, Y+18	; 0x12
    205c:	8b 89       	ldd	r24, Y+19	; 0x13
    205e:	9c 89       	ldd	r25, Y+20	; 0x14
    2060:	20 e0       	ldi	r18, 0x00	; 0
    2062:	30 e0       	ldi	r19, 0x00	; 0
    2064:	40 e8       	ldi	r20, 0x80	; 128
    2066:	5f e3       	ldi	r21, 0x3F	; 63
    2068:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    206c:	88 23       	and	r24, r24
    206e:	1c f4       	brge	.+6      	; 0x2076 <LCD_voidSendChar+0x210>
		__ticks = 1;
    2070:	81 e0       	ldi	r24, 0x01	; 1
    2072:	88 8b       	std	Y+16, r24	; 0x10
    2074:	91 c0       	rjmp	.+290    	; 0x2198 <LCD_voidSendChar+0x332>
	else if (__tmp > 255)
    2076:	69 89       	ldd	r22, Y+17	; 0x11
    2078:	7a 89       	ldd	r23, Y+18	; 0x12
    207a:	8b 89       	ldd	r24, Y+19	; 0x13
    207c:	9c 89       	ldd	r25, Y+20	; 0x14
    207e:	20 e0       	ldi	r18, 0x00	; 0
    2080:	30 e0       	ldi	r19, 0x00	; 0
    2082:	4f e7       	ldi	r20, 0x7F	; 127
    2084:	53 e4       	ldi	r21, 0x43	; 67
    2086:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    208a:	18 16       	cp	r1, r24
    208c:	0c f0       	brlt	.+2      	; 0x2090 <LCD_voidSendChar+0x22a>
    208e:	7b c0       	rjmp	.+246    	; 0x2186 <LCD_voidSendChar+0x320>
	{
		_delay_ms(__us / 1000.0);
    2090:	6d 89       	ldd	r22, Y+21	; 0x15
    2092:	7e 89       	ldd	r23, Y+22	; 0x16
    2094:	8f 89       	ldd	r24, Y+23	; 0x17
    2096:	98 8d       	ldd	r25, Y+24	; 0x18
    2098:	20 e0       	ldi	r18, 0x00	; 0
    209a:	30 e0       	ldi	r19, 0x00	; 0
    209c:	4a e7       	ldi	r20, 0x7A	; 122
    209e:	54 e4       	ldi	r21, 0x44	; 68
    20a0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    20a4:	dc 01       	movw	r26, r24
    20a6:	cb 01       	movw	r24, r22
    20a8:	8c 87       	std	Y+12, r24	; 0x0c
    20aa:	9d 87       	std	Y+13, r25	; 0x0d
    20ac:	ae 87       	std	Y+14, r26	; 0x0e
    20ae:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    20b0:	6c 85       	ldd	r22, Y+12	; 0x0c
    20b2:	7d 85       	ldd	r23, Y+13	; 0x0d
    20b4:	8e 85       	ldd	r24, Y+14	; 0x0e
    20b6:	9f 85       	ldd	r25, Y+15	; 0x0f
    20b8:	20 e0       	ldi	r18, 0x00	; 0
    20ba:	30 e0       	ldi	r19, 0x00	; 0
    20bc:	4a ef       	ldi	r20, 0xFA	; 250
    20be:	54 e4       	ldi	r21, 0x44	; 68
    20c0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20c4:	dc 01       	movw	r26, r24
    20c6:	cb 01       	movw	r24, r22
    20c8:	88 87       	std	Y+8, r24	; 0x08
    20ca:	99 87       	std	Y+9, r25	; 0x09
    20cc:	aa 87       	std	Y+10, r26	; 0x0a
    20ce:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    20d0:	68 85       	ldd	r22, Y+8	; 0x08
    20d2:	79 85       	ldd	r23, Y+9	; 0x09
    20d4:	8a 85       	ldd	r24, Y+10	; 0x0a
    20d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    20d8:	20 e0       	ldi	r18, 0x00	; 0
    20da:	30 e0       	ldi	r19, 0x00	; 0
    20dc:	40 e8       	ldi	r20, 0x80	; 128
    20de:	5f e3       	ldi	r21, 0x3F	; 63
    20e0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    20e4:	88 23       	and	r24, r24
    20e6:	2c f4       	brge	.+10     	; 0x20f2 <LCD_voidSendChar+0x28c>
		__ticks = 1;
    20e8:	81 e0       	ldi	r24, 0x01	; 1
    20ea:	90 e0       	ldi	r25, 0x00	; 0
    20ec:	9f 83       	std	Y+7, r25	; 0x07
    20ee:	8e 83       	std	Y+6, r24	; 0x06
    20f0:	3f c0       	rjmp	.+126    	; 0x2170 <LCD_voidSendChar+0x30a>
	else if (__tmp > 65535)
    20f2:	68 85       	ldd	r22, Y+8	; 0x08
    20f4:	79 85       	ldd	r23, Y+9	; 0x09
    20f6:	8a 85       	ldd	r24, Y+10	; 0x0a
    20f8:	9b 85       	ldd	r25, Y+11	; 0x0b
    20fa:	20 e0       	ldi	r18, 0x00	; 0
    20fc:	3f ef       	ldi	r19, 0xFF	; 255
    20fe:	4f e7       	ldi	r20, 0x7F	; 127
    2100:	57 e4       	ldi	r21, 0x47	; 71
    2102:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2106:	18 16       	cp	r1, r24
    2108:	4c f5       	brge	.+82     	; 0x215c <LCD_voidSendChar+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    210a:	6c 85       	ldd	r22, Y+12	; 0x0c
    210c:	7d 85       	ldd	r23, Y+13	; 0x0d
    210e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2110:	9f 85       	ldd	r25, Y+15	; 0x0f
    2112:	20 e0       	ldi	r18, 0x00	; 0
    2114:	30 e0       	ldi	r19, 0x00	; 0
    2116:	40 e2       	ldi	r20, 0x20	; 32
    2118:	51 e4       	ldi	r21, 0x41	; 65
    211a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    211e:	dc 01       	movw	r26, r24
    2120:	cb 01       	movw	r24, r22
    2122:	bc 01       	movw	r22, r24
    2124:	cd 01       	movw	r24, r26
    2126:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    212a:	dc 01       	movw	r26, r24
    212c:	cb 01       	movw	r24, r22
    212e:	9f 83       	std	Y+7, r25	; 0x07
    2130:	8e 83       	std	Y+6, r24	; 0x06
    2132:	0f c0       	rjmp	.+30     	; 0x2152 <LCD_voidSendChar+0x2ec>
    2134:	88 ec       	ldi	r24, 0xC8	; 200
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	9d 83       	std	Y+5, r25	; 0x05
    213a:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    213c:	8c 81       	ldd	r24, Y+4	; 0x04
    213e:	9d 81       	ldd	r25, Y+5	; 0x05
    2140:	01 97       	sbiw	r24, 0x01	; 1
    2142:	f1 f7       	brne	.-4      	; 0x2140 <LCD_voidSendChar+0x2da>
    2144:	9d 83       	std	Y+5, r25	; 0x05
    2146:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2148:	8e 81       	ldd	r24, Y+6	; 0x06
    214a:	9f 81       	ldd	r25, Y+7	; 0x07
    214c:	01 97       	sbiw	r24, 0x01	; 1
    214e:	9f 83       	std	Y+7, r25	; 0x07
    2150:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2152:	8e 81       	ldd	r24, Y+6	; 0x06
    2154:	9f 81       	ldd	r25, Y+7	; 0x07
    2156:	00 97       	sbiw	r24, 0x00	; 0
    2158:	69 f7       	brne	.-38     	; 0x2134 <LCD_voidSendChar+0x2ce>
    215a:	24 c0       	rjmp	.+72     	; 0x21a4 <LCD_voidSendChar+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    215c:	68 85       	ldd	r22, Y+8	; 0x08
    215e:	79 85       	ldd	r23, Y+9	; 0x09
    2160:	8a 85       	ldd	r24, Y+10	; 0x0a
    2162:	9b 85       	ldd	r25, Y+11	; 0x0b
    2164:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2168:	dc 01       	movw	r26, r24
    216a:	cb 01       	movw	r24, r22
    216c:	9f 83       	std	Y+7, r25	; 0x07
    216e:	8e 83       	std	Y+6, r24	; 0x06
    2170:	8e 81       	ldd	r24, Y+6	; 0x06
    2172:	9f 81       	ldd	r25, Y+7	; 0x07
    2174:	9b 83       	std	Y+3, r25	; 0x03
    2176:	8a 83       	std	Y+2, r24	; 0x02
    2178:	8a 81       	ldd	r24, Y+2	; 0x02
    217a:	9b 81       	ldd	r25, Y+3	; 0x03
    217c:	01 97       	sbiw	r24, 0x01	; 1
    217e:	f1 f7       	brne	.-4      	; 0x217c <LCD_voidSendChar+0x316>
    2180:	9b 83       	std	Y+3, r25	; 0x03
    2182:	8a 83       	std	Y+2, r24	; 0x02
    2184:	0f c0       	rjmp	.+30     	; 0x21a4 <LCD_voidSendChar+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2186:	69 89       	ldd	r22, Y+17	; 0x11
    2188:	7a 89       	ldd	r23, Y+18	; 0x12
    218a:	8b 89       	ldd	r24, Y+19	; 0x13
    218c:	9c 89       	ldd	r25, Y+20	; 0x14
    218e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2192:	dc 01       	movw	r26, r24
    2194:	cb 01       	movw	r24, r22
    2196:	88 8b       	std	Y+16, r24	; 0x10
    2198:	88 89       	ldd	r24, Y+16	; 0x10
    219a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    219c:	89 81       	ldd	r24, Y+1	; 0x01
    219e:	8a 95       	dec	r24
    21a0:	f1 f7       	brne	.-4      	; 0x219e <LCD_voidSendChar+0x338>
    21a2:	89 83       	std	Y+1, r24	; 0x01
	/* Step 8: E = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
	_delay_us(1); // wait tc = 500ns (not important because 1 us in step 4 is enough because >>> 230ns )

#endif
}
    21a4:	e1 96       	adiw	r28, 0x31	; 49
    21a6:	0f b6       	in	r0, 0x3f	; 63
    21a8:	f8 94       	cli
    21aa:	de bf       	out	0x3e, r29	; 62
    21ac:	0f be       	out	0x3f, r0	; 63
    21ae:	cd bf       	out	0x3d, r28	; 61
    21b0:	cf 91       	pop	r28
    21b2:	df 91       	pop	r29
    21b4:	08 95       	ret

000021b6 <LCD_voidWriteString>:

void LCD_voidWriteString(u8* Copy_pu8String)
{
    21b6:	df 93       	push	r29
    21b8:	cf 93       	push	r28
    21ba:	00 d0       	rcall	.+0      	; 0x21bc <LCD_voidWriteString+0x6>
    21bc:	cd b7       	in	r28, 0x3d	; 61
    21be:	de b7       	in	r29, 0x3e	; 62
    21c0:	9a 83       	std	Y+2, r25	; 0x02
    21c2:	89 83       	std	Y+1, r24	; 0x01
    21c4:	0a c0       	rjmp	.+20     	; 0x21da <LCD_voidWriteString+0x24>
	// Iterate through the string until the null terminator ('\0') is encountered
	while(*Copy_pu8String != '\0')
	{
		// Send each character of the string to the LCD
		LCD_voidSendChar(*Copy_pu8String);
    21c6:	e9 81       	ldd	r30, Y+1	; 0x01
    21c8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ca:	80 81       	ld	r24, Z
    21cc:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
		// Move to the next character in the string
		Copy_pu8String++;
    21d0:	89 81       	ldd	r24, Y+1	; 0x01
    21d2:	9a 81       	ldd	r25, Y+2	; 0x02
    21d4:	01 96       	adiw	r24, 0x01	; 1
    21d6:	9a 83       	std	Y+2, r25	; 0x02
    21d8:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_voidWriteString(u8* Copy_pu8String)
{
	// Iterate through the string until the null terminator ('\0') is encountered
	while(*Copy_pu8String != '\0')
    21da:	e9 81       	ldd	r30, Y+1	; 0x01
    21dc:	fa 81       	ldd	r31, Y+2	; 0x02
    21de:	80 81       	ld	r24, Z
    21e0:	88 23       	and	r24, r24
    21e2:	89 f7       	brne	.-30     	; 0x21c6 <LCD_voidWriteString+0x10>
		// Send each character of the string to the LCD
		LCD_voidSendChar(*Copy_pu8String);
		// Move to the next character in the string
		Copy_pu8String++;
	}
}
    21e4:	0f 90       	pop	r0
    21e6:	0f 90       	pop	r0
    21e8:	cf 91       	pop	r28
    21ea:	df 91       	pop	r29
    21ec:	08 95       	ret

000021ee <LCD_voidWriteNumber>:

void LCD_voidWriteNumber(u32 Copy_u32Number)
{
    21ee:	0f 93       	push	r16
    21f0:	1f 93       	push	r17
    21f2:	df 93       	push	r29
    21f4:	cf 93       	push	r28
    21f6:	cd b7       	in	r28, 0x3d	; 61
    21f8:	de b7       	in	r29, 0x3e	; 62
    21fa:	65 97       	sbiw	r28, 0x15	; 21
    21fc:	0f b6       	in	r0, 0x3f	; 63
    21fe:	f8 94       	cli
    2200:	de bf       	out	0x3e, r29	; 62
    2202:	0f be       	out	0x3f, r0	; 63
    2204:	cd bf       	out	0x3d, r28	; 61
    2206:	6a 8b       	std	Y+18, r22	; 0x12
    2208:	7b 8b       	std	Y+19, r23	; 0x13
    220a:	8c 8b       	std	Y+20, r24	; 0x14
    220c:	9d 8b       	std	Y+21, r25	; 0x15
	// Temporary array to store digits of the number
	u8 digits[15];
	// Index to keep track of the current digit position
	s8 index = -1; // Start from -1 to accommodate numbers with zero
    220e:	8f ef       	ldi	r24, 0xFF	; 255
    2210:	8a 83       	std	Y+2, r24	; 0x02
	s8 i;
	// Special case for handling zero separately
	if (Copy_u32Number == 0)
    2212:	8a 89       	ldd	r24, Y+18	; 0x12
    2214:	9b 89       	ldd	r25, Y+19	; 0x13
    2216:	ac 89       	ldd	r26, Y+20	; 0x14
    2218:	bd 89       	ldd	r27, Y+21	; 0x15
    221a:	00 97       	sbiw	r24, 0x00	; 0
    221c:	a1 05       	cpc	r26, r1
    221e:	b1 05       	cpc	r27, r1
    2220:	99 f5       	brne	.+102    	; 0x2288 <LCD_voidWriteNumber+0x9a>
    {
        LCD_voidSendChar('0');
    2222:	80 e3       	ldi	r24, 0x30	; 48
    2224:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    2228:	4e c0       	rjmp	.+156    	; 0x22c6 <LCD_voidWriteNumber+0xd8>
        return;
    }
    // Extract each digit of the number and store in the temporary array
    while(Copy_u32Number > 0)
    {
    	index++;
    222a:	8a 81       	ldd	r24, Y+2	; 0x02
    222c:	8f 5f       	subi	r24, 0xFF	; 255
    222e:	8a 83       	std	Y+2, r24	; 0x02
    	digits[index] = Copy_u32Number % 10; // Extract the last digit
    2230:	8a 81       	ldd	r24, Y+2	; 0x02
    2232:	08 2f       	mov	r16, r24
    2234:	11 27       	eor	r17, r17
    2236:	07 fd       	sbrc	r16, 7
    2238:	10 95       	com	r17
    223a:	8a 89       	ldd	r24, Y+18	; 0x12
    223c:	9b 89       	ldd	r25, Y+19	; 0x13
    223e:	ac 89       	ldd	r26, Y+20	; 0x14
    2240:	bd 89       	ldd	r27, Y+21	; 0x15
    2242:	2a e0       	ldi	r18, 0x0A	; 10
    2244:	30 e0       	ldi	r19, 0x00	; 0
    2246:	40 e0       	ldi	r20, 0x00	; 0
    2248:	50 e0       	ldi	r21, 0x00	; 0
    224a:	bc 01       	movw	r22, r24
    224c:	cd 01       	movw	r24, r26
    224e:	0e 94 00 35 	call	0x6a00	; 0x6a00 <__udivmodsi4>
    2252:	dc 01       	movw	r26, r24
    2254:	cb 01       	movw	r24, r22
    2256:	28 2f       	mov	r18, r24
    2258:	ce 01       	movw	r24, r28
    225a:	03 96       	adiw	r24, 0x03	; 3
    225c:	fc 01       	movw	r30, r24
    225e:	e0 0f       	add	r30, r16
    2260:	f1 1f       	adc	r31, r17
    2262:	20 83       	st	Z, r18
    	Copy_u32Number /= 10; // Move to the next digit
    2264:	8a 89       	ldd	r24, Y+18	; 0x12
    2266:	9b 89       	ldd	r25, Y+19	; 0x13
    2268:	ac 89       	ldd	r26, Y+20	; 0x14
    226a:	bd 89       	ldd	r27, Y+21	; 0x15
    226c:	2a e0       	ldi	r18, 0x0A	; 10
    226e:	30 e0       	ldi	r19, 0x00	; 0
    2270:	40 e0       	ldi	r20, 0x00	; 0
    2272:	50 e0       	ldi	r21, 0x00	; 0
    2274:	bc 01       	movw	r22, r24
    2276:	cd 01       	movw	r24, r26
    2278:	0e 94 00 35 	call	0x6a00	; 0x6a00 <__udivmodsi4>
    227c:	da 01       	movw	r26, r20
    227e:	c9 01       	movw	r24, r18
    2280:	8a 8b       	std	Y+18, r24	; 0x12
    2282:	9b 8b       	std	Y+19, r25	; 0x13
    2284:	ac 8b       	std	Y+20, r26	; 0x14
    2286:	bd 8b       	std	Y+21, r27	; 0x15
    {
        LCD_voidSendChar('0');
        return;
    }
    // Extract each digit of the number and store in the temporary array
    while(Copy_u32Number > 0)
    2288:	8a 89       	ldd	r24, Y+18	; 0x12
    228a:	9b 89       	ldd	r25, Y+19	; 0x13
    228c:	ac 89       	ldd	r26, Y+20	; 0x14
    228e:	bd 89       	ldd	r27, Y+21	; 0x15
    2290:	00 97       	sbiw	r24, 0x00	; 0
    2292:	a1 05       	cpc	r26, r1
    2294:	b1 05       	cpc	r27, r1
    2296:	49 f6       	brne	.-110    	; 0x222a <LCD_voidWriteNumber+0x3c>
    	digits[index] = Copy_u32Number % 10; // Extract the last digit
    	Copy_u32Number /= 10; // Move to the next digit
    }

    // Write the digits to the LCD in reverse order
    for (i = index; i >= 0; i--)
    2298:	8a 81       	ldd	r24, Y+2	; 0x02
    229a:	89 83       	std	Y+1, r24	; 0x01
    229c:	11 c0       	rjmp	.+34     	; 0x22c0 <LCD_voidWriteNumber+0xd2>
    {
    	// Convert digit to character and send to LCD
    	LCD_voidSendChar(digits[i] +'0');
    229e:	89 81       	ldd	r24, Y+1	; 0x01
    22a0:	28 2f       	mov	r18, r24
    22a2:	33 27       	eor	r19, r19
    22a4:	27 fd       	sbrc	r18, 7
    22a6:	30 95       	com	r19
    22a8:	ce 01       	movw	r24, r28
    22aa:	03 96       	adiw	r24, 0x03	; 3
    22ac:	fc 01       	movw	r30, r24
    22ae:	e2 0f       	add	r30, r18
    22b0:	f3 1f       	adc	r31, r19
    22b2:	80 81       	ld	r24, Z
    22b4:	80 5d       	subi	r24, 0xD0	; 208
    22b6:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    	digits[index] = Copy_u32Number % 10; // Extract the last digit
    	Copy_u32Number /= 10; // Move to the next digit
    }

    // Write the digits to the LCD in reverse order
    for (i = index; i >= 0; i--)
    22ba:	89 81       	ldd	r24, Y+1	; 0x01
    22bc:	81 50       	subi	r24, 0x01	; 1
    22be:	89 83       	std	Y+1, r24	; 0x01
    22c0:	89 81       	ldd	r24, Y+1	; 0x01
    22c2:	88 23       	and	r24, r24
    22c4:	64 f7       	brge	.-40     	; 0x229e <LCD_voidWriteNumber+0xb0>
    {
    	// Convert digit to character and send to LCD
    	LCD_voidSendChar(digits[i] +'0');
    }

}
    22c6:	65 96       	adiw	r28, 0x15	; 21
    22c8:	0f b6       	in	r0, 0x3f	; 63
    22ca:	f8 94       	cli
    22cc:	de bf       	out	0x3e, r29	; 62
    22ce:	0f be       	out	0x3f, r0	; 63
    22d0:	cd bf       	out	0x3d, r28	; 61
    22d2:	cf 91       	pop	r28
    22d4:	df 91       	pop	r29
    22d6:	1f 91       	pop	r17
    22d8:	0f 91       	pop	r16
    22da:	08 95       	ret

000022dc <LCD_u8GoToXY>:
u8 LCD_u8GoToXY(u8 Copy_u8LineNum, u8 Copy_u8Location)
{
    22dc:	df 93       	push	r29
    22de:	cf 93       	push	r28
    22e0:	00 d0       	rcall	.+0      	; 0x22e2 <LCD_u8GoToXY+0x6>
    22e2:	00 d0       	rcall	.+0      	; 0x22e4 <LCD_u8GoToXY+0x8>
    22e4:	0f 92       	push	r0
    22e6:	cd b7       	in	r28, 0x3d	; 61
    22e8:	de b7       	in	r29, 0x3e	; 62
    22ea:	8a 83       	std	Y+2, r24	; 0x02
    22ec:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
    22ee:	81 e0       	ldi	r24, 0x01	; 1
    22f0:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8Location <= 39)
    22f2:	8b 81       	ldd	r24, Y+3	; 0x03
    22f4:	88 32       	cpi	r24, 0x28	; 40
    22f6:	d8 f4       	brcc	.+54     	; 0x232e <LCD_u8GoToXY+0x52>
	{
		switch(Copy_u8LineNum)
    22f8:	8a 81       	ldd	r24, Y+2	; 0x02
    22fa:	28 2f       	mov	r18, r24
    22fc:	30 e0       	ldi	r19, 0x00	; 0
    22fe:	3d 83       	std	Y+5, r19	; 0x05
    2300:	2c 83       	std	Y+4, r18	; 0x04
    2302:	8c 81       	ldd	r24, Y+4	; 0x04
    2304:	9d 81       	ldd	r25, Y+5	; 0x05
    2306:	81 30       	cpi	r24, 0x01	; 1
    2308:	91 05       	cpc	r25, r1
    230a:	31 f0       	breq	.+12     	; 0x2318 <LCD_u8GoToXY+0x3c>
    230c:	2c 81       	ldd	r18, Y+4	; 0x04
    230e:	3d 81       	ldd	r19, Y+5	; 0x05
    2310:	22 30       	cpi	r18, 0x02	; 2
    2312:	31 05       	cpc	r19, r1
    2314:	31 f0       	breq	.+12     	; 0x2322 <LCD_u8GoToXY+0x46>
    2316:	0a c0       	rjmp	.+20     	; 0x232c <LCD_u8GoToXY+0x50>
		{
			case LCD_u8_LINE1:LCD_voidSendCmnd(LCD_u8_FIRSTLINE_ADDRESS + Copy_u8Location);break;
    2318:	8b 81       	ldd	r24, Y+3	; 0x03
    231a:	80 58       	subi	r24, 0x80	; 128
    231c:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
    2320:	06 c0       	rjmp	.+12     	; 0x232e <LCD_u8GoToXY+0x52>
			case LCD_u8_LINE2:LCD_voidSendCmnd(LCD_u8_SECONDLINE_ADDRESS + Copy_u8Location);break;
    2322:	8b 81       	ldd	r24, Y+3	; 0x03
    2324:	80 54       	subi	r24, 0x40	; 64
    2326:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
    232a:	01 c0       	rjmp	.+2      	; 0x232e <LCD_u8GoToXY+0x52>
			default:Local_u8ErrorState = STD_TYPES_NOK;
    232c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	return Local_u8ErrorState;
    232e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2330:	0f 90       	pop	r0
    2332:	0f 90       	pop	r0
    2334:	0f 90       	pop	r0
    2336:	0f 90       	pop	r0
    2338:	0f 90       	pop	r0
    233a:	cf 91       	pop	r28
    233c:	df 91       	pop	r29
    233e:	08 95       	ret

00002340 <LCD_voidClearScreen>:
void LCD_voidClearScreen(void)
{
    2340:	df 93       	push	r29
    2342:	cf 93       	push	r28
    2344:	cd b7       	in	r28, 0x3d	; 61
    2346:	de b7       	in	r29, 0x3e	; 62
    2348:	2e 97       	sbiw	r28, 0x0e	; 14
    234a:	0f b6       	in	r0, 0x3f	; 63
    234c:	f8 94       	cli
    234e:	de bf       	out	0x3e, r29	; 62
    2350:	0f be       	out	0x3f, r0	; 63
    2352:	cd bf       	out	0x3d, r28	; 61
	LCD_voidSendCmnd(LCD_u8_DISPLAY_CLEAR_CMND);
    2354:	81 e0       	ldi	r24, 0x01	; 1
    2356:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
    235a:	80 e0       	ldi	r24, 0x00	; 0
    235c:	90 e0       	ldi	r25, 0x00	; 0
    235e:	a0 ea       	ldi	r26, 0xA0	; 160
    2360:	b1 e4       	ldi	r27, 0x41	; 65
    2362:	8b 87       	std	Y+11, r24	; 0x0b
    2364:	9c 87       	std	Y+12, r25	; 0x0c
    2366:	ad 87       	std	Y+13, r26	; 0x0d
    2368:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    236a:	6b 85       	ldd	r22, Y+11	; 0x0b
    236c:	7c 85       	ldd	r23, Y+12	; 0x0c
    236e:	8d 85       	ldd	r24, Y+13	; 0x0d
    2370:	9e 85       	ldd	r25, Y+14	; 0x0e
    2372:	20 e0       	ldi	r18, 0x00	; 0
    2374:	30 e0       	ldi	r19, 0x00	; 0
    2376:	4a ef       	ldi	r20, 0xFA	; 250
    2378:	54 e4       	ldi	r21, 0x44	; 68
    237a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    237e:	dc 01       	movw	r26, r24
    2380:	cb 01       	movw	r24, r22
    2382:	8f 83       	std	Y+7, r24	; 0x07
    2384:	98 87       	std	Y+8, r25	; 0x08
    2386:	a9 87       	std	Y+9, r26	; 0x09
    2388:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    238a:	6f 81       	ldd	r22, Y+7	; 0x07
    238c:	78 85       	ldd	r23, Y+8	; 0x08
    238e:	89 85       	ldd	r24, Y+9	; 0x09
    2390:	9a 85       	ldd	r25, Y+10	; 0x0a
    2392:	20 e0       	ldi	r18, 0x00	; 0
    2394:	30 e0       	ldi	r19, 0x00	; 0
    2396:	40 e8       	ldi	r20, 0x80	; 128
    2398:	5f e3       	ldi	r21, 0x3F	; 63
    239a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    239e:	88 23       	and	r24, r24
    23a0:	2c f4       	brge	.+10     	; 0x23ac <LCD_voidClearScreen+0x6c>
		__ticks = 1;
    23a2:	81 e0       	ldi	r24, 0x01	; 1
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	9e 83       	std	Y+6, r25	; 0x06
    23a8:	8d 83       	std	Y+5, r24	; 0x05
    23aa:	3f c0       	rjmp	.+126    	; 0x242a <LCD_voidClearScreen+0xea>
	else if (__tmp > 65535)
    23ac:	6f 81       	ldd	r22, Y+7	; 0x07
    23ae:	78 85       	ldd	r23, Y+8	; 0x08
    23b0:	89 85       	ldd	r24, Y+9	; 0x09
    23b2:	9a 85       	ldd	r25, Y+10	; 0x0a
    23b4:	20 e0       	ldi	r18, 0x00	; 0
    23b6:	3f ef       	ldi	r19, 0xFF	; 255
    23b8:	4f e7       	ldi	r20, 0x7F	; 127
    23ba:	57 e4       	ldi	r21, 0x47	; 71
    23bc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    23c0:	18 16       	cp	r1, r24
    23c2:	4c f5       	brge	.+82     	; 0x2416 <LCD_voidClearScreen+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    23c4:	6b 85       	ldd	r22, Y+11	; 0x0b
    23c6:	7c 85       	ldd	r23, Y+12	; 0x0c
    23c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    23ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    23cc:	20 e0       	ldi	r18, 0x00	; 0
    23ce:	30 e0       	ldi	r19, 0x00	; 0
    23d0:	40 e2       	ldi	r20, 0x20	; 32
    23d2:	51 e4       	ldi	r21, 0x41	; 65
    23d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23d8:	dc 01       	movw	r26, r24
    23da:	cb 01       	movw	r24, r22
    23dc:	bc 01       	movw	r22, r24
    23de:	cd 01       	movw	r24, r26
    23e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23e4:	dc 01       	movw	r26, r24
    23e6:	cb 01       	movw	r24, r22
    23e8:	9e 83       	std	Y+6, r25	; 0x06
    23ea:	8d 83       	std	Y+5, r24	; 0x05
    23ec:	0f c0       	rjmp	.+30     	; 0x240c <LCD_voidClearScreen+0xcc>
    23ee:	88 ec       	ldi	r24, 0xC8	; 200
    23f0:	90 e0       	ldi	r25, 0x00	; 0
    23f2:	9c 83       	std	Y+4, r25	; 0x04
    23f4:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    23f6:	8b 81       	ldd	r24, Y+3	; 0x03
    23f8:	9c 81       	ldd	r25, Y+4	; 0x04
    23fa:	01 97       	sbiw	r24, 0x01	; 1
    23fc:	f1 f7       	brne	.-4      	; 0x23fa <LCD_voidClearScreen+0xba>
    23fe:	9c 83       	std	Y+4, r25	; 0x04
    2400:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2402:	8d 81       	ldd	r24, Y+5	; 0x05
    2404:	9e 81       	ldd	r25, Y+6	; 0x06
    2406:	01 97       	sbiw	r24, 0x01	; 1
    2408:	9e 83       	std	Y+6, r25	; 0x06
    240a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    240c:	8d 81       	ldd	r24, Y+5	; 0x05
    240e:	9e 81       	ldd	r25, Y+6	; 0x06
    2410:	00 97       	sbiw	r24, 0x00	; 0
    2412:	69 f7       	brne	.-38     	; 0x23ee <LCD_voidClearScreen+0xae>
    2414:	14 c0       	rjmp	.+40     	; 0x243e <LCD_voidClearScreen+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2416:	6f 81       	ldd	r22, Y+7	; 0x07
    2418:	78 85       	ldd	r23, Y+8	; 0x08
    241a:	89 85       	ldd	r24, Y+9	; 0x09
    241c:	9a 85       	ldd	r25, Y+10	; 0x0a
    241e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2422:	dc 01       	movw	r26, r24
    2424:	cb 01       	movw	r24, r22
    2426:	9e 83       	std	Y+6, r25	; 0x06
    2428:	8d 83       	std	Y+5, r24	; 0x05
    242a:	8d 81       	ldd	r24, Y+5	; 0x05
    242c:	9e 81       	ldd	r25, Y+6	; 0x06
    242e:	9a 83       	std	Y+2, r25	; 0x02
    2430:	89 83       	std	Y+1, r24	; 0x01
    2432:	89 81       	ldd	r24, Y+1	; 0x01
    2434:	9a 81       	ldd	r25, Y+2	; 0x02
    2436:	01 97       	sbiw	r24, 0x01	; 1
    2438:	f1 f7       	brne	.-4      	; 0x2436 <LCD_voidClearScreen+0xf6>
    243a:	9a 83       	std	Y+2, r25	; 0x02
    243c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(20);
}
    243e:	2e 96       	adiw	r28, 0x0e	; 14
    2440:	0f b6       	in	r0, 0x3f	; 63
    2442:	f8 94       	cli
    2444:	de bf       	out	0x3e, r29	; 62
    2446:	0f be       	out	0x3f, r0	; 63
    2448:	cd bf       	out	0x3d, r28	; 61
    244a:	cf 91       	pop	r28
    244c:	df 91       	pop	r29
    244e:	08 95       	ret

00002450 <LCD_voidWriteSpecialChar>:

u8 LCD_voidWriteSpecialChar(u8 Copy_u8CharNum, u8* Copy_pu8Char,u8 Copy_u8LineNum, u8 Copy_u8Location)
{
    2450:	df 93       	push	r29
    2452:	cf 93       	push	r28
    2454:	cd b7       	in	r28, 0x3d	; 61
    2456:	de b7       	in	r29, 0x3e	; 62
    2458:	2a 97       	sbiw	r28, 0x0a	; 10
    245a:	0f b6       	in	r0, 0x3f	; 63
    245c:	f8 94       	cli
    245e:	de bf       	out	0x3e, r29	; 62
    2460:	0f be       	out	0x3f, r0	; 63
    2462:	cd bf       	out	0x3d, r28	; 61
    2464:	8c 83       	std	Y+4, r24	; 0x04
    2466:	7e 83       	std	Y+6, r23	; 0x06
    2468:	6d 83       	std	Y+5, r22	; 0x05
    246a:	4f 83       	std	Y+7, r20	; 0x07
    246c:	28 87       	std	Y+8, r18	; 0x08
	u8 Local_u8ErrorState = STD_TYPES_OK;
    246e:	81 e0       	ldi	r24, 0x01	; 1
    2470:	8b 83       	std	Y+3, r24	; 0x03
	const u8 size = 8;
    2472:	88 e0       	ldi	r24, 0x08	; 8
    2474:	8a 83       	std	Y+2, r24	; 0x02
	u8 i;
	switch(Copy_u8CharNum)
    2476:	8c 81       	ldd	r24, Y+4	; 0x04
    2478:	28 2f       	mov	r18, r24
    247a:	30 e0       	ldi	r19, 0x00	; 0
    247c:	3a 87       	std	Y+10, r19	; 0x0a
    247e:	29 87       	std	Y+9, r18	; 0x09
    2480:	89 85       	ldd	r24, Y+9	; 0x09
    2482:	9a 85       	ldd	r25, Y+10	; 0x0a
    2484:	83 30       	cpi	r24, 0x03	; 3
    2486:	91 05       	cpc	r25, r1
    2488:	09 f4       	brne	.+2      	; 0x248c <LCD_voidWriteSpecialChar+0x3c>
    248a:	8c c0       	rjmp	.+280    	; 0x25a4 <LCD_voidWriteSpecialChar+0x154>
    248c:	29 85       	ldd	r18, Y+9	; 0x09
    248e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2490:	24 30       	cpi	r18, 0x04	; 4
    2492:	31 05       	cpc	r19, r1
    2494:	8c f4       	brge	.+34     	; 0x24b8 <LCD_voidWriteSpecialChar+0x68>
    2496:	89 85       	ldd	r24, Y+9	; 0x09
    2498:	9a 85       	ldd	r25, Y+10	; 0x0a
    249a:	81 30       	cpi	r24, 0x01	; 1
    249c:	91 05       	cpc	r25, r1
    249e:	09 f4       	brne	.+2      	; 0x24a2 <LCD_voidWriteSpecialChar+0x52>
    24a0:	43 c0       	rjmp	.+134    	; 0x2528 <LCD_voidWriteSpecialChar+0xd8>
    24a2:	29 85       	ldd	r18, Y+9	; 0x09
    24a4:	3a 85       	ldd	r19, Y+10	; 0x0a
    24a6:	22 30       	cpi	r18, 0x02	; 2
    24a8:	31 05       	cpc	r19, r1
    24aa:	0c f0       	brlt	.+2      	; 0x24ae <LCD_voidWriteSpecialChar+0x5e>
    24ac:	5c c0       	rjmp	.+184    	; 0x2566 <LCD_voidWriteSpecialChar+0x116>
    24ae:	89 85       	ldd	r24, Y+9	; 0x09
    24b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    24b2:	00 97       	sbiw	r24, 0x00	; 0
    24b4:	d1 f0       	breq	.+52     	; 0x24ea <LCD_voidWriteSpecialChar+0x9a>
    24b6:	11 c1       	rjmp	.+546    	; 0x26da <LCD_voidWriteSpecialChar+0x28a>
    24b8:	29 85       	ldd	r18, Y+9	; 0x09
    24ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    24bc:	25 30       	cpi	r18, 0x05	; 5
    24be:	31 05       	cpc	r19, r1
    24c0:	09 f4       	brne	.+2      	; 0x24c4 <LCD_voidWriteSpecialChar+0x74>
    24c2:	ae c0       	rjmp	.+348    	; 0x2620 <LCD_voidWriteSpecialChar+0x1d0>
    24c4:	89 85       	ldd	r24, Y+9	; 0x09
    24c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    24c8:	85 30       	cpi	r24, 0x05	; 5
    24ca:	91 05       	cpc	r25, r1
    24cc:	0c f4       	brge	.+2      	; 0x24d0 <LCD_voidWriteSpecialChar+0x80>
    24ce:	89 c0       	rjmp	.+274    	; 0x25e2 <LCD_voidWriteSpecialChar+0x192>
    24d0:	29 85       	ldd	r18, Y+9	; 0x09
    24d2:	3a 85       	ldd	r19, Y+10	; 0x0a
    24d4:	26 30       	cpi	r18, 0x06	; 6
    24d6:	31 05       	cpc	r19, r1
    24d8:	09 f4       	brne	.+2      	; 0x24dc <LCD_voidWriteSpecialChar+0x8c>
    24da:	c1 c0       	rjmp	.+386    	; 0x265e <LCD_voidWriteSpecialChar+0x20e>
    24dc:	89 85       	ldd	r24, Y+9	; 0x09
    24de:	9a 85       	ldd	r25, Y+10	; 0x0a
    24e0:	87 30       	cpi	r24, 0x07	; 7
    24e2:	91 05       	cpc	r25, r1
    24e4:	09 f4       	brne	.+2      	; 0x24e8 <LCD_voidWriteSpecialChar+0x98>
    24e6:	da c0       	rjmp	.+436    	; 0x269c <LCD_voidWriteSpecialChar+0x24c>
    24e8:	f8 c0       	rjmp	.+496    	; 0x26da <LCD_voidWriteSpecialChar+0x28a>
	{
	case LCD_u8_CHAR0:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_0_COMMAND);
    24ea:	80 e4       	ldi	r24, 0x40	; 64
    24ec:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    24f0:	19 82       	std	Y+1, r1	; 0x01
    24f2:	0e c0       	rjmp	.+28     	; 0x2510 <LCD_voidWriteSpecialChar+0xc0>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    24f4:	89 81       	ldd	r24, Y+1	; 0x01
    24f6:	28 2f       	mov	r18, r24
    24f8:	30 e0       	ldi	r19, 0x00	; 0
    24fa:	8d 81       	ldd	r24, Y+5	; 0x05
    24fc:	9e 81       	ldd	r25, Y+6	; 0x06
    24fe:	fc 01       	movw	r30, r24
    2500:	e2 0f       	add	r30, r18
    2502:	f3 1f       	adc	r31, r19
    2504:	80 81       	ld	r24, Z
    2506:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
	u8 i;
	switch(Copy_u8CharNum)
	{
	case LCD_u8_CHAR0:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_0_COMMAND);
		for(i = 0;i < size; i++)
    250a:	89 81       	ldd	r24, Y+1	; 0x01
    250c:	8f 5f       	subi	r24, 0xFF	; 255
    250e:	89 83       	std	Y+1, r24	; 0x01
    2510:	99 81       	ldd	r25, Y+1	; 0x01
    2512:	8a 81       	ldd	r24, Y+2	; 0x02
    2514:	98 17       	cp	r25, r24
    2516:	70 f3       	brcs	.-36     	; 0x24f4 <LCD_voidWriteSpecialChar+0xa4>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    2518:	8f 81       	ldd	r24, Y+7	; 0x07
    251a:	68 85       	ldd	r22, Y+8	; 0x08
    251c:	0e 94 6e 11 	call	0x22dc	; 0x22dc <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    2520:	8c 81       	ldd	r24, Y+4	; 0x04
    2522:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    2526:	da c0       	rjmp	.+436    	; 0x26dc <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR1:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_1_COMMAND);
    2528:	88 e4       	ldi	r24, 0x48	; 72
    252a:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    252e:	19 82       	std	Y+1, r1	; 0x01
    2530:	0e c0       	rjmp	.+28     	; 0x254e <LCD_voidWriteSpecialChar+0xfe>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    2532:	89 81       	ldd	r24, Y+1	; 0x01
    2534:	28 2f       	mov	r18, r24
    2536:	30 e0       	ldi	r19, 0x00	; 0
    2538:	8d 81       	ldd	r24, Y+5	; 0x05
    253a:	9e 81       	ldd	r25, Y+6	; 0x06
    253c:	fc 01       	movw	r30, r24
    253e:	e2 0f       	add	r30, r18
    2540:	f3 1f       	adc	r31, r19
    2542:	80 81       	ld	r24, Z
    2544:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR1:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_1_COMMAND);
		for(i = 0;i < size; i++)
    2548:	89 81       	ldd	r24, Y+1	; 0x01
    254a:	8f 5f       	subi	r24, 0xFF	; 255
    254c:	89 83       	std	Y+1, r24	; 0x01
    254e:	99 81       	ldd	r25, Y+1	; 0x01
    2550:	8a 81       	ldd	r24, Y+2	; 0x02
    2552:	98 17       	cp	r25, r24
    2554:	70 f3       	brcs	.-36     	; 0x2532 <LCD_voidWriteSpecialChar+0xe2>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    2556:	8f 81       	ldd	r24, Y+7	; 0x07
    2558:	68 85       	ldd	r22, Y+8	; 0x08
    255a:	0e 94 6e 11 	call	0x22dc	; 0x22dc <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    255e:	8c 81       	ldd	r24, Y+4	; 0x04
    2560:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    2564:	bb c0       	rjmp	.+374    	; 0x26dc <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR2:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_2_COMMAND);
    2566:	80 e5       	ldi	r24, 0x50	; 80
    2568:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    256c:	19 82       	std	Y+1, r1	; 0x01
    256e:	0e c0       	rjmp	.+28     	; 0x258c <LCD_voidWriteSpecialChar+0x13c>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    2570:	89 81       	ldd	r24, Y+1	; 0x01
    2572:	28 2f       	mov	r18, r24
    2574:	30 e0       	ldi	r19, 0x00	; 0
    2576:	8d 81       	ldd	r24, Y+5	; 0x05
    2578:	9e 81       	ldd	r25, Y+6	; 0x06
    257a:	fc 01       	movw	r30, r24
    257c:	e2 0f       	add	r30, r18
    257e:	f3 1f       	adc	r31, r19
    2580:	80 81       	ld	r24, Z
    2582:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR2:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_2_COMMAND);
		for(i = 0;i < size; i++)
    2586:	89 81       	ldd	r24, Y+1	; 0x01
    2588:	8f 5f       	subi	r24, 0xFF	; 255
    258a:	89 83       	std	Y+1, r24	; 0x01
    258c:	99 81       	ldd	r25, Y+1	; 0x01
    258e:	8a 81       	ldd	r24, Y+2	; 0x02
    2590:	98 17       	cp	r25, r24
    2592:	70 f3       	brcs	.-36     	; 0x2570 <LCD_voidWriteSpecialChar+0x120>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    2594:	8f 81       	ldd	r24, Y+7	; 0x07
    2596:	68 85       	ldd	r22, Y+8	; 0x08
    2598:	0e 94 6e 11 	call	0x22dc	; 0x22dc <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    259c:	8c 81       	ldd	r24, Y+4	; 0x04
    259e:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    25a2:	9c c0       	rjmp	.+312    	; 0x26dc <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR3:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_3_COMMAND);
    25a4:	88 e5       	ldi	r24, 0x58	; 88
    25a6:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    25aa:	19 82       	std	Y+1, r1	; 0x01
    25ac:	0e c0       	rjmp	.+28     	; 0x25ca <LCD_voidWriteSpecialChar+0x17a>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    25ae:	89 81       	ldd	r24, Y+1	; 0x01
    25b0:	28 2f       	mov	r18, r24
    25b2:	30 e0       	ldi	r19, 0x00	; 0
    25b4:	8d 81       	ldd	r24, Y+5	; 0x05
    25b6:	9e 81       	ldd	r25, Y+6	; 0x06
    25b8:	fc 01       	movw	r30, r24
    25ba:	e2 0f       	add	r30, r18
    25bc:	f3 1f       	adc	r31, r19
    25be:	80 81       	ld	r24, Z
    25c0:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR3:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_3_COMMAND);
		for(i = 0;i < size; i++)
    25c4:	89 81       	ldd	r24, Y+1	; 0x01
    25c6:	8f 5f       	subi	r24, 0xFF	; 255
    25c8:	89 83       	std	Y+1, r24	; 0x01
    25ca:	99 81       	ldd	r25, Y+1	; 0x01
    25cc:	8a 81       	ldd	r24, Y+2	; 0x02
    25ce:	98 17       	cp	r25, r24
    25d0:	70 f3       	brcs	.-36     	; 0x25ae <LCD_voidWriteSpecialChar+0x15e>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    25d2:	8f 81       	ldd	r24, Y+7	; 0x07
    25d4:	68 85       	ldd	r22, Y+8	; 0x08
    25d6:	0e 94 6e 11 	call	0x22dc	; 0x22dc <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    25da:	8c 81       	ldd	r24, Y+4	; 0x04
    25dc:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    25e0:	7d c0       	rjmp	.+250    	; 0x26dc <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR4:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_4_COMMAND);
    25e2:	80 e6       	ldi	r24, 0x60	; 96
    25e4:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    25e8:	19 82       	std	Y+1, r1	; 0x01
    25ea:	0e c0       	rjmp	.+28     	; 0x2608 <LCD_voidWriteSpecialChar+0x1b8>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    25ec:	89 81       	ldd	r24, Y+1	; 0x01
    25ee:	28 2f       	mov	r18, r24
    25f0:	30 e0       	ldi	r19, 0x00	; 0
    25f2:	8d 81       	ldd	r24, Y+5	; 0x05
    25f4:	9e 81       	ldd	r25, Y+6	; 0x06
    25f6:	fc 01       	movw	r30, r24
    25f8:	e2 0f       	add	r30, r18
    25fa:	f3 1f       	adc	r31, r19
    25fc:	80 81       	ld	r24, Z
    25fe:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR4:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_4_COMMAND);
		for(i = 0;i < size; i++)
    2602:	89 81       	ldd	r24, Y+1	; 0x01
    2604:	8f 5f       	subi	r24, 0xFF	; 255
    2606:	89 83       	std	Y+1, r24	; 0x01
    2608:	99 81       	ldd	r25, Y+1	; 0x01
    260a:	8a 81       	ldd	r24, Y+2	; 0x02
    260c:	98 17       	cp	r25, r24
    260e:	70 f3       	brcs	.-36     	; 0x25ec <LCD_voidWriteSpecialChar+0x19c>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    2610:	8f 81       	ldd	r24, Y+7	; 0x07
    2612:	68 85       	ldd	r22, Y+8	; 0x08
    2614:	0e 94 6e 11 	call	0x22dc	; 0x22dc <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    2618:	8c 81       	ldd	r24, Y+4	; 0x04
    261a:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    261e:	5e c0       	rjmp	.+188    	; 0x26dc <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR5:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_5_COMMAND);
    2620:	88 e6       	ldi	r24, 0x68	; 104
    2622:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    2626:	19 82       	std	Y+1, r1	; 0x01
    2628:	0e c0       	rjmp	.+28     	; 0x2646 <LCD_voidWriteSpecialChar+0x1f6>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    262a:	89 81       	ldd	r24, Y+1	; 0x01
    262c:	28 2f       	mov	r18, r24
    262e:	30 e0       	ldi	r19, 0x00	; 0
    2630:	8d 81       	ldd	r24, Y+5	; 0x05
    2632:	9e 81       	ldd	r25, Y+6	; 0x06
    2634:	fc 01       	movw	r30, r24
    2636:	e2 0f       	add	r30, r18
    2638:	f3 1f       	adc	r31, r19
    263a:	80 81       	ld	r24, Z
    263c:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR5:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_5_COMMAND);
		for(i = 0;i < size; i++)
    2640:	89 81       	ldd	r24, Y+1	; 0x01
    2642:	8f 5f       	subi	r24, 0xFF	; 255
    2644:	89 83       	std	Y+1, r24	; 0x01
    2646:	99 81       	ldd	r25, Y+1	; 0x01
    2648:	8a 81       	ldd	r24, Y+2	; 0x02
    264a:	98 17       	cp	r25, r24
    264c:	70 f3       	brcs	.-36     	; 0x262a <LCD_voidWriteSpecialChar+0x1da>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    264e:	8f 81       	ldd	r24, Y+7	; 0x07
    2650:	68 85       	ldd	r22, Y+8	; 0x08
    2652:	0e 94 6e 11 	call	0x22dc	; 0x22dc <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    2656:	8c 81       	ldd	r24, Y+4	; 0x04
    2658:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    265c:	3f c0       	rjmp	.+126    	; 0x26dc <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR6:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_6_COMMAND);
    265e:	80 e7       	ldi	r24, 0x70	; 112
    2660:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    2664:	19 82       	std	Y+1, r1	; 0x01
    2666:	0e c0       	rjmp	.+28     	; 0x2684 <LCD_voidWriteSpecialChar+0x234>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    2668:	89 81       	ldd	r24, Y+1	; 0x01
    266a:	28 2f       	mov	r18, r24
    266c:	30 e0       	ldi	r19, 0x00	; 0
    266e:	8d 81       	ldd	r24, Y+5	; 0x05
    2670:	9e 81       	ldd	r25, Y+6	; 0x06
    2672:	fc 01       	movw	r30, r24
    2674:	e2 0f       	add	r30, r18
    2676:	f3 1f       	adc	r31, r19
    2678:	80 81       	ld	r24, Z
    267a:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR6:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_6_COMMAND);
		for(i = 0;i < size; i++)
    267e:	89 81       	ldd	r24, Y+1	; 0x01
    2680:	8f 5f       	subi	r24, 0xFF	; 255
    2682:	89 83       	std	Y+1, r24	; 0x01
    2684:	99 81       	ldd	r25, Y+1	; 0x01
    2686:	8a 81       	ldd	r24, Y+2	; 0x02
    2688:	98 17       	cp	r25, r24
    268a:	70 f3       	brcs	.-36     	; 0x2668 <LCD_voidWriteSpecialChar+0x218>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    268c:	8f 81       	ldd	r24, Y+7	; 0x07
    268e:	68 85       	ldd	r22, Y+8	; 0x08
    2690:	0e 94 6e 11 	call	0x22dc	; 0x22dc <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    2694:	8c 81       	ldd	r24, Y+4	; 0x04
    2696:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    269a:	20 c0       	rjmp	.+64     	; 0x26dc <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR7:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_7_COMMAND);
    269c:	88 e7       	ldi	r24, 0x78	; 120
    269e:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    26a2:	19 82       	std	Y+1, r1	; 0x01
    26a4:	0e c0       	rjmp	.+28     	; 0x26c2 <LCD_voidWriteSpecialChar+0x272>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    26a6:	89 81       	ldd	r24, Y+1	; 0x01
    26a8:	28 2f       	mov	r18, r24
    26aa:	30 e0       	ldi	r19, 0x00	; 0
    26ac:	8d 81       	ldd	r24, Y+5	; 0x05
    26ae:	9e 81       	ldd	r25, Y+6	; 0x06
    26b0:	fc 01       	movw	r30, r24
    26b2:	e2 0f       	add	r30, r18
    26b4:	f3 1f       	adc	r31, r19
    26b6:	80 81       	ld	r24, Z
    26b8:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR7:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_7_COMMAND);
		for(i = 0;i < size; i++)
    26bc:	89 81       	ldd	r24, Y+1	; 0x01
    26be:	8f 5f       	subi	r24, 0xFF	; 255
    26c0:	89 83       	std	Y+1, r24	; 0x01
    26c2:	99 81       	ldd	r25, Y+1	; 0x01
    26c4:	8a 81       	ldd	r24, Y+2	; 0x02
    26c6:	98 17       	cp	r25, r24
    26c8:	70 f3       	brcs	.-36     	; 0x26a6 <LCD_voidWriteSpecialChar+0x256>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    26ca:	8f 81       	ldd	r24, Y+7	; 0x07
    26cc:	68 85       	ldd	r22, Y+8	; 0x08
    26ce:	0e 94 6e 11 	call	0x22dc	; 0x22dc <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    26d2:	8c 81       	ldd	r24, Y+4	; 0x04
    26d4:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <LCD_voidSendChar>
    26d8:	01 c0       	rjmp	.+2      	; 0x26dc <LCD_voidWriteSpecialChar+0x28c>
		break;
	default:Local_u8ErrorState = STD_TYPES_NOK;
    26da:	1b 82       	std	Y+3, r1	; 0x03
	}
	return Local_u8ErrorState;
    26dc:	8b 81       	ldd	r24, Y+3	; 0x03
}
    26de:	2a 96       	adiw	r28, 0x0a	; 10
    26e0:	0f b6       	in	r0, 0x3f	; 63
    26e2:	f8 94       	cli
    26e4:	de bf       	out	0x3e, r29	; 62
    26e6:	0f be       	out	0x3f, r0	; 63
    26e8:	cd bf       	out	0x3d, r28	; 61
    26ea:	cf 91       	pop	r28
    26ec:	df 91       	pop	r29
    26ee:	08 95       	ret

000026f0 <LCD_voidSendHalfCmnd>:

void LCD_voidSendHalfCmnd(u8 Copy_u8HalfCmnd)
{
    26f0:	df 93       	push	r29
    26f2:	cf 93       	push	r28
    26f4:	cd b7       	in	r28, 0x3d	; 61
    26f6:	de b7       	in	r29, 0x3e	; 62
    26f8:	e1 97       	sbiw	r28, 0x31	; 49
    26fa:	0f b6       	in	r0, 0x3f	; 63
    26fc:	f8 94       	cli
    26fe:	de bf       	out	0x3e, r29	; 62
    2700:	0f be       	out	0x3f, r0	; 63
    2702:	cd bf       	out	0x3d, r28	; 61
    2704:	89 ab       	std	Y+49, r24	; 0x31
	/* Step 1: RS = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RS_PIN,DIO_u8_LOW);
    2706:	80 e0       	ldi	r24, 0x00	; 0
    2708:	60 e0       	ldi	r22, 0x00	; 0
    270a:	40 e0       	ldi	r20, 0x00	; 0
    270c:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
	/* Step 2: RW = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RW_PIN,DIO_u8_LOW);
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	61 e0       	ldi	r22, 0x01	; 1
    2714:	40 e0       	ldi	r20, 0x00	; 0
    2716:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
	/* Step 3: Write Command  */
	DIO_u8SetPortValue(LCD_u8_DATA_PORT,Copy_u8HalfCmnd<<4);
    271a:	89 a9       	ldd	r24, Y+49	; 0x31
    271c:	98 2f       	mov	r25, r24
    271e:	92 95       	swap	r25
    2720:	90 7f       	andi	r25, 0xF0	; 240
    2722:	82 e0       	ldi	r24, 0x02	; 2
    2724:	69 2f       	mov	r22, r25
    2726:	0e 94 28 0a 	call	0x1450	; 0x1450 <DIO_u8SetPortValue>
	/* Step 4: E = 1 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_HIGH);
    272a:	80 e0       	ldi	r24, 0x00	; 0
    272c:	62 e0       	ldi	r22, 0x02	; 2
    272e:	41 e0       	ldi	r20, 0x01	; 1
    2730:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
    2734:	80 e0       	ldi	r24, 0x00	; 0
    2736:	90 e0       	ldi	r25, 0x00	; 0
    2738:	a0 e8       	ldi	r26, 0x80	; 128
    273a:	bf e3       	ldi	r27, 0x3F	; 63
    273c:	8d a7       	std	Y+45, r24	; 0x2d
    273e:	9e a7       	std	Y+46, r25	; 0x2e
    2740:	af a7       	std	Y+47, r26	; 0x2f
    2742:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2744:	6d a5       	ldd	r22, Y+45	; 0x2d
    2746:	7e a5       	ldd	r23, Y+46	; 0x2e
    2748:	8f a5       	ldd	r24, Y+47	; 0x2f
    274a:	98 a9       	ldd	r25, Y+48	; 0x30
    274c:	2b ea       	ldi	r18, 0xAB	; 171
    274e:	3a ea       	ldi	r19, 0xAA	; 170
    2750:	4a e2       	ldi	r20, 0x2A	; 42
    2752:	50 e4       	ldi	r21, 0x40	; 64
    2754:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2758:	dc 01       	movw	r26, r24
    275a:	cb 01       	movw	r24, r22
    275c:	89 a7       	std	Y+41, r24	; 0x29
    275e:	9a a7       	std	Y+42, r25	; 0x2a
    2760:	ab a7       	std	Y+43, r26	; 0x2b
    2762:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    2764:	69 a5       	ldd	r22, Y+41	; 0x29
    2766:	7a a5       	ldd	r23, Y+42	; 0x2a
    2768:	8b a5       	ldd	r24, Y+43	; 0x2b
    276a:	9c a5       	ldd	r25, Y+44	; 0x2c
    276c:	20 e0       	ldi	r18, 0x00	; 0
    276e:	30 e0       	ldi	r19, 0x00	; 0
    2770:	40 e8       	ldi	r20, 0x80	; 128
    2772:	5f e3       	ldi	r21, 0x3F	; 63
    2774:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2778:	88 23       	and	r24, r24
    277a:	1c f4       	brge	.+6      	; 0x2782 <LCD_voidSendHalfCmnd+0x92>
		__ticks = 1;
    277c:	81 e0       	ldi	r24, 0x01	; 1
    277e:	88 a7       	std	Y+40, r24	; 0x28
    2780:	91 c0       	rjmp	.+290    	; 0x28a4 <LCD_voidSendHalfCmnd+0x1b4>
	else if (__tmp > 255)
    2782:	69 a5       	ldd	r22, Y+41	; 0x29
    2784:	7a a5       	ldd	r23, Y+42	; 0x2a
    2786:	8b a5       	ldd	r24, Y+43	; 0x2b
    2788:	9c a5       	ldd	r25, Y+44	; 0x2c
    278a:	20 e0       	ldi	r18, 0x00	; 0
    278c:	30 e0       	ldi	r19, 0x00	; 0
    278e:	4f e7       	ldi	r20, 0x7F	; 127
    2790:	53 e4       	ldi	r21, 0x43	; 67
    2792:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2796:	18 16       	cp	r1, r24
    2798:	0c f0       	brlt	.+2      	; 0x279c <LCD_voidSendHalfCmnd+0xac>
    279a:	7b c0       	rjmp	.+246    	; 0x2892 <LCD_voidSendHalfCmnd+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    279c:	6d a5       	ldd	r22, Y+45	; 0x2d
    279e:	7e a5       	ldd	r23, Y+46	; 0x2e
    27a0:	8f a5       	ldd	r24, Y+47	; 0x2f
    27a2:	98 a9       	ldd	r25, Y+48	; 0x30
    27a4:	20 e0       	ldi	r18, 0x00	; 0
    27a6:	30 e0       	ldi	r19, 0x00	; 0
    27a8:	4a e7       	ldi	r20, 0x7A	; 122
    27aa:	54 e4       	ldi	r21, 0x44	; 68
    27ac:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    27b0:	dc 01       	movw	r26, r24
    27b2:	cb 01       	movw	r24, r22
    27b4:	8c a3       	std	Y+36, r24	; 0x24
    27b6:	9d a3       	std	Y+37, r25	; 0x25
    27b8:	ae a3       	std	Y+38, r26	; 0x26
    27ba:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27bc:	6c a1       	ldd	r22, Y+36	; 0x24
    27be:	7d a1       	ldd	r23, Y+37	; 0x25
    27c0:	8e a1       	ldd	r24, Y+38	; 0x26
    27c2:	9f a1       	ldd	r25, Y+39	; 0x27
    27c4:	20 e0       	ldi	r18, 0x00	; 0
    27c6:	30 e0       	ldi	r19, 0x00	; 0
    27c8:	4a ef       	ldi	r20, 0xFA	; 250
    27ca:	54 e4       	ldi	r21, 0x44	; 68
    27cc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27d0:	dc 01       	movw	r26, r24
    27d2:	cb 01       	movw	r24, r22
    27d4:	88 a3       	std	Y+32, r24	; 0x20
    27d6:	99 a3       	std	Y+33, r25	; 0x21
    27d8:	aa a3       	std	Y+34, r26	; 0x22
    27da:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    27dc:	68 a1       	ldd	r22, Y+32	; 0x20
    27de:	79 a1       	ldd	r23, Y+33	; 0x21
    27e0:	8a a1       	ldd	r24, Y+34	; 0x22
    27e2:	9b a1       	ldd	r25, Y+35	; 0x23
    27e4:	20 e0       	ldi	r18, 0x00	; 0
    27e6:	30 e0       	ldi	r19, 0x00	; 0
    27e8:	40 e8       	ldi	r20, 0x80	; 128
    27ea:	5f e3       	ldi	r21, 0x3F	; 63
    27ec:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    27f0:	88 23       	and	r24, r24
    27f2:	2c f4       	brge	.+10     	; 0x27fe <LCD_voidSendHalfCmnd+0x10e>
		__ticks = 1;
    27f4:	81 e0       	ldi	r24, 0x01	; 1
    27f6:	90 e0       	ldi	r25, 0x00	; 0
    27f8:	9f 8f       	std	Y+31, r25	; 0x1f
    27fa:	8e 8f       	std	Y+30, r24	; 0x1e
    27fc:	3f c0       	rjmp	.+126    	; 0x287c <LCD_voidSendHalfCmnd+0x18c>
	else if (__tmp > 65535)
    27fe:	68 a1       	ldd	r22, Y+32	; 0x20
    2800:	79 a1       	ldd	r23, Y+33	; 0x21
    2802:	8a a1       	ldd	r24, Y+34	; 0x22
    2804:	9b a1       	ldd	r25, Y+35	; 0x23
    2806:	20 e0       	ldi	r18, 0x00	; 0
    2808:	3f ef       	ldi	r19, 0xFF	; 255
    280a:	4f e7       	ldi	r20, 0x7F	; 127
    280c:	57 e4       	ldi	r21, 0x47	; 71
    280e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2812:	18 16       	cp	r1, r24
    2814:	4c f5       	brge	.+82     	; 0x2868 <LCD_voidSendHalfCmnd+0x178>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2816:	6c a1       	ldd	r22, Y+36	; 0x24
    2818:	7d a1       	ldd	r23, Y+37	; 0x25
    281a:	8e a1       	ldd	r24, Y+38	; 0x26
    281c:	9f a1       	ldd	r25, Y+39	; 0x27
    281e:	20 e0       	ldi	r18, 0x00	; 0
    2820:	30 e0       	ldi	r19, 0x00	; 0
    2822:	40 e2       	ldi	r20, 0x20	; 32
    2824:	51 e4       	ldi	r21, 0x41	; 65
    2826:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    282a:	dc 01       	movw	r26, r24
    282c:	cb 01       	movw	r24, r22
    282e:	bc 01       	movw	r22, r24
    2830:	cd 01       	movw	r24, r26
    2832:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2836:	dc 01       	movw	r26, r24
    2838:	cb 01       	movw	r24, r22
    283a:	9f 8f       	std	Y+31, r25	; 0x1f
    283c:	8e 8f       	std	Y+30, r24	; 0x1e
    283e:	0f c0       	rjmp	.+30     	; 0x285e <LCD_voidSendHalfCmnd+0x16e>
    2840:	88 ec       	ldi	r24, 0xC8	; 200
    2842:	90 e0       	ldi	r25, 0x00	; 0
    2844:	9d 8f       	std	Y+29, r25	; 0x1d
    2846:	8c 8f       	std	Y+28, r24	; 0x1c
    2848:	8c 8d       	ldd	r24, Y+28	; 0x1c
    284a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    284c:	01 97       	sbiw	r24, 0x01	; 1
    284e:	f1 f7       	brne	.-4      	; 0x284c <LCD_voidSendHalfCmnd+0x15c>
    2850:	9d 8f       	std	Y+29, r25	; 0x1d
    2852:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2854:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2856:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2858:	01 97       	sbiw	r24, 0x01	; 1
    285a:	9f 8f       	std	Y+31, r25	; 0x1f
    285c:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    285e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2860:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2862:	00 97       	sbiw	r24, 0x00	; 0
    2864:	69 f7       	brne	.-38     	; 0x2840 <LCD_voidSendHalfCmnd+0x150>
    2866:	24 c0       	rjmp	.+72     	; 0x28b0 <LCD_voidSendHalfCmnd+0x1c0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2868:	68 a1       	ldd	r22, Y+32	; 0x20
    286a:	79 a1       	ldd	r23, Y+33	; 0x21
    286c:	8a a1       	ldd	r24, Y+34	; 0x22
    286e:	9b a1       	ldd	r25, Y+35	; 0x23
    2870:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2874:	dc 01       	movw	r26, r24
    2876:	cb 01       	movw	r24, r22
    2878:	9f 8f       	std	Y+31, r25	; 0x1f
    287a:	8e 8f       	std	Y+30, r24	; 0x1e
    287c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    287e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2880:	9b 8f       	std	Y+27, r25	; 0x1b
    2882:	8a 8f       	std	Y+26, r24	; 0x1a
    2884:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2886:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2888:	01 97       	sbiw	r24, 0x01	; 1
    288a:	f1 f7       	brne	.-4      	; 0x2888 <LCD_voidSendHalfCmnd+0x198>
    288c:	9b 8f       	std	Y+27, r25	; 0x1b
    288e:	8a 8f       	std	Y+26, r24	; 0x1a
    2890:	0f c0       	rjmp	.+30     	; 0x28b0 <LCD_voidSendHalfCmnd+0x1c0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2892:	69 a5       	ldd	r22, Y+41	; 0x29
    2894:	7a a5       	ldd	r23, Y+42	; 0x2a
    2896:	8b a5       	ldd	r24, Y+43	; 0x2b
    2898:	9c a5       	ldd	r25, Y+44	; 0x2c
    289a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    289e:	dc 01       	movw	r26, r24
    28a0:	cb 01       	movw	r24, r22
    28a2:	88 a7       	std	Y+40, r24	; 0x28
    28a4:	88 a5       	ldd	r24, Y+40	; 0x28
    28a6:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    28a8:	89 8d       	ldd	r24, Y+25	; 0x19
    28aa:	8a 95       	dec	r24
    28ac:	f1 f7       	brne	.-4      	; 0x28aa <LCD_voidSendHalfCmnd+0x1ba>
    28ae:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1); //wait tw = 230 ns
	/* Step 5: E = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
    28b0:	80 e0       	ldi	r24, 0x00	; 0
    28b2:	62 e0       	ldi	r22, 0x02	; 2
    28b4:	40 e0       	ldi	r20, 0x00	; 0
    28b6:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
    28ba:	80 e0       	ldi	r24, 0x00	; 0
    28bc:	90 e0       	ldi	r25, 0x00	; 0
    28be:	a0 e8       	ldi	r26, 0x80	; 128
    28c0:	bf e3       	ldi	r27, 0x3F	; 63
    28c2:	8d 8b       	std	Y+21, r24	; 0x15
    28c4:	9e 8b       	std	Y+22, r25	; 0x16
    28c6:	af 8b       	std	Y+23, r26	; 0x17
    28c8:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    28ca:	6d 89       	ldd	r22, Y+21	; 0x15
    28cc:	7e 89       	ldd	r23, Y+22	; 0x16
    28ce:	8f 89       	ldd	r24, Y+23	; 0x17
    28d0:	98 8d       	ldd	r25, Y+24	; 0x18
    28d2:	2b ea       	ldi	r18, 0xAB	; 171
    28d4:	3a ea       	ldi	r19, 0xAA	; 170
    28d6:	4a e2       	ldi	r20, 0x2A	; 42
    28d8:	50 e4       	ldi	r21, 0x40	; 64
    28da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    28de:	dc 01       	movw	r26, r24
    28e0:	cb 01       	movw	r24, r22
    28e2:	89 8b       	std	Y+17, r24	; 0x11
    28e4:	9a 8b       	std	Y+18, r25	; 0x12
    28e6:	ab 8b       	std	Y+19, r26	; 0x13
    28e8:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    28ea:	69 89       	ldd	r22, Y+17	; 0x11
    28ec:	7a 89       	ldd	r23, Y+18	; 0x12
    28ee:	8b 89       	ldd	r24, Y+19	; 0x13
    28f0:	9c 89       	ldd	r25, Y+20	; 0x14
    28f2:	20 e0       	ldi	r18, 0x00	; 0
    28f4:	30 e0       	ldi	r19, 0x00	; 0
    28f6:	40 e8       	ldi	r20, 0x80	; 128
    28f8:	5f e3       	ldi	r21, 0x3F	; 63
    28fa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    28fe:	88 23       	and	r24, r24
    2900:	1c f4       	brge	.+6      	; 0x2908 <LCD_voidSendHalfCmnd+0x218>
		__ticks = 1;
    2902:	81 e0       	ldi	r24, 0x01	; 1
    2904:	88 8b       	std	Y+16, r24	; 0x10
    2906:	91 c0       	rjmp	.+290    	; 0x2a2a <LCD_voidSendHalfCmnd+0x33a>
	else if (__tmp > 255)
    2908:	69 89       	ldd	r22, Y+17	; 0x11
    290a:	7a 89       	ldd	r23, Y+18	; 0x12
    290c:	8b 89       	ldd	r24, Y+19	; 0x13
    290e:	9c 89       	ldd	r25, Y+20	; 0x14
    2910:	20 e0       	ldi	r18, 0x00	; 0
    2912:	30 e0       	ldi	r19, 0x00	; 0
    2914:	4f e7       	ldi	r20, 0x7F	; 127
    2916:	53 e4       	ldi	r21, 0x43	; 67
    2918:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    291c:	18 16       	cp	r1, r24
    291e:	0c f0       	brlt	.+2      	; 0x2922 <LCD_voidSendHalfCmnd+0x232>
    2920:	7b c0       	rjmp	.+246    	; 0x2a18 <LCD_voidSendHalfCmnd+0x328>
	{
		_delay_ms(__us / 1000.0);
    2922:	6d 89       	ldd	r22, Y+21	; 0x15
    2924:	7e 89       	ldd	r23, Y+22	; 0x16
    2926:	8f 89       	ldd	r24, Y+23	; 0x17
    2928:	98 8d       	ldd	r25, Y+24	; 0x18
    292a:	20 e0       	ldi	r18, 0x00	; 0
    292c:	30 e0       	ldi	r19, 0x00	; 0
    292e:	4a e7       	ldi	r20, 0x7A	; 122
    2930:	54 e4       	ldi	r21, 0x44	; 68
    2932:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2936:	dc 01       	movw	r26, r24
    2938:	cb 01       	movw	r24, r22
    293a:	8c 87       	std	Y+12, r24	; 0x0c
    293c:	9d 87       	std	Y+13, r25	; 0x0d
    293e:	ae 87       	std	Y+14, r26	; 0x0e
    2940:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2942:	6c 85       	ldd	r22, Y+12	; 0x0c
    2944:	7d 85       	ldd	r23, Y+13	; 0x0d
    2946:	8e 85       	ldd	r24, Y+14	; 0x0e
    2948:	9f 85       	ldd	r25, Y+15	; 0x0f
    294a:	20 e0       	ldi	r18, 0x00	; 0
    294c:	30 e0       	ldi	r19, 0x00	; 0
    294e:	4a ef       	ldi	r20, 0xFA	; 250
    2950:	54 e4       	ldi	r21, 0x44	; 68
    2952:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2956:	dc 01       	movw	r26, r24
    2958:	cb 01       	movw	r24, r22
    295a:	88 87       	std	Y+8, r24	; 0x08
    295c:	99 87       	std	Y+9, r25	; 0x09
    295e:	aa 87       	std	Y+10, r26	; 0x0a
    2960:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    2962:	68 85       	ldd	r22, Y+8	; 0x08
    2964:	79 85       	ldd	r23, Y+9	; 0x09
    2966:	8a 85       	ldd	r24, Y+10	; 0x0a
    2968:	9b 85       	ldd	r25, Y+11	; 0x0b
    296a:	20 e0       	ldi	r18, 0x00	; 0
    296c:	30 e0       	ldi	r19, 0x00	; 0
    296e:	40 e8       	ldi	r20, 0x80	; 128
    2970:	5f e3       	ldi	r21, 0x3F	; 63
    2972:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2976:	88 23       	and	r24, r24
    2978:	2c f4       	brge	.+10     	; 0x2984 <LCD_voidSendHalfCmnd+0x294>
		__ticks = 1;
    297a:	81 e0       	ldi	r24, 0x01	; 1
    297c:	90 e0       	ldi	r25, 0x00	; 0
    297e:	9f 83       	std	Y+7, r25	; 0x07
    2980:	8e 83       	std	Y+6, r24	; 0x06
    2982:	3f c0       	rjmp	.+126    	; 0x2a02 <LCD_voidSendHalfCmnd+0x312>
	else if (__tmp > 65535)
    2984:	68 85       	ldd	r22, Y+8	; 0x08
    2986:	79 85       	ldd	r23, Y+9	; 0x09
    2988:	8a 85       	ldd	r24, Y+10	; 0x0a
    298a:	9b 85       	ldd	r25, Y+11	; 0x0b
    298c:	20 e0       	ldi	r18, 0x00	; 0
    298e:	3f ef       	ldi	r19, 0xFF	; 255
    2990:	4f e7       	ldi	r20, 0x7F	; 127
    2992:	57 e4       	ldi	r21, 0x47	; 71
    2994:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2998:	18 16       	cp	r1, r24
    299a:	4c f5       	brge	.+82     	; 0x29ee <LCD_voidSendHalfCmnd+0x2fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    299c:	6c 85       	ldd	r22, Y+12	; 0x0c
    299e:	7d 85       	ldd	r23, Y+13	; 0x0d
    29a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    29a2:	9f 85       	ldd	r25, Y+15	; 0x0f
    29a4:	20 e0       	ldi	r18, 0x00	; 0
    29a6:	30 e0       	ldi	r19, 0x00	; 0
    29a8:	40 e2       	ldi	r20, 0x20	; 32
    29aa:	51 e4       	ldi	r21, 0x41	; 65
    29ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29b0:	dc 01       	movw	r26, r24
    29b2:	cb 01       	movw	r24, r22
    29b4:	bc 01       	movw	r22, r24
    29b6:	cd 01       	movw	r24, r26
    29b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29bc:	dc 01       	movw	r26, r24
    29be:	cb 01       	movw	r24, r22
    29c0:	9f 83       	std	Y+7, r25	; 0x07
    29c2:	8e 83       	std	Y+6, r24	; 0x06
    29c4:	0f c0       	rjmp	.+30     	; 0x29e4 <LCD_voidSendHalfCmnd+0x2f4>
    29c6:	88 ec       	ldi	r24, 0xC8	; 200
    29c8:	90 e0       	ldi	r25, 0x00	; 0
    29ca:	9d 83       	std	Y+5, r25	; 0x05
    29cc:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    29ce:	8c 81       	ldd	r24, Y+4	; 0x04
    29d0:	9d 81       	ldd	r25, Y+5	; 0x05
    29d2:	01 97       	sbiw	r24, 0x01	; 1
    29d4:	f1 f7       	brne	.-4      	; 0x29d2 <LCD_voidSendHalfCmnd+0x2e2>
    29d6:	9d 83       	std	Y+5, r25	; 0x05
    29d8:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    29da:	8e 81       	ldd	r24, Y+6	; 0x06
    29dc:	9f 81       	ldd	r25, Y+7	; 0x07
    29de:	01 97       	sbiw	r24, 0x01	; 1
    29e0:	9f 83       	std	Y+7, r25	; 0x07
    29e2:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    29e4:	8e 81       	ldd	r24, Y+6	; 0x06
    29e6:	9f 81       	ldd	r25, Y+7	; 0x07
    29e8:	00 97       	sbiw	r24, 0x00	; 0
    29ea:	69 f7       	brne	.-38     	; 0x29c6 <LCD_voidSendHalfCmnd+0x2d6>
    29ec:	24 c0       	rjmp	.+72     	; 0x2a36 <LCD_voidSendHalfCmnd+0x346>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    29ee:	68 85       	ldd	r22, Y+8	; 0x08
    29f0:	79 85       	ldd	r23, Y+9	; 0x09
    29f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    29f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    29f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29fa:	dc 01       	movw	r26, r24
    29fc:	cb 01       	movw	r24, r22
    29fe:	9f 83       	std	Y+7, r25	; 0x07
    2a00:	8e 83       	std	Y+6, r24	; 0x06
    2a02:	8e 81       	ldd	r24, Y+6	; 0x06
    2a04:	9f 81       	ldd	r25, Y+7	; 0x07
    2a06:	9b 83       	std	Y+3, r25	; 0x03
    2a08:	8a 83       	std	Y+2, r24	; 0x02
    2a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0c:	9b 81       	ldd	r25, Y+3	; 0x03
    2a0e:	01 97       	sbiw	r24, 0x01	; 1
    2a10:	f1 f7       	brne	.-4      	; 0x2a0e <LCD_voidSendHalfCmnd+0x31e>
    2a12:	9b 83       	std	Y+3, r25	; 0x03
    2a14:	8a 83       	std	Y+2, r24	; 0x02
    2a16:	0f c0       	rjmp	.+30     	; 0x2a36 <LCD_voidSendHalfCmnd+0x346>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2a18:	69 89       	ldd	r22, Y+17	; 0x11
    2a1a:	7a 89       	ldd	r23, Y+18	; 0x12
    2a1c:	8b 89       	ldd	r24, Y+19	; 0x13
    2a1e:	9c 89       	ldd	r25, Y+20	; 0x14
    2a20:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a24:	dc 01       	movw	r26, r24
    2a26:	cb 01       	movw	r24, r22
    2a28:	88 8b       	std	Y+16, r24	; 0x10
    2a2a:	88 89       	ldd	r24, Y+16	; 0x10
    2a2c:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2a2e:	89 81       	ldd	r24, Y+1	; 0x01
    2a30:	8a 95       	dec	r24
    2a32:	f1 f7       	brne	.-4      	; 0x2a30 <LCD_voidSendHalfCmnd+0x340>
    2a34:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1); // wait tc = 500ns (not important because 1 us in step 4 is enough because >>> 230ns )
    2a36:	e1 96       	adiw	r28, 0x31	; 49
    2a38:	0f b6       	in	r0, 0x3f	; 63
    2a3a:	f8 94       	cli
    2a3c:	de bf       	out	0x3e, r29	; 62
    2a3e:	0f be       	out	0x3f, r0	; 63
    2a40:	cd bf       	out	0x3d, r28	; 61
    2a42:	cf 91       	pop	r28
    2a44:	df 91       	pop	r29
    2a46:	08 95       	ret

00002a48 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    2a48:	df 93       	push	r29
    2a4a:	cf 93       	push	r28
    2a4c:	00 d0       	rcall	.+0      	; 0x2a4e <xEventGroupCreate+0x6>
    2a4e:	cd b7       	in	r28, 0x3d	; 61
    2a50:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    2a52:	8b e0       	ldi	r24, 0x0B	; 11
    2a54:	90 e0       	ldi	r25, 0x00	; 0
    2a56:	0e 94 69 18 	call	0x30d2	; 0x30d2 <pvPortMalloc>
    2a5a:	9a 83       	std	Y+2, r25	; 0x02
    2a5c:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    2a5e:	89 81       	ldd	r24, Y+1	; 0x01
    2a60:	9a 81       	ldd	r25, Y+2	; 0x02
    2a62:	00 97       	sbiw	r24, 0x00	; 0
    2a64:	49 f0       	breq	.+18     	; 0x2a78 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    2a66:	e9 81       	ldd	r30, Y+1	; 0x01
    2a68:	fa 81       	ldd	r31, Y+2	; 0x02
    2a6a:	11 82       	std	Z+1, r1	; 0x01
    2a6c:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    2a6e:	89 81       	ldd	r24, Y+1	; 0x01
    2a70:	9a 81       	ldd	r25, Y+2	; 0x02
    2a72:	02 96       	adiw	r24, 0x02	; 2
    2a74:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    2a78:	89 81       	ldd	r24, Y+1	; 0x01
    2a7a:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    2a7c:	0f 90       	pop	r0
    2a7e:	0f 90       	pop	r0
    2a80:	cf 91       	pop	r28
    2a82:	df 91       	pop	r29
    2a84:	08 95       	ret

00002a86 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    2a86:	df 93       	push	r29
    2a88:	cf 93       	push	r28
    2a8a:	cd b7       	in	r28, 0x3d	; 61
    2a8c:	de b7       	in	r29, 0x3e	; 62
    2a8e:	60 97       	sbiw	r28, 0x10	; 16
    2a90:	0f b6       	in	r0, 0x3f	; 63
    2a92:	f8 94       	cli
    2a94:	de bf       	out	0x3e, r29	; 62
    2a96:	0f be       	out	0x3f, r0	; 63
    2a98:	cd bf       	out	0x3d, r28	; 61
    2a9a:	9a 87       	std	Y+10, r25	; 0x0a
    2a9c:	89 87       	std	Y+9, r24	; 0x09
    2a9e:	7c 87       	std	Y+12, r23	; 0x0c
    2aa0:	6b 87       	std	Y+11, r22	; 0x0b
    2aa2:	5e 87       	std	Y+14, r21	; 0x0e
    2aa4:	4d 87       	std	Y+13, r20	; 0x0d
    2aa6:	38 8b       	std	Y+16, r19	; 0x10
    2aa8:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    2aaa:	89 85       	ldd	r24, Y+9	; 0x09
    2aac:	9a 85       	ldd	r25, Y+10	; 0x0a
    2aae:	9c 83       	std	Y+4, r25	; 0x04
    2ab0:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2ab2:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2ab4:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    2ab8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aba:	fc 81       	ldd	r31, Y+4	; 0x04
    2abc:	80 81       	ld	r24, Z
    2abe:	91 81       	ldd	r25, Z+1	; 0x01
    2ac0:	98 87       	std	Y+8, r25	; 0x08
    2ac2:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2ac4:	89 85       	ldd	r24, Y+9	; 0x09
    2ac6:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ac8:	2b 85       	ldd	r18, Y+11	; 0x0b
    2aca:	3c 85       	ldd	r19, Y+12	; 0x0c
    2acc:	b9 01       	movw	r22, r18
    2ace:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2ad2:	2f 81       	ldd	r18, Y+7	; 0x07
    2ad4:	38 85       	ldd	r19, Y+8	; 0x08
    2ad6:	8b 85       	ldd	r24, Y+11	; 0x0b
    2ad8:	9c 85       	ldd	r25, Y+12	; 0x0c
    2ada:	28 2b       	or	r18, r24
    2adc:	39 2b       	or	r19, r25
    2ade:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ae0:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ae2:	28 23       	and	r18, r24
    2ae4:	39 23       	and	r19, r25
    2ae6:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ae8:	9e 85       	ldd	r25, Y+14	; 0x0e
    2aea:	28 17       	cp	r18, r24
    2aec:	39 07       	cpc	r19, r25
    2aee:	c9 f4       	brne	.+50     	; 0x2b22 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    2af0:	2f 81       	ldd	r18, Y+7	; 0x07
    2af2:	38 85       	ldd	r19, Y+8	; 0x08
    2af4:	8b 85       	ldd	r24, Y+11	; 0x0b
    2af6:	9c 85       	ldd	r25, Y+12	; 0x0c
    2af8:	82 2b       	or	r24, r18
    2afa:	93 2b       	or	r25, r19
    2afc:	9e 83       	std	Y+6, r25	; 0x06
    2afe:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2b00:	eb 81       	ldd	r30, Y+3	; 0x03
    2b02:	fc 81       	ldd	r31, Y+4	; 0x04
    2b04:	20 81       	ld	r18, Z
    2b06:	31 81       	ldd	r19, Z+1	; 0x01
    2b08:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b0a:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b0c:	80 95       	com	r24
    2b0e:	90 95       	com	r25
    2b10:	82 23       	and	r24, r18
    2b12:	93 23       	and	r25, r19
    2b14:	eb 81       	ldd	r30, Y+3	; 0x03
    2b16:	fc 81       	ldd	r31, Y+4	; 0x04
    2b18:	91 83       	std	Z+1, r25	; 0x01
    2b1a:	80 83       	st	Z, r24

			xTicksToWait = 0;
    2b1c:	18 8a       	std	Y+16, r1	; 0x10
    2b1e:	1f 86       	std	Y+15, r1	; 0x0f
    2b20:	1e c0       	rjmp	.+60     	; 0x2b5e <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    2b22:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b24:	98 89       	ldd	r25, Y+16	; 0x10
    2b26:	00 97       	sbiw	r24, 0x00	; 0
    2b28:	91 f0       	breq	.+36     	; 0x2b4e <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2b2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2e:	bc 01       	movw	r22, r24
    2b30:	6e 5f       	subi	r22, 0xFE	; 254
    2b32:	7f 4f       	sbci	r23, 0xFF	; 255
    2b34:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b36:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b38:	9c 01       	movw	r18, r24
    2b3a:	35 60       	ori	r19, 0x05	; 5
    2b3c:	4f 85       	ldd	r20, Y+15	; 0x0f
    2b3e:	58 89       	ldd	r21, Y+16	; 0x10
    2b40:	cb 01       	movw	r24, r22
    2b42:	b9 01       	movw	r22, r18
    2b44:	0e 94 f9 2d 	call	0x5bf2	; 0x5bf2 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    2b48:	1e 82       	std	Y+6, r1	; 0x06
    2b4a:	1d 82       	std	Y+5, r1	; 0x05
    2b4c:	08 c0       	rjmp	.+16     	; 0x2b5e <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2b4e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b50:	fc 81       	ldd	r31, Y+4	; 0x04
    2b52:	80 81       	ld	r24, Z
    2b54:	91 81       	ldd	r25, Z+1	; 0x01
    2b56:	9e 83       	std	Y+6, r25	; 0x06
    2b58:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    2b5a:	81 e0       	ldi	r24, 0x01	; 1
    2b5c:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2b5e:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    2b62:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    2b64:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b66:	98 89       	ldd	r25, Y+16	; 0x10
    2b68:	00 97       	sbiw	r24, 0x00	; 0
    2b6a:	09 f4       	brne	.+2      	; 0x2b6e <xEventGroupSync+0xe8>
    2b6c:	3a c0       	rjmp	.+116    	; 0x2be2 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    2b6e:	8a 81       	ldd	r24, Y+2	; 0x02
    2b70:	88 23       	and	r24, r24
    2b72:	11 f4       	brne	.+4      	; 0x2b78 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    2b74:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2b78:	0e 94 5a 30 	call	0x60b4	; 0x60b4 <uxTaskResetEventItemValue>
    2b7c:	9e 83       	std	Y+6, r25	; 0x06
    2b7e:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2b80:	8d 81       	ldd	r24, Y+5	; 0x05
    2b82:	9e 81       	ldd	r25, Y+6	; 0x06
    2b84:	80 70       	andi	r24, 0x00	; 0
    2b86:	92 70       	andi	r25, 0x02	; 2
    2b88:	00 97       	sbiw	r24, 0x00	; 0
    2b8a:	31 f5       	brne	.+76     	; 0x2bd8 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    2b8c:	0f b6       	in	r0, 0x3f	; 63
    2b8e:	f8 94       	cli
    2b90:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    2b92:	eb 81       	ldd	r30, Y+3	; 0x03
    2b94:	fc 81       	ldd	r31, Y+4	; 0x04
    2b96:	80 81       	ld	r24, Z
    2b98:	91 81       	ldd	r25, Z+1	; 0x01
    2b9a:	9e 83       	std	Y+6, r25	; 0x06
    2b9c:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2b9e:	2d 81       	ldd	r18, Y+5	; 0x05
    2ba0:	3e 81       	ldd	r19, Y+6	; 0x06
    2ba2:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ba4:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ba6:	28 23       	and	r18, r24
    2ba8:	39 23       	and	r19, r25
    2baa:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bac:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bae:	28 17       	cp	r18, r24
    2bb0:	39 07       	cpc	r19, r25
    2bb2:	71 f4       	brne	.+28     	; 0x2bd0 <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2bb4:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb6:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb8:	20 81       	ld	r18, Z
    2bba:	31 81       	ldd	r19, Z+1	; 0x01
    2bbc:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bbe:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bc0:	80 95       	com	r24
    2bc2:	90 95       	com	r25
    2bc4:	82 23       	and	r24, r18
    2bc6:	93 23       	and	r25, r19
    2bc8:	eb 81       	ldd	r30, Y+3	; 0x03
    2bca:	fc 81       	ldd	r31, Y+4	; 0x04
    2bcc:	91 83       	std	Z+1, r25	; 0x01
    2bce:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2bd0:	0f 90       	pop	r0
    2bd2:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    2bd4:	81 e0       	ldi	r24, 0x01	; 1
    2bd6:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2bd8:	8d 81       	ldd	r24, Y+5	; 0x05
    2bda:	9e 81       	ldd	r25, Y+6	; 0x06
    2bdc:	90 70       	andi	r25, 0x00	; 0
    2bde:	9e 83       	std	Y+6, r25	; 0x06
    2be0:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    2be2:	8d 81       	ldd	r24, Y+5	; 0x05
    2be4:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2be6:	60 96       	adiw	r28, 0x10	; 16
    2be8:	0f b6       	in	r0, 0x3f	; 63
    2bea:	f8 94       	cli
    2bec:	de bf       	out	0x3e, r29	; 62
    2bee:	0f be       	out	0x3f, r0	; 63
    2bf0:	cd bf       	out	0x3d, r28	; 61
    2bf2:	cf 91       	pop	r28
    2bf4:	df 91       	pop	r29
    2bf6:	08 95       	ret

00002bf8 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    2bf8:	0f 93       	push	r16
    2bfa:	1f 93       	push	r17
    2bfc:	df 93       	push	r29
    2bfe:	cf 93       	push	r28
    2c00:	cd b7       	in	r28, 0x3d	; 61
    2c02:	de b7       	in	r29, 0x3e	; 62
    2c04:	63 97       	sbiw	r28, 0x13	; 19
    2c06:	0f b6       	in	r0, 0x3f	; 63
    2c08:	f8 94       	cli
    2c0a:	de bf       	out	0x3e, r29	; 62
    2c0c:	0f be       	out	0x3f, r0	; 63
    2c0e:	cd bf       	out	0x3d, r28	; 61
    2c10:	9d 87       	std	Y+13, r25	; 0x0d
    2c12:	8c 87       	std	Y+12, r24	; 0x0c
    2c14:	7f 87       	std	Y+15, r23	; 0x0f
    2c16:	6e 87       	std	Y+14, r22	; 0x0e
    2c18:	48 8b       	std	Y+16, r20	; 0x10
    2c1a:	29 8b       	std	Y+17, r18	; 0x11
    2c1c:	1b 8b       	std	Y+19, r17	; 0x13
    2c1e:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    2c20:	8c 85       	ldd	r24, Y+12	; 0x0c
    2c22:	9d 85       	ldd	r25, Y+13	; 0x0d
    2c24:	9b 87       	std	Y+11, r25	; 0x0b
    2c26:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    2c28:	1f 82       	std	Y+7, r1	; 0x07
    2c2a:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2c2c:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2c2e:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2c32:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c34:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c36:	80 81       	ld	r24, Z
    2c38:	91 81       	ldd	r25, Z+1	; 0x01
    2c3a:	9a 83       	std	Y+2, r25	; 0x02
    2c3c:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2c3e:	89 81       	ldd	r24, Y+1	; 0x01
    2c40:	9a 81       	ldd	r25, Y+2	; 0x02
    2c42:	2e 85       	ldd	r18, Y+14	; 0x0e
    2c44:	3f 85       	ldd	r19, Y+15	; 0x0f
    2c46:	b9 01       	movw	r22, r18
    2c48:	49 89       	ldd	r20, Y+17	; 0x11
    2c4a:	0e 94 37 18 	call	0x306e	; 0x306e <prvTestWaitCondition>
    2c4e:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    2c50:	8d 81       	ldd	r24, Y+5	; 0x05
    2c52:	88 23       	and	r24, r24
    2c54:	c1 f0       	breq	.+48     	; 0x2c86 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    2c56:	89 81       	ldd	r24, Y+1	; 0x01
    2c58:	9a 81       	ldd	r25, Y+2	; 0x02
    2c5a:	99 87       	std	Y+9, r25	; 0x09
    2c5c:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    2c5e:	1b 8a       	std	Y+19, r1	; 0x13
    2c60:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2c62:	88 89       	ldd	r24, Y+16	; 0x10
    2c64:	88 23       	and	r24, r24
    2c66:	e9 f1       	breq	.+122    	; 0x2ce2 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2c68:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c6a:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c6c:	20 81       	ld	r18, Z
    2c6e:	31 81       	ldd	r19, Z+1	; 0x01
    2c70:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c72:	9f 85       	ldd	r25, Y+15	; 0x0f
    2c74:	80 95       	com	r24
    2c76:	90 95       	com	r25
    2c78:	82 23       	and	r24, r18
    2c7a:	93 23       	and	r25, r19
    2c7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c80:	91 83       	std	Z+1, r25	; 0x01
    2c82:	80 83       	st	Z, r24
    2c84:	2e c0       	rjmp	.+92     	; 0x2ce2 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2c86:	8a 89       	ldd	r24, Y+18	; 0x12
    2c88:	9b 89       	ldd	r25, Y+19	; 0x13
    2c8a:	00 97       	sbiw	r24, 0x00	; 0
    2c8c:	39 f4       	brne	.+14     	; 0x2c9c <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    2c8e:	89 81       	ldd	r24, Y+1	; 0x01
    2c90:	9a 81       	ldd	r25, Y+2	; 0x02
    2c92:	99 87       	std	Y+9, r25	; 0x09
    2c94:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    2c96:	81 e0       	ldi	r24, 0x01	; 1
    2c98:	8b 83       	std	Y+3, r24	; 0x03
    2c9a:	23 c0       	rjmp	.+70     	; 0x2ce2 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2c9c:	88 89       	ldd	r24, Y+16	; 0x10
    2c9e:	88 23       	and	r24, r24
    2ca0:	29 f0       	breq	.+10     	; 0x2cac <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2ca2:	8e 81       	ldd	r24, Y+6	; 0x06
    2ca4:	9f 81       	ldd	r25, Y+7	; 0x07
    2ca6:	91 60       	ori	r25, 0x01	; 1
    2ca8:	9f 83       	std	Y+7, r25	; 0x07
    2caa:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2cac:	89 89       	ldd	r24, Y+17	; 0x11
    2cae:	88 23       	and	r24, r24
    2cb0:	29 f0       	breq	.+10     	; 0x2cbc <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2cb2:	8e 81       	ldd	r24, Y+6	; 0x06
    2cb4:	9f 81       	ldd	r25, Y+7	; 0x07
    2cb6:	94 60       	ori	r25, 0x04	; 4
    2cb8:	9f 83       	std	Y+7, r25	; 0x07
    2cba:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2cbc:	8a 85       	ldd	r24, Y+10	; 0x0a
    2cbe:	9b 85       	ldd	r25, Y+11	; 0x0b
    2cc0:	bc 01       	movw	r22, r24
    2cc2:	6e 5f       	subi	r22, 0xFE	; 254
    2cc4:	7f 4f       	sbci	r23, 0xFF	; 255
    2cc6:	2e 85       	ldd	r18, Y+14	; 0x0e
    2cc8:	3f 85       	ldd	r19, Y+15	; 0x0f
    2cca:	8e 81       	ldd	r24, Y+6	; 0x06
    2ccc:	9f 81       	ldd	r25, Y+7	; 0x07
    2cce:	28 2b       	or	r18, r24
    2cd0:	39 2b       	or	r19, r25
    2cd2:	4a 89       	ldd	r20, Y+18	; 0x12
    2cd4:	5b 89       	ldd	r21, Y+19	; 0x13
    2cd6:	cb 01       	movw	r24, r22
    2cd8:	b9 01       	movw	r22, r18
    2cda:	0e 94 f9 2d 	call	0x5bf2	; 0x5bf2 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    2cde:	19 86       	std	Y+9, r1	; 0x09
    2ce0:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2ce2:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    2ce6:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    2ce8:	8a 89       	ldd	r24, Y+18	; 0x12
    2cea:	9b 89       	ldd	r25, Y+19	; 0x13
    2cec:	00 97       	sbiw	r24, 0x00	; 0
    2cee:	09 f4       	brne	.+2      	; 0x2cf2 <xEventGroupWaitBits+0xfa>
    2cf0:	3c c0       	rjmp	.+120    	; 0x2d6a <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    2cf2:	8c 81       	ldd	r24, Y+4	; 0x04
    2cf4:	88 23       	and	r24, r24
    2cf6:	11 f4       	brne	.+4      	; 0x2cfc <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    2cf8:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2cfc:	0e 94 5a 30 	call	0x60b4	; 0x60b4 <uxTaskResetEventItemValue>
    2d00:	99 87       	std	Y+9, r25	; 0x09
    2d02:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2d04:	88 85       	ldd	r24, Y+8	; 0x08
    2d06:	99 85       	ldd	r25, Y+9	; 0x09
    2d08:	80 70       	andi	r24, 0x00	; 0
    2d0a:	92 70       	andi	r25, 0x02	; 2
    2d0c:	00 97       	sbiw	r24, 0x00	; 0
    2d0e:	41 f5       	brne	.+80     	; 0x2d60 <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    2d10:	0f b6       	in	r0, 0x3f	; 63
    2d12:	f8 94       	cli
    2d14:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2d16:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d18:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d1a:	80 81       	ld	r24, Z
    2d1c:	91 81       	ldd	r25, Z+1	; 0x01
    2d1e:	99 87       	std	Y+9, r25	; 0x09
    2d20:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2d22:	88 85       	ldd	r24, Y+8	; 0x08
    2d24:	99 85       	ldd	r25, Y+9	; 0x09
    2d26:	2e 85       	ldd	r18, Y+14	; 0x0e
    2d28:	3f 85       	ldd	r19, Y+15	; 0x0f
    2d2a:	b9 01       	movw	r22, r18
    2d2c:	49 89       	ldd	r20, Y+17	; 0x11
    2d2e:	0e 94 37 18 	call	0x306e	; 0x306e <prvTestWaitCondition>
    2d32:	88 23       	and	r24, r24
    2d34:	89 f0       	breq	.+34     	; 0x2d58 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    2d36:	88 89       	ldd	r24, Y+16	; 0x10
    2d38:	88 23       	and	r24, r24
    2d3a:	71 f0       	breq	.+28     	; 0x2d58 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2d3c:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d3e:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d40:	20 81       	ld	r18, Z
    2d42:	31 81       	ldd	r19, Z+1	; 0x01
    2d44:	8e 85       	ldd	r24, Y+14	; 0x0e
    2d46:	9f 85       	ldd	r25, Y+15	; 0x0f
    2d48:	80 95       	com	r24
    2d4a:	90 95       	com	r25
    2d4c:	82 23       	and	r24, r18
    2d4e:	93 23       	and	r25, r19
    2d50:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d52:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d54:	91 83       	std	Z+1, r25	; 0x01
    2d56:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    2d58:	81 e0       	ldi	r24, 0x01	; 1
    2d5a:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    2d5c:	0f 90       	pop	r0
    2d5e:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2d60:	88 85       	ldd	r24, Y+8	; 0x08
    2d62:	99 85       	ldd	r25, Y+9	; 0x09
    2d64:	90 70       	andi	r25, 0x00	; 0
    2d66:	99 87       	std	Y+9, r25	; 0x09
    2d68:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    2d6a:	88 85       	ldd	r24, Y+8	; 0x08
    2d6c:	99 85       	ldd	r25, Y+9	; 0x09
}
    2d6e:	63 96       	adiw	r28, 0x13	; 19
    2d70:	0f b6       	in	r0, 0x3f	; 63
    2d72:	f8 94       	cli
    2d74:	de bf       	out	0x3e, r29	; 62
    2d76:	0f be       	out	0x3f, r0	; 63
    2d78:	cd bf       	out	0x3d, r28	; 61
    2d7a:	cf 91       	pop	r28
    2d7c:	df 91       	pop	r29
    2d7e:	1f 91       	pop	r17
    2d80:	0f 91       	pop	r16
    2d82:	08 95       	ret

00002d84 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    2d84:	df 93       	push	r29
    2d86:	cf 93       	push	r28
    2d88:	cd b7       	in	r28, 0x3d	; 61
    2d8a:	de b7       	in	r29, 0x3e	; 62
    2d8c:	28 97       	sbiw	r28, 0x08	; 8
    2d8e:	0f b6       	in	r0, 0x3f	; 63
    2d90:	f8 94       	cli
    2d92:	de bf       	out	0x3e, r29	; 62
    2d94:	0f be       	out	0x3f, r0	; 63
    2d96:	cd bf       	out	0x3d, r28	; 61
    2d98:	9e 83       	std	Y+6, r25	; 0x06
    2d9a:	8d 83       	std	Y+5, r24	; 0x05
    2d9c:	78 87       	std	Y+8, r23	; 0x08
    2d9e:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    2da0:	8d 81       	ldd	r24, Y+5	; 0x05
    2da2:	9e 81       	ldd	r25, Y+6	; 0x06
    2da4:	9c 83       	std	Y+4, r25	; 0x04
    2da6:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    2da8:	0f b6       	in	r0, 0x3f	; 63
    2daa:	f8 94       	cli
    2dac:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2dae:	eb 81       	ldd	r30, Y+3	; 0x03
    2db0:	fc 81       	ldd	r31, Y+4	; 0x04
    2db2:	80 81       	ld	r24, Z
    2db4:	91 81       	ldd	r25, Z+1	; 0x01
    2db6:	9a 83       	std	Y+2, r25	; 0x02
    2db8:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2dba:	eb 81       	ldd	r30, Y+3	; 0x03
    2dbc:	fc 81       	ldd	r31, Y+4	; 0x04
    2dbe:	20 81       	ld	r18, Z
    2dc0:	31 81       	ldd	r19, Z+1	; 0x01
    2dc2:	8f 81       	ldd	r24, Y+7	; 0x07
    2dc4:	98 85       	ldd	r25, Y+8	; 0x08
    2dc6:	80 95       	com	r24
    2dc8:	90 95       	com	r25
    2dca:	82 23       	and	r24, r18
    2dcc:	93 23       	and	r25, r19
    2dce:	eb 81       	ldd	r30, Y+3	; 0x03
    2dd0:	fc 81       	ldd	r31, Y+4	; 0x04
    2dd2:	91 83       	std	Z+1, r25	; 0x01
    2dd4:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    2dd6:	0f 90       	pop	r0
    2dd8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2dda:	89 81       	ldd	r24, Y+1	; 0x01
    2ddc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2dde:	28 96       	adiw	r28, 0x08	; 8
    2de0:	0f b6       	in	r0, 0x3f	; 63
    2de2:	f8 94       	cli
    2de4:	de bf       	out	0x3e, r29	; 62
    2de6:	0f be       	out	0x3f, r0	; 63
    2de8:	cd bf       	out	0x3d, r28	; 61
    2dea:	cf 91       	pop	r28
    2dec:	df 91       	pop	r29
    2dee:	08 95       	ret

00002df0 <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2df0:	df 93       	push	r29
    2df2:	cf 93       	push	r28
    2df4:	cd b7       	in	r28, 0x3d	; 61
    2df6:	de b7       	in	r29, 0x3e	; 62
    2df8:	27 97       	sbiw	r28, 0x07	; 7
    2dfa:	0f b6       	in	r0, 0x3f	; 63
    2dfc:	f8 94       	cli
    2dfe:	de bf       	out	0x3e, r29	; 62
    2e00:	0f be       	out	0x3f, r0	; 63
    2e02:	cd bf       	out	0x3d, r28	; 61
    2e04:	9f 83       	std	Y+7, r25	; 0x07
    2e06:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    2e08:	8e 81       	ldd	r24, Y+6	; 0x06
    2e0a:	9f 81       	ldd	r25, Y+7	; 0x07
    2e0c:	9c 83       	std	Y+4, r25	; 0x04
    2e0e:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2e10:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    2e12:	eb 81       	ldd	r30, Y+3	; 0x03
    2e14:	fc 81       	ldd	r31, Y+4	; 0x04
    2e16:	80 81       	ld	r24, Z
    2e18:	91 81       	ldd	r25, Z+1	; 0x01
    2e1a:	9a 83       	std	Y+2, r25	; 0x02
    2e1c:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    2e1e:	89 81       	ldd	r24, Y+1	; 0x01
    2e20:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2e22:	27 96       	adiw	r28, 0x07	; 7
    2e24:	0f b6       	in	r0, 0x3f	; 63
    2e26:	f8 94       	cli
    2e28:	de bf       	out	0x3e, r29	; 62
    2e2a:	0f be       	out	0x3f, r0	; 63
    2e2c:	cd bf       	out	0x3d, r28	; 61
    2e2e:	cf 91       	pop	r28
    2e30:	df 91       	pop	r29
    2e32:	08 95       	ret

00002e34 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2e34:	df 93       	push	r29
    2e36:	cf 93       	push	r28
    2e38:	cd b7       	in	r28, 0x3d	; 61
    2e3a:	de b7       	in	r29, 0x3e	; 62
    2e3c:	65 97       	sbiw	r28, 0x15	; 21
    2e3e:	0f b6       	in	r0, 0x3f	; 63
    2e40:	f8 94       	cli
    2e42:	de bf       	out	0x3e, r29	; 62
    2e44:	0f be       	out	0x3f, r0	; 63
    2e46:	cd bf       	out	0x3d, r28	; 61
    2e48:	9b 8b       	std	Y+19, r25	; 0x13
    2e4a:	8a 8b       	std	Y+18, r24	; 0x12
    2e4c:	7d 8b       	std	Y+21, r23	; 0x15
    2e4e:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2e50:	19 86       	std	Y+9, r1	; 0x09
    2e52:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    2e54:	8a 89       	ldd	r24, Y+18	; 0x12
    2e56:	9b 89       	ldd	r25, Y+19	; 0x13
    2e58:	9b 83       	std	Y+3, r25	; 0x03
    2e5a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    2e5c:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    2e5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e60:	9b 81       	ldd	r25, Y+3	; 0x03
    2e62:	02 96       	adiw	r24, 0x02	; 2
    2e64:	9b 87       	std	Y+11, r25	; 0x0b
    2e66:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2e68:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e6a:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e6c:	03 96       	adiw	r24, 0x03	; 3
    2e6e:	9d 87       	std	Y+13, r25	; 0x0d
    2e70:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    2e72:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2e76:	ea 85       	ldd	r30, Y+10	; 0x0a
    2e78:	fb 85       	ldd	r31, Y+11	; 0x0b
    2e7a:	85 81       	ldd	r24, Z+5	; 0x05
    2e7c:	96 81       	ldd	r25, Z+6	; 0x06
    2e7e:	99 8b       	std	Y+17, r25	; 0x11
    2e80:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    2e82:	ea 81       	ldd	r30, Y+2	; 0x02
    2e84:	fb 81       	ldd	r31, Y+3	; 0x03
    2e86:	20 81       	ld	r18, Z
    2e88:	31 81       	ldd	r19, Z+1	; 0x01
    2e8a:	8c 89       	ldd	r24, Y+20	; 0x14
    2e8c:	9d 89       	ldd	r25, Y+21	; 0x15
    2e8e:	82 2b       	or	r24, r18
    2e90:	93 2b       	or	r25, r19
    2e92:	ea 81       	ldd	r30, Y+2	; 0x02
    2e94:	fb 81       	ldd	r31, Y+3	; 0x03
    2e96:	91 83       	std	Z+1, r25	; 0x01
    2e98:	80 83       	st	Z, r24
    2e9a:	59 c0       	rjmp	.+178    	; 0x2f4e <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    2e9c:	e8 89       	ldd	r30, Y+16	; 0x10
    2e9e:	f9 89       	ldd	r31, Y+17	; 0x11
    2ea0:	82 81       	ldd	r24, Z+2	; 0x02
    2ea2:	93 81       	ldd	r25, Z+3	; 0x03
    2ea4:	9f 87       	std	Y+15, r25	; 0x0f
    2ea6:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2ea8:	e8 89       	ldd	r30, Y+16	; 0x10
    2eaa:	f9 89       	ldd	r31, Y+17	; 0x11
    2eac:	80 81       	ld	r24, Z
    2eae:	91 81       	ldd	r25, Z+1	; 0x01
    2eb0:	9f 83       	std	Y+7, r25	; 0x07
    2eb2:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    2eb4:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2eb6:	8e 81       	ldd	r24, Y+6	; 0x06
    2eb8:	9f 81       	ldd	r25, Y+7	; 0x07
    2eba:	80 70       	andi	r24, 0x00	; 0
    2ebc:	9d 83       	std	Y+5, r25	; 0x05
    2ebe:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2ec0:	8e 81       	ldd	r24, Y+6	; 0x06
    2ec2:	9f 81       	ldd	r25, Y+7	; 0x07
    2ec4:	90 70       	andi	r25, 0x00	; 0
    2ec6:	9f 83       	std	Y+7, r25	; 0x07
    2ec8:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2eca:	8c 81       	ldd	r24, Y+4	; 0x04
    2ecc:	9d 81       	ldd	r25, Y+5	; 0x05
    2ece:	80 70       	andi	r24, 0x00	; 0
    2ed0:	94 70       	andi	r25, 0x04	; 4
    2ed2:	00 97       	sbiw	r24, 0x00	; 0
    2ed4:	69 f4       	brne	.+26     	; 0x2ef0 <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2ed6:	ea 81       	ldd	r30, Y+2	; 0x02
    2ed8:	fb 81       	ldd	r31, Y+3	; 0x03
    2eda:	20 81       	ld	r18, Z
    2edc:	31 81       	ldd	r19, Z+1	; 0x01
    2ede:	8e 81       	ldd	r24, Y+6	; 0x06
    2ee0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ee2:	82 23       	and	r24, r18
    2ee4:	93 23       	and	r25, r19
    2ee6:	00 97       	sbiw	r24, 0x00	; 0
    2ee8:	91 f0       	breq	.+36     	; 0x2f0e <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    2eea:	81 e0       	ldi	r24, 0x01	; 1
    2eec:	89 83       	std	Y+1, r24	; 0x01
    2eee:	0f c0       	rjmp	.+30     	; 0x2f0e <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    2ef0:	ea 81       	ldd	r30, Y+2	; 0x02
    2ef2:	fb 81       	ldd	r31, Y+3	; 0x03
    2ef4:	20 81       	ld	r18, Z
    2ef6:	31 81       	ldd	r19, Z+1	; 0x01
    2ef8:	8e 81       	ldd	r24, Y+6	; 0x06
    2efa:	9f 81       	ldd	r25, Y+7	; 0x07
    2efc:	28 23       	and	r18, r24
    2efe:	39 23       	and	r19, r25
    2f00:	8e 81       	ldd	r24, Y+6	; 0x06
    2f02:	9f 81       	ldd	r25, Y+7	; 0x07
    2f04:	28 17       	cp	r18, r24
    2f06:	39 07       	cpc	r19, r25
    2f08:	11 f4       	brne	.+4      	; 0x2f0e <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    2f0a:	81 e0       	ldi	r24, 0x01	; 1
    2f0c:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    2f0e:	89 81       	ldd	r24, Y+1	; 0x01
    2f10:	88 23       	and	r24, r24
    2f12:	c9 f0       	breq	.+50     	; 0x2f46 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2f14:	8c 81       	ldd	r24, Y+4	; 0x04
    2f16:	9d 81       	ldd	r25, Y+5	; 0x05
    2f18:	80 70       	andi	r24, 0x00	; 0
    2f1a:	91 70       	andi	r25, 0x01	; 1
    2f1c:	00 97       	sbiw	r24, 0x00	; 0
    2f1e:	41 f0       	breq	.+16     	; 0x2f30 <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    2f20:	88 85       	ldd	r24, Y+8	; 0x08
    2f22:	99 85       	ldd	r25, Y+9	; 0x09
    2f24:	2e 81       	ldd	r18, Y+6	; 0x06
    2f26:	3f 81       	ldd	r19, Y+7	; 0x07
    2f28:	82 2b       	or	r24, r18
    2f2a:	93 2b       	or	r25, r19
    2f2c:	99 87       	std	Y+9, r25	; 0x09
    2f2e:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2f30:	ea 81       	ldd	r30, Y+2	; 0x02
    2f32:	fb 81       	ldd	r31, Y+3	; 0x03
    2f34:	80 81       	ld	r24, Z
    2f36:	91 81       	ldd	r25, Z+1	; 0x01
    2f38:	9c 01       	movw	r18, r24
    2f3a:	32 60       	ori	r19, 0x02	; 2
    2f3c:	88 89       	ldd	r24, Y+16	; 0x10
    2f3e:	99 89       	ldd	r25, Y+17	; 0x11
    2f40:	b9 01       	movw	r22, r18
    2f42:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    2f46:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f48:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f4a:	99 8b       	std	Y+17, r25	; 0x11
    2f4c:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2f4e:	28 89       	ldd	r18, Y+16	; 0x10
    2f50:	39 89       	ldd	r19, Y+17	; 0x11
    2f52:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f54:	9d 85       	ldd	r25, Y+13	; 0x0d
    2f56:	28 17       	cp	r18, r24
    2f58:	39 07       	cpc	r19, r25
    2f5a:	09 f0       	breq	.+2      	; 0x2f5e <xEventGroupSetBits+0x12a>
    2f5c:	9f cf       	rjmp	.-194    	; 0x2e9c <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2f5e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f60:	fb 81       	ldd	r31, Y+3	; 0x03
    2f62:	20 81       	ld	r18, Z
    2f64:	31 81       	ldd	r19, Z+1	; 0x01
    2f66:	88 85       	ldd	r24, Y+8	; 0x08
    2f68:	99 85       	ldd	r25, Y+9	; 0x09
    2f6a:	80 95       	com	r24
    2f6c:	90 95       	com	r25
    2f6e:	82 23       	and	r24, r18
    2f70:	93 23       	and	r25, r19
    2f72:	ea 81       	ldd	r30, Y+2	; 0x02
    2f74:	fb 81       	ldd	r31, Y+3	; 0x03
    2f76:	91 83       	std	Z+1, r25	; 0x01
    2f78:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    2f7a:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    2f7e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f80:	fb 81       	ldd	r31, Y+3	; 0x03
    2f82:	80 81       	ld	r24, Z
    2f84:	91 81       	ldd	r25, Z+1	; 0x01
}
    2f86:	65 96       	adiw	r28, 0x15	; 21
    2f88:	0f b6       	in	r0, 0x3f	; 63
    2f8a:	f8 94       	cli
    2f8c:	de bf       	out	0x3e, r29	; 62
    2f8e:	0f be       	out	0x3f, r0	; 63
    2f90:	cd bf       	out	0x3d, r28	; 61
    2f92:	cf 91       	pop	r28
    2f94:	df 91       	pop	r29
    2f96:	08 95       	ret

00002f98 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2f98:	df 93       	push	r29
    2f9a:	cf 93       	push	r28
    2f9c:	00 d0       	rcall	.+0      	; 0x2f9e <vEventGroupDelete+0x6>
    2f9e:	00 d0       	rcall	.+0      	; 0x2fa0 <vEventGroupDelete+0x8>
    2fa0:	00 d0       	rcall	.+0      	; 0x2fa2 <vEventGroupDelete+0xa>
    2fa2:	cd b7       	in	r28, 0x3d	; 61
    2fa4:	de b7       	in	r29, 0x3e	; 62
    2fa6:	9e 83       	std	Y+6, r25	; 0x06
    2fa8:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    2faa:	8d 81       	ldd	r24, Y+5	; 0x05
    2fac:	9e 81       	ldd	r25, Y+6	; 0x06
    2fae:	9c 83       	std	Y+4, r25	; 0x04
    2fb0:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2fb2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb6:	02 96       	adiw	r24, 0x02	; 2
    2fb8:	9a 83       	std	Y+2, r25	; 0x02
    2fba:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    2fbc:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
    2fc0:	08 c0       	rjmp	.+16     	; 0x2fd2 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fc6:	85 81       	ldd	r24, Z+5	; 0x05
    2fc8:	96 81       	ldd	r25, Z+6	; 0x06
    2fca:	60 e0       	ldi	r22, 0x00	; 0
    2fcc:	72 e0       	ldi	r23, 0x02	; 2
    2fce:	0e 94 94 2e 	call	0x5d28	; 0x5d28 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2fd2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fd4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd6:	80 81       	ld	r24, Z
    2fd8:	88 23       	and	r24, r24
    2fda:	99 f7       	brne	.-26     	; 0x2fc2 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    2fdc:	8b 81       	ldd	r24, Y+3	; 0x03
    2fde:	9c 81       	ldd	r25, Y+4	; 0x04
    2fe0:	0e 94 bf 18 	call	0x317e	; 0x317e <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    2fe4:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
}
    2fe8:	26 96       	adiw	r28, 0x06	; 6
    2fea:	0f b6       	in	r0, 0x3f	; 63
    2fec:	f8 94       	cli
    2fee:	de bf       	out	0x3e, r29	; 62
    2ff0:	0f be       	out	0x3f, r0	; 63
    2ff2:	cd bf       	out	0x3d, r28	; 61
    2ff4:	cf 91       	pop	r28
    2ff6:	df 91       	pop	r29
    2ff8:	08 95       	ret

00002ffa <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    2ffa:	df 93       	push	r29
    2ffc:	cf 93       	push	r28
    2ffe:	00 d0       	rcall	.+0      	; 0x3000 <vEventGroupSetBitsCallback+0x6>
    3000:	00 d0       	rcall	.+0      	; 0x3002 <vEventGroupSetBitsCallback+0x8>
    3002:	00 d0       	rcall	.+0      	; 0x3004 <vEventGroupSetBitsCallback+0xa>
    3004:	cd b7       	in	r28, 0x3d	; 61
    3006:	de b7       	in	r29, 0x3e	; 62
    3008:	9a 83       	std	Y+2, r25	; 0x02
    300a:	89 83       	std	Y+1, r24	; 0x01
    300c:	4b 83       	std	Y+3, r20	; 0x03
    300e:	5c 83       	std	Y+4, r21	; 0x04
    3010:	6d 83       	std	Y+5, r22	; 0x05
    3012:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    3014:	89 81       	ldd	r24, Y+1	; 0x01
    3016:	9a 81       	ldd	r25, Y+2	; 0x02
    3018:	2b 81       	ldd	r18, Y+3	; 0x03
    301a:	3c 81       	ldd	r19, Y+4	; 0x04
    301c:	b9 01       	movw	r22, r18
    301e:	0e 94 1a 17 	call	0x2e34	; 0x2e34 <xEventGroupSetBits>
}
    3022:	26 96       	adiw	r28, 0x06	; 6
    3024:	0f b6       	in	r0, 0x3f	; 63
    3026:	f8 94       	cli
    3028:	de bf       	out	0x3e, r29	; 62
    302a:	0f be       	out	0x3f, r0	; 63
    302c:	cd bf       	out	0x3d, r28	; 61
    302e:	cf 91       	pop	r28
    3030:	df 91       	pop	r29
    3032:	08 95       	ret

00003034 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    3034:	df 93       	push	r29
    3036:	cf 93       	push	r28
    3038:	00 d0       	rcall	.+0      	; 0x303a <vEventGroupClearBitsCallback+0x6>
    303a:	00 d0       	rcall	.+0      	; 0x303c <vEventGroupClearBitsCallback+0x8>
    303c:	00 d0       	rcall	.+0      	; 0x303e <vEventGroupClearBitsCallback+0xa>
    303e:	cd b7       	in	r28, 0x3d	; 61
    3040:	de b7       	in	r29, 0x3e	; 62
    3042:	9a 83       	std	Y+2, r25	; 0x02
    3044:	89 83       	std	Y+1, r24	; 0x01
    3046:	4b 83       	std	Y+3, r20	; 0x03
    3048:	5c 83       	std	Y+4, r21	; 0x04
    304a:	6d 83       	std	Y+5, r22	; 0x05
    304c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    304e:	89 81       	ldd	r24, Y+1	; 0x01
    3050:	9a 81       	ldd	r25, Y+2	; 0x02
    3052:	2b 81       	ldd	r18, Y+3	; 0x03
    3054:	3c 81       	ldd	r19, Y+4	; 0x04
    3056:	b9 01       	movw	r22, r18
    3058:	0e 94 c2 16 	call	0x2d84	; 0x2d84 <xEventGroupClearBits>
}
    305c:	26 96       	adiw	r28, 0x06	; 6
    305e:	0f b6       	in	r0, 0x3f	; 63
    3060:	f8 94       	cli
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	cd bf       	out	0x3d, r28	; 61
    3068:	cf 91       	pop	r28
    306a:	df 91       	pop	r29
    306c:	08 95       	ret

0000306e <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    306e:	df 93       	push	r29
    3070:	cf 93       	push	r28
    3072:	00 d0       	rcall	.+0      	; 0x3074 <prvTestWaitCondition+0x6>
    3074:	00 d0       	rcall	.+0      	; 0x3076 <prvTestWaitCondition+0x8>
    3076:	00 d0       	rcall	.+0      	; 0x3078 <prvTestWaitCondition+0xa>
    3078:	cd b7       	in	r28, 0x3d	; 61
    307a:	de b7       	in	r29, 0x3e	; 62
    307c:	9b 83       	std	Y+3, r25	; 0x03
    307e:	8a 83       	std	Y+2, r24	; 0x02
    3080:	7d 83       	std	Y+5, r23	; 0x05
    3082:	6c 83       	std	Y+4, r22	; 0x04
    3084:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    3086:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    3088:	8e 81       	ldd	r24, Y+6	; 0x06
    308a:	88 23       	and	r24, r24
    308c:	59 f4       	brne	.+22     	; 0x30a4 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    308e:	8a 81       	ldd	r24, Y+2	; 0x02
    3090:	9b 81       	ldd	r25, Y+3	; 0x03
    3092:	2c 81       	ldd	r18, Y+4	; 0x04
    3094:	3d 81       	ldd	r19, Y+5	; 0x05
    3096:	82 23       	and	r24, r18
    3098:	93 23       	and	r25, r19
    309a:	00 97       	sbiw	r24, 0x00	; 0
    309c:	81 f0       	breq	.+32     	; 0x30be <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    309e:	81 e0       	ldi	r24, 0x01	; 1
    30a0:	89 83       	std	Y+1, r24	; 0x01
    30a2:	0d c0       	rjmp	.+26     	; 0x30be <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    30a4:	2a 81       	ldd	r18, Y+2	; 0x02
    30a6:	3b 81       	ldd	r19, Y+3	; 0x03
    30a8:	8c 81       	ldd	r24, Y+4	; 0x04
    30aa:	9d 81       	ldd	r25, Y+5	; 0x05
    30ac:	28 23       	and	r18, r24
    30ae:	39 23       	and	r19, r25
    30b0:	8c 81       	ldd	r24, Y+4	; 0x04
    30b2:	9d 81       	ldd	r25, Y+5	; 0x05
    30b4:	28 17       	cp	r18, r24
    30b6:	39 07       	cpc	r19, r25
    30b8:	11 f4       	brne	.+4      	; 0x30be <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    30ba:	81 e0       	ldi	r24, 0x01	; 1
    30bc:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    30be:	89 81       	ldd	r24, Y+1	; 0x01
}
    30c0:	26 96       	adiw	r28, 0x06	; 6
    30c2:	0f b6       	in	r0, 0x3f	; 63
    30c4:	f8 94       	cli
    30c6:	de bf       	out	0x3e, r29	; 62
    30c8:	0f be       	out	0x3f, r0	; 63
    30ca:	cd bf       	out	0x3d, r28	; 61
    30cc:	cf 91       	pop	r28
    30ce:	df 91       	pop	r29
    30d0:	08 95       	ret

000030d2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    30d2:	df 93       	push	r29
    30d4:	cf 93       	push	r28
    30d6:	00 d0       	rcall	.+0      	; 0x30d8 <pvPortMalloc+0x6>
    30d8:	00 d0       	rcall	.+0      	; 0x30da <pvPortMalloc+0x8>
    30da:	cd b7       	in	r28, 0x3d	; 61
    30dc:	de b7       	in	r29, 0x3e	; 62
    30de:	9c 83       	std	Y+4, r25	; 0x04
    30e0:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    30e2:	1a 82       	std	Y+2, r1	; 0x02
    30e4:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    30e6:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    30ea:	80 91 88 00 	lds	r24, 0x0088
    30ee:	90 91 89 00 	lds	r25, 0x0089
    30f2:	00 97       	sbiw	r24, 0x00	; 0
    30f4:	31 f4       	brne	.+12     	; 0x3102 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    30f6:	8b e8       	ldi	r24, 0x8B	; 139
    30f8:	90 e0       	ldi	r25, 0x00	; 0
    30fa:	90 93 89 00 	sts	0x0089, r25
    30fe:	80 93 88 00 	sts	0x0088, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    3102:	80 91 86 00 	lds	r24, 0x0086
    3106:	90 91 87 00 	lds	r25, 0x0087
    310a:	2b 81       	ldd	r18, Y+3	; 0x03
    310c:	3c 81       	ldd	r19, Y+4	; 0x04
    310e:	82 0f       	add	r24, r18
    3110:	93 1f       	adc	r25, r19
    3112:	23 e0       	ldi	r18, 0x03	; 3
    3114:	87 3e       	cpi	r24, 0xE7	; 231
    3116:	92 07       	cpc	r25, r18
    3118:	38 f5       	brcc	.+78     	; 0x3168 <pvPortMalloc+0x96>
    311a:	20 91 86 00 	lds	r18, 0x0086
    311e:	30 91 87 00 	lds	r19, 0x0087
    3122:	8b 81       	ldd	r24, Y+3	; 0x03
    3124:	9c 81       	ldd	r25, Y+4	; 0x04
    3126:	28 0f       	add	r18, r24
    3128:	39 1f       	adc	r19, r25
    312a:	80 91 86 00 	lds	r24, 0x0086
    312e:	90 91 87 00 	lds	r25, 0x0087
    3132:	82 17       	cp	r24, r18
    3134:	93 07       	cpc	r25, r19
    3136:	c0 f4       	brcc	.+48     	; 0x3168 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    3138:	20 91 88 00 	lds	r18, 0x0088
    313c:	30 91 89 00 	lds	r19, 0x0089
    3140:	80 91 86 00 	lds	r24, 0x0086
    3144:	90 91 87 00 	lds	r25, 0x0087
    3148:	82 0f       	add	r24, r18
    314a:	93 1f       	adc	r25, r19
    314c:	9a 83       	std	Y+2, r25	; 0x02
    314e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    3150:	20 91 86 00 	lds	r18, 0x0086
    3154:	30 91 87 00 	lds	r19, 0x0087
    3158:	8b 81       	ldd	r24, Y+3	; 0x03
    315a:	9c 81       	ldd	r25, Y+4	; 0x04
    315c:	82 0f       	add	r24, r18
    315e:	93 1f       	adc	r25, r19
    3160:	90 93 87 00 	sts	0x0087, r25
    3164:	80 93 86 00 	sts	0x0086, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    3168:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    316c:	89 81       	ldd	r24, Y+1	; 0x01
    316e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3170:	0f 90       	pop	r0
    3172:	0f 90       	pop	r0
    3174:	0f 90       	pop	r0
    3176:	0f 90       	pop	r0
    3178:	cf 91       	pop	r28
    317a:	df 91       	pop	r29
    317c:	08 95       	ret

0000317e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    317e:	df 93       	push	r29
    3180:	cf 93       	push	r28
    3182:	00 d0       	rcall	.+0      	; 0x3184 <vPortFree+0x6>
    3184:	cd b7       	in	r28, 0x3d	; 61
    3186:	de b7       	in	r29, 0x3e	; 62
    3188:	9a 83       	std	Y+2, r25	; 0x02
    318a:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    318c:	0f 90       	pop	r0
    318e:	0f 90       	pop	r0
    3190:	cf 91       	pop	r28
    3192:	df 91       	pop	r29
    3194:	08 95       	ret

00003196 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    3196:	df 93       	push	r29
    3198:	cf 93       	push	r28
    319a:	cd b7       	in	r28, 0x3d	; 61
    319c:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    319e:	10 92 87 00 	sts	0x0087, r1
    31a2:	10 92 86 00 	sts	0x0086, r1
}
    31a6:	cf 91       	pop	r28
    31a8:	df 91       	pop	r29
    31aa:	08 95       	ret

000031ac <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    31ac:	df 93       	push	r29
    31ae:	cf 93       	push	r28
    31b0:	cd b7       	in	r28, 0x3d	; 61
    31b2:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    31b4:	20 91 86 00 	lds	r18, 0x0086
    31b8:	30 91 87 00 	lds	r19, 0x0087
    31bc:	87 ee       	ldi	r24, 0xE7	; 231
    31be:	93 e0       	ldi	r25, 0x03	; 3
    31c0:	82 1b       	sub	r24, r18
    31c2:	93 0b       	sbc	r25, r19
}
    31c4:	cf 91       	pop	r28
    31c6:	df 91       	pop	r29
    31c8:	08 95       	ret

000031ca <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    31ca:	df 93       	push	r29
    31cc:	cf 93       	push	r28
    31ce:	00 d0       	rcall	.+0      	; 0x31d0 <vListInitialise+0x6>
    31d0:	cd b7       	in	r28, 0x3d	; 61
    31d2:	de b7       	in	r29, 0x3e	; 62
    31d4:	9a 83       	std	Y+2, r25	; 0x02
    31d6:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    31d8:	89 81       	ldd	r24, Y+1	; 0x01
    31da:	9a 81       	ldd	r25, Y+2	; 0x02
    31dc:	03 96       	adiw	r24, 0x03	; 3
    31de:	e9 81       	ldd	r30, Y+1	; 0x01
    31e0:	fa 81       	ldd	r31, Y+2	; 0x02
    31e2:	92 83       	std	Z+2, r25	; 0x02
    31e4:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    31e6:	e9 81       	ldd	r30, Y+1	; 0x01
    31e8:	fa 81       	ldd	r31, Y+2	; 0x02
    31ea:	8f ef       	ldi	r24, 0xFF	; 255
    31ec:	9f ef       	ldi	r25, 0xFF	; 255
    31ee:	94 83       	std	Z+4, r25	; 0x04
    31f0:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    31f2:	89 81       	ldd	r24, Y+1	; 0x01
    31f4:	9a 81       	ldd	r25, Y+2	; 0x02
    31f6:	03 96       	adiw	r24, 0x03	; 3
    31f8:	e9 81       	ldd	r30, Y+1	; 0x01
    31fa:	fa 81       	ldd	r31, Y+2	; 0x02
    31fc:	96 83       	std	Z+6, r25	; 0x06
    31fe:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3200:	89 81       	ldd	r24, Y+1	; 0x01
    3202:	9a 81       	ldd	r25, Y+2	; 0x02
    3204:	03 96       	adiw	r24, 0x03	; 3
    3206:	e9 81       	ldd	r30, Y+1	; 0x01
    3208:	fa 81       	ldd	r31, Y+2	; 0x02
    320a:	90 87       	std	Z+8, r25	; 0x08
    320c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    320e:	e9 81       	ldd	r30, Y+1	; 0x01
    3210:	fa 81       	ldd	r31, Y+2	; 0x02
    3212:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    3214:	0f 90       	pop	r0
    3216:	0f 90       	pop	r0
    3218:	cf 91       	pop	r28
    321a:	df 91       	pop	r29
    321c:	08 95       	ret

0000321e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    321e:	df 93       	push	r29
    3220:	cf 93       	push	r28
    3222:	00 d0       	rcall	.+0      	; 0x3224 <vListInitialiseItem+0x6>
    3224:	cd b7       	in	r28, 0x3d	; 61
    3226:	de b7       	in	r29, 0x3e	; 62
    3228:	9a 83       	std	Y+2, r25	; 0x02
    322a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    322c:	e9 81       	ldd	r30, Y+1	; 0x01
    322e:	fa 81       	ldd	r31, Y+2	; 0x02
    3230:	11 86       	std	Z+9, r1	; 0x09
    3232:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    3234:	0f 90       	pop	r0
    3236:	0f 90       	pop	r0
    3238:	cf 91       	pop	r28
    323a:	df 91       	pop	r29
    323c:	08 95       	ret

0000323e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    323e:	df 93       	push	r29
    3240:	cf 93       	push	r28
    3242:	00 d0       	rcall	.+0      	; 0x3244 <vListInsertEnd+0x6>
    3244:	00 d0       	rcall	.+0      	; 0x3246 <vListInsertEnd+0x8>
    3246:	00 d0       	rcall	.+0      	; 0x3248 <vListInsertEnd+0xa>
    3248:	cd b7       	in	r28, 0x3d	; 61
    324a:	de b7       	in	r29, 0x3e	; 62
    324c:	9c 83       	std	Y+4, r25	; 0x04
    324e:	8b 83       	std	Y+3, r24	; 0x03
    3250:	7e 83       	std	Y+6, r23	; 0x06
    3252:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    3254:	eb 81       	ldd	r30, Y+3	; 0x03
    3256:	fc 81       	ldd	r31, Y+4	; 0x04
    3258:	81 81       	ldd	r24, Z+1	; 0x01
    325a:	92 81       	ldd	r25, Z+2	; 0x02
    325c:	9a 83       	std	Y+2, r25	; 0x02
    325e:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    3260:	ed 81       	ldd	r30, Y+5	; 0x05
    3262:	fe 81       	ldd	r31, Y+6	; 0x06
    3264:	89 81       	ldd	r24, Y+1	; 0x01
    3266:	9a 81       	ldd	r25, Y+2	; 0x02
    3268:	93 83       	std	Z+3, r25	; 0x03
    326a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    326c:	e9 81       	ldd	r30, Y+1	; 0x01
    326e:	fa 81       	ldd	r31, Y+2	; 0x02
    3270:	84 81       	ldd	r24, Z+4	; 0x04
    3272:	95 81       	ldd	r25, Z+5	; 0x05
    3274:	ed 81       	ldd	r30, Y+5	; 0x05
    3276:	fe 81       	ldd	r31, Y+6	; 0x06
    3278:	95 83       	std	Z+5, r25	; 0x05
    327a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    327c:	e9 81       	ldd	r30, Y+1	; 0x01
    327e:	fa 81       	ldd	r31, Y+2	; 0x02
    3280:	04 80       	ldd	r0, Z+4	; 0x04
    3282:	f5 81       	ldd	r31, Z+5	; 0x05
    3284:	e0 2d       	mov	r30, r0
    3286:	8d 81       	ldd	r24, Y+5	; 0x05
    3288:	9e 81       	ldd	r25, Y+6	; 0x06
    328a:	93 83       	std	Z+3, r25	; 0x03
    328c:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    328e:	e9 81       	ldd	r30, Y+1	; 0x01
    3290:	fa 81       	ldd	r31, Y+2	; 0x02
    3292:	8d 81       	ldd	r24, Y+5	; 0x05
    3294:	9e 81       	ldd	r25, Y+6	; 0x06
    3296:	95 83       	std	Z+5, r25	; 0x05
    3298:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    329a:	ed 81       	ldd	r30, Y+5	; 0x05
    329c:	fe 81       	ldd	r31, Y+6	; 0x06
    329e:	8b 81       	ldd	r24, Y+3	; 0x03
    32a0:	9c 81       	ldd	r25, Y+4	; 0x04
    32a2:	91 87       	std	Z+9, r25	; 0x09
    32a4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    32a6:	eb 81       	ldd	r30, Y+3	; 0x03
    32a8:	fc 81       	ldd	r31, Y+4	; 0x04
    32aa:	80 81       	ld	r24, Z
    32ac:	8f 5f       	subi	r24, 0xFF	; 255
    32ae:	eb 81       	ldd	r30, Y+3	; 0x03
    32b0:	fc 81       	ldd	r31, Y+4	; 0x04
    32b2:	80 83       	st	Z, r24
}
    32b4:	26 96       	adiw	r28, 0x06	; 6
    32b6:	0f b6       	in	r0, 0x3f	; 63
    32b8:	f8 94       	cli
    32ba:	de bf       	out	0x3e, r29	; 62
    32bc:	0f be       	out	0x3f, r0	; 63
    32be:	cd bf       	out	0x3d, r28	; 61
    32c0:	cf 91       	pop	r28
    32c2:	df 91       	pop	r29
    32c4:	08 95       	ret

000032c6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    32c6:	df 93       	push	r29
    32c8:	cf 93       	push	r28
    32ca:	cd b7       	in	r28, 0x3d	; 61
    32cc:	de b7       	in	r29, 0x3e	; 62
    32ce:	28 97       	sbiw	r28, 0x08	; 8
    32d0:	0f b6       	in	r0, 0x3f	; 63
    32d2:	f8 94       	cli
    32d4:	de bf       	out	0x3e, r29	; 62
    32d6:	0f be       	out	0x3f, r0	; 63
    32d8:	cd bf       	out	0x3d, r28	; 61
    32da:	9e 83       	std	Y+6, r25	; 0x06
    32dc:	8d 83       	std	Y+5, r24	; 0x05
    32de:	78 87       	std	Y+8, r23	; 0x08
    32e0:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    32e2:	ef 81       	ldd	r30, Y+7	; 0x07
    32e4:	f8 85       	ldd	r31, Y+8	; 0x08
    32e6:	80 81       	ld	r24, Z
    32e8:	91 81       	ldd	r25, Z+1	; 0x01
    32ea:	9a 83       	std	Y+2, r25	; 0x02
    32ec:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    32ee:	89 81       	ldd	r24, Y+1	; 0x01
    32f0:	9a 81       	ldd	r25, Y+2	; 0x02
    32f2:	2f ef       	ldi	r18, 0xFF	; 255
    32f4:	8f 3f       	cpi	r24, 0xFF	; 255
    32f6:	92 07       	cpc	r25, r18
    32f8:	39 f4       	brne	.+14     	; 0x3308 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    32fa:	ed 81       	ldd	r30, Y+5	; 0x05
    32fc:	fe 81       	ldd	r31, Y+6	; 0x06
    32fe:	87 81       	ldd	r24, Z+7	; 0x07
    3300:	90 85       	ldd	r25, Z+8	; 0x08
    3302:	9c 83       	std	Y+4, r25	; 0x04
    3304:	8b 83       	std	Y+3, r24	; 0x03
    3306:	18 c0       	rjmp	.+48     	; 0x3338 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3308:	8d 81       	ldd	r24, Y+5	; 0x05
    330a:	9e 81       	ldd	r25, Y+6	; 0x06
    330c:	03 96       	adiw	r24, 0x03	; 3
    330e:	9c 83       	std	Y+4, r25	; 0x04
    3310:	8b 83       	std	Y+3, r24	; 0x03
    3312:	06 c0       	rjmp	.+12     	; 0x3320 <vListInsert+0x5a>
    3314:	eb 81       	ldd	r30, Y+3	; 0x03
    3316:	fc 81       	ldd	r31, Y+4	; 0x04
    3318:	82 81       	ldd	r24, Z+2	; 0x02
    331a:	93 81       	ldd	r25, Z+3	; 0x03
    331c:	9c 83       	std	Y+4, r25	; 0x04
    331e:	8b 83       	std	Y+3, r24	; 0x03
    3320:	eb 81       	ldd	r30, Y+3	; 0x03
    3322:	fc 81       	ldd	r31, Y+4	; 0x04
    3324:	02 80       	ldd	r0, Z+2	; 0x02
    3326:	f3 81       	ldd	r31, Z+3	; 0x03
    3328:	e0 2d       	mov	r30, r0
    332a:	20 81       	ld	r18, Z
    332c:	31 81       	ldd	r19, Z+1	; 0x01
    332e:	89 81       	ldd	r24, Y+1	; 0x01
    3330:	9a 81       	ldd	r25, Y+2	; 0x02
    3332:	82 17       	cp	r24, r18
    3334:	93 07       	cpc	r25, r19
    3336:	70 f7       	brcc	.-36     	; 0x3314 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    3338:	eb 81       	ldd	r30, Y+3	; 0x03
    333a:	fc 81       	ldd	r31, Y+4	; 0x04
    333c:	82 81       	ldd	r24, Z+2	; 0x02
    333e:	93 81       	ldd	r25, Z+3	; 0x03
    3340:	ef 81       	ldd	r30, Y+7	; 0x07
    3342:	f8 85       	ldd	r31, Y+8	; 0x08
    3344:	93 83       	std	Z+3, r25	; 0x03
    3346:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3348:	ef 81       	ldd	r30, Y+7	; 0x07
    334a:	f8 85       	ldd	r31, Y+8	; 0x08
    334c:	02 80       	ldd	r0, Z+2	; 0x02
    334e:	f3 81       	ldd	r31, Z+3	; 0x03
    3350:	e0 2d       	mov	r30, r0
    3352:	8f 81       	ldd	r24, Y+7	; 0x07
    3354:	98 85       	ldd	r25, Y+8	; 0x08
    3356:	95 83       	std	Z+5, r25	; 0x05
    3358:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    335a:	ef 81       	ldd	r30, Y+7	; 0x07
    335c:	f8 85       	ldd	r31, Y+8	; 0x08
    335e:	8b 81       	ldd	r24, Y+3	; 0x03
    3360:	9c 81       	ldd	r25, Y+4	; 0x04
    3362:	95 83       	std	Z+5, r25	; 0x05
    3364:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    3366:	eb 81       	ldd	r30, Y+3	; 0x03
    3368:	fc 81       	ldd	r31, Y+4	; 0x04
    336a:	8f 81       	ldd	r24, Y+7	; 0x07
    336c:	98 85       	ldd	r25, Y+8	; 0x08
    336e:	93 83       	std	Z+3, r25	; 0x03
    3370:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    3372:	ef 81       	ldd	r30, Y+7	; 0x07
    3374:	f8 85       	ldd	r31, Y+8	; 0x08
    3376:	8d 81       	ldd	r24, Y+5	; 0x05
    3378:	9e 81       	ldd	r25, Y+6	; 0x06
    337a:	91 87       	std	Z+9, r25	; 0x09
    337c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    337e:	ed 81       	ldd	r30, Y+5	; 0x05
    3380:	fe 81       	ldd	r31, Y+6	; 0x06
    3382:	80 81       	ld	r24, Z
    3384:	8f 5f       	subi	r24, 0xFF	; 255
    3386:	ed 81       	ldd	r30, Y+5	; 0x05
    3388:	fe 81       	ldd	r31, Y+6	; 0x06
    338a:	80 83       	st	Z, r24
}
    338c:	28 96       	adiw	r28, 0x08	; 8
    338e:	0f b6       	in	r0, 0x3f	; 63
    3390:	f8 94       	cli
    3392:	de bf       	out	0x3e, r29	; 62
    3394:	0f be       	out	0x3f, r0	; 63
    3396:	cd bf       	out	0x3d, r28	; 61
    3398:	cf 91       	pop	r28
    339a:	df 91       	pop	r29
    339c:	08 95       	ret

0000339e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    339e:	df 93       	push	r29
    33a0:	cf 93       	push	r28
    33a2:	00 d0       	rcall	.+0      	; 0x33a4 <uxListRemove+0x6>
    33a4:	00 d0       	rcall	.+0      	; 0x33a6 <uxListRemove+0x8>
    33a6:	cd b7       	in	r28, 0x3d	; 61
    33a8:	de b7       	in	r29, 0x3e	; 62
    33aa:	9c 83       	std	Y+4, r25	; 0x04
    33ac:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    33ae:	eb 81       	ldd	r30, Y+3	; 0x03
    33b0:	fc 81       	ldd	r31, Y+4	; 0x04
    33b2:	80 85       	ldd	r24, Z+8	; 0x08
    33b4:	91 85       	ldd	r25, Z+9	; 0x09
    33b6:	9a 83       	std	Y+2, r25	; 0x02
    33b8:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    33ba:	eb 81       	ldd	r30, Y+3	; 0x03
    33bc:	fc 81       	ldd	r31, Y+4	; 0x04
    33be:	a2 81       	ldd	r26, Z+2	; 0x02
    33c0:	b3 81       	ldd	r27, Z+3	; 0x03
    33c2:	eb 81       	ldd	r30, Y+3	; 0x03
    33c4:	fc 81       	ldd	r31, Y+4	; 0x04
    33c6:	84 81       	ldd	r24, Z+4	; 0x04
    33c8:	95 81       	ldd	r25, Z+5	; 0x05
    33ca:	15 96       	adiw	r26, 0x05	; 5
    33cc:	9c 93       	st	X, r25
    33ce:	8e 93       	st	-X, r24
    33d0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    33d2:	eb 81       	ldd	r30, Y+3	; 0x03
    33d4:	fc 81       	ldd	r31, Y+4	; 0x04
    33d6:	a4 81       	ldd	r26, Z+4	; 0x04
    33d8:	b5 81       	ldd	r27, Z+5	; 0x05
    33da:	eb 81       	ldd	r30, Y+3	; 0x03
    33dc:	fc 81       	ldd	r31, Y+4	; 0x04
    33de:	82 81       	ldd	r24, Z+2	; 0x02
    33e0:	93 81       	ldd	r25, Z+3	; 0x03
    33e2:	13 96       	adiw	r26, 0x03	; 3
    33e4:	9c 93       	st	X, r25
    33e6:	8e 93       	st	-X, r24
    33e8:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    33ea:	e9 81       	ldd	r30, Y+1	; 0x01
    33ec:	fa 81       	ldd	r31, Y+2	; 0x02
    33ee:	21 81       	ldd	r18, Z+1	; 0x01
    33f0:	32 81       	ldd	r19, Z+2	; 0x02
    33f2:	8b 81       	ldd	r24, Y+3	; 0x03
    33f4:	9c 81       	ldd	r25, Y+4	; 0x04
    33f6:	28 17       	cp	r18, r24
    33f8:	39 07       	cpc	r19, r25
    33fa:	41 f4       	brne	.+16     	; 0x340c <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    33fc:	eb 81       	ldd	r30, Y+3	; 0x03
    33fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3400:	84 81       	ldd	r24, Z+4	; 0x04
    3402:	95 81       	ldd	r25, Z+5	; 0x05
    3404:	e9 81       	ldd	r30, Y+1	; 0x01
    3406:	fa 81       	ldd	r31, Y+2	; 0x02
    3408:	92 83       	std	Z+2, r25	; 0x02
    340a:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    340c:	eb 81       	ldd	r30, Y+3	; 0x03
    340e:	fc 81       	ldd	r31, Y+4	; 0x04
    3410:	11 86       	std	Z+9, r1	; 0x09
    3412:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3414:	e9 81       	ldd	r30, Y+1	; 0x01
    3416:	fa 81       	ldd	r31, Y+2	; 0x02
    3418:	80 81       	ld	r24, Z
    341a:	81 50       	subi	r24, 0x01	; 1
    341c:	e9 81       	ldd	r30, Y+1	; 0x01
    341e:	fa 81       	ldd	r31, Y+2	; 0x02
    3420:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    3422:	e9 81       	ldd	r30, Y+1	; 0x01
    3424:	fa 81       	ldd	r31, Y+2	; 0x02
    3426:	80 81       	ld	r24, Z
}
    3428:	0f 90       	pop	r0
    342a:	0f 90       	pop	r0
    342c:	0f 90       	pop	r0
    342e:	0f 90       	pop	r0
    3430:	cf 91       	pop	r28
    3432:	df 91       	pop	r29
    3434:	08 95       	ret

00003436 <main>:
xSemaphoreHandle LCD_Semaphore;

xSemaphoreHandle Switch_Semaphore;

int main(void)
{
    3436:	ef 92       	push	r14
    3438:	ff 92       	push	r15
    343a:	0f 93       	push	r16
    343c:	df 93       	push	r29
    343e:	cf 93       	push	r28
    3440:	cd b7       	in	r28, 0x3d	; 61
    3442:	de b7       	in	r29, 0x3e	; 62
	DIO_voidInit();
    3444:	0e 94 4f 06 	call	0xc9e	; 0xc9e <DIO_voidInit>
	LCD_voidInit();
    3448:	0e 94 c8 0a 	call	0x1590	; 0x1590 <LCD_voidInit>
	//	if (xTaskCreate(&App_voidLCD2, "LCD2", 200, NULL, 3, NULL) != pdPASS) {
	//		// Handle task creation failure
	//		LCD_voidWriteNumber(2);
	//		while(1);
	//	}
	xTaskCreate(&App_voidSwitchTask,NULL,200,NULL,2,NULL);
    344c:	81 ea       	ldi	r24, 0xA1	; 161
    344e:	9b e1       	ldi	r25, 0x1B	; 27
    3450:	60 e0       	ldi	r22, 0x00	; 0
    3452:	70 e0       	ldi	r23, 0x00	; 0
    3454:	48 ec       	ldi	r20, 0xC8	; 200
    3456:	50 e0       	ldi	r21, 0x00	; 0
    3458:	20 e0       	ldi	r18, 0x00	; 0
    345a:	30 e0       	ldi	r19, 0x00	; 0
    345c:	02 e0       	ldi	r16, 0x02	; 2
    345e:	ee 24       	eor	r14, r14
    3460:	ff 24       	eor	r15, r15
    3462:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <xTaskCreate>
	xTaskCreate(&App_voidLedTask,NULL,200,NULL,1,NULL);
    3466:	84 ec       	ldi	r24, 0xC4	; 196
    3468:	9b e1       	ldi	r25, 0x1B	; 27
    346a:	60 e0       	ldi	r22, 0x00	; 0
    346c:	70 e0       	ldi	r23, 0x00	; 0
    346e:	48 ec       	ldi	r20, 0xC8	; 200
    3470:	50 e0       	ldi	r21, 0x00	; 0
    3472:	20 e0       	ldi	r18, 0x00	; 0
    3474:	30 e0       	ldi	r19, 0x00	; 0
    3476:	01 e0       	ldi	r16, 0x01	; 1
    3478:	ee 24       	eor	r14, r14
    347a:	ff 24       	eor	r15, r15
    347c:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <xTaskCreate>

	/* Create Semaphore */
	vSemaphoreCreateBinary(Switch_Semaphore);
    3480:	81 e0       	ldi	r24, 0x01	; 1
    3482:	60 e0       	ldi	r22, 0x00	; 0
    3484:	43 e0       	ldi	r20, 0x03	; 3
    3486:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <xQueueGenericCreate>
    348a:	90 93 e6 04 	sts	0x04E6, r25
    348e:	80 93 e5 04 	sts	0x04E5, r24
    3492:	80 91 e5 04 	lds	r24, 0x04E5
    3496:	90 91 e6 04 	lds	r25, 0x04E6
    349a:	00 97       	sbiw	r24, 0x00	; 0
    349c:	59 f0       	breq	.+22     	; 0x34b4 <main+0x7e>
    349e:	80 91 e5 04 	lds	r24, 0x04E5
    34a2:	90 91 e6 04 	lds	r25, 0x04E6
    34a6:	60 e0       	ldi	r22, 0x00	; 0
    34a8:	70 e0       	ldi	r23, 0x00	; 0
    34aa:	40 e0       	ldi	r20, 0x00	; 0
    34ac:	50 e0       	ldi	r21, 0x00	; 0
    34ae:	20 e0       	ldi	r18, 0x00	; 0
    34b0:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <xQueueGenericSend>

	/* Take Semaphore */
	xSemaphoreTake(Switch_Semaphore,portMAX_DELAY);
    34b4:	80 91 e5 04 	lds	r24, 0x04E5
    34b8:	90 91 e6 04 	lds	r25, 0x04E6
    34bc:	6f ef       	ldi	r22, 0xFF	; 255
    34be:	7f ef       	ldi	r23, 0xFF	; 255
    34c0:	0e 94 ce 21 	call	0x439c	; 0x439c <xQueueSemaphoreTake>

	//	LCD_Semaphore = xSemaphoreCreateCounting(1,1);

	/* Start Scheduler */
	vTaskStartScheduler();
    34c4:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskStartScheduler>
    34c8:	ff cf       	rjmp	.-2      	; 0x34c8 <main+0x92>

000034ca <App_voidLCD1>:

	return 0;
}

void App_voidLCD1(void * Copy_pv)
{
    34ca:	df 93       	push	r29
    34cc:	cf 93       	push	r28
    34ce:	cd b7       	in	r28, 0x3d	; 61
    34d0:	de b7       	in	r29, 0x3e	; 62
    34d2:	60 97       	sbiw	r28, 0x10	; 16
    34d4:	0f b6       	in	r0, 0x3f	; 63
    34d6:	f8 94       	cli
    34d8:	de bf       	out	0x3e, r29	; 62
    34da:	0f be       	out	0x3f, r0	; 63
    34dc:	cd bf       	out	0x3d, r28	; 61
    34de:	98 8b       	std	Y+16, r25	; 0x10
    34e0:	8f 87       	std	Y+15, r24	; 0x0f
	while(1)
	{
		/* Take Semaphore */
		if(xSemaphoreTake(LCD_Semaphore,portMAX_DELAY) == pdTRUE)
    34e2:	80 91 e3 04 	lds	r24, 0x04E3
    34e6:	90 91 e4 04 	lds	r25, 0x04E4
    34ea:	6f ef       	ldi	r22, 0xFF	; 255
    34ec:	7f ef       	ldi	r23, 0xFF	; 255
    34ee:	0e 94 ce 21 	call	0x439c	; 0x439c <xQueueSemaphoreTake>
    34f2:	81 30       	cpi	r24, 0x01	; 1
    34f4:	b1 f7       	brne	.-20     	; 0x34e2 <App_voidLCD1+0x18>
		{
			LCD_voidWriteString((u8*)"I am TASK 1");
    34f6:	80 e6       	ldi	r24, 0x60	; 96
    34f8:	90 e0       	ldi	r25, 0x00	; 0
    34fa:	0e 94 db 10 	call	0x21b6	; 0x21b6 <LCD_voidWriteString>
    34fe:	80 e0       	ldi	r24, 0x00	; 0
    3500:	90 e0       	ldi	r25, 0x00	; 0
    3502:	a8 e4       	ldi	r26, 0x48	; 72
    3504:	b4 e4       	ldi	r27, 0x44	; 68
    3506:	8b 87       	std	Y+11, r24	; 0x0b
    3508:	9c 87       	std	Y+12, r25	; 0x0c
    350a:	ad 87       	std	Y+13, r26	; 0x0d
    350c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    350e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3510:	7c 85       	ldd	r23, Y+12	; 0x0c
    3512:	8d 85       	ldd	r24, Y+13	; 0x0d
    3514:	9e 85       	ldd	r25, Y+14	; 0x0e
    3516:	20 e0       	ldi	r18, 0x00	; 0
    3518:	30 e0       	ldi	r19, 0x00	; 0
    351a:	4a ef       	ldi	r20, 0xFA	; 250
    351c:	54 e4       	ldi	r21, 0x44	; 68
    351e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3522:	dc 01       	movw	r26, r24
    3524:	cb 01       	movw	r24, r22
    3526:	8f 83       	std	Y+7, r24	; 0x07
    3528:	98 87       	std	Y+8, r25	; 0x08
    352a:	a9 87       	std	Y+9, r26	; 0x09
    352c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    352e:	6f 81       	ldd	r22, Y+7	; 0x07
    3530:	78 85       	ldd	r23, Y+8	; 0x08
    3532:	89 85       	ldd	r24, Y+9	; 0x09
    3534:	9a 85       	ldd	r25, Y+10	; 0x0a
    3536:	20 e0       	ldi	r18, 0x00	; 0
    3538:	30 e0       	ldi	r19, 0x00	; 0
    353a:	40 e8       	ldi	r20, 0x80	; 128
    353c:	5f e3       	ldi	r21, 0x3F	; 63
    353e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3542:	88 23       	and	r24, r24
    3544:	2c f4       	brge	.+10     	; 0x3550 <App_voidLCD1+0x86>
		__ticks = 1;
    3546:	81 e0       	ldi	r24, 0x01	; 1
    3548:	90 e0       	ldi	r25, 0x00	; 0
    354a:	9e 83       	std	Y+6, r25	; 0x06
    354c:	8d 83       	std	Y+5, r24	; 0x05
    354e:	3f c0       	rjmp	.+126    	; 0x35ce <App_voidLCD1+0x104>
	else if (__tmp > 65535)
    3550:	6f 81       	ldd	r22, Y+7	; 0x07
    3552:	78 85       	ldd	r23, Y+8	; 0x08
    3554:	89 85       	ldd	r24, Y+9	; 0x09
    3556:	9a 85       	ldd	r25, Y+10	; 0x0a
    3558:	20 e0       	ldi	r18, 0x00	; 0
    355a:	3f ef       	ldi	r19, 0xFF	; 255
    355c:	4f e7       	ldi	r20, 0x7F	; 127
    355e:	57 e4       	ldi	r21, 0x47	; 71
    3560:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3564:	18 16       	cp	r1, r24
    3566:	4c f5       	brge	.+82     	; 0x35ba <App_voidLCD1+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3568:	6b 85       	ldd	r22, Y+11	; 0x0b
    356a:	7c 85       	ldd	r23, Y+12	; 0x0c
    356c:	8d 85       	ldd	r24, Y+13	; 0x0d
    356e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3570:	20 e0       	ldi	r18, 0x00	; 0
    3572:	30 e0       	ldi	r19, 0x00	; 0
    3574:	40 e2       	ldi	r20, 0x20	; 32
    3576:	51 e4       	ldi	r21, 0x41	; 65
    3578:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    357c:	dc 01       	movw	r26, r24
    357e:	cb 01       	movw	r24, r22
    3580:	bc 01       	movw	r22, r24
    3582:	cd 01       	movw	r24, r26
    3584:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3588:	dc 01       	movw	r26, r24
    358a:	cb 01       	movw	r24, r22
    358c:	9e 83       	std	Y+6, r25	; 0x06
    358e:	8d 83       	std	Y+5, r24	; 0x05
    3590:	0f c0       	rjmp	.+30     	; 0x35b0 <App_voidLCD1+0xe6>
    3592:	88 ec       	ldi	r24, 0xC8	; 200
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	9c 83       	std	Y+4, r25	; 0x04
    3598:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    359a:	8b 81       	ldd	r24, Y+3	; 0x03
    359c:	9c 81       	ldd	r25, Y+4	; 0x04
    359e:	01 97       	sbiw	r24, 0x01	; 1
    35a0:	f1 f7       	brne	.-4      	; 0x359e <App_voidLCD1+0xd4>
    35a2:	9c 83       	std	Y+4, r25	; 0x04
    35a4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35a6:	8d 81       	ldd	r24, Y+5	; 0x05
    35a8:	9e 81       	ldd	r25, Y+6	; 0x06
    35aa:	01 97       	sbiw	r24, 0x01	; 1
    35ac:	9e 83       	std	Y+6, r25	; 0x06
    35ae:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35b0:	8d 81       	ldd	r24, Y+5	; 0x05
    35b2:	9e 81       	ldd	r25, Y+6	; 0x06
    35b4:	00 97       	sbiw	r24, 0x00	; 0
    35b6:	69 f7       	brne	.-38     	; 0x3592 <App_voidLCD1+0xc8>
    35b8:	14 c0       	rjmp	.+40     	; 0x35e2 <App_voidLCD1+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35ba:	6f 81       	ldd	r22, Y+7	; 0x07
    35bc:	78 85       	ldd	r23, Y+8	; 0x08
    35be:	89 85       	ldd	r24, Y+9	; 0x09
    35c0:	9a 85       	ldd	r25, Y+10	; 0x0a
    35c2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35c6:	dc 01       	movw	r26, r24
    35c8:	cb 01       	movw	r24, r22
    35ca:	9e 83       	std	Y+6, r25	; 0x06
    35cc:	8d 83       	std	Y+5, r24	; 0x05
    35ce:	8d 81       	ldd	r24, Y+5	; 0x05
    35d0:	9e 81       	ldd	r25, Y+6	; 0x06
    35d2:	9a 83       	std	Y+2, r25	; 0x02
    35d4:	89 83       	std	Y+1, r24	; 0x01
    35d6:	89 81       	ldd	r24, Y+1	; 0x01
    35d8:	9a 81       	ldd	r25, Y+2	; 0x02
    35da:	01 97       	sbiw	r24, 0x01	; 1
    35dc:	f1 f7       	brne	.-4      	; 0x35da <App_voidLCD1+0x110>
    35de:	9a 83       	std	Y+2, r25	; 0x02
    35e0:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(800);
			LCD_voidClearScreen();
    35e2:	0e 94 a0 11 	call	0x2340	; 0x2340 <LCD_voidClearScreen>
			xSemaphoreGive(LCD_Semaphore);
    35e6:	80 91 e3 04 	lds	r24, 0x04E3
    35ea:	90 91 e4 04 	lds	r25, 0x04E4
    35ee:	60 e0       	ldi	r22, 0x00	; 0
    35f0:	70 e0       	ldi	r23, 0x00	; 0
    35f2:	40 e0       	ldi	r20, 0x00	; 0
    35f4:	50 e0       	ldi	r21, 0x00	; 0
    35f6:	20 e0       	ldi	r18, 0x00	; 0
    35f8:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <xQueueGenericSend>

			vTaskDelay(1000);
    35fc:	88 ee       	ldi	r24, 0xE8	; 232
    35fe:	93 e0       	ldi	r25, 0x03	; 3
    3600:	0e 94 6e 28 	call	0x50dc	; 0x50dc <vTaskDelay>
    3604:	6e cf       	rjmp	.-292    	; 0x34e2 <App_voidLCD1+0x18>

00003606 <App_voidLCD2>:
		}

	}
}
void App_voidLCD2(void * Copy_pv)
{
    3606:	df 93       	push	r29
    3608:	cf 93       	push	r28
    360a:	cd b7       	in	r28, 0x3d	; 61
    360c:	de b7       	in	r29, 0x3e	; 62
    360e:	60 97       	sbiw	r28, 0x10	; 16
    3610:	0f b6       	in	r0, 0x3f	; 63
    3612:	f8 94       	cli
    3614:	de bf       	out	0x3e, r29	; 62
    3616:	0f be       	out	0x3f, r0	; 63
    3618:	cd bf       	out	0x3d, r28	; 61
    361a:	98 8b       	std	Y+16, r25	; 0x10
    361c:	8f 87       	std	Y+15, r24	; 0x0f
	while(1)
	{
		/* Take Semaphore */
		if(xSemaphoreTake(LCD_Semaphore,portMAX_DELAY) == pdTRUE)
    361e:	80 91 e3 04 	lds	r24, 0x04E3
    3622:	90 91 e4 04 	lds	r25, 0x04E4
    3626:	6f ef       	ldi	r22, 0xFF	; 255
    3628:	7f ef       	ldi	r23, 0xFF	; 255
    362a:	0e 94 ce 21 	call	0x439c	; 0x439c <xQueueSemaphoreTake>
    362e:	81 30       	cpi	r24, 0x01	; 1
    3630:	b1 f7       	brne	.-20     	; 0x361e <App_voidLCD2+0x18>
		{
			LCD_voidWriteString((u8*)"I am TASK 2");
    3632:	8c e6       	ldi	r24, 0x6C	; 108
    3634:	90 e0       	ldi	r25, 0x00	; 0
    3636:	0e 94 db 10 	call	0x21b6	; 0x21b6 <LCD_voidWriteString>
    363a:	80 e0       	ldi	r24, 0x00	; 0
    363c:	90 e0       	ldi	r25, 0x00	; 0
    363e:	a8 e4       	ldi	r26, 0x48	; 72
    3640:	b4 e4       	ldi	r27, 0x44	; 68
    3642:	8b 87       	std	Y+11, r24	; 0x0b
    3644:	9c 87       	std	Y+12, r25	; 0x0c
    3646:	ad 87       	std	Y+13, r26	; 0x0d
    3648:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    364a:	6b 85       	ldd	r22, Y+11	; 0x0b
    364c:	7c 85       	ldd	r23, Y+12	; 0x0c
    364e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3650:	9e 85       	ldd	r25, Y+14	; 0x0e
    3652:	20 e0       	ldi	r18, 0x00	; 0
    3654:	30 e0       	ldi	r19, 0x00	; 0
    3656:	4a ef       	ldi	r20, 0xFA	; 250
    3658:	54 e4       	ldi	r21, 0x44	; 68
    365a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    365e:	dc 01       	movw	r26, r24
    3660:	cb 01       	movw	r24, r22
    3662:	8f 83       	std	Y+7, r24	; 0x07
    3664:	98 87       	std	Y+8, r25	; 0x08
    3666:	a9 87       	std	Y+9, r26	; 0x09
    3668:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    366a:	6f 81       	ldd	r22, Y+7	; 0x07
    366c:	78 85       	ldd	r23, Y+8	; 0x08
    366e:	89 85       	ldd	r24, Y+9	; 0x09
    3670:	9a 85       	ldd	r25, Y+10	; 0x0a
    3672:	20 e0       	ldi	r18, 0x00	; 0
    3674:	30 e0       	ldi	r19, 0x00	; 0
    3676:	40 e8       	ldi	r20, 0x80	; 128
    3678:	5f e3       	ldi	r21, 0x3F	; 63
    367a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    367e:	88 23       	and	r24, r24
    3680:	2c f4       	brge	.+10     	; 0x368c <App_voidLCD2+0x86>
		__ticks = 1;
    3682:	81 e0       	ldi	r24, 0x01	; 1
    3684:	90 e0       	ldi	r25, 0x00	; 0
    3686:	9e 83       	std	Y+6, r25	; 0x06
    3688:	8d 83       	std	Y+5, r24	; 0x05
    368a:	3f c0       	rjmp	.+126    	; 0x370a <App_voidLCD2+0x104>
	else if (__tmp > 65535)
    368c:	6f 81       	ldd	r22, Y+7	; 0x07
    368e:	78 85       	ldd	r23, Y+8	; 0x08
    3690:	89 85       	ldd	r24, Y+9	; 0x09
    3692:	9a 85       	ldd	r25, Y+10	; 0x0a
    3694:	20 e0       	ldi	r18, 0x00	; 0
    3696:	3f ef       	ldi	r19, 0xFF	; 255
    3698:	4f e7       	ldi	r20, 0x7F	; 127
    369a:	57 e4       	ldi	r21, 0x47	; 71
    369c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    36a0:	18 16       	cp	r1, r24
    36a2:	4c f5       	brge	.+82     	; 0x36f6 <App_voidLCD2+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    36a4:	6b 85       	ldd	r22, Y+11	; 0x0b
    36a6:	7c 85       	ldd	r23, Y+12	; 0x0c
    36a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    36aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    36ac:	20 e0       	ldi	r18, 0x00	; 0
    36ae:	30 e0       	ldi	r19, 0x00	; 0
    36b0:	40 e2       	ldi	r20, 0x20	; 32
    36b2:	51 e4       	ldi	r21, 0x41	; 65
    36b4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    36b8:	dc 01       	movw	r26, r24
    36ba:	cb 01       	movw	r24, r22
    36bc:	bc 01       	movw	r22, r24
    36be:	cd 01       	movw	r24, r26
    36c0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36c4:	dc 01       	movw	r26, r24
    36c6:	cb 01       	movw	r24, r22
    36c8:	9e 83       	std	Y+6, r25	; 0x06
    36ca:	8d 83       	std	Y+5, r24	; 0x05
    36cc:	0f c0       	rjmp	.+30     	; 0x36ec <App_voidLCD2+0xe6>
    36ce:	88 ec       	ldi	r24, 0xC8	; 200
    36d0:	90 e0       	ldi	r25, 0x00	; 0
    36d2:	9c 83       	std	Y+4, r25	; 0x04
    36d4:	8b 83       	std	Y+3, r24	; 0x03
    36d6:	8b 81       	ldd	r24, Y+3	; 0x03
    36d8:	9c 81       	ldd	r25, Y+4	; 0x04
    36da:	01 97       	sbiw	r24, 0x01	; 1
    36dc:	f1 f7       	brne	.-4      	; 0x36da <App_voidLCD2+0xd4>
    36de:	9c 83       	std	Y+4, r25	; 0x04
    36e0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    36e2:	8d 81       	ldd	r24, Y+5	; 0x05
    36e4:	9e 81       	ldd	r25, Y+6	; 0x06
    36e6:	01 97       	sbiw	r24, 0x01	; 1
    36e8:	9e 83       	std	Y+6, r25	; 0x06
    36ea:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    36ec:	8d 81       	ldd	r24, Y+5	; 0x05
    36ee:	9e 81       	ldd	r25, Y+6	; 0x06
    36f0:	00 97       	sbiw	r24, 0x00	; 0
    36f2:	69 f7       	brne	.-38     	; 0x36ce <App_voidLCD2+0xc8>
    36f4:	14 c0       	rjmp	.+40     	; 0x371e <App_voidLCD2+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    36f6:	6f 81       	ldd	r22, Y+7	; 0x07
    36f8:	78 85       	ldd	r23, Y+8	; 0x08
    36fa:	89 85       	ldd	r24, Y+9	; 0x09
    36fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    36fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3702:	dc 01       	movw	r26, r24
    3704:	cb 01       	movw	r24, r22
    3706:	9e 83       	std	Y+6, r25	; 0x06
    3708:	8d 83       	std	Y+5, r24	; 0x05
    370a:	8d 81       	ldd	r24, Y+5	; 0x05
    370c:	9e 81       	ldd	r25, Y+6	; 0x06
    370e:	9a 83       	std	Y+2, r25	; 0x02
    3710:	89 83       	std	Y+1, r24	; 0x01
    3712:	89 81       	ldd	r24, Y+1	; 0x01
    3714:	9a 81       	ldd	r25, Y+2	; 0x02
    3716:	01 97       	sbiw	r24, 0x01	; 1
    3718:	f1 f7       	brne	.-4      	; 0x3716 <App_voidLCD2+0x110>
    371a:	9a 83       	std	Y+2, r25	; 0x02
    371c:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(800);
			LCD_voidClearScreen();
    371e:	0e 94 a0 11 	call	0x2340	; 0x2340 <LCD_voidClearScreen>
			xSemaphoreGive(LCD_Semaphore);
    3722:	80 91 e3 04 	lds	r24, 0x04E3
    3726:	90 91 e4 04 	lds	r25, 0x04E4
    372a:	60 e0       	ldi	r22, 0x00	; 0
    372c:	70 e0       	ldi	r23, 0x00	; 0
    372e:	40 e0       	ldi	r20, 0x00	; 0
    3730:	50 e0       	ldi	r21, 0x00	; 0
    3732:	20 e0       	ldi	r18, 0x00	; 0
    3734:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <xQueueGenericSend>
			vTaskDelay(1000);
    3738:	88 ee       	ldi	r24, 0xE8	; 232
    373a:	93 e0       	ldi	r25, 0x03	; 3
    373c:	0e 94 6e 28 	call	0x50dc	; 0x50dc <vTaskDelay>
    3740:	6e cf       	rjmp	.-292    	; 0x361e <App_voidLCD2+0x18>

00003742 <App_voidSwitchTask>:
		}
	}
}
void App_voidSwitchTask(void * Copy_pv)
{
    3742:	df 93       	push	r29
    3744:	cf 93       	push	r28
    3746:	00 d0       	rcall	.+0      	; 0x3748 <App_voidSwitchTask+0x6>
    3748:	0f 92       	push	r0
    374a:	cd b7       	in	r28, 0x3d	; 61
    374c:	de b7       	in	r29, 0x3e	; 62
    374e:	9b 83       	std	Y+3, r25	; 0x03
    3750:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8Key;
	while(1)
	{
		/* Check Switch State */
		DIO_u8GetPinValue(DIO_u8_PORTB,DIO_u8_PIN0,&Local_u8Key);
    3752:	81 e0       	ldi	r24, 0x01	; 1
    3754:	60 e0       	ldi	r22, 0x00	; 0
    3756:	9e 01       	movw	r18, r28
    3758:	2f 5f       	subi	r18, 0xFF	; 255
    375a:	3f 4f       	sbci	r19, 0xFF	; 255
    375c:	a9 01       	movw	r20, r18
    375e:	0e 94 c6 08 	call	0x118c	; 0x118c <DIO_u8GetPinValue>
		if(Local_u8Key == DIO_u8_LOW)
    3762:	89 81       	ldd	r24, Y+1	; 0x01
    3764:	88 23       	and	r24, r24
    3766:	59 f4       	brne	.+22     	; 0x377e <App_voidSwitchTask+0x3c>
		{
			xSemaphoreGive(Switch_Semaphore);
    3768:	80 91 e5 04 	lds	r24, 0x04E5
    376c:	90 91 e6 04 	lds	r25, 0x04E6
    3770:	60 e0       	ldi	r22, 0x00	; 0
    3772:	70 e0       	ldi	r23, 0x00	; 0
    3774:	40 e0       	ldi	r20, 0x00	; 0
    3776:	50 e0       	ldi	r21, 0x00	; 0
    3778:	20 e0       	ldi	r18, 0x00	; 0
    377a:	0e 94 ca 1f 	call	0x3f94	; 0x3f94 <xQueueGenericSend>
		}
		vTaskDelay(200);
    377e:	88 ec       	ldi	r24, 0xC8	; 200
    3780:	90 e0       	ldi	r25, 0x00	; 0
    3782:	0e 94 6e 28 	call	0x50dc	; 0x50dc <vTaskDelay>
    3786:	e5 cf       	rjmp	.-54     	; 0x3752 <App_voidSwitchTask+0x10>

00003788 <App_voidLedTask>:
	}
}
void App_voidLedTask(void * Copy_pv)
{
    3788:	df 93       	push	r29
    378a:	cf 93       	push	r28
    378c:	00 d0       	rcall	.+0      	; 0x378e <App_voidLedTask+0x6>
    378e:	cd b7       	in	r28, 0x3d	; 61
    3790:	de b7       	in	r29, 0x3e	; 62
    3792:	9a 83       	std	Y+2, r25	; 0x02
    3794:	89 83       	std	Y+1, r24	; 0x01
	static u8 Local_u8Falg = 0;
	while(1)
	{
		/* Take Semaphore */
		if(xSemaphoreTake(Switch_Semaphore,portMAX_DELAY) == pdTRUE)
    3796:	80 91 e5 04 	lds	r24, 0x04E5
    379a:	90 91 e6 04 	lds	r25, 0x04E6
    379e:	6f ef       	ldi	r22, 0xFF	; 255
    37a0:	7f ef       	ldi	r23, 0xFF	; 255
    37a2:	0e 94 ce 21 	call	0x439c	; 0x439c <xQueueSemaphoreTake>
    37a6:	81 30       	cpi	r24, 0x01	; 1
    37a8:	b1 f7       	brne	.-20     	; 0x3796 <App_voidLedTask+0xe>
		{
			if(Local_u8Falg == 0)
    37aa:	80 91 72 04 	lds	r24, 0x0472
    37ae:	88 23       	and	r24, r24
    37b0:	49 f4       	brne	.+18     	; 0x37c4 <App_voidLedTask+0x3c>
			{
				DIO_u8SetPinValue(DIO_u8_PORTA,DIO_u8_PIN0,DIO_u8_HIGH);
    37b2:	80 e0       	ldi	r24, 0x00	; 0
    37b4:	60 e0       	ldi	r22, 0x00	; 0
    37b6:	41 e0       	ldi	r20, 0x01	; 1
    37b8:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
				Local_u8Falg = 1;
    37bc:	81 e0       	ldi	r24, 0x01	; 1
    37be:	80 93 72 04 	sts	0x0472, r24
    37c2:	e9 cf       	rjmp	.-46     	; 0x3796 <App_voidLedTask+0xe>
			}
			else
			{
				DIO_u8SetPinValue(DIO_u8_PORTA,DIO_u8_PIN0,DIO_u8_LOW);
    37c4:	80 e0       	ldi	r24, 0x00	; 0
    37c6:	60 e0       	ldi	r22, 0x00	; 0
    37c8:	40 e0       	ldi	r20, 0x00	; 0
    37ca:	0e 94 9c 07 	call	0xf38	; 0xf38 <DIO_u8SetPinValue>
				Local_u8Falg = 0;
    37ce:	10 92 72 04 	sts	0x0472, r1
    37d2:	e1 cf       	rjmp	.-62     	; 0x3796 <App_voidLedTask+0xe>

000037d4 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    37d4:	df 93       	push	r29
    37d6:	cf 93       	push	r28
    37d8:	cd b7       	in	r28, 0x3d	; 61
    37da:	de b7       	in	r29, 0x3e	; 62
    37dc:	28 97       	sbiw	r28, 0x08	; 8
    37de:	0f b6       	in	r0, 0x3f	; 63
    37e0:	f8 94       	cli
    37e2:	de bf       	out	0x3e, r29	; 62
    37e4:	0f be       	out	0x3f, r0	; 63
    37e6:	cd bf       	out	0x3d, r28	; 61
    37e8:	9c 83       	std	Y+4, r25	; 0x04
    37ea:	8b 83       	std	Y+3, r24	; 0x03
    37ec:	7e 83       	std	Y+6, r23	; 0x06
    37ee:	6d 83       	std	Y+5, r22	; 0x05
    37f0:	58 87       	std	Y+8, r21	; 0x08
    37f2:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    37f4:	eb 81       	ldd	r30, Y+3	; 0x03
    37f6:	fc 81       	ldd	r31, Y+4	; 0x04
    37f8:	81 e1       	ldi	r24, 0x11	; 17
    37fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    37fc:	8b 81       	ldd	r24, Y+3	; 0x03
    37fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3800:	01 97       	sbiw	r24, 0x01	; 1
    3802:	9c 83       	std	Y+4, r25	; 0x04
    3804:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    3806:	eb 81       	ldd	r30, Y+3	; 0x03
    3808:	fc 81       	ldd	r31, Y+4	; 0x04
    380a:	82 e2       	ldi	r24, 0x22	; 34
    380c:	80 83       	st	Z, r24
	pxTopOfStack--;
    380e:	8b 81       	ldd	r24, Y+3	; 0x03
    3810:	9c 81       	ldd	r25, Y+4	; 0x04
    3812:	01 97       	sbiw	r24, 0x01	; 1
    3814:	9c 83       	std	Y+4, r25	; 0x04
    3816:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    3818:	eb 81       	ldd	r30, Y+3	; 0x03
    381a:	fc 81       	ldd	r31, Y+4	; 0x04
    381c:	83 e3       	ldi	r24, 0x33	; 51
    381e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3820:	8b 81       	ldd	r24, Y+3	; 0x03
    3822:	9c 81       	ldd	r25, Y+4	; 0x04
    3824:	01 97       	sbiw	r24, 0x01	; 1
    3826:	9c 83       	std	Y+4, r25	; 0x04
    3828:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    382a:	8d 81       	ldd	r24, Y+5	; 0x05
    382c:	9e 81       	ldd	r25, Y+6	; 0x06
    382e:	9a 83       	std	Y+2, r25	; 0x02
    3830:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3832:	89 81       	ldd	r24, Y+1	; 0x01
    3834:	eb 81       	ldd	r30, Y+3	; 0x03
    3836:	fc 81       	ldd	r31, Y+4	; 0x04
    3838:	80 83       	st	Z, r24
	pxTopOfStack--;
    383a:	8b 81       	ldd	r24, Y+3	; 0x03
    383c:	9c 81       	ldd	r25, Y+4	; 0x04
    383e:	01 97       	sbiw	r24, 0x01	; 1
    3840:	9c 83       	std	Y+4, r25	; 0x04
    3842:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3844:	89 81       	ldd	r24, Y+1	; 0x01
    3846:	9a 81       	ldd	r25, Y+2	; 0x02
    3848:	89 2f       	mov	r24, r25
    384a:	99 27       	eor	r25, r25
    384c:	9a 83       	std	Y+2, r25	; 0x02
    384e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3850:	89 81       	ldd	r24, Y+1	; 0x01
    3852:	eb 81       	ldd	r30, Y+3	; 0x03
    3854:	fc 81       	ldd	r31, Y+4	; 0x04
    3856:	80 83       	st	Z, r24
	pxTopOfStack--;
    3858:	8b 81       	ldd	r24, Y+3	; 0x03
    385a:	9c 81       	ldd	r25, Y+4	; 0x04
    385c:	01 97       	sbiw	r24, 0x01	; 1
    385e:	9c 83       	std	Y+4, r25	; 0x04
    3860:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    3862:	eb 81       	ldd	r30, Y+3	; 0x03
    3864:	fc 81       	ldd	r31, Y+4	; 0x04
    3866:	10 82       	st	Z, r1
	pxTopOfStack--;
    3868:	8b 81       	ldd	r24, Y+3	; 0x03
    386a:	9c 81       	ldd	r25, Y+4	; 0x04
    386c:	01 97       	sbiw	r24, 0x01	; 1
    386e:	9c 83       	std	Y+4, r25	; 0x04
    3870:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3872:	eb 81       	ldd	r30, Y+3	; 0x03
    3874:	fc 81       	ldd	r31, Y+4	; 0x04
    3876:	80 e8       	ldi	r24, 0x80	; 128
    3878:	80 83       	st	Z, r24
	pxTopOfStack--;
    387a:	8b 81       	ldd	r24, Y+3	; 0x03
    387c:	9c 81       	ldd	r25, Y+4	; 0x04
    387e:	01 97       	sbiw	r24, 0x01	; 1
    3880:	9c 83       	std	Y+4, r25	; 0x04
    3882:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3884:	eb 81       	ldd	r30, Y+3	; 0x03
    3886:	fc 81       	ldd	r31, Y+4	; 0x04
    3888:	10 82       	st	Z, r1
	pxTopOfStack--;
    388a:	8b 81       	ldd	r24, Y+3	; 0x03
    388c:	9c 81       	ldd	r25, Y+4	; 0x04
    388e:	01 97       	sbiw	r24, 0x01	; 1
    3890:	9c 83       	std	Y+4, r25	; 0x04
    3892:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3894:	eb 81       	ldd	r30, Y+3	; 0x03
    3896:	fc 81       	ldd	r31, Y+4	; 0x04
    3898:	82 e0       	ldi	r24, 0x02	; 2
    389a:	80 83       	st	Z, r24
	pxTopOfStack--;
    389c:	8b 81       	ldd	r24, Y+3	; 0x03
    389e:	9c 81       	ldd	r25, Y+4	; 0x04
    38a0:	01 97       	sbiw	r24, 0x01	; 1
    38a2:	9c 83       	std	Y+4, r25	; 0x04
    38a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    38a6:	eb 81       	ldd	r30, Y+3	; 0x03
    38a8:	fc 81       	ldd	r31, Y+4	; 0x04
    38aa:	83 e0       	ldi	r24, 0x03	; 3
    38ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    38ae:	8b 81       	ldd	r24, Y+3	; 0x03
    38b0:	9c 81       	ldd	r25, Y+4	; 0x04
    38b2:	01 97       	sbiw	r24, 0x01	; 1
    38b4:	9c 83       	std	Y+4, r25	; 0x04
    38b6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    38b8:	eb 81       	ldd	r30, Y+3	; 0x03
    38ba:	fc 81       	ldd	r31, Y+4	; 0x04
    38bc:	84 e0       	ldi	r24, 0x04	; 4
    38be:	80 83       	st	Z, r24
	pxTopOfStack--;
    38c0:	8b 81       	ldd	r24, Y+3	; 0x03
    38c2:	9c 81       	ldd	r25, Y+4	; 0x04
    38c4:	01 97       	sbiw	r24, 0x01	; 1
    38c6:	9c 83       	std	Y+4, r25	; 0x04
    38c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    38ca:	eb 81       	ldd	r30, Y+3	; 0x03
    38cc:	fc 81       	ldd	r31, Y+4	; 0x04
    38ce:	85 e0       	ldi	r24, 0x05	; 5
    38d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    38d2:	8b 81       	ldd	r24, Y+3	; 0x03
    38d4:	9c 81       	ldd	r25, Y+4	; 0x04
    38d6:	01 97       	sbiw	r24, 0x01	; 1
    38d8:	9c 83       	std	Y+4, r25	; 0x04
    38da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    38dc:	eb 81       	ldd	r30, Y+3	; 0x03
    38de:	fc 81       	ldd	r31, Y+4	; 0x04
    38e0:	86 e0       	ldi	r24, 0x06	; 6
    38e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    38e4:	8b 81       	ldd	r24, Y+3	; 0x03
    38e6:	9c 81       	ldd	r25, Y+4	; 0x04
    38e8:	01 97       	sbiw	r24, 0x01	; 1
    38ea:	9c 83       	std	Y+4, r25	; 0x04
    38ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    38ee:	eb 81       	ldd	r30, Y+3	; 0x03
    38f0:	fc 81       	ldd	r31, Y+4	; 0x04
    38f2:	87 e0       	ldi	r24, 0x07	; 7
    38f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    38f6:	8b 81       	ldd	r24, Y+3	; 0x03
    38f8:	9c 81       	ldd	r25, Y+4	; 0x04
    38fa:	01 97       	sbiw	r24, 0x01	; 1
    38fc:	9c 83       	std	Y+4, r25	; 0x04
    38fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    3900:	eb 81       	ldd	r30, Y+3	; 0x03
    3902:	fc 81       	ldd	r31, Y+4	; 0x04
    3904:	88 e0       	ldi	r24, 0x08	; 8
    3906:	80 83       	st	Z, r24
	pxTopOfStack--;
    3908:	8b 81       	ldd	r24, Y+3	; 0x03
    390a:	9c 81       	ldd	r25, Y+4	; 0x04
    390c:	01 97       	sbiw	r24, 0x01	; 1
    390e:	9c 83       	std	Y+4, r25	; 0x04
    3910:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3912:	eb 81       	ldd	r30, Y+3	; 0x03
    3914:	fc 81       	ldd	r31, Y+4	; 0x04
    3916:	89 e0       	ldi	r24, 0x09	; 9
    3918:	80 83       	st	Z, r24
	pxTopOfStack--;
    391a:	8b 81       	ldd	r24, Y+3	; 0x03
    391c:	9c 81       	ldd	r25, Y+4	; 0x04
    391e:	01 97       	sbiw	r24, 0x01	; 1
    3920:	9c 83       	std	Y+4, r25	; 0x04
    3922:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3924:	eb 81       	ldd	r30, Y+3	; 0x03
    3926:	fc 81       	ldd	r31, Y+4	; 0x04
    3928:	80 e1       	ldi	r24, 0x10	; 16
    392a:	80 83       	st	Z, r24
	pxTopOfStack--;
    392c:	8b 81       	ldd	r24, Y+3	; 0x03
    392e:	9c 81       	ldd	r25, Y+4	; 0x04
    3930:	01 97       	sbiw	r24, 0x01	; 1
    3932:	9c 83       	std	Y+4, r25	; 0x04
    3934:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3936:	eb 81       	ldd	r30, Y+3	; 0x03
    3938:	fc 81       	ldd	r31, Y+4	; 0x04
    393a:	81 e1       	ldi	r24, 0x11	; 17
    393c:	80 83       	st	Z, r24
	pxTopOfStack--;
    393e:	8b 81       	ldd	r24, Y+3	; 0x03
    3940:	9c 81       	ldd	r25, Y+4	; 0x04
    3942:	01 97       	sbiw	r24, 0x01	; 1
    3944:	9c 83       	std	Y+4, r25	; 0x04
    3946:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3948:	eb 81       	ldd	r30, Y+3	; 0x03
    394a:	fc 81       	ldd	r31, Y+4	; 0x04
    394c:	82 e1       	ldi	r24, 0x12	; 18
    394e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3950:	8b 81       	ldd	r24, Y+3	; 0x03
    3952:	9c 81       	ldd	r25, Y+4	; 0x04
    3954:	01 97       	sbiw	r24, 0x01	; 1
    3956:	9c 83       	std	Y+4, r25	; 0x04
    3958:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    395a:	eb 81       	ldd	r30, Y+3	; 0x03
    395c:	fc 81       	ldd	r31, Y+4	; 0x04
    395e:	83 e1       	ldi	r24, 0x13	; 19
    3960:	80 83       	st	Z, r24
	pxTopOfStack--;
    3962:	8b 81       	ldd	r24, Y+3	; 0x03
    3964:	9c 81       	ldd	r25, Y+4	; 0x04
    3966:	01 97       	sbiw	r24, 0x01	; 1
    3968:	9c 83       	std	Y+4, r25	; 0x04
    396a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    396c:	eb 81       	ldd	r30, Y+3	; 0x03
    396e:	fc 81       	ldd	r31, Y+4	; 0x04
    3970:	84 e1       	ldi	r24, 0x14	; 20
    3972:	80 83       	st	Z, r24
	pxTopOfStack--;
    3974:	8b 81       	ldd	r24, Y+3	; 0x03
    3976:	9c 81       	ldd	r25, Y+4	; 0x04
    3978:	01 97       	sbiw	r24, 0x01	; 1
    397a:	9c 83       	std	Y+4, r25	; 0x04
    397c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    397e:	eb 81       	ldd	r30, Y+3	; 0x03
    3980:	fc 81       	ldd	r31, Y+4	; 0x04
    3982:	85 e1       	ldi	r24, 0x15	; 21
    3984:	80 83       	st	Z, r24
	pxTopOfStack--;
    3986:	8b 81       	ldd	r24, Y+3	; 0x03
    3988:	9c 81       	ldd	r25, Y+4	; 0x04
    398a:	01 97       	sbiw	r24, 0x01	; 1
    398c:	9c 83       	std	Y+4, r25	; 0x04
    398e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    3990:	eb 81       	ldd	r30, Y+3	; 0x03
    3992:	fc 81       	ldd	r31, Y+4	; 0x04
    3994:	86 e1       	ldi	r24, 0x16	; 22
    3996:	80 83       	st	Z, r24
	pxTopOfStack--;
    3998:	8b 81       	ldd	r24, Y+3	; 0x03
    399a:	9c 81       	ldd	r25, Y+4	; 0x04
    399c:	01 97       	sbiw	r24, 0x01	; 1
    399e:	9c 83       	std	Y+4, r25	; 0x04
    39a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    39a2:	eb 81       	ldd	r30, Y+3	; 0x03
    39a4:	fc 81       	ldd	r31, Y+4	; 0x04
    39a6:	87 e1       	ldi	r24, 0x17	; 23
    39a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    39aa:	8b 81       	ldd	r24, Y+3	; 0x03
    39ac:	9c 81       	ldd	r25, Y+4	; 0x04
    39ae:	01 97       	sbiw	r24, 0x01	; 1
    39b0:	9c 83       	std	Y+4, r25	; 0x04
    39b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    39b4:	eb 81       	ldd	r30, Y+3	; 0x03
    39b6:	fc 81       	ldd	r31, Y+4	; 0x04
    39b8:	88 e1       	ldi	r24, 0x18	; 24
    39ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    39bc:	8b 81       	ldd	r24, Y+3	; 0x03
    39be:	9c 81       	ldd	r25, Y+4	; 0x04
    39c0:	01 97       	sbiw	r24, 0x01	; 1
    39c2:	9c 83       	std	Y+4, r25	; 0x04
    39c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    39c6:	eb 81       	ldd	r30, Y+3	; 0x03
    39c8:	fc 81       	ldd	r31, Y+4	; 0x04
    39ca:	89 e1       	ldi	r24, 0x19	; 25
    39cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    39ce:	8b 81       	ldd	r24, Y+3	; 0x03
    39d0:	9c 81       	ldd	r25, Y+4	; 0x04
    39d2:	01 97       	sbiw	r24, 0x01	; 1
    39d4:	9c 83       	std	Y+4, r25	; 0x04
    39d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    39d8:	eb 81       	ldd	r30, Y+3	; 0x03
    39da:	fc 81       	ldd	r31, Y+4	; 0x04
    39dc:	80 e2       	ldi	r24, 0x20	; 32
    39de:	80 83       	st	Z, r24
	pxTopOfStack--;
    39e0:	8b 81       	ldd	r24, Y+3	; 0x03
    39e2:	9c 81       	ldd	r25, Y+4	; 0x04
    39e4:	01 97       	sbiw	r24, 0x01	; 1
    39e6:	9c 83       	std	Y+4, r25	; 0x04
    39e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    39ea:	eb 81       	ldd	r30, Y+3	; 0x03
    39ec:	fc 81       	ldd	r31, Y+4	; 0x04
    39ee:	81 e2       	ldi	r24, 0x21	; 33
    39f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    39f2:	8b 81       	ldd	r24, Y+3	; 0x03
    39f4:	9c 81       	ldd	r25, Y+4	; 0x04
    39f6:	01 97       	sbiw	r24, 0x01	; 1
    39f8:	9c 83       	std	Y+4, r25	; 0x04
    39fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    39fc:	eb 81       	ldd	r30, Y+3	; 0x03
    39fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3a00:	82 e2       	ldi	r24, 0x22	; 34
    3a02:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a04:	8b 81       	ldd	r24, Y+3	; 0x03
    3a06:	9c 81       	ldd	r25, Y+4	; 0x04
    3a08:	01 97       	sbiw	r24, 0x01	; 1
    3a0a:	9c 83       	std	Y+4, r25	; 0x04
    3a0c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3a0e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a10:	fc 81       	ldd	r31, Y+4	; 0x04
    3a12:	83 e2       	ldi	r24, 0x23	; 35
    3a14:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a16:	8b 81       	ldd	r24, Y+3	; 0x03
    3a18:	9c 81       	ldd	r25, Y+4	; 0x04
    3a1a:	01 97       	sbiw	r24, 0x01	; 1
    3a1c:	9c 83       	std	Y+4, r25	; 0x04
    3a1e:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    3a20:	8f 81       	ldd	r24, Y+7	; 0x07
    3a22:	98 85       	ldd	r25, Y+8	; 0x08
    3a24:	9a 83       	std	Y+2, r25	; 0x02
    3a26:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3a28:	89 81       	ldd	r24, Y+1	; 0x01
    3a2a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a2c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a2e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a30:	8b 81       	ldd	r24, Y+3	; 0x03
    3a32:	9c 81       	ldd	r25, Y+4	; 0x04
    3a34:	01 97       	sbiw	r24, 0x01	; 1
    3a36:	9c 83       	std	Y+4, r25	; 0x04
    3a38:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3a3a:	89 81       	ldd	r24, Y+1	; 0x01
    3a3c:	9a 81       	ldd	r25, Y+2	; 0x02
    3a3e:	89 2f       	mov	r24, r25
    3a40:	99 27       	eor	r25, r25
    3a42:	9a 83       	std	Y+2, r25	; 0x02
    3a44:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3a46:	89 81       	ldd	r24, Y+1	; 0x01
    3a48:	eb 81       	ldd	r30, Y+3	; 0x03
    3a4a:	fc 81       	ldd	r31, Y+4	; 0x04
    3a4c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a50:	9c 81       	ldd	r25, Y+4	; 0x04
    3a52:	01 97       	sbiw	r24, 0x01	; 1
    3a54:	9c 83       	std	Y+4, r25	; 0x04
    3a56:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    3a58:	eb 81       	ldd	r30, Y+3	; 0x03
    3a5a:	fc 81       	ldd	r31, Y+4	; 0x04
    3a5c:	86 e2       	ldi	r24, 0x26	; 38
    3a5e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a60:	8b 81       	ldd	r24, Y+3	; 0x03
    3a62:	9c 81       	ldd	r25, Y+4	; 0x04
    3a64:	01 97       	sbiw	r24, 0x01	; 1
    3a66:	9c 83       	std	Y+4, r25	; 0x04
    3a68:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3a6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3a6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3a6e:	87 e2       	ldi	r24, 0x27	; 39
    3a70:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a72:	8b 81       	ldd	r24, Y+3	; 0x03
    3a74:	9c 81       	ldd	r25, Y+4	; 0x04
    3a76:	01 97       	sbiw	r24, 0x01	; 1
    3a78:	9c 83       	std	Y+4, r25	; 0x04
    3a7a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3a7c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a7e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a80:	88 e2       	ldi	r24, 0x28	; 40
    3a82:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a84:	8b 81       	ldd	r24, Y+3	; 0x03
    3a86:	9c 81       	ldd	r25, Y+4	; 0x04
    3a88:	01 97       	sbiw	r24, 0x01	; 1
    3a8a:	9c 83       	std	Y+4, r25	; 0x04
    3a8c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    3a8e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a90:	fc 81       	ldd	r31, Y+4	; 0x04
    3a92:	89 e2       	ldi	r24, 0x29	; 41
    3a94:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a96:	8b 81       	ldd	r24, Y+3	; 0x03
    3a98:	9c 81       	ldd	r25, Y+4	; 0x04
    3a9a:	01 97       	sbiw	r24, 0x01	; 1
    3a9c:	9c 83       	std	Y+4, r25	; 0x04
    3a9e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    3aa0:	eb 81       	ldd	r30, Y+3	; 0x03
    3aa2:	fc 81       	ldd	r31, Y+4	; 0x04
    3aa4:	80 e3       	ldi	r24, 0x30	; 48
    3aa6:	80 83       	st	Z, r24
	pxTopOfStack--;
    3aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    3aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    3aac:	01 97       	sbiw	r24, 0x01	; 1
    3aae:	9c 83       	std	Y+4, r25	; 0x04
    3ab0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3ab2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ab4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ab6:	81 e3       	ldi	r24, 0x31	; 49
    3ab8:	80 83       	st	Z, r24
	pxTopOfStack--;
    3aba:	8b 81       	ldd	r24, Y+3	; 0x03
    3abc:	9c 81       	ldd	r25, Y+4	; 0x04
    3abe:	01 97       	sbiw	r24, 0x01	; 1
    3ac0:	9c 83       	std	Y+4, r25	; 0x04
    3ac2:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3ac4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ac6:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3ac8:	28 96       	adiw	r28, 0x08	; 8
    3aca:	0f b6       	in	r0, 0x3f	; 63
    3acc:	f8 94       	cli
    3ace:	de bf       	out	0x3e, r29	; 62
    3ad0:	0f be       	out	0x3f, r0	; 63
    3ad2:	cd bf       	out	0x3d, r28	; 61
    3ad4:	cf 91       	pop	r28
    3ad6:	df 91       	pop	r29
    3ad8:	08 95       	ret

00003ada <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    3ada:	df 93       	push	r29
    3adc:	cf 93       	push	r28
    3ade:	cd b7       	in	r28, 0x3d	; 61
    3ae0:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3ae2:	0e 94 5f 1e 	call	0x3cbe	; 0x3cbe <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3ae6:	a0 91 73 04 	lds	r26, 0x0473
    3aea:	b0 91 74 04 	lds	r27, 0x0474
    3aee:	cd 91       	ld	r28, X+
    3af0:	cd bf       	out	0x3d, r28	; 61
    3af2:	dd 91       	ld	r29, X+
    3af4:	de bf       	out	0x3e, r29	; 62
    3af6:	ff 91       	pop	r31
    3af8:	ef 91       	pop	r30
    3afa:	df 91       	pop	r29
    3afc:	cf 91       	pop	r28
    3afe:	bf 91       	pop	r27
    3b00:	af 91       	pop	r26
    3b02:	9f 91       	pop	r25
    3b04:	8f 91       	pop	r24
    3b06:	7f 91       	pop	r23
    3b08:	6f 91       	pop	r22
    3b0a:	5f 91       	pop	r21
    3b0c:	4f 91       	pop	r20
    3b0e:	3f 91       	pop	r19
    3b10:	2f 91       	pop	r18
    3b12:	1f 91       	pop	r17
    3b14:	0f 91       	pop	r16
    3b16:	ff 90       	pop	r15
    3b18:	ef 90       	pop	r14
    3b1a:	df 90       	pop	r13
    3b1c:	cf 90       	pop	r12
    3b1e:	bf 90       	pop	r11
    3b20:	af 90       	pop	r10
    3b22:	9f 90       	pop	r9
    3b24:	8f 90       	pop	r8
    3b26:	7f 90       	pop	r7
    3b28:	6f 90       	pop	r6
    3b2a:	5f 90       	pop	r5
    3b2c:	4f 90       	pop	r4
    3b2e:	3f 90       	pop	r3
    3b30:	2f 90       	pop	r2
    3b32:	1f 90       	pop	r1
    3b34:	0f 90       	pop	r0
    3b36:	0f be       	out	0x3f, r0	; 63
    3b38:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3b3a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3b3c:	81 e0       	ldi	r24, 0x01	; 1
}
    3b3e:	cf 91       	pop	r28
    3b40:	df 91       	pop	r29
    3b42:	08 95       	ret

00003b44 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3b44:	df 93       	push	r29
    3b46:	cf 93       	push	r28
    3b48:	cd b7       	in	r28, 0x3d	; 61
    3b4a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3b4c:	cf 91       	pop	r28
    3b4e:	df 91       	pop	r29
    3b50:	08 95       	ret

00003b52 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3b52:	0f 92       	push	r0
    3b54:	0f b6       	in	r0, 0x3f	; 63
    3b56:	f8 94       	cli
    3b58:	0f 92       	push	r0
    3b5a:	1f 92       	push	r1
    3b5c:	11 24       	eor	r1, r1
    3b5e:	2f 92       	push	r2
    3b60:	3f 92       	push	r3
    3b62:	4f 92       	push	r4
    3b64:	5f 92       	push	r5
    3b66:	6f 92       	push	r6
    3b68:	7f 92       	push	r7
    3b6a:	8f 92       	push	r8
    3b6c:	9f 92       	push	r9
    3b6e:	af 92       	push	r10
    3b70:	bf 92       	push	r11
    3b72:	cf 92       	push	r12
    3b74:	df 92       	push	r13
    3b76:	ef 92       	push	r14
    3b78:	ff 92       	push	r15
    3b7a:	0f 93       	push	r16
    3b7c:	1f 93       	push	r17
    3b7e:	2f 93       	push	r18
    3b80:	3f 93       	push	r19
    3b82:	4f 93       	push	r20
    3b84:	5f 93       	push	r21
    3b86:	6f 93       	push	r22
    3b88:	7f 93       	push	r23
    3b8a:	8f 93       	push	r24
    3b8c:	9f 93       	push	r25
    3b8e:	af 93       	push	r26
    3b90:	bf 93       	push	r27
    3b92:	cf 93       	push	r28
    3b94:	df 93       	push	r29
    3b96:	ef 93       	push	r30
    3b98:	ff 93       	push	r31
    3b9a:	a0 91 73 04 	lds	r26, 0x0473
    3b9e:	b0 91 74 04 	lds	r27, 0x0474
    3ba2:	0d b6       	in	r0, 0x3d	; 61
    3ba4:	0d 92       	st	X+, r0
    3ba6:	0e b6       	in	r0, 0x3e	; 62
    3ba8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3baa:	0e 94 6a 2d 	call	0x5ad4	; 0x5ad4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3bae:	a0 91 73 04 	lds	r26, 0x0473
    3bb2:	b0 91 74 04 	lds	r27, 0x0474
    3bb6:	cd 91       	ld	r28, X+
    3bb8:	cd bf       	out	0x3d, r28	; 61
    3bba:	dd 91       	ld	r29, X+
    3bbc:	de bf       	out	0x3e, r29	; 62
    3bbe:	ff 91       	pop	r31
    3bc0:	ef 91       	pop	r30
    3bc2:	df 91       	pop	r29
    3bc4:	cf 91       	pop	r28
    3bc6:	bf 91       	pop	r27
    3bc8:	af 91       	pop	r26
    3bca:	9f 91       	pop	r25
    3bcc:	8f 91       	pop	r24
    3bce:	7f 91       	pop	r23
    3bd0:	6f 91       	pop	r22
    3bd2:	5f 91       	pop	r21
    3bd4:	4f 91       	pop	r20
    3bd6:	3f 91       	pop	r19
    3bd8:	2f 91       	pop	r18
    3bda:	1f 91       	pop	r17
    3bdc:	0f 91       	pop	r16
    3bde:	ff 90       	pop	r15
    3be0:	ef 90       	pop	r14
    3be2:	df 90       	pop	r13
    3be4:	cf 90       	pop	r12
    3be6:	bf 90       	pop	r11
    3be8:	af 90       	pop	r10
    3bea:	9f 90       	pop	r9
    3bec:	8f 90       	pop	r8
    3bee:	7f 90       	pop	r7
    3bf0:	6f 90       	pop	r6
    3bf2:	5f 90       	pop	r5
    3bf4:	4f 90       	pop	r4
    3bf6:	3f 90       	pop	r3
    3bf8:	2f 90       	pop	r2
    3bfa:	1f 90       	pop	r1
    3bfc:	0f 90       	pop	r0
    3bfe:	0f be       	out	0x3f, r0	; 63
    3c00:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3c02:	08 95       	ret

00003c04 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3c04:	0f 92       	push	r0
    3c06:	0f b6       	in	r0, 0x3f	; 63
    3c08:	f8 94       	cli
    3c0a:	0f 92       	push	r0
    3c0c:	1f 92       	push	r1
    3c0e:	11 24       	eor	r1, r1
    3c10:	2f 92       	push	r2
    3c12:	3f 92       	push	r3
    3c14:	4f 92       	push	r4
    3c16:	5f 92       	push	r5
    3c18:	6f 92       	push	r6
    3c1a:	7f 92       	push	r7
    3c1c:	8f 92       	push	r8
    3c1e:	9f 92       	push	r9
    3c20:	af 92       	push	r10
    3c22:	bf 92       	push	r11
    3c24:	cf 92       	push	r12
    3c26:	df 92       	push	r13
    3c28:	ef 92       	push	r14
    3c2a:	ff 92       	push	r15
    3c2c:	0f 93       	push	r16
    3c2e:	1f 93       	push	r17
    3c30:	2f 93       	push	r18
    3c32:	3f 93       	push	r19
    3c34:	4f 93       	push	r20
    3c36:	5f 93       	push	r21
    3c38:	6f 93       	push	r22
    3c3a:	7f 93       	push	r23
    3c3c:	8f 93       	push	r24
    3c3e:	9f 93       	push	r25
    3c40:	af 93       	push	r26
    3c42:	bf 93       	push	r27
    3c44:	cf 93       	push	r28
    3c46:	df 93       	push	r29
    3c48:	ef 93       	push	r30
    3c4a:	ff 93       	push	r31
    3c4c:	a0 91 73 04 	lds	r26, 0x0473
    3c50:	b0 91 74 04 	lds	r27, 0x0474
    3c54:	0d b6       	in	r0, 0x3d	; 61
    3c56:	0d 92       	st	X+, r0
    3c58:	0e b6       	in	r0, 0x3e	; 62
    3c5a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    3c5c:	0e 94 81 2c 	call	0x5902	; 0x5902 <xTaskIncrementTick>
    3c60:	88 23       	and	r24, r24
    3c62:	11 f0       	breq	.+4      	; 0x3c68 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    3c64:	0e 94 6a 2d 	call	0x5ad4	; 0x5ad4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    3c68:	a0 91 73 04 	lds	r26, 0x0473
    3c6c:	b0 91 74 04 	lds	r27, 0x0474
    3c70:	cd 91       	ld	r28, X+
    3c72:	cd bf       	out	0x3d, r28	; 61
    3c74:	dd 91       	ld	r29, X+
    3c76:	de bf       	out	0x3e, r29	; 62
    3c78:	ff 91       	pop	r31
    3c7a:	ef 91       	pop	r30
    3c7c:	df 91       	pop	r29
    3c7e:	cf 91       	pop	r28
    3c80:	bf 91       	pop	r27
    3c82:	af 91       	pop	r26
    3c84:	9f 91       	pop	r25
    3c86:	8f 91       	pop	r24
    3c88:	7f 91       	pop	r23
    3c8a:	6f 91       	pop	r22
    3c8c:	5f 91       	pop	r21
    3c8e:	4f 91       	pop	r20
    3c90:	3f 91       	pop	r19
    3c92:	2f 91       	pop	r18
    3c94:	1f 91       	pop	r17
    3c96:	0f 91       	pop	r16
    3c98:	ff 90       	pop	r15
    3c9a:	ef 90       	pop	r14
    3c9c:	df 90       	pop	r13
    3c9e:	cf 90       	pop	r12
    3ca0:	bf 90       	pop	r11
    3ca2:	af 90       	pop	r10
    3ca4:	9f 90       	pop	r9
    3ca6:	8f 90       	pop	r8
    3ca8:	7f 90       	pop	r7
    3caa:	6f 90       	pop	r6
    3cac:	5f 90       	pop	r5
    3cae:	4f 90       	pop	r4
    3cb0:	3f 90       	pop	r3
    3cb2:	2f 90       	pop	r2
    3cb4:	1f 90       	pop	r1
    3cb6:	0f 90       	pop	r0
    3cb8:	0f be       	out	0x3f, r0	; 63
    3cba:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3cbc:	08 95       	ret

00003cbe <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3cbe:	df 93       	push	r29
    3cc0:	cf 93       	push	r28
    3cc2:	00 d0       	rcall	.+0      	; 0x3cc4 <prvSetupTimerInterrupt+0x6>
    3cc4:	00 d0       	rcall	.+0      	; 0x3cc6 <prvSetupTimerInterrupt+0x8>
    3cc6:	00 d0       	rcall	.+0      	; 0x3cc8 <prvSetupTimerInterrupt+0xa>
    3cc8:	cd b7       	in	r28, 0x3d	; 61
    3cca:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3ccc:	80 e4       	ldi	r24, 0x40	; 64
    3cce:	9f e1       	ldi	r25, 0x1F	; 31
    3cd0:	a0 e0       	ldi	r26, 0x00	; 0
    3cd2:	b0 e0       	ldi	r27, 0x00	; 0
    3cd4:	8b 83       	std	Y+3, r24	; 0x03
    3cd6:	9c 83       	std	Y+4, r25	; 0x04
    3cd8:	ad 83       	std	Y+5, r26	; 0x05
    3cda:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    3cde:	9c 81       	ldd	r25, Y+4	; 0x04
    3ce0:	ad 81       	ldd	r26, Y+5	; 0x05
    3ce2:	be 81       	ldd	r27, Y+6	; 0x06
    3ce4:	68 94       	set
    3ce6:	15 f8       	bld	r1, 5
    3ce8:	b6 95       	lsr	r27
    3cea:	a7 95       	ror	r26
    3cec:	97 95       	ror	r25
    3cee:	87 95       	ror	r24
    3cf0:	16 94       	lsr	r1
    3cf2:	d1 f7       	brne	.-12     	; 0x3ce8 <prvSetupTimerInterrupt+0x2a>
    3cf4:	8b 83       	std	Y+3, r24	; 0x03
    3cf6:	9c 83       	std	Y+4, r25	; 0x04
    3cf8:	ad 83       	std	Y+5, r26	; 0x05
    3cfa:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    3cfc:	8b 81       	ldd	r24, Y+3	; 0x03
    3cfe:	9c 81       	ldd	r25, Y+4	; 0x04
    3d00:	ad 81       	ldd	r26, Y+5	; 0x05
    3d02:	be 81       	ldd	r27, Y+6	; 0x06
    3d04:	01 97       	sbiw	r24, 0x01	; 1
    3d06:	a1 09       	sbc	r26, r1
    3d08:	b1 09       	sbc	r27, r1
    3d0a:	8b 83       	std	Y+3, r24	; 0x03
    3d0c:	9c 83       	std	Y+4, r25	; 0x04
    3d0e:	ad 83       	std	Y+5, r26	; 0x05
    3d10:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3d12:	8b 81       	ldd	r24, Y+3	; 0x03
    3d14:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3d16:	8b 81       	ldd	r24, Y+3	; 0x03
    3d18:	9c 81       	ldd	r25, Y+4	; 0x04
    3d1a:	ad 81       	ldd	r26, Y+5	; 0x05
    3d1c:	be 81       	ldd	r27, Y+6	; 0x06
    3d1e:	89 2f       	mov	r24, r25
    3d20:	9a 2f       	mov	r25, r26
    3d22:	ab 2f       	mov	r26, r27
    3d24:	bb 27       	eor	r27, r27
    3d26:	8b 83       	std	Y+3, r24	; 0x03
    3d28:	9c 83       	std	Y+4, r25	; 0x04
    3d2a:	ad 83       	std	Y+5, r26	; 0x05
    3d2c:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3d2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d30:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3d32:	eb e4       	ldi	r30, 0x4B	; 75
    3d34:	f0 e0       	ldi	r31, 0x00	; 0
    3d36:	8a 81       	ldd	r24, Y+2	; 0x02
    3d38:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3d3a:	ea e4       	ldi	r30, 0x4A	; 74
    3d3c:	f0 e0       	ldi	r31, 0x00	; 0
    3d3e:	89 81       	ldd	r24, Y+1	; 0x01
    3d40:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3d42:	8b e0       	ldi	r24, 0x0B	; 11
    3d44:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3d46:	ee e4       	ldi	r30, 0x4E	; 78
    3d48:	f0 e0       	ldi	r31, 0x00	; 0
    3d4a:	89 81       	ldd	r24, Y+1	; 0x01
    3d4c:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3d4e:	e9 e5       	ldi	r30, 0x59	; 89
    3d50:	f0 e0       	ldi	r31, 0x00	; 0
    3d52:	80 81       	ld	r24, Z
    3d54:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3d56:	89 81       	ldd	r24, Y+1	; 0x01
    3d58:	80 61       	ori	r24, 0x10	; 16
    3d5a:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3d5c:	e9 e5       	ldi	r30, 0x59	; 89
    3d5e:	f0 e0       	ldi	r31, 0x00	; 0
    3d60:	89 81       	ldd	r24, Y+1	; 0x01
    3d62:	80 83       	st	Z, r24
}
    3d64:	26 96       	adiw	r28, 0x06	; 6
    3d66:	0f b6       	in	r0, 0x3f	; 63
    3d68:	f8 94       	cli
    3d6a:	de bf       	out	0x3e, r29	; 62
    3d6c:	0f be       	out	0x3f, r0	; 63
    3d6e:	cd bf       	out	0x3d, r28	; 61
    3d70:	cf 91       	pop	r28
    3d72:	df 91       	pop	r29
    3d74:	08 95       	ret

00003d76 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    3d76:	0e 94 02 1e 	call	0x3c04	; 0x3c04 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3d7a:	18 95       	reti

00003d7c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    3d7c:	df 93       	push	r29
    3d7e:	cf 93       	push	r28
    3d80:	00 d0       	rcall	.+0      	; 0x3d82 <xQueueGenericReset+0x6>
    3d82:	00 d0       	rcall	.+0      	; 0x3d84 <xQueueGenericReset+0x8>
    3d84:	0f 92       	push	r0
    3d86:	cd b7       	in	r28, 0x3d	; 61
    3d88:	de b7       	in	r29, 0x3e	; 62
    3d8a:	9c 83       	std	Y+4, r25	; 0x04
    3d8c:	8b 83       	std	Y+3, r24	; 0x03
    3d8e:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    3d90:	8b 81       	ldd	r24, Y+3	; 0x03
    3d92:	9c 81       	ldd	r25, Y+4	; 0x04
    3d94:	9a 83       	std	Y+2, r25	; 0x02
    3d96:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3d98:	0f b6       	in	r0, 0x3f	; 63
    3d9a:	f8 94       	cli
    3d9c:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3d9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3da0:	fa 81       	ldd	r31, Y+2	; 0x02
    3da2:	40 81       	ld	r20, Z
    3da4:	51 81       	ldd	r21, Z+1	; 0x01
    3da6:	e9 81       	ldd	r30, Y+1	; 0x01
    3da8:	fa 81       	ldd	r31, Y+2	; 0x02
    3daa:	83 8d       	ldd	r24, Z+27	; 0x1b
    3dac:	28 2f       	mov	r18, r24
    3dae:	30 e0       	ldi	r19, 0x00	; 0
    3db0:	e9 81       	ldd	r30, Y+1	; 0x01
    3db2:	fa 81       	ldd	r31, Y+2	; 0x02
    3db4:	84 8d       	ldd	r24, Z+28	; 0x1c
    3db6:	88 2f       	mov	r24, r24
    3db8:	90 e0       	ldi	r25, 0x00	; 0
    3dba:	bc 01       	movw	r22, r24
    3dbc:	26 9f       	mul	r18, r22
    3dbe:	c0 01       	movw	r24, r0
    3dc0:	27 9f       	mul	r18, r23
    3dc2:	90 0d       	add	r25, r0
    3dc4:	36 9f       	mul	r19, r22
    3dc6:	90 0d       	add	r25, r0
    3dc8:	11 24       	eor	r1, r1
    3dca:	84 0f       	add	r24, r20
    3dcc:	95 1f       	adc	r25, r21
    3dce:	e9 81       	ldd	r30, Y+1	; 0x01
    3dd0:	fa 81       	ldd	r31, Y+2	; 0x02
    3dd2:	95 83       	std	Z+5, r25	; 0x05
    3dd4:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3dd6:	e9 81       	ldd	r30, Y+1	; 0x01
    3dd8:	fa 81       	ldd	r31, Y+2	; 0x02
    3dda:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    3ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    3dde:	fa 81       	ldd	r31, Y+2	; 0x02
    3de0:	80 81       	ld	r24, Z
    3de2:	91 81       	ldd	r25, Z+1	; 0x01
    3de4:	e9 81       	ldd	r30, Y+1	; 0x01
    3de6:	fa 81       	ldd	r31, Y+2	; 0x02
    3de8:	93 83       	std	Z+3, r25	; 0x03
    3dea:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3dec:	e9 81       	ldd	r30, Y+1	; 0x01
    3dee:	fa 81       	ldd	r31, Y+2	; 0x02
    3df0:	40 81       	ld	r20, Z
    3df2:	51 81       	ldd	r21, Z+1	; 0x01
    3df4:	e9 81       	ldd	r30, Y+1	; 0x01
    3df6:	fa 81       	ldd	r31, Y+2	; 0x02
    3df8:	83 8d       	ldd	r24, Z+27	; 0x1b
    3dfa:	88 2f       	mov	r24, r24
    3dfc:	90 e0       	ldi	r25, 0x00	; 0
    3dfe:	9c 01       	movw	r18, r24
    3e00:	21 50       	subi	r18, 0x01	; 1
    3e02:	30 40       	sbci	r19, 0x00	; 0
    3e04:	e9 81       	ldd	r30, Y+1	; 0x01
    3e06:	fa 81       	ldd	r31, Y+2	; 0x02
    3e08:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e0a:	88 2f       	mov	r24, r24
    3e0c:	90 e0       	ldi	r25, 0x00	; 0
    3e0e:	bc 01       	movw	r22, r24
    3e10:	26 9f       	mul	r18, r22
    3e12:	c0 01       	movw	r24, r0
    3e14:	27 9f       	mul	r18, r23
    3e16:	90 0d       	add	r25, r0
    3e18:	36 9f       	mul	r19, r22
    3e1a:	90 0d       	add	r25, r0
    3e1c:	11 24       	eor	r1, r1
    3e1e:	84 0f       	add	r24, r20
    3e20:	95 1f       	adc	r25, r21
    3e22:	e9 81       	ldd	r30, Y+1	; 0x01
    3e24:	fa 81       	ldd	r31, Y+2	; 0x02
    3e26:	97 83       	std	Z+7, r25	; 0x07
    3e28:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    3e2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e2e:	8f ef       	ldi	r24, 0xFF	; 255
    3e30:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    3e32:	e9 81       	ldd	r30, Y+1	; 0x01
    3e34:	fa 81       	ldd	r31, Y+2	; 0x02
    3e36:	8f ef       	ldi	r24, 0xFF	; 255
    3e38:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    3e3a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e3c:	88 23       	and	r24, r24
    3e3e:	79 f4       	brne	.+30     	; 0x3e5e <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e40:	e9 81       	ldd	r30, Y+1	; 0x01
    3e42:	fa 81       	ldd	r31, Y+2	; 0x02
    3e44:	80 85       	ldd	r24, Z+8	; 0x08
    3e46:	88 23       	and	r24, r24
    3e48:	a1 f0       	breq	.+40     	; 0x3e72 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e4a:	89 81       	ldd	r24, Y+1	; 0x01
    3e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e4e:	08 96       	adiw	r24, 0x08	; 8
    3e50:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    3e54:	88 23       	and	r24, r24
    3e56:	69 f0       	breq	.+26     	; 0x3e72 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3e58:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
    3e5c:	0a c0       	rjmp	.+20     	; 0x3e72 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3e5e:	89 81       	ldd	r24, Y+1	; 0x01
    3e60:	9a 81       	ldd	r25, Y+2	; 0x02
    3e62:	08 96       	adiw	r24, 0x08	; 8
    3e64:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3e68:	89 81       	ldd	r24, Y+1	; 0x01
    3e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e6c:	41 96       	adiw	r24, 0x11	; 17
    3e6e:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    3e72:	0f 90       	pop	r0
    3e74:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3e76:	81 e0       	ldi	r24, 0x01	; 1
}
    3e78:	0f 90       	pop	r0
    3e7a:	0f 90       	pop	r0
    3e7c:	0f 90       	pop	r0
    3e7e:	0f 90       	pop	r0
    3e80:	0f 90       	pop	r0
    3e82:	cf 91       	pop	r28
    3e84:	df 91       	pop	r29
    3e86:	08 95       	ret

00003e88 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    3e88:	0f 93       	push	r16
    3e8a:	1f 93       	push	r17
    3e8c:	df 93       	push	r29
    3e8e:	cf 93       	push	r28
    3e90:	cd b7       	in	r28, 0x3d	; 61
    3e92:	de b7       	in	r29, 0x3e	; 62
    3e94:	29 97       	sbiw	r28, 0x09	; 9
    3e96:	0f b6       	in	r0, 0x3f	; 63
    3e98:	f8 94       	cli
    3e9a:	de bf       	out	0x3e, r29	; 62
    3e9c:	0f be       	out	0x3f, r0	; 63
    3e9e:	cd bf       	out	0x3d, r28	; 61
    3ea0:	8f 83       	std	Y+7, r24	; 0x07
    3ea2:	68 87       	std	Y+8, r22	; 0x08
    3ea4:	49 87       	std	Y+9, r20	; 0x09
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3ea6:	8f 81       	ldd	r24, Y+7	; 0x07
    3ea8:	28 2f       	mov	r18, r24
    3eaa:	30 e0       	ldi	r19, 0x00	; 0
    3eac:	88 85       	ldd	r24, Y+8	; 0x08
    3eae:	88 2f       	mov	r24, r24
    3eb0:	90 e0       	ldi	r25, 0x00	; 0
    3eb2:	ac 01       	movw	r20, r24
    3eb4:	24 9f       	mul	r18, r20
    3eb6:	c0 01       	movw	r24, r0
    3eb8:	25 9f       	mul	r18, r21
    3eba:	90 0d       	add	r25, r0
    3ebc:	34 9f       	mul	r19, r20
    3ebe:	90 0d       	add	r25, r0
    3ec0:	11 24       	eor	r1, r1
    3ec2:	9c 83       	std	Y+4, r25	; 0x04
    3ec4:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    3ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    3eca:	4f 96       	adiw	r24, 0x1f	; 31
    3ecc:	0e 94 69 18 	call	0x30d2	; 0x30d2 <pvPortMalloc>
    3ed0:	9e 83       	std	Y+6, r25	; 0x06
    3ed2:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    3ed4:	8d 81       	ldd	r24, Y+5	; 0x05
    3ed6:	9e 81       	ldd	r25, Y+6	; 0x06
    3ed8:	00 97       	sbiw	r24, 0x00	; 0
    3eda:	a1 f0       	breq	.+40     	; 0x3f04 <xQueueGenericCreate+0x7c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    3edc:	8d 81       	ldd	r24, Y+5	; 0x05
    3ede:	9e 81       	ldd	r25, Y+6	; 0x06
    3ee0:	9a 83       	std	Y+2, r25	; 0x02
    3ee2:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3ee4:	89 81       	ldd	r24, Y+1	; 0x01
    3ee6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ee8:	4f 96       	adiw	r24, 0x1f	; 31
    3eea:	9a 83       	std	Y+2, r25	; 0x02
    3eec:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    3eee:	29 81       	ldd	r18, Y+1	; 0x01
    3ef0:	3a 81       	ldd	r19, Y+2	; 0x02
    3ef2:	ed 81       	ldd	r30, Y+5	; 0x05
    3ef4:	fe 81       	ldd	r31, Y+6	; 0x06
    3ef6:	8f 81       	ldd	r24, Y+7	; 0x07
    3ef8:	68 85       	ldd	r22, Y+8	; 0x08
    3efa:	a9 01       	movw	r20, r18
    3efc:	29 85       	ldd	r18, Y+9	; 0x09
    3efe:	8f 01       	movw	r16, r30
    3f00:	0e 94 8f 1f 	call	0x3f1e	; 0x3f1e <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    3f04:	8d 81       	ldd	r24, Y+5	; 0x05
    3f06:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    3f08:	29 96       	adiw	r28, 0x09	; 9
    3f0a:	0f b6       	in	r0, 0x3f	; 63
    3f0c:	f8 94       	cli
    3f0e:	de bf       	out	0x3e, r29	; 62
    3f10:	0f be       	out	0x3f, r0	; 63
    3f12:	cd bf       	out	0x3d, r28	; 61
    3f14:	cf 91       	pop	r28
    3f16:	df 91       	pop	r29
    3f18:	1f 91       	pop	r17
    3f1a:	0f 91       	pop	r16
    3f1c:	08 95       	ret

00003f1e <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    3f1e:	0f 93       	push	r16
    3f20:	1f 93       	push	r17
    3f22:	df 93       	push	r29
    3f24:	cf 93       	push	r28
    3f26:	cd b7       	in	r28, 0x3d	; 61
    3f28:	de b7       	in	r29, 0x3e	; 62
    3f2a:	27 97       	sbiw	r28, 0x07	; 7
    3f2c:	0f b6       	in	r0, 0x3f	; 63
    3f2e:	f8 94       	cli
    3f30:	de bf       	out	0x3e, r29	; 62
    3f32:	0f be       	out	0x3f, r0	; 63
    3f34:	cd bf       	out	0x3d, r28	; 61
    3f36:	89 83       	std	Y+1, r24	; 0x01
    3f38:	6a 83       	std	Y+2, r22	; 0x02
    3f3a:	5c 83       	std	Y+4, r21	; 0x04
    3f3c:	4b 83       	std	Y+3, r20	; 0x03
    3f3e:	2d 83       	std	Y+5, r18	; 0x05
    3f40:	1f 83       	std	Y+7, r17	; 0x07
    3f42:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    3f44:	8a 81       	ldd	r24, Y+2	; 0x02
    3f46:	88 23       	and	r24, r24
    3f48:	39 f4       	brne	.+14     	; 0x3f58 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3f4a:	8e 81       	ldd	r24, Y+6	; 0x06
    3f4c:	9f 81       	ldd	r25, Y+7	; 0x07
    3f4e:	ee 81       	ldd	r30, Y+6	; 0x06
    3f50:	ff 81       	ldd	r31, Y+7	; 0x07
    3f52:	91 83       	std	Z+1, r25	; 0x01
    3f54:	80 83       	st	Z, r24
    3f56:	06 c0       	rjmp	.+12     	; 0x3f64 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    3f58:	8b 81       	ldd	r24, Y+3	; 0x03
    3f5a:	9c 81       	ldd	r25, Y+4	; 0x04
    3f5c:	ee 81       	ldd	r30, Y+6	; 0x06
    3f5e:	ff 81       	ldd	r31, Y+7	; 0x07
    3f60:	91 83       	std	Z+1, r25	; 0x01
    3f62:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    3f64:	ee 81       	ldd	r30, Y+6	; 0x06
    3f66:	ff 81       	ldd	r31, Y+7	; 0x07
    3f68:	89 81       	ldd	r24, Y+1	; 0x01
    3f6a:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    3f6c:	ee 81       	ldd	r30, Y+6	; 0x06
    3f6e:	ff 81       	ldd	r31, Y+7	; 0x07
    3f70:	8a 81       	ldd	r24, Y+2	; 0x02
    3f72:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3f74:	8e 81       	ldd	r24, Y+6	; 0x06
    3f76:	9f 81       	ldd	r25, Y+7	; 0x07
    3f78:	61 e0       	ldi	r22, 0x01	; 1
    3f7a:	0e 94 be 1e 	call	0x3d7c	; 0x3d7c <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    3f7e:	27 96       	adiw	r28, 0x07	; 7
    3f80:	0f b6       	in	r0, 0x3f	; 63
    3f82:	f8 94       	cli
    3f84:	de bf       	out	0x3e, r29	; 62
    3f86:	0f be       	out	0x3f, r0	; 63
    3f88:	cd bf       	out	0x3d, r28	; 61
    3f8a:	cf 91       	pop	r28
    3f8c:	df 91       	pop	r29
    3f8e:	1f 91       	pop	r17
    3f90:	0f 91       	pop	r16
    3f92:	08 95       	ret

00003f94 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    3f94:	df 93       	push	r29
    3f96:	cf 93       	push	r28
    3f98:	cd b7       	in	r28, 0x3d	; 61
    3f9a:	de b7       	in	r29, 0x3e	; 62
    3f9c:	2f 97       	sbiw	r28, 0x0f	; 15
    3f9e:	0f b6       	in	r0, 0x3f	; 63
    3fa0:	f8 94       	cli
    3fa2:	de bf       	out	0x3e, r29	; 62
    3fa4:	0f be       	out	0x3f, r0	; 63
    3fa6:	cd bf       	out	0x3d, r28	; 61
    3fa8:	99 87       	std	Y+9, r25	; 0x09
    3faa:	88 87       	std	Y+8, r24	; 0x08
    3fac:	7b 87       	std	Y+11, r23	; 0x0b
    3fae:	6a 87       	std	Y+10, r22	; 0x0a
    3fb0:	5d 87       	std	Y+13, r21	; 0x0d
    3fb2:	4c 87       	std	Y+12, r20	; 0x0c
    3fb4:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3fb6:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3fb8:	88 85       	ldd	r24, Y+8	; 0x08
    3fba:	99 85       	ldd	r25, Y+9	; 0x09
    3fbc:	9a 83       	std	Y+2, r25	; 0x02
    3fbe:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3fc0:	0f b6       	in	r0, 0x3f	; 63
    3fc2:	f8 94       	cli
    3fc4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3fc6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fca:	92 8d       	ldd	r25, Z+26	; 0x1a
    3fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    3fce:	fa 81       	ldd	r31, Y+2	; 0x02
    3fd0:	83 8d       	ldd	r24, Z+27	; 0x1b
    3fd2:	98 17       	cp	r25, r24
    3fd4:	18 f0       	brcs	.+6      	; 0x3fdc <xQueueGenericSend+0x48>
    3fd6:	8e 85       	ldd	r24, Y+14	; 0x0e
    3fd8:	82 30       	cpi	r24, 0x02	; 2
    3fda:	11 f5       	brne	.+68     	; 0x4020 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3fdc:	89 81       	ldd	r24, Y+1	; 0x01
    3fde:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe0:	2a 85       	ldd	r18, Y+10	; 0x0a
    3fe2:	3b 85       	ldd	r19, Y+11	; 0x0b
    3fe4:	b9 01       	movw	r22, r18
    3fe6:	4e 85       	ldd	r20, Y+14	; 0x0e
    3fe8:	0e 94 20 24 	call	0x4840	; 0x4840 <prvCopyDataToQueue>
    3fec:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3fee:	e9 81       	ldd	r30, Y+1	; 0x01
    3ff0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ff2:	81 89       	ldd	r24, Z+17	; 0x11
    3ff4:	88 23       	and	r24, r24
    3ff6:	51 f0       	breq	.+20     	; 0x400c <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ff8:	89 81       	ldd	r24, Y+1	; 0x01
    3ffa:	9a 81       	ldd	r25, Y+2	; 0x02
    3ffc:	41 96       	adiw	r24, 0x11	; 17
    3ffe:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    4002:	88 23       	and	r24, r24
    4004:	41 f0       	breq	.+16     	; 0x4016 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    4006:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
    400a:	05 c0       	rjmp	.+10     	; 0x4016 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    400c:	8b 81       	ldd	r24, Y+3	; 0x03
    400e:	88 23       	and	r24, r24
    4010:	11 f0       	breq	.+4      	; 0x4016 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    4012:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    4016:	0f 90       	pop	r0
    4018:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    401a:	81 e0       	ldi	r24, 0x01	; 1
    401c:	8f 87       	std	Y+15, r24	; 0x0f
    401e:	5c c0       	rjmp	.+184    	; 0x40d8 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    4020:	8c 85       	ldd	r24, Y+12	; 0x0c
    4022:	9d 85       	ldd	r25, Y+13	; 0x0d
    4024:	00 97       	sbiw	r24, 0x00	; 0
    4026:	21 f4       	brne	.+8      	; 0x4030 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    4028:	0f 90       	pop	r0
    402a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    402c:	1f 86       	std	Y+15, r1	; 0x0f
    402e:	54 c0       	rjmp	.+168    	; 0x40d8 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    4030:	8c 81       	ldd	r24, Y+4	; 0x04
    4032:	88 23       	and	r24, r24
    4034:	31 f4       	brne	.+12     	; 0x4042 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    4036:	ce 01       	movw	r24, r28
    4038:	05 96       	adiw	r24, 0x05	; 5
    403a:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    403e:	81 e0       	ldi	r24, 0x01	; 1
    4040:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4042:	0f 90       	pop	r0
    4044:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4046:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    404a:	0f b6       	in	r0, 0x3f	; 63
    404c:	f8 94       	cli
    404e:	0f 92       	push	r0
    4050:	e9 81       	ldd	r30, Y+1	; 0x01
    4052:	fa 81       	ldd	r31, Y+2	; 0x02
    4054:	85 8d       	ldd	r24, Z+29	; 0x1d
    4056:	8f 3f       	cpi	r24, 0xFF	; 255
    4058:	19 f4       	brne	.+6      	; 0x4060 <xQueueGenericSend+0xcc>
    405a:	e9 81       	ldd	r30, Y+1	; 0x01
    405c:	fa 81       	ldd	r31, Y+2	; 0x02
    405e:	15 8e       	std	Z+29, r1	; 0x1d
    4060:	e9 81       	ldd	r30, Y+1	; 0x01
    4062:	fa 81       	ldd	r31, Y+2	; 0x02
    4064:	86 8d       	ldd	r24, Z+30	; 0x1e
    4066:	8f 3f       	cpi	r24, 0xFF	; 255
    4068:	19 f4       	brne	.+6      	; 0x4070 <xQueueGenericSend+0xdc>
    406a:	e9 81       	ldd	r30, Y+1	; 0x01
    406c:	fa 81       	ldd	r31, Y+2	; 0x02
    406e:	16 8e       	std	Z+30, r1	; 0x1e
    4070:	0f 90       	pop	r0
    4072:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4074:	ce 01       	movw	r24, r28
    4076:	05 96       	adiw	r24, 0x05	; 5
    4078:	9e 01       	movw	r18, r28
    407a:	24 5f       	subi	r18, 0xF4	; 244
    407c:	3f 4f       	sbci	r19, 0xFF	; 255
    407e:	b9 01       	movw	r22, r18
    4080:	0e 94 28 2f 	call	0x5e50	; 0x5e50 <xTaskCheckForTimeOut>
    4084:	88 23       	and	r24, r24
    4086:	09 f5       	brne	.+66     	; 0x40ca <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4088:	89 81       	ldd	r24, Y+1	; 0x01
    408a:	9a 81       	ldd	r25, Y+2	; 0x02
    408c:	0e 94 9c 25 	call	0x4b38	; 0x4b38 <prvIsQueueFull>
    4090:	88 23       	and	r24, r24
    4092:	a1 f0       	breq	.+40     	; 0x40bc <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4094:	89 81       	ldd	r24, Y+1	; 0x01
    4096:	9a 81       	ldd	r25, Y+2	; 0x02
    4098:	08 96       	adiw	r24, 0x08	; 8
    409a:	2c 85       	ldd	r18, Y+12	; 0x0c
    409c:	3d 85       	ldd	r19, Y+13	; 0x0d
    409e:	b9 01       	movw	r22, r18
    40a0:	0e 94 d7 2d 	call	0x5bae	; 0x5bae <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    40a4:	89 81       	ldd	r24, Y+1	; 0x01
    40a6:	9a 81       	ldd	r25, Y+2	; 0x02
    40a8:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    40ac:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    40b0:	88 23       	and	r24, r24
    40b2:	09 f0       	breq	.+2      	; 0x40b6 <xQueueGenericSend+0x122>
    40b4:	85 cf       	rjmp	.-246    	; 0x3fc0 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    40b6:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
    40ba:	82 cf       	rjmp	.-252    	; 0x3fc0 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    40bc:	89 81       	ldd	r24, Y+1	; 0x01
    40be:	9a 81       	ldd	r25, Y+2	; 0x02
    40c0:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    40c4:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    40c8:	7b cf       	rjmp	.-266    	; 0x3fc0 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    40ca:	89 81       	ldd	r24, Y+1	; 0x01
    40cc:	9a 81       	ldd	r25, Y+2	; 0x02
    40ce:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    40d2:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    40d6:	1f 86       	std	Y+15, r1	; 0x0f
    40d8:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    40da:	2f 96       	adiw	r28, 0x0f	; 15
    40dc:	0f b6       	in	r0, 0x3f	; 63
    40de:	f8 94       	cli
    40e0:	de bf       	out	0x3e, r29	; 62
    40e2:	0f be       	out	0x3f, r0	; 63
    40e4:	cd bf       	out	0x3d, r28	; 61
    40e6:	cf 91       	pop	r28
    40e8:	df 91       	pop	r29
    40ea:	08 95       	ret

000040ec <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    40ec:	df 93       	push	r29
    40ee:	cf 93       	push	r28
    40f0:	cd b7       	in	r28, 0x3d	; 61
    40f2:	de b7       	in	r29, 0x3e	; 62
    40f4:	2d 97       	sbiw	r28, 0x0d	; 13
    40f6:	0f b6       	in	r0, 0x3f	; 63
    40f8:	f8 94       	cli
    40fa:	de bf       	out	0x3e, r29	; 62
    40fc:	0f be       	out	0x3f, r0	; 63
    40fe:	cd bf       	out	0x3d, r28	; 61
    4100:	98 87       	std	Y+8, r25	; 0x08
    4102:	8f 83       	std	Y+7, r24	; 0x07
    4104:	7a 87       	std	Y+10, r23	; 0x0a
    4106:	69 87       	std	Y+9, r22	; 0x09
    4108:	5c 87       	std	Y+12, r21	; 0x0c
    410a:	4b 87       	std	Y+11, r20	; 0x0b
    410c:	2d 87       	std	Y+13, r18	; 0x0d
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    410e:	8f 81       	ldd	r24, Y+7	; 0x07
    4110:	98 85       	ldd	r25, Y+8	; 0x08
    4112:	9c 83       	std	Y+4, r25	; 0x04
    4114:	8b 83       	std	Y+3, r24	; 0x03
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4116:	1d 82       	std	Y+5, r1	; 0x05
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    4118:	eb 81       	ldd	r30, Y+3	; 0x03
    411a:	fc 81       	ldd	r31, Y+4	; 0x04
    411c:	92 8d       	ldd	r25, Z+26	; 0x1a
    411e:	eb 81       	ldd	r30, Y+3	; 0x03
    4120:	fc 81       	ldd	r31, Y+4	; 0x04
    4122:	83 8d       	ldd	r24, Z+27	; 0x1b
    4124:	98 17       	cp	r25, r24
    4126:	18 f0       	brcs	.+6      	; 0x412e <xQueueGenericSendFromISR+0x42>
    4128:	8d 85       	ldd	r24, Y+13	; 0x0d
    412a:	82 30       	cpi	r24, 0x02	; 2
    412c:	81 f5       	brne	.+96     	; 0x418e <xQueueGenericSendFromISR+0xa2>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    412e:	eb 81       	ldd	r30, Y+3	; 0x03
    4130:	fc 81       	ldd	r31, Y+4	; 0x04
    4132:	86 8d       	ldd	r24, Z+30	; 0x1e
    4134:	8a 83       	std	Y+2, r24	; 0x02
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    4136:	eb 81       	ldd	r30, Y+3	; 0x03
    4138:	fc 81       	ldd	r31, Y+4	; 0x04
    413a:	82 8d       	ldd	r24, Z+26	; 0x1a
    413c:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    413e:	8b 81       	ldd	r24, Y+3	; 0x03
    4140:	9c 81       	ldd	r25, Y+4	; 0x04
    4142:	29 85       	ldd	r18, Y+9	; 0x09
    4144:	3a 85       	ldd	r19, Y+10	; 0x0a
    4146:	b9 01       	movw	r22, r18
    4148:	4d 85       	ldd	r20, Y+13	; 0x0d
    414a:	0e 94 20 24 	call	0x4840	; 0x4840 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    414e:	8a 81       	ldd	r24, Y+2	; 0x02
    4150:	8f 3f       	cpi	r24, 0xFF	; 255
    4152:	a9 f4       	brne	.+42     	; 0x417e <xQueueGenericSendFromISR+0x92>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4154:	eb 81       	ldd	r30, Y+3	; 0x03
    4156:	fc 81       	ldd	r31, Y+4	; 0x04
    4158:	81 89       	ldd	r24, Z+17	; 0x11
    415a:	88 23       	and	r24, r24
    415c:	a9 f0       	breq	.+42     	; 0x4188 <xQueueGenericSendFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    415e:	8b 81       	ldd	r24, Y+3	; 0x03
    4160:	9c 81       	ldd	r25, Y+4	; 0x04
    4162:	41 96       	adiw	r24, 0x11	; 17
    4164:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    4168:	88 23       	and	r24, r24
    416a:	71 f0       	breq	.+28     	; 0x4188 <xQueueGenericSendFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    416c:	8b 85       	ldd	r24, Y+11	; 0x0b
    416e:	9c 85       	ldd	r25, Y+12	; 0x0c
    4170:	00 97       	sbiw	r24, 0x00	; 0
    4172:	51 f0       	breq	.+20     	; 0x4188 <xQueueGenericSendFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    4174:	eb 85       	ldd	r30, Y+11	; 0x0b
    4176:	fc 85       	ldd	r31, Y+12	; 0x0c
    4178:	81 e0       	ldi	r24, 0x01	; 1
    417a:	80 83       	st	Z, r24
    417c:	05 c0       	rjmp	.+10     	; 0x4188 <xQueueGenericSendFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    417e:	8a 81       	ldd	r24, Y+2	; 0x02
    4180:	8f 5f       	subi	r24, 0xFF	; 255
    4182:	eb 81       	ldd	r30, Y+3	; 0x03
    4184:	fc 81       	ldd	r31, Y+4	; 0x04
    4186:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    4188:	81 e0       	ldi	r24, 0x01	; 1
    418a:	8e 83       	std	Y+6, r24	; 0x06
    418c:	01 c0       	rjmp	.+2      	; 0x4190 <xQueueGenericSendFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    418e:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4190:	8e 81       	ldd	r24, Y+6	; 0x06
}
    4192:	2d 96       	adiw	r28, 0x0d	; 13
    4194:	0f b6       	in	r0, 0x3f	; 63
    4196:	f8 94       	cli
    4198:	de bf       	out	0x3e, r29	; 62
    419a:	0f be       	out	0x3f, r0	; 63
    419c:	cd bf       	out	0x3d, r28	; 61
    419e:	cf 91       	pop	r28
    41a0:	df 91       	pop	r29
    41a2:	08 95       	ret

000041a4 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    41a4:	df 93       	push	r29
    41a6:	cf 93       	push	r28
    41a8:	cd b7       	in	r28, 0x3d	; 61
    41aa:	de b7       	in	r29, 0x3e	; 62
    41ac:	2a 97       	sbiw	r28, 0x0a	; 10
    41ae:	0f b6       	in	r0, 0x3f	; 63
    41b0:	f8 94       	cli
    41b2:	de bf       	out	0x3e, r29	; 62
    41b4:	0f be       	out	0x3f, r0	; 63
    41b6:	cd bf       	out	0x3d, r28	; 61
    41b8:	98 87       	std	Y+8, r25	; 0x08
    41ba:	8f 83       	std	Y+7, r24	; 0x07
    41bc:	7a 87       	std	Y+10, r23	; 0x0a
    41be:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    41c0:	8f 81       	ldd	r24, Y+7	; 0x07
    41c2:	98 85       	ldd	r25, Y+8	; 0x08
    41c4:	9c 83       	std	Y+4, r25	; 0x04
    41c6:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    41c8:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    41ca:	eb 81       	ldd	r30, Y+3	; 0x03
    41cc:	fc 81       	ldd	r31, Y+4	; 0x04
    41ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    41d0:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    41d2:	eb 81       	ldd	r30, Y+3	; 0x03
    41d4:	fc 81       	ldd	r31, Y+4	; 0x04
    41d6:	93 8d       	ldd	r25, Z+27	; 0x1b
    41d8:	8a 81       	ldd	r24, Y+2	; 0x02
    41da:	89 17       	cp	r24, r25
    41dc:	48 f5       	brcc	.+82     	; 0x4230 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    41de:	eb 81       	ldd	r30, Y+3	; 0x03
    41e0:	fc 81       	ldd	r31, Y+4	; 0x04
    41e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    41e4:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    41e6:	8a 81       	ldd	r24, Y+2	; 0x02
    41e8:	8f 5f       	subi	r24, 0xFF	; 255
    41ea:	eb 81       	ldd	r30, Y+3	; 0x03
    41ec:	fc 81       	ldd	r31, Y+4	; 0x04
    41ee:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    41f0:	89 81       	ldd	r24, Y+1	; 0x01
    41f2:	8f 3f       	cpi	r24, 0xFF	; 255
    41f4:	a9 f4       	brne	.+42     	; 0x4220 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    41f6:	eb 81       	ldd	r30, Y+3	; 0x03
    41f8:	fc 81       	ldd	r31, Y+4	; 0x04
    41fa:	81 89       	ldd	r24, Z+17	; 0x11
    41fc:	88 23       	and	r24, r24
    41fe:	a9 f0       	breq	.+42     	; 0x422a <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4200:	8b 81       	ldd	r24, Y+3	; 0x03
    4202:	9c 81       	ldd	r25, Y+4	; 0x04
    4204:	41 96       	adiw	r24, 0x11	; 17
    4206:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    420a:	88 23       	and	r24, r24
    420c:	71 f0       	breq	.+28     	; 0x422a <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    420e:	89 85       	ldd	r24, Y+9	; 0x09
    4210:	9a 85       	ldd	r25, Y+10	; 0x0a
    4212:	00 97       	sbiw	r24, 0x00	; 0
    4214:	51 f0       	breq	.+20     	; 0x422a <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    4216:	e9 85       	ldd	r30, Y+9	; 0x09
    4218:	fa 85       	ldd	r31, Y+10	; 0x0a
    421a:	81 e0       	ldi	r24, 0x01	; 1
    421c:	80 83       	st	Z, r24
    421e:	05 c0       	rjmp	.+10     	; 0x422a <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    4220:	89 81       	ldd	r24, Y+1	; 0x01
    4222:	8f 5f       	subi	r24, 0xFF	; 255
    4224:	eb 81       	ldd	r30, Y+3	; 0x03
    4226:	fc 81       	ldd	r31, Y+4	; 0x04
    4228:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    422a:	81 e0       	ldi	r24, 0x01	; 1
    422c:	8e 83       	std	Y+6, r24	; 0x06
    422e:	01 c0       	rjmp	.+2      	; 0x4232 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    4230:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4232:	8e 81       	ldd	r24, Y+6	; 0x06
}
    4234:	2a 96       	adiw	r28, 0x0a	; 10
    4236:	0f b6       	in	r0, 0x3f	; 63
    4238:	f8 94       	cli
    423a:	de bf       	out	0x3e, r29	; 62
    423c:	0f be       	out	0x3f, r0	; 63
    423e:	cd bf       	out	0x3d, r28	; 61
    4240:	cf 91       	pop	r28
    4242:	df 91       	pop	r29
    4244:	08 95       	ret

00004246 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    4246:	df 93       	push	r29
    4248:	cf 93       	push	r28
    424a:	cd b7       	in	r28, 0x3d	; 61
    424c:	de b7       	in	r29, 0x3e	; 62
    424e:	2e 97       	sbiw	r28, 0x0e	; 14
    4250:	0f b6       	in	r0, 0x3f	; 63
    4252:	f8 94       	cli
    4254:	de bf       	out	0x3e, r29	; 62
    4256:	0f be       	out	0x3f, r0	; 63
    4258:	cd bf       	out	0x3d, r28	; 61
    425a:	99 87       	std	Y+9, r25	; 0x09
    425c:	88 87       	std	Y+8, r24	; 0x08
    425e:	7b 87       	std	Y+11, r23	; 0x0b
    4260:	6a 87       	std	Y+10, r22	; 0x0a
    4262:	5d 87       	std	Y+13, r21	; 0x0d
    4264:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    4266:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    4268:	88 85       	ldd	r24, Y+8	; 0x08
    426a:	99 85       	ldd	r25, Y+9	; 0x09
    426c:	9b 83       	std	Y+3, r25	; 0x03
    426e:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    4270:	0f b6       	in	r0, 0x3f	; 63
    4272:	f8 94       	cli
    4274:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    4276:	ea 81       	ldd	r30, Y+2	; 0x02
    4278:	fb 81       	ldd	r31, Y+3	; 0x03
    427a:	82 8d       	ldd	r24, Z+26	; 0x1a
    427c:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    427e:	89 81       	ldd	r24, Y+1	; 0x01
    4280:	88 23       	and	r24, r24
    4282:	f9 f0       	breq	.+62     	; 0x42c2 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    4284:	8a 81       	ldd	r24, Y+2	; 0x02
    4286:	9b 81       	ldd	r25, Y+3	; 0x03
    4288:	2a 85       	ldd	r18, Y+10	; 0x0a
    428a:	3b 85       	ldd	r19, Y+11	; 0x0b
    428c:	b9 01       	movw	r22, r18
    428e:	0e 94 c6 24 	call	0x498c	; 0x498c <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    4292:	89 81       	ldd	r24, Y+1	; 0x01
    4294:	81 50       	subi	r24, 0x01	; 1
    4296:	ea 81       	ldd	r30, Y+2	; 0x02
    4298:	fb 81       	ldd	r31, Y+3	; 0x03
    429a:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    429c:	ea 81       	ldd	r30, Y+2	; 0x02
    429e:	fb 81       	ldd	r31, Y+3	; 0x03
    42a0:	80 85       	ldd	r24, Z+8	; 0x08
    42a2:	88 23       	and	r24, r24
    42a4:	49 f0       	breq	.+18     	; 0x42b8 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    42a6:	8a 81       	ldd	r24, Y+2	; 0x02
    42a8:	9b 81       	ldd	r25, Y+3	; 0x03
    42aa:	08 96       	adiw	r24, 0x08	; 8
    42ac:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    42b0:	88 23       	and	r24, r24
    42b2:	11 f0       	breq	.+4      	; 0x42b8 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    42b4:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    42b8:	0f 90       	pop	r0
    42ba:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    42bc:	81 e0       	ldi	r24, 0x01	; 1
    42be:	8e 87       	std	Y+14, r24	; 0x0e
    42c0:	63 c0       	rjmp	.+198    	; 0x4388 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    42c2:	8c 85       	ldd	r24, Y+12	; 0x0c
    42c4:	9d 85       	ldd	r25, Y+13	; 0x0d
    42c6:	00 97       	sbiw	r24, 0x00	; 0
    42c8:	21 f4       	brne	.+8      	; 0x42d2 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    42ca:	0f 90       	pop	r0
    42cc:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    42ce:	1e 86       	std	Y+14, r1	; 0x0e
    42d0:	5b c0       	rjmp	.+182    	; 0x4388 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    42d2:	8c 81       	ldd	r24, Y+4	; 0x04
    42d4:	88 23       	and	r24, r24
    42d6:	31 f4       	brne	.+12     	; 0x42e4 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    42d8:	ce 01       	movw	r24, r28
    42da:	05 96       	adiw	r24, 0x05	; 5
    42dc:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    42e0:	81 e0       	ldi	r24, 0x01	; 1
    42e2:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    42e4:	0f 90       	pop	r0
    42e6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    42e8:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    42ec:	0f b6       	in	r0, 0x3f	; 63
    42ee:	f8 94       	cli
    42f0:	0f 92       	push	r0
    42f2:	ea 81       	ldd	r30, Y+2	; 0x02
    42f4:	fb 81       	ldd	r31, Y+3	; 0x03
    42f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    42f8:	8f 3f       	cpi	r24, 0xFF	; 255
    42fa:	19 f4       	brne	.+6      	; 0x4302 <xQueueReceive+0xbc>
    42fc:	ea 81       	ldd	r30, Y+2	; 0x02
    42fe:	fb 81       	ldd	r31, Y+3	; 0x03
    4300:	15 8e       	std	Z+29, r1	; 0x1d
    4302:	ea 81       	ldd	r30, Y+2	; 0x02
    4304:	fb 81       	ldd	r31, Y+3	; 0x03
    4306:	86 8d       	ldd	r24, Z+30	; 0x1e
    4308:	8f 3f       	cpi	r24, 0xFF	; 255
    430a:	19 f4       	brne	.+6      	; 0x4312 <xQueueReceive+0xcc>
    430c:	ea 81       	ldd	r30, Y+2	; 0x02
    430e:	fb 81       	ldd	r31, Y+3	; 0x03
    4310:	16 8e       	std	Z+30, r1	; 0x1e
    4312:	0f 90       	pop	r0
    4314:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4316:	ce 01       	movw	r24, r28
    4318:	05 96       	adiw	r24, 0x05	; 5
    431a:	9e 01       	movw	r18, r28
    431c:	24 5f       	subi	r18, 0xF4	; 244
    431e:	3f 4f       	sbci	r19, 0xFF	; 255
    4320:	b9 01       	movw	r22, r18
    4322:	0e 94 28 2f 	call	0x5e50	; 0x5e50 <xTaskCheckForTimeOut>
    4326:	88 23       	and	r24, r24
    4328:	09 f5       	brne	.+66     	; 0x436c <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    432a:	8a 81       	ldd	r24, Y+2	; 0x02
    432c:	9b 81       	ldd	r25, Y+3	; 0x03
    432e:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <prvIsQueueEmpty>
    4332:	88 23       	and	r24, r24
    4334:	a1 f0       	breq	.+40     	; 0x435e <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4336:	8a 81       	ldd	r24, Y+2	; 0x02
    4338:	9b 81       	ldd	r25, Y+3	; 0x03
    433a:	41 96       	adiw	r24, 0x11	; 17
    433c:	2c 85       	ldd	r18, Y+12	; 0x0c
    433e:	3d 85       	ldd	r19, Y+13	; 0x0d
    4340:	b9 01       	movw	r22, r18
    4342:	0e 94 d7 2d 	call	0x5bae	; 0x5bae <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    4346:	8a 81       	ldd	r24, Y+2	; 0x02
    4348:	9b 81       	ldd	r25, Y+3	; 0x03
    434a:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    434e:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    4352:	88 23       	and	r24, r24
    4354:	09 f0       	breq	.+2      	; 0x4358 <xQueueReceive+0x112>
    4356:	8c cf       	rjmp	.-232    	; 0x4270 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    4358:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
    435c:	89 cf       	rjmp	.-238    	; 0x4270 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    435e:	8a 81       	ldd	r24, Y+2	; 0x02
    4360:	9b 81       	ldd	r25, Y+3	; 0x03
    4362:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4366:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    436a:	82 cf       	rjmp	.-252    	; 0x4270 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    436c:	8a 81       	ldd	r24, Y+2	; 0x02
    436e:	9b 81       	ldd	r25, Y+3	; 0x03
    4370:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4374:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4378:	8a 81       	ldd	r24, Y+2	; 0x02
    437a:	9b 81       	ldd	r25, Y+3	; 0x03
    437c:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <prvIsQueueEmpty>
    4380:	88 23       	and	r24, r24
    4382:	09 f4       	brne	.+2      	; 0x4386 <xQueueReceive+0x140>
    4384:	75 cf       	rjmp	.-278    	; 0x4270 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    4386:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    4388:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    438a:	2e 96       	adiw	r28, 0x0e	; 14
    438c:	0f b6       	in	r0, 0x3f	; 63
    438e:	f8 94       	cli
    4390:	de bf       	out	0x3e, r29	; 62
    4392:	0f be       	out	0x3f, r0	; 63
    4394:	cd bf       	out	0x3d, r28	; 61
    4396:	cf 91       	pop	r28
    4398:	df 91       	pop	r29
    439a:	08 95       	ret

0000439c <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    439c:	df 93       	push	r29
    439e:	cf 93       	push	r28
    43a0:	cd b7       	in	r28, 0x3d	; 61
    43a2:	de b7       	in	r29, 0x3e	; 62
    43a4:	2c 97       	sbiw	r28, 0x0c	; 12
    43a6:	0f b6       	in	r0, 0x3f	; 63
    43a8:	f8 94       	cli
    43aa:	de bf       	out	0x3e, r29	; 62
    43ac:	0f be       	out	0x3f, r0	; 63
    43ae:	cd bf       	out	0x3d, r28	; 61
    43b0:	99 87       	std	Y+9, r25	; 0x09
    43b2:	88 87       	std	Y+8, r24	; 0x08
    43b4:	7b 87       	std	Y+11, r23	; 0x0b
    43b6:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    43b8:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    43ba:	88 85       	ldd	r24, Y+8	; 0x08
    43bc:	99 85       	ldd	r25, Y+9	; 0x09
    43be:	9b 83       	std	Y+3, r25	; 0x03
    43c0:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    43c2:	0f b6       	in	r0, 0x3f	; 63
    43c4:	f8 94       	cli
    43c6:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    43c8:	ea 81       	ldd	r30, Y+2	; 0x02
    43ca:	fb 81       	ldd	r31, Y+3	; 0x03
    43cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    43ce:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    43d0:	89 81       	ldd	r24, Y+1	; 0x01
    43d2:	88 23       	and	r24, r24
    43d4:	c1 f0       	breq	.+48     	; 0x4406 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    43d6:	89 81       	ldd	r24, Y+1	; 0x01
    43d8:	81 50       	subi	r24, 0x01	; 1
    43da:	ea 81       	ldd	r30, Y+2	; 0x02
    43dc:	fb 81       	ldd	r31, Y+3	; 0x03
    43de:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    43e0:	ea 81       	ldd	r30, Y+2	; 0x02
    43e2:	fb 81       	ldd	r31, Y+3	; 0x03
    43e4:	80 85       	ldd	r24, Z+8	; 0x08
    43e6:	88 23       	and	r24, r24
    43e8:	49 f0       	breq	.+18     	; 0x43fc <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    43ea:	8a 81       	ldd	r24, Y+2	; 0x02
    43ec:	9b 81       	ldd	r25, Y+3	; 0x03
    43ee:	08 96       	adiw	r24, 0x08	; 8
    43f0:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    43f4:	88 23       	and	r24, r24
    43f6:	11 f0       	breq	.+4      	; 0x43fc <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    43f8:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    43fc:	0f 90       	pop	r0
    43fe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    4400:	81 e0       	ldi	r24, 0x01	; 1
    4402:	8c 87       	std	Y+12, r24	; 0x0c
    4404:	63 c0       	rjmp	.+198    	; 0x44cc <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    4406:	8a 85       	ldd	r24, Y+10	; 0x0a
    4408:	9b 85       	ldd	r25, Y+11	; 0x0b
    440a:	00 97       	sbiw	r24, 0x00	; 0
    440c:	21 f4       	brne	.+8      	; 0x4416 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    440e:	0f 90       	pop	r0
    4410:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    4412:	1c 86       	std	Y+12, r1	; 0x0c
    4414:	5b c0       	rjmp	.+182    	; 0x44cc <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    4416:	8c 81       	ldd	r24, Y+4	; 0x04
    4418:	88 23       	and	r24, r24
    441a:	31 f4       	brne	.+12     	; 0x4428 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    441c:	ce 01       	movw	r24, r28
    441e:	05 96       	adiw	r24, 0x05	; 5
    4420:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4424:	81 e0       	ldi	r24, 0x01	; 1
    4426:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4428:	0f 90       	pop	r0
    442a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    442c:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4430:	0f b6       	in	r0, 0x3f	; 63
    4432:	f8 94       	cli
    4434:	0f 92       	push	r0
    4436:	ea 81       	ldd	r30, Y+2	; 0x02
    4438:	fb 81       	ldd	r31, Y+3	; 0x03
    443a:	85 8d       	ldd	r24, Z+29	; 0x1d
    443c:	8f 3f       	cpi	r24, 0xFF	; 255
    443e:	19 f4       	brne	.+6      	; 0x4446 <xQueueSemaphoreTake+0xaa>
    4440:	ea 81       	ldd	r30, Y+2	; 0x02
    4442:	fb 81       	ldd	r31, Y+3	; 0x03
    4444:	15 8e       	std	Z+29, r1	; 0x1d
    4446:	ea 81       	ldd	r30, Y+2	; 0x02
    4448:	fb 81       	ldd	r31, Y+3	; 0x03
    444a:	86 8d       	ldd	r24, Z+30	; 0x1e
    444c:	8f 3f       	cpi	r24, 0xFF	; 255
    444e:	19 f4       	brne	.+6      	; 0x4456 <xQueueSemaphoreTake+0xba>
    4450:	ea 81       	ldd	r30, Y+2	; 0x02
    4452:	fb 81       	ldd	r31, Y+3	; 0x03
    4454:	16 8e       	std	Z+30, r1	; 0x1e
    4456:	0f 90       	pop	r0
    4458:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    445a:	ce 01       	movw	r24, r28
    445c:	05 96       	adiw	r24, 0x05	; 5
    445e:	9e 01       	movw	r18, r28
    4460:	26 5f       	subi	r18, 0xF6	; 246
    4462:	3f 4f       	sbci	r19, 0xFF	; 255
    4464:	b9 01       	movw	r22, r18
    4466:	0e 94 28 2f 	call	0x5e50	; 0x5e50 <xTaskCheckForTimeOut>
    446a:	88 23       	and	r24, r24
    446c:	09 f5       	brne	.+66     	; 0x44b0 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    446e:	8a 81       	ldd	r24, Y+2	; 0x02
    4470:	9b 81       	ldd	r25, Y+3	; 0x03
    4472:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <prvIsQueueEmpty>
    4476:	88 23       	and	r24, r24
    4478:	a1 f0       	breq	.+40     	; 0x44a2 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    447a:	8a 81       	ldd	r24, Y+2	; 0x02
    447c:	9b 81       	ldd	r25, Y+3	; 0x03
    447e:	41 96       	adiw	r24, 0x11	; 17
    4480:	2a 85       	ldd	r18, Y+10	; 0x0a
    4482:	3b 85       	ldd	r19, Y+11	; 0x0b
    4484:	b9 01       	movw	r22, r18
    4486:	0e 94 d7 2d 	call	0x5bae	; 0x5bae <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    448a:	8a 81       	ldd	r24, Y+2	; 0x02
    448c:	9b 81       	ldd	r25, Y+3	; 0x03
    448e:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    4492:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    4496:	88 23       	and	r24, r24
    4498:	09 f0       	breq	.+2      	; 0x449c <xQueueSemaphoreTake+0x100>
    449a:	93 cf       	rjmp	.-218    	; 0x43c2 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    449c:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
    44a0:	90 cf       	rjmp	.-224    	; 0x43c2 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    44a2:	8a 81       	ldd	r24, Y+2	; 0x02
    44a4:	9b 81       	ldd	r25, Y+3	; 0x03
    44a6:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    44aa:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    44ae:	89 cf       	rjmp	.-238    	; 0x43c2 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    44b0:	8a 81       	ldd	r24, Y+2	; 0x02
    44b2:	9b 81       	ldd	r25, Y+3	; 0x03
    44b4:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    44b8:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    44bc:	8a 81       	ldd	r24, Y+2	; 0x02
    44be:	9b 81       	ldd	r25, Y+3	; 0x03
    44c0:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <prvIsQueueEmpty>
    44c4:	88 23       	and	r24, r24
    44c6:	09 f4       	brne	.+2      	; 0x44ca <xQueueSemaphoreTake+0x12e>
    44c8:	7c cf       	rjmp	.-264    	; 0x43c2 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    44ca:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    44cc:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    44ce:	2c 96       	adiw	r28, 0x0c	; 12
    44d0:	0f b6       	in	r0, 0x3f	; 63
    44d2:	f8 94       	cli
    44d4:	de bf       	out	0x3e, r29	; 62
    44d6:	0f be       	out	0x3f, r0	; 63
    44d8:	cd bf       	out	0x3d, r28	; 61
    44da:	cf 91       	pop	r28
    44dc:	df 91       	pop	r29
    44de:	08 95       	ret

000044e0 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    44e0:	df 93       	push	r29
    44e2:	cf 93       	push	r28
    44e4:	cd b7       	in	r28, 0x3d	; 61
    44e6:	de b7       	in	r29, 0x3e	; 62
    44e8:	60 97       	sbiw	r28, 0x10	; 16
    44ea:	0f b6       	in	r0, 0x3f	; 63
    44ec:	f8 94       	cli
    44ee:	de bf       	out	0x3e, r29	; 62
    44f0:	0f be       	out	0x3f, r0	; 63
    44f2:	cd bf       	out	0x3d, r28	; 61
    44f4:	9b 87       	std	Y+11, r25	; 0x0b
    44f6:	8a 87       	std	Y+10, r24	; 0x0a
    44f8:	7d 87       	std	Y+13, r23	; 0x0d
    44fa:	6c 87       	std	Y+12, r22	; 0x0c
    44fc:	5f 87       	std	Y+15, r21	; 0x0f
    44fe:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    4500:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    4502:	8a 85       	ldd	r24, Y+10	; 0x0a
    4504:	9b 85       	ldd	r25, Y+11	; 0x0b
    4506:	9b 83       	std	Y+3, r25	; 0x03
    4508:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    450a:	0f b6       	in	r0, 0x3f	; 63
    450c:	f8 94       	cli
    450e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    4510:	ea 81       	ldd	r30, Y+2	; 0x02
    4512:	fb 81       	ldd	r31, Y+3	; 0x03
    4514:	82 8d       	ldd	r24, Z+26	; 0x1a
    4516:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    4518:	89 81       	ldd	r24, Y+1	; 0x01
    451a:	88 23       	and	r24, r24
    451c:	31 f1       	breq	.+76     	; 0x456a <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    451e:	ea 81       	ldd	r30, Y+2	; 0x02
    4520:	fb 81       	ldd	r31, Y+3	; 0x03
    4522:	86 81       	ldd	r24, Z+6	; 0x06
    4524:	97 81       	ldd	r25, Z+7	; 0x07
    4526:	9d 83       	std	Y+5, r25	; 0x05
    4528:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    452a:	8a 81       	ldd	r24, Y+2	; 0x02
    452c:	9b 81       	ldd	r25, Y+3	; 0x03
    452e:	2c 85       	ldd	r18, Y+12	; 0x0c
    4530:	3d 85       	ldd	r19, Y+13	; 0x0d
    4532:	b9 01       	movw	r22, r18
    4534:	0e 94 c6 24 	call	0x498c	; 0x498c <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    4538:	ea 81       	ldd	r30, Y+2	; 0x02
    453a:	fb 81       	ldd	r31, Y+3	; 0x03
    453c:	8c 81       	ldd	r24, Y+4	; 0x04
    453e:	9d 81       	ldd	r25, Y+5	; 0x05
    4540:	97 83       	std	Z+7, r25	; 0x07
    4542:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4544:	ea 81       	ldd	r30, Y+2	; 0x02
    4546:	fb 81       	ldd	r31, Y+3	; 0x03
    4548:	81 89       	ldd	r24, Z+17	; 0x11
    454a:	88 23       	and	r24, r24
    454c:	49 f0       	breq	.+18     	; 0x4560 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    454e:	8a 81       	ldd	r24, Y+2	; 0x02
    4550:	9b 81       	ldd	r25, Y+3	; 0x03
    4552:	41 96       	adiw	r24, 0x11	; 17
    4554:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    4558:	88 23       	and	r24, r24
    455a:	11 f0       	breq	.+4      	; 0x4560 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    455c:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    4560:	0f 90       	pop	r0
    4562:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    4564:	81 e0       	ldi	r24, 0x01	; 1
    4566:	88 8b       	std	Y+16, r24	; 0x10
    4568:	63 c0       	rjmp	.+198    	; 0x4630 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    456a:	8e 85       	ldd	r24, Y+14	; 0x0e
    456c:	9f 85       	ldd	r25, Y+15	; 0x0f
    456e:	00 97       	sbiw	r24, 0x00	; 0
    4570:	21 f4       	brne	.+8      	; 0x457a <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    4572:	0f 90       	pop	r0
    4574:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    4576:	18 8a       	std	Y+16, r1	; 0x10
    4578:	5b c0       	rjmp	.+182    	; 0x4630 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    457a:	8e 81       	ldd	r24, Y+6	; 0x06
    457c:	88 23       	and	r24, r24
    457e:	31 f4       	brne	.+12     	; 0x458c <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    4580:	ce 01       	movw	r24, r28
    4582:	07 96       	adiw	r24, 0x07	; 7
    4584:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4588:	81 e0       	ldi	r24, 0x01	; 1
    458a:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    458c:	0f 90       	pop	r0
    458e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4590:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4594:	0f b6       	in	r0, 0x3f	; 63
    4596:	f8 94       	cli
    4598:	0f 92       	push	r0
    459a:	ea 81       	ldd	r30, Y+2	; 0x02
    459c:	fb 81       	ldd	r31, Y+3	; 0x03
    459e:	85 8d       	ldd	r24, Z+29	; 0x1d
    45a0:	8f 3f       	cpi	r24, 0xFF	; 255
    45a2:	19 f4       	brne	.+6      	; 0x45aa <xQueuePeek+0xca>
    45a4:	ea 81       	ldd	r30, Y+2	; 0x02
    45a6:	fb 81       	ldd	r31, Y+3	; 0x03
    45a8:	15 8e       	std	Z+29, r1	; 0x1d
    45aa:	ea 81       	ldd	r30, Y+2	; 0x02
    45ac:	fb 81       	ldd	r31, Y+3	; 0x03
    45ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    45b0:	8f 3f       	cpi	r24, 0xFF	; 255
    45b2:	19 f4       	brne	.+6      	; 0x45ba <xQueuePeek+0xda>
    45b4:	ea 81       	ldd	r30, Y+2	; 0x02
    45b6:	fb 81       	ldd	r31, Y+3	; 0x03
    45b8:	16 8e       	std	Z+30, r1	; 0x1e
    45ba:	0f 90       	pop	r0
    45bc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    45be:	ce 01       	movw	r24, r28
    45c0:	07 96       	adiw	r24, 0x07	; 7
    45c2:	9e 01       	movw	r18, r28
    45c4:	22 5f       	subi	r18, 0xF2	; 242
    45c6:	3f 4f       	sbci	r19, 0xFF	; 255
    45c8:	b9 01       	movw	r22, r18
    45ca:	0e 94 28 2f 	call	0x5e50	; 0x5e50 <xTaskCheckForTimeOut>
    45ce:	88 23       	and	r24, r24
    45d0:	09 f5       	brne	.+66     	; 0x4614 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    45d2:	8a 81       	ldd	r24, Y+2	; 0x02
    45d4:	9b 81       	ldd	r25, Y+3	; 0x03
    45d6:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <prvIsQueueEmpty>
    45da:	88 23       	and	r24, r24
    45dc:	a1 f0       	breq	.+40     	; 0x4606 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    45de:	8a 81       	ldd	r24, Y+2	; 0x02
    45e0:	9b 81       	ldd	r25, Y+3	; 0x03
    45e2:	41 96       	adiw	r24, 0x11	; 17
    45e4:	2e 85       	ldd	r18, Y+14	; 0x0e
    45e6:	3f 85       	ldd	r19, Y+15	; 0x0f
    45e8:	b9 01       	movw	r22, r18
    45ea:	0e 94 d7 2d 	call	0x5bae	; 0x5bae <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    45ee:	8a 81       	ldd	r24, Y+2	; 0x02
    45f0:	9b 81       	ldd	r25, Y+3	; 0x03
    45f2:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    45f6:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    45fa:	88 23       	and	r24, r24
    45fc:	09 f0       	breq	.+2      	; 0x4600 <xQueuePeek+0x120>
    45fe:	85 cf       	rjmp	.-246    	; 0x450a <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    4600:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
    4604:	82 cf       	rjmp	.-252    	; 0x450a <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    4606:	8a 81       	ldd	r24, Y+2	; 0x02
    4608:	9b 81       	ldd	r25, Y+3	; 0x03
    460a:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
				( void ) xTaskResumeAll();
    460e:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    4612:	7b cf       	rjmp	.-266    	; 0x450a <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    4614:	8a 81       	ldd	r24, Y+2	; 0x02
    4616:	9b 81       	ldd	r25, Y+3	; 0x03
    4618:	0e 94 0d 25 	call	0x4a1a	; 0x4a1a <prvUnlockQueue>
			( void ) xTaskResumeAll();
    461c:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4620:	8a 81       	ldd	r24, Y+2	; 0x02
    4622:	9b 81       	ldd	r25, Y+3	; 0x03
    4624:	0e 94 60 25 	call	0x4ac0	; 0x4ac0 <prvIsQueueEmpty>
    4628:	88 23       	and	r24, r24
    462a:	09 f4       	brne	.+2      	; 0x462e <xQueuePeek+0x14e>
    462c:	6e cf       	rjmp	.-292    	; 0x450a <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    462e:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    4630:	88 89       	ldd	r24, Y+16	; 0x10
}
    4632:	60 96       	adiw	r28, 0x10	; 16
    4634:	0f b6       	in	r0, 0x3f	; 63
    4636:	f8 94       	cli
    4638:	de bf       	out	0x3e, r29	; 62
    463a:	0f be       	out	0x3f, r0	; 63
    463c:	cd bf       	out	0x3d, r28	; 61
    463e:	cf 91       	pop	r28
    4640:	df 91       	pop	r29
    4642:	08 95       	ret

00004644 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    4644:	df 93       	push	r29
    4646:	cf 93       	push	r28
    4648:	cd b7       	in	r28, 0x3d	; 61
    464a:	de b7       	in	r29, 0x3e	; 62
    464c:	2c 97       	sbiw	r28, 0x0c	; 12
    464e:	0f b6       	in	r0, 0x3f	; 63
    4650:	f8 94       	cli
    4652:	de bf       	out	0x3e, r29	; 62
    4654:	0f be       	out	0x3f, r0	; 63
    4656:	cd bf       	out	0x3d, r28	; 61
    4658:	98 87       	std	Y+8, r25	; 0x08
    465a:	8f 83       	std	Y+7, r24	; 0x07
    465c:	7a 87       	std	Y+10, r23	; 0x0a
    465e:	69 87       	std	Y+9, r22	; 0x09
    4660:	5c 87       	std	Y+12, r21	; 0x0c
    4662:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    4664:	8f 81       	ldd	r24, Y+7	; 0x07
    4666:	98 85       	ldd	r25, Y+8	; 0x08
    4668:	9c 83       	std	Y+4, r25	; 0x04
    466a:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    466c:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    466e:	eb 81       	ldd	r30, Y+3	; 0x03
    4670:	fc 81       	ldd	r31, Y+4	; 0x04
    4672:	82 8d       	ldd	r24, Z+26	; 0x1a
    4674:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    4676:	8a 81       	ldd	r24, Y+2	; 0x02
    4678:	88 23       	and	r24, r24
    467a:	81 f1       	breq	.+96     	; 0x46dc <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    467c:	eb 81       	ldd	r30, Y+3	; 0x03
    467e:	fc 81       	ldd	r31, Y+4	; 0x04
    4680:	85 8d       	ldd	r24, Z+29	; 0x1d
    4682:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    4684:	8b 81       	ldd	r24, Y+3	; 0x03
    4686:	9c 81       	ldd	r25, Y+4	; 0x04
    4688:	29 85       	ldd	r18, Y+9	; 0x09
    468a:	3a 85       	ldd	r19, Y+10	; 0x0a
    468c:	b9 01       	movw	r22, r18
    468e:	0e 94 c6 24 	call	0x498c	; 0x498c <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    4692:	8a 81       	ldd	r24, Y+2	; 0x02
    4694:	81 50       	subi	r24, 0x01	; 1
    4696:	eb 81       	ldd	r30, Y+3	; 0x03
    4698:	fc 81       	ldd	r31, Y+4	; 0x04
    469a:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    469c:	89 81       	ldd	r24, Y+1	; 0x01
    469e:	8f 3f       	cpi	r24, 0xFF	; 255
    46a0:	a9 f4       	brne	.+42     	; 0x46cc <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    46a2:	eb 81       	ldd	r30, Y+3	; 0x03
    46a4:	fc 81       	ldd	r31, Y+4	; 0x04
    46a6:	80 85       	ldd	r24, Z+8	; 0x08
    46a8:	88 23       	and	r24, r24
    46aa:	a9 f0       	breq	.+42     	; 0x46d6 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    46ac:	8b 81       	ldd	r24, Y+3	; 0x03
    46ae:	9c 81       	ldd	r25, Y+4	; 0x04
    46b0:	08 96       	adiw	r24, 0x08	; 8
    46b2:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    46b6:	88 23       	and	r24, r24
    46b8:	71 f0       	breq	.+28     	; 0x46d6 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    46ba:	8b 85       	ldd	r24, Y+11	; 0x0b
    46bc:	9c 85       	ldd	r25, Y+12	; 0x0c
    46be:	00 97       	sbiw	r24, 0x00	; 0
    46c0:	51 f0       	breq	.+20     	; 0x46d6 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    46c2:	eb 85       	ldd	r30, Y+11	; 0x0b
    46c4:	fc 85       	ldd	r31, Y+12	; 0x0c
    46c6:	81 e0       	ldi	r24, 0x01	; 1
    46c8:	80 83       	st	Z, r24
    46ca:	05 c0       	rjmp	.+10     	; 0x46d6 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    46cc:	89 81       	ldd	r24, Y+1	; 0x01
    46ce:	8f 5f       	subi	r24, 0xFF	; 255
    46d0:	eb 81       	ldd	r30, Y+3	; 0x03
    46d2:	fc 81       	ldd	r31, Y+4	; 0x04
    46d4:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    46d6:	81 e0       	ldi	r24, 0x01	; 1
    46d8:	8e 83       	std	Y+6, r24	; 0x06
    46da:	01 c0       	rjmp	.+2      	; 0x46de <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    46dc:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    46de:	8e 81       	ldd	r24, Y+6	; 0x06
}
    46e0:	2c 96       	adiw	r28, 0x0c	; 12
    46e2:	0f b6       	in	r0, 0x3f	; 63
    46e4:	f8 94       	cli
    46e6:	de bf       	out	0x3e, r29	; 62
    46e8:	0f be       	out	0x3f, r0	; 63
    46ea:	cd bf       	out	0x3d, r28	; 61
    46ec:	cf 91       	pop	r28
    46ee:	df 91       	pop	r29
    46f0:	08 95       	ret

000046f2 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    46f2:	df 93       	push	r29
    46f4:	cf 93       	push	r28
    46f6:	cd b7       	in	r28, 0x3d	; 61
    46f8:	de b7       	in	r29, 0x3e	; 62
    46fa:	2a 97       	sbiw	r28, 0x0a	; 10
    46fc:	0f b6       	in	r0, 0x3f	; 63
    46fe:	f8 94       	cli
    4700:	de bf       	out	0x3e, r29	; 62
    4702:	0f be       	out	0x3f, r0	; 63
    4704:	cd bf       	out	0x3d, r28	; 61
    4706:	98 87       	std	Y+8, r25	; 0x08
    4708:	8f 83       	std	Y+7, r24	; 0x07
    470a:	7a 87       	std	Y+10, r23	; 0x0a
    470c:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    470e:	8f 81       	ldd	r24, Y+7	; 0x07
    4710:	98 85       	ldd	r25, Y+8	; 0x08
    4712:	9a 83       	std	Y+2, r25	; 0x02
    4714:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4716:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4718:	e9 81       	ldd	r30, Y+1	; 0x01
    471a:	fa 81       	ldd	r31, Y+2	; 0x02
    471c:	82 8d       	ldd	r24, Z+26	; 0x1a
    471e:	88 23       	and	r24, r24
    4720:	b1 f0       	breq	.+44     	; 0x474e <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    4722:	e9 81       	ldd	r30, Y+1	; 0x01
    4724:	fa 81       	ldd	r31, Y+2	; 0x02
    4726:	86 81       	ldd	r24, Z+6	; 0x06
    4728:	97 81       	ldd	r25, Z+7	; 0x07
    472a:	9c 83       	std	Y+4, r25	; 0x04
    472c:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    472e:	89 81       	ldd	r24, Y+1	; 0x01
    4730:	9a 81       	ldd	r25, Y+2	; 0x02
    4732:	29 85       	ldd	r18, Y+9	; 0x09
    4734:	3a 85       	ldd	r19, Y+10	; 0x0a
    4736:	b9 01       	movw	r22, r18
    4738:	0e 94 c6 24 	call	0x498c	; 0x498c <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    473c:	e9 81       	ldd	r30, Y+1	; 0x01
    473e:	fa 81       	ldd	r31, Y+2	; 0x02
    4740:	8b 81       	ldd	r24, Y+3	; 0x03
    4742:	9c 81       	ldd	r25, Y+4	; 0x04
    4744:	97 83       	std	Z+7, r25	; 0x07
    4746:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    4748:	81 e0       	ldi	r24, 0x01	; 1
    474a:	8e 83       	std	Y+6, r24	; 0x06
    474c:	01 c0       	rjmp	.+2      	; 0x4750 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    474e:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4750:	8e 81       	ldd	r24, Y+6	; 0x06
}
    4752:	2a 96       	adiw	r28, 0x0a	; 10
    4754:	0f b6       	in	r0, 0x3f	; 63
    4756:	f8 94       	cli
    4758:	de bf       	out	0x3e, r29	; 62
    475a:	0f be       	out	0x3f, r0	; 63
    475c:	cd bf       	out	0x3d, r28	; 61
    475e:	cf 91       	pop	r28
    4760:	df 91       	pop	r29
    4762:	08 95       	ret

00004764 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    4764:	df 93       	push	r29
    4766:	cf 93       	push	r28
    4768:	00 d0       	rcall	.+0      	; 0x476a <uxQueueMessagesWaiting+0x6>
    476a:	0f 92       	push	r0
    476c:	cd b7       	in	r28, 0x3d	; 61
    476e:	de b7       	in	r29, 0x3e	; 62
    4770:	9b 83       	std	Y+3, r25	; 0x03
    4772:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    4774:	0f b6       	in	r0, 0x3f	; 63
    4776:	f8 94       	cli
    4778:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    477a:	ea 81       	ldd	r30, Y+2	; 0x02
    477c:	fb 81       	ldd	r31, Y+3	; 0x03
    477e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4780:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4782:	0f 90       	pop	r0
    4784:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    4786:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4788:	0f 90       	pop	r0
    478a:	0f 90       	pop	r0
    478c:	0f 90       	pop	r0
    478e:	cf 91       	pop	r28
    4790:	df 91       	pop	r29
    4792:	08 95       	ret

00004794 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    4794:	df 93       	push	r29
    4796:	cf 93       	push	r28
    4798:	00 d0       	rcall	.+0      	; 0x479a <uxQueueSpacesAvailable+0x6>
    479a:	00 d0       	rcall	.+0      	; 0x479c <uxQueueSpacesAvailable+0x8>
    479c:	0f 92       	push	r0
    479e:	cd b7       	in	r28, 0x3d	; 61
    47a0:	de b7       	in	r29, 0x3e	; 62
    47a2:	9d 83       	std	Y+5, r25	; 0x05
    47a4:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    47a6:	8c 81       	ldd	r24, Y+4	; 0x04
    47a8:	9d 81       	ldd	r25, Y+5	; 0x05
    47aa:	9a 83       	std	Y+2, r25	; 0x02
    47ac:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    47ae:	0f b6       	in	r0, 0x3f	; 63
    47b0:	f8 94       	cli
    47b2:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    47b4:	e9 81       	ldd	r30, Y+1	; 0x01
    47b6:	fa 81       	ldd	r31, Y+2	; 0x02
    47b8:	93 8d       	ldd	r25, Z+27	; 0x1b
    47ba:	e9 81       	ldd	r30, Y+1	; 0x01
    47bc:	fa 81       	ldd	r31, Y+2	; 0x02
    47be:	82 8d       	ldd	r24, Z+26	; 0x1a
    47c0:	29 2f       	mov	r18, r25
    47c2:	28 1b       	sub	r18, r24
    47c4:	82 2f       	mov	r24, r18
    47c6:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    47c8:	0f 90       	pop	r0
    47ca:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    47cc:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    47ce:	0f 90       	pop	r0
    47d0:	0f 90       	pop	r0
    47d2:	0f 90       	pop	r0
    47d4:	0f 90       	pop	r0
    47d6:	0f 90       	pop	r0
    47d8:	cf 91       	pop	r28
    47da:	df 91       	pop	r29
    47dc:	08 95       	ret

000047de <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    47de:	df 93       	push	r29
    47e0:	cf 93       	push	r28
    47e2:	00 d0       	rcall	.+0      	; 0x47e4 <uxQueueMessagesWaitingFromISR+0x6>
    47e4:	00 d0       	rcall	.+0      	; 0x47e6 <uxQueueMessagesWaitingFromISR+0x8>
    47e6:	0f 92       	push	r0
    47e8:	cd b7       	in	r28, 0x3d	; 61
    47ea:	de b7       	in	r29, 0x3e	; 62
    47ec:	9d 83       	std	Y+5, r25	; 0x05
    47ee:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    47f0:	8c 81       	ldd	r24, Y+4	; 0x04
    47f2:	9d 81       	ldd	r25, Y+5	; 0x05
    47f4:	9a 83       	std	Y+2, r25	; 0x02
    47f6:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    47f8:	e9 81       	ldd	r30, Y+1	; 0x01
    47fa:	fa 81       	ldd	r31, Y+2	; 0x02
    47fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    47fe:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    4800:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4802:	0f 90       	pop	r0
    4804:	0f 90       	pop	r0
    4806:	0f 90       	pop	r0
    4808:	0f 90       	pop	r0
    480a:	0f 90       	pop	r0
    480c:	cf 91       	pop	r28
    480e:	df 91       	pop	r29
    4810:	08 95       	ret

00004812 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    4812:	df 93       	push	r29
    4814:	cf 93       	push	r28
    4816:	00 d0       	rcall	.+0      	; 0x4818 <vQueueDelete+0x6>
    4818:	00 d0       	rcall	.+0      	; 0x481a <vQueueDelete+0x8>
    481a:	cd b7       	in	r28, 0x3d	; 61
    481c:	de b7       	in	r29, 0x3e	; 62
    481e:	9c 83       	std	Y+4, r25	; 0x04
    4820:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    4822:	8b 81       	ldd	r24, Y+3	; 0x03
    4824:	9c 81       	ldd	r25, Y+4	; 0x04
    4826:	9a 83       	std	Y+2, r25	; 0x02
    4828:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    482a:	89 81       	ldd	r24, Y+1	; 0x01
    482c:	9a 81       	ldd	r25, Y+2	; 0x02
    482e:	0e 94 bf 18 	call	0x317e	; 0x317e <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    4832:	0f 90       	pop	r0
    4834:	0f 90       	pop	r0
    4836:	0f 90       	pop	r0
    4838:	0f 90       	pop	r0
    483a:	cf 91       	pop	r28
    483c:	df 91       	pop	r29
    483e:	08 95       	ret

00004840 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    4840:	df 93       	push	r29
    4842:	cf 93       	push	r28
    4844:	cd b7       	in	r28, 0x3d	; 61
    4846:	de b7       	in	r29, 0x3e	; 62
    4848:	27 97       	sbiw	r28, 0x07	; 7
    484a:	0f b6       	in	r0, 0x3f	; 63
    484c:	f8 94       	cli
    484e:	de bf       	out	0x3e, r29	; 62
    4850:	0f be       	out	0x3f, r0	; 63
    4852:	cd bf       	out	0x3d, r28	; 61
    4854:	9c 83       	std	Y+4, r25	; 0x04
    4856:	8b 83       	std	Y+3, r24	; 0x03
    4858:	7e 83       	std	Y+6, r23	; 0x06
    485a:	6d 83       	std	Y+5, r22	; 0x05
    485c:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    485e:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    4860:	eb 81       	ldd	r30, Y+3	; 0x03
    4862:	fc 81       	ldd	r31, Y+4	; 0x04
    4864:	82 8d       	ldd	r24, Z+26	; 0x1a
    4866:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    4868:	eb 81       	ldd	r30, Y+3	; 0x03
    486a:	fc 81       	ldd	r31, Y+4	; 0x04
    486c:	84 8d       	ldd	r24, Z+28	; 0x1c
    486e:	88 23       	and	r24, r24
    4870:	09 f4       	brne	.+2      	; 0x4874 <prvCopyDataToQueue+0x34>
    4872:	7d c0       	rjmp	.+250    	; 0x496e <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    4874:	8f 81       	ldd	r24, Y+7	; 0x07
    4876:	88 23       	and	r24, r24
    4878:	99 f5       	brne	.+102    	; 0x48e0 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    487a:	eb 81       	ldd	r30, Y+3	; 0x03
    487c:	fc 81       	ldd	r31, Y+4	; 0x04
    487e:	62 81       	ldd	r22, Z+2	; 0x02
    4880:	73 81       	ldd	r23, Z+3	; 0x03
    4882:	eb 81       	ldd	r30, Y+3	; 0x03
    4884:	fc 81       	ldd	r31, Y+4	; 0x04
    4886:	84 8d       	ldd	r24, Z+28	; 0x1c
    4888:	48 2f       	mov	r20, r24
    488a:	50 e0       	ldi	r21, 0x00	; 0
    488c:	2d 81       	ldd	r18, Y+5	; 0x05
    488e:	3e 81       	ldd	r19, Y+6	; 0x06
    4890:	cb 01       	movw	r24, r22
    4892:	b9 01       	movw	r22, r18
    4894:	0e 94 59 35 	call	0x6ab2	; 0x6ab2 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    4898:	eb 81       	ldd	r30, Y+3	; 0x03
    489a:	fc 81       	ldd	r31, Y+4	; 0x04
    489c:	22 81       	ldd	r18, Z+2	; 0x02
    489e:	33 81       	ldd	r19, Z+3	; 0x03
    48a0:	eb 81       	ldd	r30, Y+3	; 0x03
    48a2:	fc 81       	ldd	r31, Y+4	; 0x04
    48a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    48a6:	88 2f       	mov	r24, r24
    48a8:	90 e0       	ldi	r25, 0x00	; 0
    48aa:	82 0f       	add	r24, r18
    48ac:	93 1f       	adc	r25, r19
    48ae:	eb 81       	ldd	r30, Y+3	; 0x03
    48b0:	fc 81       	ldd	r31, Y+4	; 0x04
    48b2:	93 83       	std	Z+3, r25	; 0x03
    48b4:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    48b6:	eb 81       	ldd	r30, Y+3	; 0x03
    48b8:	fc 81       	ldd	r31, Y+4	; 0x04
    48ba:	22 81       	ldd	r18, Z+2	; 0x02
    48bc:	33 81       	ldd	r19, Z+3	; 0x03
    48be:	eb 81       	ldd	r30, Y+3	; 0x03
    48c0:	fc 81       	ldd	r31, Y+4	; 0x04
    48c2:	84 81       	ldd	r24, Z+4	; 0x04
    48c4:	95 81       	ldd	r25, Z+5	; 0x05
    48c6:	28 17       	cp	r18, r24
    48c8:	39 07       	cpc	r19, r25
    48ca:	08 f4       	brcc	.+2      	; 0x48ce <prvCopyDataToQueue+0x8e>
    48cc:	50 c0       	rjmp	.+160    	; 0x496e <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    48ce:	eb 81       	ldd	r30, Y+3	; 0x03
    48d0:	fc 81       	ldd	r31, Y+4	; 0x04
    48d2:	80 81       	ld	r24, Z
    48d4:	91 81       	ldd	r25, Z+1	; 0x01
    48d6:	eb 81       	ldd	r30, Y+3	; 0x03
    48d8:	fc 81       	ldd	r31, Y+4	; 0x04
    48da:	93 83       	std	Z+3, r25	; 0x03
    48dc:	82 83       	std	Z+2, r24	; 0x02
    48de:	47 c0       	rjmp	.+142    	; 0x496e <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    48e0:	eb 81       	ldd	r30, Y+3	; 0x03
    48e2:	fc 81       	ldd	r31, Y+4	; 0x04
    48e4:	66 81       	ldd	r22, Z+6	; 0x06
    48e6:	77 81       	ldd	r23, Z+7	; 0x07
    48e8:	eb 81       	ldd	r30, Y+3	; 0x03
    48ea:	fc 81       	ldd	r31, Y+4	; 0x04
    48ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    48ee:	48 2f       	mov	r20, r24
    48f0:	50 e0       	ldi	r21, 0x00	; 0
    48f2:	2d 81       	ldd	r18, Y+5	; 0x05
    48f4:	3e 81       	ldd	r19, Y+6	; 0x06
    48f6:	cb 01       	movw	r24, r22
    48f8:	b9 01       	movw	r22, r18
    48fa:	0e 94 59 35 	call	0x6ab2	; 0x6ab2 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    48fe:	eb 81       	ldd	r30, Y+3	; 0x03
    4900:	fc 81       	ldd	r31, Y+4	; 0x04
    4902:	26 81       	ldd	r18, Z+6	; 0x06
    4904:	37 81       	ldd	r19, Z+7	; 0x07
    4906:	eb 81       	ldd	r30, Y+3	; 0x03
    4908:	fc 81       	ldd	r31, Y+4	; 0x04
    490a:	84 8d       	ldd	r24, Z+28	; 0x1c
    490c:	88 2f       	mov	r24, r24
    490e:	90 e0       	ldi	r25, 0x00	; 0
    4910:	90 95       	com	r25
    4912:	81 95       	neg	r24
    4914:	9f 4f       	sbci	r25, 0xFF	; 255
    4916:	82 0f       	add	r24, r18
    4918:	93 1f       	adc	r25, r19
    491a:	eb 81       	ldd	r30, Y+3	; 0x03
    491c:	fc 81       	ldd	r31, Y+4	; 0x04
    491e:	97 83       	std	Z+7, r25	; 0x07
    4920:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    4922:	eb 81       	ldd	r30, Y+3	; 0x03
    4924:	fc 81       	ldd	r31, Y+4	; 0x04
    4926:	26 81       	ldd	r18, Z+6	; 0x06
    4928:	37 81       	ldd	r19, Z+7	; 0x07
    492a:	eb 81       	ldd	r30, Y+3	; 0x03
    492c:	fc 81       	ldd	r31, Y+4	; 0x04
    492e:	80 81       	ld	r24, Z
    4930:	91 81       	ldd	r25, Z+1	; 0x01
    4932:	28 17       	cp	r18, r24
    4934:	39 07       	cpc	r19, r25
    4936:	90 f4       	brcc	.+36     	; 0x495c <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    4938:	eb 81       	ldd	r30, Y+3	; 0x03
    493a:	fc 81       	ldd	r31, Y+4	; 0x04
    493c:	24 81       	ldd	r18, Z+4	; 0x04
    493e:	35 81       	ldd	r19, Z+5	; 0x05
    4940:	eb 81       	ldd	r30, Y+3	; 0x03
    4942:	fc 81       	ldd	r31, Y+4	; 0x04
    4944:	84 8d       	ldd	r24, Z+28	; 0x1c
    4946:	88 2f       	mov	r24, r24
    4948:	90 e0       	ldi	r25, 0x00	; 0
    494a:	90 95       	com	r25
    494c:	81 95       	neg	r24
    494e:	9f 4f       	sbci	r25, 0xFF	; 255
    4950:	82 0f       	add	r24, r18
    4952:	93 1f       	adc	r25, r19
    4954:	eb 81       	ldd	r30, Y+3	; 0x03
    4956:	fc 81       	ldd	r31, Y+4	; 0x04
    4958:	97 83       	std	Z+7, r25	; 0x07
    495a:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    495c:	8f 81       	ldd	r24, Y+7	; 0x07
    495e:	82 30       	cpi	r24, 0x02	; 2
    4960:	31 f4       	brne	.+12     	; 0x496e <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    4962:	89 81       	ldd	r24, Y+1	; 0x01
    4964:	88 23       	and	r24, r24
    4966:	19 f0       	breq	.+6      	; 0x496e <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    4968:	89 81       	ldd	r24, Y+1	; 0x01
    496a:	81 50       	subi	r24, 0x01	; 1
    496c:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    496e:	89 81       	ldd	r24, Y+1	; 0x01
    4970:	8f 5f       	subi	r24, 0xFF	; 255
    4972:	eb 81       	ldd	r30, Y+3	; 0x03
    4974:	fc 81       	ldd	r31, Y+4	; 0x04
    4976:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    4978:	8a 81       	ldd	r24, Y+2	; 0x02
}
    497a:	27 96       	adiw	r28, 0x07	; 7
    497c:	0f b6       	in	r0, 0x3f	; 63
    497e:	f8 94       	cli
    4980:	de bf       	out	0x3e, r29	; 62
    4982:	0f be       	out	0x3f, r0	; 63
    4984:	cd bf       	out	0x3d, r28	; 61
    4986:	cf 91       	pop	r28
    4988:	df 91       	pop	r29
    498a:	08 95       	ret

0000498c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    498c:	df 93       	push	r29
    498e:	cf 93       	push	r28
    4990:	00 d0       	rcall	.+0      	; 0x4992 <prvCopyDataFromQueue+0x6>
    4992:	00 d0       	rcall	.+0      	; 0x4994 <prvCopyDataFromQueue+0x8>
    4994:	cd b7       	in	r28, 0x3d	; 61
    4996:	de b7       	in	r29, 0x3e	; 62
    4998:	9a 83       	std	Y+2, r25	; 0x02
    499a:	89 83       	std	Y+1, r24	; 0x01
    499c:	7c 83       	std	Y+4, r23	; 0x04
    499e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    49a0:	e9 81       	ldd	r30, Y+1	; 0x01
    49a2:	fa 81       	ldd	r31, Y+2	; 0x02
    49a4:	84 8d       	ldd	r24, Z+28	; 0x1c
    49a6:	88 23       	and	r24, r24
    49a8:	89 f1       	breq	.+98     	; 0x4a0c <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    49aa:	e9 81       	ldd	r30, Y+1	; 0x01
    49ac:	fa 81       	ldd	r31, Y+2	; 0x02
    49ae:	26 81       	ldd	r18, Z+6	; 0x06
    49b0:	37 81       	ldd	r19, Z+7	; 0x07
    49b2:	e9 81       	ldd	r30, Y+1	; 0x01
    49b4:	fa 81       	ldd	r31, Y+2	; 0x02
    49b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    49b8:	88 2f       	mov	r24, r24
    49ba:	90 e0       	ldi	r25, 0x00	; 0
    49bc:	82 0f       	add	r24, r18
    49be:	93 1f       	adc	r25, r19
    49c0:	e9 81       	ldd	r30, Y+1	; 0x01
    49c2:	fa 81       	ldd	r31, Y+2	; 0x02
    49c4:	97 83       	std	Z+7, r25	; 0x07
    49c6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    49c8:	e9 81       	ldd	r30, Y+1	; 0x01
    49ca:	fa 81       	ldd	r31, Y+2	; 0x02
    49cc:	26 81       	ldd	r18, Z+6	; 0x06
    49ce:	37 81       	ldd	r19, Z+7	; 0x07
    49d0:	e9 81       	ldd	r30, Y+1	; 0x01
    49d2:	fa 81       	ldd	r31, Y+2	; 0x02
    49d4:	84 81       	ldd	r24, Z+4	; 0x04
    49d6:	95 81       	ldd	r25, Z+5	; 0x05
    49d8:	28 17       	cp	r18, r24
    49da:	39 07       	cpc	r19, r25
    49dc:	40 f0       	brcs	.+16     	; 0x49ee <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    49de:	e9 81       	ldd	r30, Y+1	; 0x01
    49e0:	fa 81       	ldd	r31, Y+2	; 0x02
    49e2:	80 81       	ld	r24, Z
    49e4:	91 81       	ldd	r25, Z+1	; 0x01
    49e6:	e9 81       	ldd	r30, Y+1	; 0x01
    49e8:	fa 81       	ldd	r31, Y+2	; 0x02
    49ea:	97 83       	std	Z+7, r25	; 0x07
    49ec:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    49ee:	e9 81       	ldd	r30, Y+1	; 0x01
    49f0:	fa 81       	ldd	r31, Y+2	; 0x02
    49f2:	46 81       	ldd	r20, Z+6	; 0x06
    49f4:	57 81       	ldd	r21, Z+7	; 0x07
    49f6:	e9 81       	ldd	r30, Y+1	; 0x01
    49f8:	fa 81       	ldd	r31, Y+2	; 0x02
    49fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    49fc:	28 2f       	mov	r18, r24
    49fe:	30 e0       	ldi	r19, 0x00	; 0
    4a00:	8b 81       	ldd	r24, Y+3	; 0x03
    4a02:	9c 81       	ldd	r25, Y+4	; 0x04
    4a04:	ba 01       	movw	r22, r20
    4a06:	a9 01       	movw	r20, r18
    4a08:	0e 94 59 35 	call	0x6ab2	; 0x6ab2 <memcpy>
	}
}
    4a0c:	0f 90       	pop	r0
    4a0e:	0f 90       	pop	r0
    4a10:	0f 90       	pop	r0
    4a12:	0f 90       	pop	r0
    4a14:	cf 91       	pop	r28
    4a16:	df 91       	pop	r29
    4a18:	08 95       	ret

00004a1a <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    4a1a:	df 93       	push	r29
    4a1c:	cf 93       	push	r28
    4a1e:	00 d0       	rcall	.+0      	; 0x4a20 <prvUnlockQueue+0x6>
    4a20:	00 d0       	rcall	.+0      	; 0x4a22 <prvUnlockQueue+0x8>
    4a22:	cd b7       	in	r28, 0x3d	; 61
    4a24:	de b7       	in	r29, 0x3e	; 62
    4a26:	9c 83       	std	Y+4, r25	; 0x04
    4a28:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4a2a:	0f b6       	in	r0, 0x3f	; 63
    4a2c:	f8 94       	cli
    4a2e:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    4a30:	eb 81       	ldd	r30, Y+3	; 0x03
    4a32:	fc 81       	ldd	r31, Y+4	; 0x04
    4a34:	86 8d       	ldd	r24, Z+30	; 0x1e
    4a36:	8a 83       	std	Y+2, r24	; 0x02
    4a38:	11 c0       	rjmp	.+34     	; 0x4a5c <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4a3a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a3c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a3e:	81 89       	ldd	r24, Z+17	; 0x11
    4a40:	88 23       	and	r24, r24
    4a42:	79 f0       	breq	.+30     	; 0x4a62 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4a44:	8b 81       	ldd	r24, Y+3	; 0x03
    4a46:	9c 81       	ldd	r25, Y+4	; 0x04
    4a48:	41 96       	adiw	r24, 0x11	; 17
    4a4a:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    4a4e:	88 23       	and	r24, r24
    4a50:	11 f0       	breq	.+4      	; 0x4a56 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    4a52:	0e 94 95 2f 	call	0x5f2a	; 0x5f2a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    4a56:	8a 81       	ldd	r24, Y+2	; 0x02
    4a58:	81 50       	subi	r24, 0x01	; 1
    4a5a:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    4a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a5e:	18 16       	cp	r1, r24
    4a60:	64 f3       	brlt	.-40     	; 0x4a3a <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    4a62:	eb 81       	ldd	r30, Y+3	; 0x03
    4a64:	fc 81       	ldd	r31, Y+4	; 0x04
    4a66:	8f ef       	ldi	r24, 0xFF	; 255
    4a68:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    4a6a:	0f 90       	pop	r0
    4a6c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4a6e:	0f b6       	in	r0, 0x3f	; 63
    4a70:	f8 94       	cli
    4a72:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    4a74:	eb 81       	ldd	r30, Y+3	; 0x03
    4a76:	fc 81       	ldd	r31, Y+4	; 0x04
    4a78:	85 8d       	ldd	r24, Z+29	; 0x1d
    4a7a:	89 83       	std	Y+1, r24	; 0x01
    4a7c:	11 c0       	rjmp	.+34     	; 0x4aa0 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4a7e:	eb 81       	ldd	r30, Y+3	; 0x03
    4a80:	fc 81       	ldd	r31, Y+4	; 0x04
    4a82:	80 85       	ldd	r24, Z+8	; 0x08
    4a84:	88 23       	and	r24, r24
    4a86:	79 f0       	breq	.+30     	; 0x4aa6 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4a88:	8b 81       	ldd	r24, Y+3	; 0x03
    4a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a8c:	08 96       	adiw	r24, 0x08	; 8
    4a8e:	0e 94 29 2e 	call	0x5c52	; 0x5c52 <xTaskRemoveFromEventList>
    4a92:	88 23       	and	r24, r24
    4a94:	11 f0       	breq	.+4      	; 0x4a9a <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    4a96:	0e 94 95 2f 	call	0x5f2a	; 0x5f2a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    4a9a:	89 81       	ldd	r24, Y+1	; 0x01
    4a9c:	81 50       	subi	r24, 0x01	; 1
    4a9e:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    4aa0:	89 81       	ldd	r24, Y+1	; 0x01
    4aa2:	18 16       	cp	r1, r24
    4aa4:	64 f3       	brlt	.-40     	; 0x4a7e <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    4aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    4aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    4aaa:	8f ef       	ldi	r24, 0xFF	; 255
    4aac:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4aae:	0f 90       	pop	r0
    4ab0:	0f be       	out	0x3f, r0	; 63
}
    4ab2:	0f 90       	pop	r0
    4ab4:	0f 90       	pop	r0
    4ab6:	0f 90       	pop	r0
    4ab8:	0f 90       	pop	r0
    4aba:	cf 91       	pop	r28
    4abc:	df 91       	pop	r29
    4abe:	08 95       	ret

00004ac0 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    4ac0:	df 93       	push	r29
    4ac2:	cf 93       	push	r28
    4ac4:	00 d0       	rcall	.+0      	; 0x4ac6 <prvIsQueueEmpty+0x6>
    4ac6:	0f 92       	push	r0
    4ac8:	cd b7       	in	r28, 0x3d	; 61
    4aca:	de b7       	in	r29, 0x3e	; 62
    4acc:	9b 83       	std	Y+3, r25	; 0x03
    4ace:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4ad0:	0f b6       	in	r0, 0x3f	; 63
    4ad2:	f8 94       	cli
    4ad4:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    4ad6:	ea 81       	ldd	r30, Y+2	; 0x02
    4ad8:	fb 81       	ldd	r31, Y+3	; 0x03
    4ada:	82 8d       	ldd	r24, Z+26	; 0x1a
    4adc:	88 23       	and	r24, r24
    4ade:	19 f4       	brne	.+6      	; 0x4ae6 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    4ae0:	81 e0       	ldi	r24, 0x01	; 1
    4ae2:	89 83       	std	Y+1, r24	; 0x01
    4ae4:	01 c0       	rjmp	.+2      	; 0x4ae8 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    4ae6:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4ae8:	0f 90       	pop	r0
    4aea:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4aec:	89 81       	ldd	r24, Y+1	; 0x01
}
    4aee:	0f 90       	pop	r0
    4af0:	0f 90       	pop	r0
    4af2:	0f 90       	pop	r0
    4af4:	cf 91       	pop	r28
    4af6:	df 91       	pop	r29
    4af8:	08 95       	ret

00004afa <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    4afa:	df 93       	push	r29
    4afc:	cf 93       	push	r28
    4afe:	00 d0       	rcall	.+0      	; 0x4b00 <xQueueIsQueueEmptyFromISR+0x6>
    4b00:	00 d0       	rcall	.+0      	; 0x4b02 <xQueueIsQueueEmptyFromISR+0x8>
    4b02:	0f 92       	push	r0
    4b04:	cd b7       	in	r28, 0x3d	; 61
    4b06:	de b7       	in	r29, 0x3e	; 62
    4b08:	9d 83       	std	Y+5, r25	; 0x05
    4b0a:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    4b0c:	8c 81       	ldd	r24, Y+4	; 0x04
    4b0e:	9d 81       	ldd	r25, Y+5	; 0x05
    4b10:	9a 83       	std	Y+2, r25	; 0x02
    4b12:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4b14:	e9 81       	ldd	r30, Y+1	; 0x01
    4b16:	fa 81       	ldd	r31, Y+2	; 0x02
    4b18:	82 8d       	ldd	r24, Z+26	; 0x1a
    4b1a:	88 23       	and	r24, r24
    4b1c:	19 f4       	brne	.+6      	; 0x4b24 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    4b1e:	81 e0       	ldi	r24, 0x01	; 1
    4b20:	8b 83       	std	Y+3, r24	; 0x03
    4b22:	01 c0       	rjmp	.+2      	; 0x4b26 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    4b24:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    4b26:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4b28:	0f 90       	pop	r0
    4b2a:	0f 90       	pop	r0
    4b2c:	0f 90       	pop	r0
    4b2e:	0f 90       	pop	r0
    4b30:	0f 90       	pop	r0
    4b32:	cf 91       	pop	r28
    4b34:	df 91       	pop	r29
    4b36:	08 95       	ret

00004b38 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    4b38:	df 93       	push	r29
    4b3a:	cf 93       	push	r28
    4b3c:	00 d0       	rcall	.+0      	; 0x4b3e <prvIsQueueFull+0x6>
    4b3e:	0f 92       	push	r0
    4b40:	cd b7       	in	r28, 0x3d	; 61
    4b42:	de b7       	in	r29, 0x3e	; 62
    4b44:	9b 83       	std	Y+3, r25	; 0x03
    4b46:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4b48:	0f b6       	in	r0, 0x3f	; 63
    4b4a:	f8 94       	cli
    4b4c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4b4e:	ea 81       	ldd	r30, Y+2	; 0x02
    4b50:	fb 81       	ldd	r31, Y+3	; 0x03
    4b52:	92 8d       	ldd	r25, Z+26	; 0x1a
    4b54:	ea 81       	ldd	r30, Y+2	; 0x02
    4b56:	fb 81       	ldd	r31, Y+3	; 0x03
    4b58:	83 8d       	ldd	r24, Z+27	; 0x1b
    4b5a:	98 17       	cp	r25, r24
    4b5c:	19 f4       	brne	.+6      	; 0x4b64 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    4b5e:	81 e0       	ldi	r24, 0x01	; 1
    4b60:	89 83       	std	Y+1, r24	; 0x01
    4b62:	01 c0       	rjmp	.+2      	; 0x4b66 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    4b64:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4b66:	0f 90       	pop	r0
    4b68:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4b6a:	89 81       	ldd	r24, Y+1	; 0x01
}
    4b6c:	0f 90       	pop	r0
    4b6e:	0f 90       	pop	r0
    4b70:	0f 90       	pop	r0
    4b72:	cf 91       	pop	r28
    4b74:	df 91       	pop	r29
    4b76:	08 95       	ret

00004b78 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    4b78:	df 93       	push	r29
    4b7a:	cf 93       	push	r28
    4b7c:	00 d0       	rcall	.+0      	; 0x4b7e <xQueueIsQueueFullFromISR+0x6>
    4b7e:	00 d0       	rcall	.+0      	; 0x4b80 <xQueueIsQueueFullFromISR+0x8>
    4b80:	0f 92       	push	r0
    4b82:	cd b7       	in	r28, 0x3d	; 61
    4b84:	de b7       	in	r29, 0x3e	; 62
    4b86:	9d 83       	std	Y+5, r25	; 0x05
    4b88:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    4b8a:	8c 81       	ldd	r24, Y+4	; 0x04
    4b8c:	9d 81       	ldd	r25, Y+5	; 0x05
    4b8e:	9a 83       	std	Y+2, r25	; 0x02
    4b90:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4b92:	e9 81       	ldd	r30, Y+1	; 0x01
    4b94:	fa 81       	ldd	r31, Y+2	; 0x02
    4b96:	92 8d       	ldd	r25, Z+26	; 0x1a
    4b98:	e9 81       	ldd	r30, Y+1	; 0x01
    4b9a:	fa 81       	ldd	r31, Y+2	; 0x02
    4b9c:	83 8d       	ldd	r24, Z+27	; 0x1b
    4b9e:	98 17       	cp	r25, r24
    4ba0:	19 f4       	brne	.+6      	; 0x4ba8 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    4ba2:	81 e0       	ldi	r24, 0x01	; 1
    4ba4:	8b 83       	std	Y+3, r24	; 0x03
    4ba6:	01 c0       	rjmp	.+2      	; 0x4baa <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    4ba8:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    4baa:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4bac:	0f 90       	pop	r0
    4bae:	0f 90       	pop	r0
    4bb0:	0f 90       	pop	r0
    4bb2:	0f 90       	pop	r0
    4bb4:	0f 90       	pop	r0
    4bb6:	cf 91       	pop	r28
    4bb8:	df 91       	pop	r29
    4bba:	08 95       	ret

00004bbc <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4bbc:	8f 92       	push	r8
    4bbe:	9f 92       	push	r9
    4bc0:	af 92       	push	r10
    4bc2:	bf 92       	push	r11
    4bc4:	cf 92       	push	r12
    4bc6:	df 92       	push	r13
    4bc8:	ef 92       	push	r14
    4bca:	ff 92       	push	r15
    4bcc:	0f 93       	push	r16
    4bce:	1f 93       	push	r17
    4bd0:	df 93       	push	r29
    4bd2:	cf 93       	push	r28
    4bd4:	cd b7       	in	r28, 0x3d	; 61
    4bd6:	de b7       	in	r29, 0x3e	; 62
    4bd8:	60 97       	sbiw	r28, 0x10	; 16
    4bda:	0f b6       	in	r0, 0x3f	; 63
    4bdc:	f8 94       	cli
    4bde:	de bf       	out	0x3e, r29	; 62
    4be0:	0f be       	out	0x3f, r0	; 63
    4be2:	cd bf       	out	0x3d, r28	; 61
    4be4:	9f 83       	std	Y+7, r25	; 0x07
    4be6:	8e 83       	std	Y+6, r24	; 0x06
    4be8:	79 87       	std	Y+9, r23	; 0x09
    4bea:	68 87       	std	Y+8, r22	; 0x08
    4bec:	5b 87       	std	Y+11, r21	; 0x0b
    4bee:	4a 87       	std	Y+10, r20	; 0x0a
    4bf0:	3d 87       	std	Y+13, r19	; 0x0d
    4bf2:	2c 87       	std	Y+12, r18	; 0x0c
    4bf4:	0e 87       	std	Y+14, r16	; 0x0e
    4bf6:	f8 8a       	std	Y+16, r15	; 0x10
    4bf8:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    4bfa:	8a 85       	ldd	r24, Y+10	; 0x0a
    4bfc:	9b 85       	ldd	r25, Y+11	; 0x0b
    4bfe:	0e 94 69 18 	call	0x30d2	; 0x30d2 <pvPortMalloc>
    4c02:	9a 83       	std	Y+2, r25	; 0x02
    4c04:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    4c06:	89 81       	ldd	r24, Y+1	; 0x01
    4c08:	9a 81       	ldd	r25, Y+2	; 0x02
    4c0a:	00 97       	sbiw	r24, 0x00	; 0
    4c0c:	b1 f0       	breq	.+44     	; 0x4c3a <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    4c0e:	86 e2       	ldi	r24, 0x26	; 38
    4c10:	90 e0       	ldi	r25, 0x00	; 0
    4c12:	0e 94 69 18 	call	0x30d2	; 0x30d2 <pvPortMalloc>
    4c16:	9d 83       	std	Y+5, r25	; 0x05
    4c18:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    4c1a:	8c 81       	ldd	r24, Y+4	; 0x04
    4c1c:	9d 81       	ldd	r25, Y+5	; 0x05
    4c1e:	00 97       	sbiw	r24, 0x00	; 0
    4c20:	39 f0       	breq	.+14     	; 0x4c30 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4c22:	ec 81       	ldd	r30, Y+4	; 0x04
    4c24:	fd 81       	ldd	r31, Y+5	; 0x05
    4c26:	89 81       	ldd	r24, Y+1	; 0x01
    4c28:	9a 81       	ldd	r25, Y+2	; 0x02
    4c2a:	90 8f       	std	Z+24, r25	; 0x18
    4c2c:	87 8b       	std	Z+23, r24	; 0x17
    4c2e:	07 c0       	rjmp	.+14     	; 0x4c3e <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    4c30:	89 81       	ldd	r24, Y+1	; 0x01
    4c32:	9a 81       	ldd	r25, Y+2	; 0x02
    4c34:	0e 94 bf 18 	call	0x317e	; 0x317e <vPortFree>
    4c38:	02 c0       	rjmp	.+4      	; 0x4c3e <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4c3a:	1d 82       	std	Y+5, r1	; 0x05
    4c3c:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4c3e:	8c 81       	ldd	r24, Y+4	; 0x04
    4c40:	9d 81       	ldd	r25, Y+5	; 0x05
    4c42:	00 97       	sbiw	r24, 0x00	; 0
    4c44:	e9 f0       	breq	.+58     	; 0x4c80 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4c46:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c48:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c4a:	9c 01       	movw	r18, r24
    4c4c:	40 e0       	ldi	r20, 0x00	; 0
    4c4e:	50 e0       	ldi	r21, 0x00	; 0
    4c50:	8e 81       	ldd	r24, Y+6	; 0x06
    4c52:	9f 81       	ldd	r25, Y+7	; 0x07
    4c54:	68 85       	ldd	r22, Y+8	; 0x08
    4c56:	79 85       	ldd	r23, Y+9	; 0x09
    4c58:	ec 85       	ldd	r30, Y+12	; 0x0c
    4c5a:	fd 85       	ldd	r31, Y+13	; 0x0d
    4c5c:	af 85       	ldd	r26, Y+15	; 0x0f
    4c5e:	b8 89       	ldd	r27, Y+16	; 0x10
    4c60:	ac 80       	ldd	r10, Y+4	; 0x04
    4c62:	bd 80       	ldd	r11, Y+5	; 0x05
    4c64:	8f 01       	movw	r16, r30
    4c66:	ee 84       	ldd	r14, Y+14	; 0x0e
    4c68:	6d 01       	movw	r12, r26
    4c6a:	88 24       	eor	r8, r8
    4c6c:	99 24       	eor	r9, r9
    4c6e:	0e 94 56 26 	call	0x4cac	; 0x4cac <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    4c72:	8c 81       	ldd	r24, Y+4	; 0x04
    4c74:	9d 81       	ldd	r25, Y+5	; 0x05
    4c76:	0e 94 12 27 	call	0x4e24	; 0x4e24 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    4c7a:	81 e0       	ldi	r24, 0x01	; 1
    4c7c:	8b 83       	std	Y+3, r24	; 0x03
    4c7e:	02 c0       	rjmp	.+4      	; 0x4c84 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4c80:	8f ef       	ldi	r24, 0xFF	; 255
    4c82:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    4c84:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4c86:	60 96       	adiw	r28, 0x10	; 16
    4c88:	0f b6       	in	r0, 0x3f	; 63
    4c8a:	f8 94       	cli
    4c8c:	de bf       	out	0x3e, r29	; 62
    4c8e:	0f be       	out	0x3f, r0	; 63
    4c90:	cd bf       	out	0x3d, r28	; 61
    4c92:	cf 91       	pop	r28
    4c94:	df 91       	pop	r29
    4c96:	1f 91       	pop	r17
    4c98:	0f 91       	pop	r16
    4c9a:	ff 90       	pop	r15
    4c9c:	ef 90       	pop	r14
    4c9e:	df 90       	pop	r13
    4ca0:	cf 90       	pop	r12
    4ca2:	bf 90       	pop	r11
    4ca4:	af 90       	pop	r10
    4ca6:	9f 90       	pop	r9
    4ca8:	8f 90       	pop	r8
    4caa:	08 95       	ret

00004cac <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    4cac:	8f 92       	push	r8
    4cae:	9f 92       	push	r9
    4cb0:	af 92       	push	r10
    4cb2:	bf 92       	push	r11
    4cb4:	cf 92       	push	r12
    4cb6:	df 92       	push	r13
    4cb8:	ef 92       	push	r14
    4cba:	0f 93       	push	r16
    4cbc:	1f 93       	push	r17
    4cbe:	df 93       	push	r29
    4cc0:	cf 93       	push	r28
    4cc2:	cd b7       	in	r28, 0x3d	; 61
    4cc4:	de b7       	in	r29, 0x3e	; 62
    4cc6:	64 97       	sbiw	r28, 0x14	; 20
    4cc8:	0f b6       	in	r0, 0x3f	; 63
    4cca:	f8 94       	cli
    4ccc:	de bf       	out	0x3e, r29	; 62
    4cce:	0f be       	out	0x3f, r0	; 63
    4cd0:	cd bf       	out	0x3d, r28	; 61
    4cd2:	9d 83       	std	Y+5, r25	; 0x05
    4cd4:	8c 83       	std	Y+4, r24	; 0x04
    4cd6:	7f 83       	std	Y+7, r23	; 0x07
    4cd8:	6e 83       	std	Y+6, r22	; 0x06
    4cda:	28 87       	std	Y+8, r18	; 0x08
    4cdc:	39 87       	std	Y+9, r19	; 0x09
    4cde:	4a 87       	std	Y+10, r20	; 0x0a
    4ce0:	5b 87       	std	Y+11, r21	; 0x0b
    4ce2:	1d 87       	std	Y+13, r17	; 0x0d
    4ce4:	0c 87       	std	Y+12, r16	; 0x0c
    4ce6:	ee 86       	std	Y+14, r14	; 0x0e
    4ce8:	d8 8a       	std	Y+16, r13	; 0x10
    4cea:	cf 86       	std	Y+15, r12	; 0x0f
    4cec:	ba 8a       	std	Y+18, r11	; 0x12
    4cee:	a9 8a       	std	Y+17, r10	; 0x11
    4cf0:	9c 8a       	std	Y+20, r9	; 0x14
    4cf2:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4cf4:	e9 89       	ldd	r30, Y+17	; 0x11
    4cf6:	fa 89       	ldd	r31, Y+18	; 0x12
    4cf8:	27 89       	ldd	r18, Z+23	; 0x17
    4cfa:	30 8d       	ldd	r19, Z+24	; 0x18
    4cfc:	88 85       	ldd	r24, Y+8	; 0x08
    4cfe:	99 85       	ldd	r25, Y+9	; 0x09
    4d00:	01 97       	sbiw	r24, 0x01	; 1
    4d02:	82 0f       	add	r24, r18
    4d04:	93 1f       	adc	r25, r19
    4d06:	9b 83       	std	Y+3, r25	; 0x03
    4d08:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    4d0a:	8e 81       	ldd	r24, Y+6	; 0x06
    4d0c:	9f 81       	ldd	r25, Y+7	; 0x07
    4d0e:	00 97       	sbiw	r24, 0x00	; 0
    4d10:	51 f1       	breq	.+84     	; 0x4d66 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4d12:	19 82       	std	Y+1, r1	; 0x01
    4d14:	21 c0       	rjmp	.+66     	; 0x4d58 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4d16:	89 81       	ldd	r24, Y+1	; 0x01
    4d18:	48 2f       	mov	r20, r24
    4d1a:	50 e0       	ldi	r21, 0x00	; 0
    4d1c:	89 81       	ldd	r24, Y+1	; 0x01
    4d1e:	28 2f       	mov	r18, r24
    4d20:	30 e0       	ldi	r19, 0x00	; 0
    4d22:	8e 81       	ldd	r24, Y+6	; 0x06
    4d24:	9f 81       	ldd	r25, Y+7	; 0x07
    4d26:	fc 01       	movw	r30, r24
    4d28:	e2 0f       	add	r30, r18
    4d2a:	f3 1f       	adc	r31, r19
    4d2c:	20 81       	ld	r18, Z
    4d2e:	89 89       	ldd	r24, Y+17	; 0x11
    4d30:	9a 89       	ldd	r25, Y+18	; 0x12
    4d32:	84 0f       	add	r24, r20
    4d34:	95 1f       	adc	r25, r21
    4d36:	fc 01       	movw	r30, r24
    4d38:	79 96       	adiw	r30, 0x19	; 25
    4d3a:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4d3c:	89 81       	ldd	r24, Y+1	; 0x01
    4d3e:	28 2f       	mov	r18, r24
    4d40:	30 e0       	ldi	r19, 0x00	; 0
    4d42:	8e 81       	ldd	r24, Y+6	; 0x06
    4d44:	9f 81       	ldd	r25, Y+7	; 0x07
    4d46:	fc 01       	movw	r30, r24
    4d48:	e2 0f       	add	r30, r18
    4d4a:	f3 1f       	adc	r31, r19
    4d4c:	80 81       	ld	r24, Z
    4d4e:	88 23       	and	r24, r24
    4d50:	31 f0       	breq	.+12     	; 0x4d5e <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4d52:	89 81       	ldd	r24, Y+1	; 0x01
    4d54:	8f 5f       	subi	r24, 0xFF	; 255
    4d56:	89 83       	std	Y+1, r24	; 0x01
    4d58:	89 81       	ldd	r24, Y+1	; 0x01
    4d5a:	88 30       	cpi	r24, 0x08	; 8
    4d5c:	e0 f2       	brcs	.-72     	; 0x4d16 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4d5e:	e9 89       	ldd	r30, Y+17	; 0x11
    4d60:	fa 89       	ldd	r31, Y+18	; 0x12
    4d62:	10 a2       	std	Z+32, r1	; 0x20
    4d64:	03 c0       	rjmp	.+6      	; 0x4d6c <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4d66:	e9 89       	ldd	r30, Y+17	; 0x11
    4d68:	fa 89       	ldd	r31, Y+18	; 0x12
    4d6a:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4d6c:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d6e:	85 30       	cpi	r24, 0x05	; 5
    4d70:	10 f0       	brcs	.+4      	; 0x4d76 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4d72:	84 e0       	ldi	r24, 0x04	; 4
    4d74:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4d76:	e9 89       	ldd	r30, Y+17	; 0x11
    4d78:	fa 89       	ldd	r31, Y+18	; 0x12
    4d7a:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d7c:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4d7e:	89 89       	ldd	r24, Y+17	; 0x11
    4d80:	9a 89       	ldd	r25, Y+18	; 0x12
    4d82:	02 96       	adiw	r24, 0x02	; 2
    4d84:	0e 94 0f 19 	call	0x321e	; 0x321e <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4d88:	89 89       	ldd	r24, Y+17	; 0x11
    4d8a:	9a 89       	ldd	r25, Y+18	; 0x12
    4d8c:	0c 96       	adiw	r24, 0x0c	; 12
    4d8e:	0e 94 0f 19 	call	0x321e	; 0x321e <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4d92:	e9 89       	ldd	r30, Y+17	; 0x11
    4d94:	fa 89       	ldd	r31, Y+18	; 0x12
    4d96:	89 89       	ldd	r24, Y+17	; 0x11
    4d98:	9a 89       	ldd	r25, Y+18	; 0x12
    4d9a:	91 87       	std	Z+9, r25	; 0x09
    4d9c:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4d9e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4da0:	28 2f       	mov	r18, r24
    4da2:	30 e0       	ldi	r19, 0x00	; 0
    4da4:	85 e0       	ldi	r24, 0x05	; 5
    4da6:	90 e0       	ldi	r25, 0x00	; 0
    4da8:	82 1b       	sub	r24, r18
    4daa:	93 0b       	sbc	r25, r19
    4dac:	e9 89       	ldd	r30, Y+17	; 0x11
    4dae:	fa 89       	ldd	r31, Y+18	; 0x12
    4db0:	95 87       	std	Z+13, r25	; 0x0d
    4db2:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4db4:	e9 89       	ldd	r30, Y+17	; 0x11
    4db6:	fa 89       	ldd	r31, Y+18	; 0x12
    4db8:	89 89       	ldd	r24, Y+17	; 0x11
    4dba:	9a 89       	ldd	r25, Y+18	; 0x12
    4dbc:	93 8b       	std	Z+19, r25	; 0x13
    4dbe:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4dc0:	e9 89       	ldd	r30, Y+17	; 0x11
    4dc2:	fa 89       	ldd	r31, Y+18	; 0x12
    4dc4:	11 a2       	std	Z+33, r1	; 0x21
    4dc6:	12 a2       	std	Z+34, r1	; 0x22
    4dc8:	13 a2       	std	Z+35, r1	; 0x23
    4dca:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4dcc:	e9 89       	ldd	r30, Y+17	; 0x11
    4dce:	fa 89       	ldd	r31, Y+18	; 0x12
    4dd0:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4dd2:	8a 81       	ldd	r24, Y+2	; 0x02
    4dd4:	9b 81       	ldd	r25, Y+3	; 0x03
    4dd6:	2c 81       	ldd	r18, Y+4	; 0x04
    4dd8:	3d 81       	ldd	r19, Y+5	; 0x05
    4dda:	4c 85       	ldd	r20, Y+12	; 0x0c
    4ddc:	5d 85       	ldd	r21, Y+13	; 0x0d
    4dde:	b9 01       	movw	r22, r18
    4de0:	0e 94 ea 1b 	call	0x37d4	; 0x37d4 <pxPortInitialiseStack>
    4de4:	e9 89       	ldd	r30, Y+17	; 0x11
    4de6:	fa 89       	ldd	r31, Y+18	; 0x12
    4de8:	91 83       	std	Z+1, r25	; 0x01
    4dea:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    4dec:	8f 85       	ldd	r24, Y+15	; 0x0f
    4dee:	98 89       	ldd	r25, Y+16	; 0x10
    4df0:	00 97       	sbiw	r24, 0x00	; 0
    4df2:	31 f0       	breq	.+12     	; 0x4e00 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4df4:	ef 85       	ldd	r30, Y+15	; 0x0f
    4df6:	f8 89       	ldd	r31, Y+16	; 0x10
    4df8:	89 89       	ldd	r24, Y+17	; 0x11
    4dfa:	9a 89       	ldd	r25, Y+18	; 0x12
    4dfc:	91 83       	std	Z+1, r25	; 0x01
    4dfe:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4e00:	64 96       	adiw	r28, 0x14	; 20
    4e02:	0f b6       	in	r0, 0x3f	; 63
    4e04:	f8 94       	cli
    4e06:	de bf       	out	0x3e, r29	; 62
    4e08:	0f be       	out	0x3f, r0	; 63
    4e0a:	cd bf       	out	0x3d, r28	; 61
    4e0c:	cf 91       	pop	r28
    4e0e:	df 91       	pop	r29
    4e10:	1f 91       	pop	r17
    4e12:	0f 91       	pop	r16
    4e14:	ef 90       	pop	r14
    4e16:	df 90       	pop	r13
    4e18:	cf 90       	pop	r12
    4e1a:	bf 90       	pop	r11
    4e1c:	af 90       	pop	r10
    4e1e:	9f 90       	pop	r9
    4e20:	8f 90       	pop	r8
    4e22:	08 95       	ret

00004e24 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4e24:	df 93       	push	r29
    4e26:	cf 93       	push	r28
    4e28:	00 d0       	rcall	.+0      	; 0x4e2a <prvAddNewTaskToReadyList+0x6>
    4e2a:	cd b7       	in	r28, 0x3d	; 61
    4e2c:	de b7       	in	r29, 0x3e	; 62
    4e2e:	9a 83       	std	Y+2, r25	; 0x02
    4e30:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4e32:	0f b6       	in	r0, 0x3f	; 63
    4e34:	f8 94       	cli
    4e36:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4e38:	80 91 76 04 	lds	r24, 0x0476
    4e3c:	8f 5f       	subi	r24, 0xFF	; 255
    4e3e:	80 93 76 04 	sts	0x0476, r24
		if( pxCurrentTCB == NULL )
    4e42:	80 91 73 04 	lds	r24, 0x0473
    4e46:	90 91 74 04 	lds	r25, 0x0474
    4e4a:	00 97       	sbiw	r24, 0x00	; 0
    4e4c:	69 f4       	brne	.+26     	; 0x4e68 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4e4e:	89 81       	ldd	r24, Y+1	; 0x01
    4e50:	9a 81       	ldd	r25, Y+2	; 0x02
    4e52:	90 93 74 04 	sts	0x0474, r25
    4e56:	80 93 73 04 	sts	0x0473, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4e5a:	80 91 76 04 	lds	r24, 0x0476
    4e5e:	81 30       	cpi	r24, 0x01	; 1
    4e60:	b9 f4       	brne	.+46     	; 0x4e90 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4e62:	0e 94 a9 2f 	call	0x5f52	; 0x5f52 <prvInitialiseTaskLists>
    4e66:	14 c0       	rjmp	.+40     	; 0x4e90 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4e68:	80 91 7a 04 	lds	r24, 0x047A
    4e6c:	88 23       	and	r24, r24
    4e6e:	81 f4       	brne	.+32     	; 0x4e90 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4e70:	e0 91 73 04 	lds	r30, 0x0473
    4e74:	f0 91 74 04 	lds	r31, 0x0474
    4e78:	96 89       	ldd	r25, Z+22	; 0x16
    4e7a:	e9 81       	ldd	r30, Y+1	; 0x01
    4e7c:	fa 81       	ldd	r31, Y+2	; 0x02
    4e7e:	86 89       	ldd	r24, Z+22	; 0x16
    4e80:	89 17       	cp	r24, r25
    4e82:	30 f0       	brcs	.+12     	; 0x4e90 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    4e84:	89 81       	ldd	r24, Y+1	; 0x01
    4e86:	9a 81       	ldd	r25, Y+2	; 0x02
    4e88:	90 93 74 04 	sts	0x0474, r25
    4e8c:	80 93 73 04 	sts	0x0473, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4e90:	80 91 7f 04 	lds	r24, 0x047F
    4e94:	8f 5f       	subi	r24, 0xFF	; 255
    4e96:	80 93 7f 04 	sts	0x047F, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4e9a:	e9 81       	ldd	r30, Y+1	; 0x01
    4e9c:	fa 81       	ldd	r31, Y+2	; 0x02
    4e9e:	96 89       	ldd	r25, Z+22	; 0x16
    4ea0:	80 91 79 04 	lds	r24, 0x0479
    4ea4:	89 17       	cp	r24, r25
    4ea6:	28 f4       	brcc	.+10     	; 0x4eb2 <prvAddNewTaskToReadyList+0x8e>
    4ea8:	e9 81       	ldd	r30, Y+1	; 0x01
    4eaa:	fa 81       	ldd	r31, Y+2	; 0x02
    4eac:	86 89       	ldd	r24, Z+22	; 0x16
    4eae:	80 93 79 04 	sts	0x0479, r24
    4eb2:	e9 81       	ldd	r30, Y+1	; 0x01
    4eb4:	fa 81       	ldd	r31, Y+2	; 0x02
    4eb6:	86 89       	ldd	r24, Z+22	; 0x16
    4eb8:	28 2f       	mov	r18, r24
    4eba:	30 e0       	ldi	r19, 0x00	; 0
    4ebc:	c9 01       	movw	r24, r18
    4ebe:	88 0f       	add	r24, r24
    4ec0:	99 1f       	adc	r25, r25
    4ec2:	88 0f       	add	r24, r24
    4ec4:	99 1f       	adc	r25, r25
    4ec6:	88 0f       	add	r24, r24
    4ec8:	99 1f       	adc	r25, r25
    4eca:	82 0f       	add	r24, r18
    4ecc:	93 1f       	adc	r25, r19
    4ece:	ac 01       	movw	r20, r24
    4ed0:	4b 57       	subi	r20, 0x7B	; 123
    4ed2:	5b 4f       	sbci	r21, 0xFB	; 251
    4ed4:	89 81       	ldd	r24, Y+1	; 0x01
    4ed6:	9a 81       	ldd	r25, Y+2	; 0x02
    4ed8:	9c 01       	movw	r18, r24
    4eda:	2e 5f       	subi	r18, 0xFE	; 254
    4edc:	3f 4f       	sbci	r19, 0xFF	; 255
    4ede:	ca 01       	movw	r24, r20
    4ee0:	b9 01       	movw	r22, r18
    4ee2:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4ee6:	0f 90       	pop	r0
    4ee8:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4eea:	80 91 7a 04 	lds	r24, 0x047A
    4eee:	88 23       	and	r24, r24
    4ef0:	61 f0       	breq	.+24     	; 0x4f0a <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4ef2:	e0 91 73 04 	lds	r30, 0x0473
    4ef6:	f0 91 74 04 	lds	r31, 0x0474
    4efa:	96 89       	ldd	r25, Z+22	; 0x16
    4efc:	e9 81       	ldd	r30, Y+1	; 0x01
    4efe:	fa 81       	ldd	r31, Y+2	; 0x02
    4f00:	86 89       	ldd	r24, Z+22	; 0x16
    4f02:	98 17       	cp	r25, r24
    4f04:	10 f4       	brcc	.+4      	; 0x4f0a <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4f06:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4f0a:	0f 90       	pop	r0
    4f0c:	0f 90       	pop	r0
    4f0e:	cf 91       	pop	r28
    4f10:	df 91       	pop	r29
    4f12:	08 95       	ret

00004f14 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4f14:	df 93       	push	r29
    4f16:	cf 93       	push	r28
    4f18:	00 d0       	rcall	.+0      	; 0x4f1a <vTaskDelete+0x6>
    4f1a:	00 d0       	rcall	.+0      	; 0x4f1c <vTaskDelete+0x8>
    4f1c:	00 d0       	rcall	.+0      	; 0x4f1e <vTaskDelete+0xa>
    4f1e:	cd b7       	in	r28, 0x3d	; 61
    4f20:	de b7       	in	r29, 0x3e	; 62
    4f22:	9c 83       	std	Y+4, r25	; 0x04
    4f24:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4f26:	0f b6       	in	r0, 0x3f	; 63
    4f28:	f8 94       	cli
    4f2a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4f2c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f2e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f30:	00 97       	sbiw	r24, 0x00	; 0
    4f32:	39 f4       	brne	.+14     	; 0x4f42 <vTaskDelete+0x2e>
    4f34:	80 91 73 04 	lds	r24, 0x0473
    4f38:	90 91 74 04 	lds	r25, 0x0474
    4f3c:	9e 83       	std	Y+6, r25	; 0x06
    4f3e:	8d 83       	std	Y+5, r24	; 0x05
    4f40:	04 c0       	rjmp	.+8      	; 0x4f4a <vTaskDelete+0x36>
    4f42:	8b 81       	ldd	r24, Y+3	; 0x03
    4f44:	9c 81       	ldd	r25, Y+4	; 0x04
    4f46:	9e 83       	std	Y+6, r25	; 0x06
    4f48:	8d 83       	std	Y+5, r24	; 0x05
    4f4a:	8d 81       	ldd	r24, Y+5	; 0x05
    4f4c:	9e 81       	ldd	r25, Y+6	; 0x06
    4f4e:	9a 83       	std	Y+2, r25	; 0x02
    4f50:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4f52:	89 81       	ldd	r24, Y+1	; 0x01
    4f54:	9a 81       	ldd	r25, Y+2	; 0x02
    4f56:	02 96       	adiw	r24, 0x02	; 2
    4f58:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4f5c:	e9 81       	ldd	r30, Y+1	; 0x01
    4f5e:	fa 81       	ldd	r31, Y+2	; 0x02
    4f60:	84 89       	ldd	r24, Z+20	; 0x14
    4f62:	95 89       	ldd	r25, Z+21	; 0x15
    4f64:	00 97       	sbiw	r24, 0x00	; 0
    4f66:	29 f0       	breq	.+10     	; 0x4f72 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4f68:	89 81       	ldd	r24, Y+1	; 0x01
    4f6a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f6c:	0c 96       	adiw	r24, 0x0c	; 12
    4f6e:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4f72:	80 91 7f 04 	lds	r24, 0x047F
    4f76:	8f 5f       	subi	r24, 0xFF	; 255
    4f78:	80 93 7f 04 	sts	0x047F, r24

			if( pxTCB == pxCurrentTCB )
    4f7c:	20 91 73 04 	lds	r18, 0x0473
    4f80:	30 91 74 04 	lds	r19, 0x0474
    4f84:	89 81       	ldd	r24, Y+1	; 0x01
    4f86:	9a 81       	ldd	r25, Y+2	; 0x02
    4f88:	82 17       	cp	r24, r18
    4f8a:	93 07       	cpc	r25, r19
    4f8c:	81 f4       	brne	.+32     	; 0x4fae <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4f8e:	89 81       	ldd	r24, Y+1	; 0x01
    4f90:	9a 81       	ldd	r25, Y+2	; 0x02
    4f92:	9c 01       	movw	r18, r24
    4f94:	2e 5f       	subi	r18, 0xFE	; 254
    4f96:	3f 4f       	sbci	r19, 0xFF	; 255
    4f98:	81 ed       	ldi	r24, 0xD1	; 209
    4f9a:	94 e0       	ldi	r25, 0x04	; 4
    4f9c:	b9 01       	movw	r22, r18
    4f9e:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4fa2:	80 91 75 04 	lds	r24, 0x0475
    4fa6:	8f 5f       	subi	r24, 0xFF	; 255
    4fa8:	80 93 75 04 	sts	0x0475, r24
    4fac:	0b c0       	rjmp	.+22     	; 0x4fc4 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4fae:	80 91 76 04 	lds	r24, 0x0476
    4fb2:	81 50       	subi	r24, 0x01	; 1
    4fb4:	80 93 76 04 	sts	0x0476, r24
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
    4fb8:	89 81       	ldd	r24, Y+1	; 0x01
    4fba:	9a 81       	ldd	r25, Y+2	; 0x02
    4fbc:	0e 94 19 30 	call	0x6032	; 0x6032 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    4fc0:	0e 94 2f 30 	call	0x605e	; 0x605e <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
    4fc4:	0f 90       	pop	r0
    4fc6:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4fc8:	80 91 7a 04 	lds	r24, 0x047A
    4fcc:	88 23       	and	r24, r24
    4fce:	59 f0       	breq	.+22     	; 0x4fe6 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    4fd0:	20 91 73 04 	lds	r18, 0x0473
    4fd4:	30 91 74 04 	lds	r19, 0x0474
    4fd8:	89 81       	ldd	r24, Y+1	; 0x01
    4fda:	9a 81       	ldd	r25, Y+2	; 0x02
    4fdc:	82 17       	cp	r24, r18
    4fde:	93 07       	cpc	r25, r19
    4fe0:	11 f4       	brne	.+4      	; 0x4fe6 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4fe2:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    4fe6:	26 96       	adiw	r28, 0x06	; 6
    4fe8:	0f b6       	in	r0, 0x3f	; 63
    4fea:	f8 94       	cli
    4fec:	de bf       	out	0x3e, r29	; 62
    4fee:	0f be       	out	0x3f, r0	; 63
    4ff0:	cd bf       	out	0x3d, r28	; 61
    4ff2:	cf 91       	pop	r28
    4ff4:	df 91       	pop	r29
    4ff6:	08 95       	ret

00004ff8 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    4ff8:	df 93       	push	r29
    4ffa:	cf 93       	push	r28
    4ffc:	cd b7       	in	r28, 0x3d	; 61
    4ffe:	de b7       	in	r29, 0x3e	; 62
    5000:	2a 97       	sbiw	r28, 0x0a	; 10
    5002:	0f b6       	in	r0, 0x3f	; 63
    5004:	f8 94       	cli
    5006:	de bf       	out	0x3e, r29	; 62
    5008:	0f be       	out	0x3f, r0	; 63
    500a:	cd bf       	out	0x3d, r28	; 61
    500c:	98 87       	std	Y+8, r25	; 0x08
    500e:	8f 83       	std	Y+7, r24	; 0x07
    5010:	7a 87       	std	Y+10, r23	; 0x0a
    5012:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    5014:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    5016:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    501a:	80 91 77 04 	lds	r24, 0x0477
    501e:	90 91 78 04 	lds	r25, 0x0478
    5022:	9a 83       	std	Y+2, r25	; 0x02
    5024:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    5026:	ef 81       	ldd	r30, Y+7	; 0x07
    5028:	f8 85       	ldd	r31, Y+8	; 0x08
    502a:	20 81       	ld	r18, Z
    502c:	31 81       	ldd	r19, Z+1	; 0x01
    502e:	89 85       	ldd	r24, Y+9	; 0x09
    5030:	9a 85       	ldd	r25, Y+10	; 0x0a
    5032:	82 0f       	add	r24, r18
    5034:	93 1f       	adc	r25, r19
    5036:	9e 83       	std	Y+6, r25	; 0x06
    5038:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    503a:	ef 81       	ldd	r30, Y+7	; 0x07
    503c:	f8 85       	ldd	r31, Y+8	; 0x08
    503e:	20 81       	ld	r18, Z
    5040:	31 81       	ldd	r19, Z+1	; 0x01
    5042:	89 81       	ldd	r24, Y+1	; 0x01
    5044:	9a 81       	ldd	r25, Y+2	; 0x02
    5046:	82 17       	cp	r24, r18
    5048:	93 07       	cpc	r25, r19
    504a:	98 f4       	brcc	.+38     	; 0x5072 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    504c:	ef 81       	ldd	r30, Y+7	; 0x07
    504e:	f8 85       	ldd	r31, Y+8	; 0x08
    5050:	20 81       	ld	r18, Z
    5052:	31 81       	ldd	r19, Z+1	; 0x01
    5054:	8d 81       	ldd	r24, Y+5	; 0x05
    5056:	9e 81       	ldd	r25, Y+6	; 0x06
    5058:	82 17       	cp	r24, r18
    505a:	93 07       	cpc	r25, r19
    505c:	e0 f4       	brcc	.+56     	; 0x5096 <vTaskDelayUntil+0x9e>
    505e:	2d 81       	ldd	r18, Y+5	; 0x05
    5060:	3e 81       	ldd	r19, Y+6	; 0x06
    5062:	89 81       	ldd	r24, Y+1	; 0x01
    5064:	9a 81       	ldd	r25, Y+2	; 0x02
    5066:	82 17       	cp	r24, r18
    5068:	93 07       	cpc	r25, r19
    506a:	a8 f4       	brcc	.+42     	; 0x5096 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    506c:	81 e0       	ldi	r24, 0x01	; 1
    506e:	8b 83       	std	Y+3, r24	; 0x03
    5070:	12 c0       	rjmp	.+36     	; 0x5096 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    5072:	ef 81       	ldd	r30, Y+7	; 0x07
    5074:	f8 85       	ldd	r31, Y+8	; 0x08
    5076:	20 81       	ld	r18, Z
    5078:	31 81       	ldd	r19, Z+1	; 0x01
    507a:	8d 81       	ldd	r24, Y+5	; 0x05
    507c:	9e 81       	ldd	r25, Y+6	; 0x06
    507e:	82 17       	cp	r24, r18
    5080:	93 07       	cpc	r25, r19
    5082:	38 f0       	brcs	.+14     	; 0x5092 <vTaskDelayUntil+0x9a>
    5084:	2d 81       	ldd	r18, Y+5	; 0x05
    5086:	3e 81       	ldd	r19, Y+6	; 0x06
    5088:	89 81       	ldd	r24, Y+1	; 0x01
    508a:	9a 81       	ldd	r25, Y+2	; 0x02
    508c:	82 17       	cp	r24, r18
    508e:	93 07       	cpc	r25, r19
    5090:	10 f4       	brcc	.+4      	; 0x5096 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5092:	81 e0       	ldi	r24, 0x01	; 1
    5094:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    5096:	ef 81       	ldd	r30, Y+7	; 0x07
    5098:	f8 85       	ldd	r31, Y+8	; 0x08
    509a:	8d 81       	ldd	r24, Y+5	; 0x05
    509c:	9e 81       	ldd	r25, Y+6	; 0x06
    509e:	91 83       	std	Z+1, r25	; 0x01
    50a0:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    50a2:	8b 81       	ldd	r24, Y+3	; 0x03
    50a4:	88 23       	and	r24, r24
    50a6:	49 f0       	breq	.+18     	; 0x50ba <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    50a8:	8d 81       	ldd	r24, Y+5	; 0x05
    50aa:	9e 81       	ldd	r25, Y+6	; 0x06
    50ac:	29 81       	ldd	r18, Y+1	; 0x01
    50ae:	3a 81       	ldd	r19, Y+2	; 0x02
    50b0:	82 1b       	sub	r24, r18
    50b2:	93 0b       	sbc	r25, r19
    50b4:	60 e0       	ldi	r22, 0x00	; 0
    50b6:	0e 94 84 34 	call	0x6908	; 0x6908 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    50ba:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    50be:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    50c0:	8c 81       	ldd	r24, Y+4	; 0x04
    50c2:	88 23       	and	r24, r24
    50c4:	11 f4       	brne	.+4      	; 0x50ca <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    50c6:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    50ca:	2a 96       	adiw	r28, 0x0a	; 10
    50cc:	0f b6       	in	r0, 0x3f	; 63
    50ce:	f8 94       	cli
    50d0:	de bf       	out	0x3e, r29	; 62
    50d2:	0f be       	out	0x3f, r0	; 63
    50d4:	cd bf       	out	0x3d, r28	; 61
    50d6:	cf 91       	pop	r28
    50d8:	df 91       	pop	r29
    50da:	08 95       	ret

000050dc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    50dc:	df 93       	push	r29
    50de:	cf 93       	push	r28
    50e0:	00 d0       	rcall	.+0      	; 0x50e2 <vTaskDelay+0x6>
    50e2:	0f 92       	push	r0
    50e4:	cd b7       	in	r28, 0x3d	; 61
    50e6:	de b7       	in	r29, 0x3e	; 62
    50e8:	9b 83       	std	Y+3, r25	; 0x03
    50ea:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    50ec:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    50ee:	8a 81       	ldd	r24, Y+2	; 0x02
    50f0:	9b 81       	ldd	r25, Y+3	; 0x03
    50f2:	00 97       	sbiw	r24, 0x00	; 0
    50f4:	51 f0       	breq	.+20     	; 0x510a <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    50f6:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    50fa:	8a 81       	ldd	r24, Y+2	; 0x02
    50fc:	9b 81       	ldd	r25, Y+3	; 0x03
    50fe:	60 e0       	ldi	r22, 0x00	; 0
    5100:	0e 94 84 34 	call	0x6908	; 0x6908 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    5104:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    5108:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    510a:	89 81       	ldd	r24, Y+1	; 0x01
    510c:	88 23       	and	r24, r24
    510e:	11 f4       	brne	.+4      	; 0x5114 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    5110:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5114:	0f 90       	pop	r0
    5116:	0f 90       	pop	r0
    5118:	0f 90       	pop	r0
    511a:	cf 91       	pop	r28
    511c:	df 91       	pop	r29
    511e:	08 95       	ret

00005120 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
    5120:	df 93       	push	r29
    5122:	cf 93       	push	r28
    5124:	cd b7       	in	r28, 0x3d	; 61
    5126:	de b7       	in	r29, 0x3e	; 62
    5128:	27 97       	sbiw	r28, 0x07	; 7
    512a:	0f b6       	in	r0, 0x3f	; 63
    512c:	f8 94       	cli
    512e:	de bf       	out	0x3e, r29	; 62
    5130:	0f be       	out	0x3f, r0	; 63
    5132:	cd bf       	out	0x3d, r28	; 61
    5134:	9d 83       	std	Y+5, r25	; 0x05
    5136:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    5138:	0f b6       	in	r0, 0x3f	; 63
    513a:	f8 94       	cli
    513c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    513e:	8c 81       	ldd	r24, Y+4	; 0x04
    5140:	9d 81       	ldd	r25, Y+5	; 0x05
    5142:	00 97       	sbiw	r24, 0x00	; 0
    5144:	39 f4       	brne	.+14     	; 0x5154 <uxTaskPriorityGet+0x34>
    5146:	80 91 73 04 	lds	r24, 0x0473
    514a:	90 91 74 04 	lds	r25, 0x0474
    514e:	9f 83       	std	Y+7, r25	; 0x07
    5150:	8e 83       	std	Y+6, r24	; 0x06
    5152:	04 c0       	rjmp	.+8      	; 0x515c <uxTaskPriorityGet+0x3c>
    5154:	8c 81       	ldd	r24, Y+4	; 0x04
    5156:	9d 81       	ldd	r25, Y+5	; 0x05
    5158:	9f 83       	std	Y+7, r25	; 0x07
    515a:	8e 83       	std	Y+6, r24	; 0x06
    515c:	8e 81       	ldd	r24, Y+6	; 0x06
    515e:	9f 81       	ldd	r25, Y+7	; 0x07
    5160:	9b 83       	std	Y+3, r25	; 0x03
    5162:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    5164:	ea 81       	ldd	r30, Y+2	; 0x02
    5166:	fb 81       	ldd	r31, Y+3	; 0x03
    5168:	86 89       	ldd	r24, Z+22	; 0x16
    516a:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    516c:	0f 90       	pop	r0
    516e:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    5170:	89 81       	ldd	r24, Y+1	; 0x01
	}
    5172:	27 96       	adiw	r28, 0x07	; 7
    5174:	0f b6       	in	r0, 0x3f	; 63
    5176:	f8 94       	cli
    5178:	de bf       	out	0x3e, r29	; 62
    517a:	0f be       	out	0x3f, r0	; 63
    517c:	cd bf       	out	0x3d, r28	; 61
    517e:	cf 91       	pop	r28
    5180:	df 91       	pop	r29
    5182:	08 95       	ret

00005184 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
    5184:	df 93       	push	r29
    5186:	cf 93       	push	r28
    5188:	cd b7       	in	r28, 0x3d	; 61
    518a:	de b7       	in	r29, 0x3e	; 62
    518c:	28 97       	sbiw	r28, 0x08	; 8
    518e:	0f b6       	in	r0, 0x3f	; 63
    5190:	f8 94       	cli
    5192:	de bf       	out	0x3e, r29	; 62
    5194:	0f be       	out	0x3f, r0	; 63
    5196:	cd bf       	out	0x3d, r28	; 61
    5198:	9e 83       	std	Y+6, r25	; 0x06
    519a:	8d 83       	std	Y+5, r24	; 0x05
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    519c:	19 82       	std	Y+1, r1	; 0x01
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    519e:	8d 81       	ldd	r24, Y+5	; 0x05
    51a0:	9e 81       	ldd	r25, Y+6	; 0x06
    51a2:	00 97       	sbiw	r24, 0x00	; 0
    51a4:	39 f4       	brne	.+14     	; 0x51b4 <uxTaskPriorityGetFromISR+0x30>
    51a6:	80 91 73 04 	lds	r24, 0x0473
    51aa:	90 91 74 04 	lds	r25, 0x0474
    51ae:	98 87       	std	Y+8, r25	; 0x08
    51b0:	8f 83       	std	Y+7, r24	; 0x07
    51b2:	04 c0       	rjmp	.+8      	; 0x51bc <uxTaskPriorityGetFromISR+0x38>
    51b4:	8d 81       	ldd	r24, Y+5	; 0x05
    51b6:	9e 81       	ldd	r25, Y+6	; 0x06
    51b8:	98 87       	std	Y+8, r25	; 0x08
    51ba:	8f 83       	std	Y+7, r24	; 0x07
    51bc:	8f 81       	ldd	r24, Y+7	; 0x07
    51be:	98 85       	ldd	r25, Y+8	; 0x08
    51c0:	9c 83       	std	Y+4, r25	; 0x04
    51c2:	8b 83       	std	Y+3, r24	; 0x03
			uxReturn = pxTCB->uxPriority;
    51c4:	eb 81       	ldd	r30, Y+3	; 0x03
    51c6:	fc 81       	ldd	r31, Y+4	; 0x04
    51c8:	86 89       	ldd	r24, Z+22	; 0x16
    51ca:	8a 83       	std	Y+2, r24	; 0x02
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    51cc:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    51ce:	28 96       	adiw	r28, 0x08	; 8
    51d0:	0f b6       	in	r0, 0x3f	; 63
    51d2:	f8 94       	cli
    51d4:	de bf       	out	0x3e, r29	; 62
    51d6:	0f be       	out	0x3f, r0	; 63
    51d8:	cd bf       	out	0x3d, r28	; 61
    51da:	cf 91       	pop	r28
    51dc:	df 91       	pop	r29
    51de:	08 95       	ret

000051e0 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    51e0:	df 93       	push	r29
    51e2:	cf 93       	push	r28
    51e4:	cd b7       	in	r28, 0x3d	; 61
    51e6:	de b7       	in	r29, 0x3e	; 62
    51e8:	2a 97       	sbiw	r28, 0x0a	; 10
    51ea:	0f b6       	in	r0, 0x3f	; 63
    51ec:	f8 94       	cli
    51ee:	de bf       	out	0x3e, r29	; 62
    51f0:	0f be       	out	0x3f, r0	; 63
    51f2:	cd bf       	out	0x3d, r28	; 61
    51f4:	9f 83       	std	Y+7, r25	; 0x07
    51f6:	8e 83       	std	Y+6, r24	; 0x06
    51f8:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    51fa:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    51fc:	88 85       	ldd	r24, Y+8	; 0x08
    51fe:	85 30       	cpi	r24, 0x05	; 5
    5200:	10 f0       	brcs	.+4      	; 0x5206 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5202:	84 e0       	ldi	r24, 0x04	; 4
    5204:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    5206:	0f b6       	in	r0, 0x3f	; 63
    5208:	f8 94       	cli
    520a:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    520c:	8e 81       	ldd	r24, Y+6	; 0x06
    520e:	9f 81       	ldd	r25, Y+7	; 0x07
    5210:	00 97       	sbiw	r24, 0x00	; 0
    5212:	39 f4       	brne	.+14     	; 0x5222 <vTaskPrioritySet+0x42>
    5214:	80 91 73 04 	lds	r24, 0x0473
    5218:	90 91 74 04 	lds	r25, 0x0474
    521c:	9a 87       	std	Y+10, r25	; 0x0a
    521e:	89 87       	std	Y+9, r24	; 0x09
    5220:	04 c0       	rjmp	.+8      	; 0x522a <vTaskPrioritySet+0x4a>
    5222:	8e 81       	ldd	r24, Y+6	; 0x06
    5224:	9f 81       	ldd	r25, Y+7	; 0x07
    5226:	9a 87       	std	Y+10, r25	; 0x0a
    5228:	89 87       	std	Y+9, r24	; 0x09
    522a:	89 85       	ldd	r24, Y+9	; 0x09
    522c:	9a 85       	ldd	r25, Y+10	; 0x0a
    522e:	9d 83       	std	Y+5, r25	; 0x05
    5230:	8c 83       	std	Y+4, r24	; 0x04
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
    5232:	ec 81       	ldd	r30, Y+4	; 0x04
    5234:	fd 81       	ldd	r31, Y+5	; 0x05
    5236:	86 89       	ldd	r24, Z+22	; 0x16
    5238:	8b 83       	std	Y+3, r24	; 0x03
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    523a:	9b 81       	ldd	r25, Y+3	; 0x03
    523c:	88 85       	ldd	r24, Y+8	; 0x08
    523e:	98 17       	cp	r25, r24
    5240:	09 f4       	brne	.+2      	; 0x5244 <vTaskPrioritySet+0x64>
    5242:	81 c0       	rjmp	.+258    	; 0x5346 <vTaskPrioritySet+0x166>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    5244:	98 85       	ldd	r25, Y+8	; 0x08
    5246:	8b 81       	ldd	r24, Y+3	; 0x03
    5248:	89 17       	cp	r24, r25
    524a:	a0 f4       	brcc	.+40     	; 0x5274 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    524c:	20 91 73 04 	lds	r18, 0x0473
    5250:	30 91 74 04 	lds	r19, 0x0474
    5254:	8c 81       	ldd	r24, Y+4	; 0x04
    5256:	9d 81       	ldd	r25, Y+5	; 0x05
    5258:	82 17       	cp	r24, r18
    525a:	93 07       	cpc	r25, r19
    525c:	b1 f0       	breq	.+44     	; 0x528a <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    525e:	e0 91 73 04 	lds	r30, 0x0473
    5262:	f0 91 74 04 	lds	r31, 0x0474
    5266:	96 89       	ldd	r25, Z+22	; 0x16
    5268:	88 85       	ldd	r24, Y+8	; 0x08
    526a:	89 17       	cp	r24, r25
    526c:	70 f0       	brcs	.+28     	; 0x528a <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    526e:	81 e0       	ldi	r24, 0x01	; 1
    5270:	89 83       	std	Y+1, r24	; 0x01
    5272:	0b c0       	rjmp	.+22     	; 0x528a <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    5274:	20 91 73 04 	lds	r18, 0x0473
    5278:	30 91 74 04 	lds	r19, 0x0474
    527c:	8c 81       	ldd	r24, Y+4	; 0x04
    527e:	9d 81       	ldd	r25, Y+5	; 0x05
    5280:	82 17       	cp	r24, r18
    5282:	93 07       	cpc	r25, r19
    5284:	11 f4       	brne	.+4      	; 0x528a <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    5286:	81 e0       	ldi	r24, 0x01	; 1
    5288:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    528a:	ec 81       	ldd	r30, Y+4	; 0x04
    528c:	fd 81       	ldd	r31, Y+5	; 0x05
    528e:	86 89       	ldd	r24, Z+22	; 0x16
    5290:	8a 83       	std	Y+2, r24	; 0x02
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    5292:	ec 81       	ldd	r30, Y+4	; 0x04
    5294:	fd 81       	ldd	r31, Y+5	; 0x05
    5296:	88 85       	ldd	r24, Y+8	; 0x08
    5298:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    529a:	ec 81       	ldd	r30, Y+4	; 0x04
    529c:	fd 81       	ldd	r31, Y+5	; 0x05
    529e:	84 85       	ldd	r24, Z+12	; 0x0c
    52a0:	95 85       	ldd	r25, Z+13	; 0x0d
    52a2:	99 23       	and	r25, r25
    52a4:	5c f0       	brlt	.+22     	; 0x52bc <vTaskPrioritySet+0xdc>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    52a6:	88 85       	ldd	r24, Y+8	; 0x08
    52a8:	28 2f       	mov	r18, r24
    52aa:	30 e0       	ldi	r19, 0x00	; 0
    52ac:	85 e0       	ldi	r24, 0x05	; 5
    52ae:	90 e0       	ldi	r25, 0x00	; 0
    52b0:	82 1b       	sub	r24, r18
    52b2:	93 0b       	sbc	r25, r19
    52b4:	ec 81       	ldd	r30, Y+4	; 0x04
    52b6:	fd 81       	ldd	r31, Y+5	; 0x05
    52b8:	95 87       	std	Z+13, r25	; 0x0d
    52ba:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    52bc:	ec 81       	ldd	r30, Y+4	; 0x04
    52be:	fd 81       	ldd	r31, Y+5	; 0x05
    52c0:	42 85       	ldd	r20, Z+10	; 0x0a
    52c2:	53 85       	ldd	r21, Z+11	; 0x0b
    52c4:	8a 81       	ldd	r24, Y+2	; 0x02
    52c6:	28 2f       	mov	r18, r24
    52c8:	30 e0       	ldi	r19, 0x00	; 0
    52ca:	c9 01       	movw	r24, r18
    52cc:	88 0f       	add	r24, r24
    52ce:	99 1f       	adc	r25, r25
    52d0:	88 0f       	add	r24, r24
    52d2:	99 1f       	adc	r25, r25
    52d4:	88 0f       	add	r24, r24
    52d6:	99 1f       	adc	r25, r25
    52d8:	82 0f       	add	r24, r18
    52da:	93 1f       	adc	r25, r19
    52dc:	8b 57       	subi	r24, 0x7B	; 123
    52de:	9b 4f       	sbci	r25, 0xFB	; 251
    52e0:	48 17       	cp	r20, r24
    52e2:	59 07       	cpc	r21, r25
    52e4:	59 f5       	brne	.+86     	; 0x533c <vTaskPrioritySet+0x15c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    52e6:	8c 81       	ldd	r24, Y+4	; 0x04
    52e8:	9d 81       	ldd	r25, Y+5	; 0x05
    52ea:	02 96       	adiw	r24, 0x02	; 2
    52ec:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    52f0:	ec 81       	ldd	r30, Y+4	; 0x04
    52f2:	fd 81       	ldd	r31, Y+5	; 0x05
    52f4:	96 89       	ldd	r25, Z+22	; 0x16
    52f6:	80 91 79 04 	lds	r24, 0x0479
    52fa:	89 17       	cp	r24, r25
    52fc:	28 f4       	brcc	.+10     	; 0x5308 <vTaskPrioritySet+0x128>
    52fe:	ec 81       	ldd	r30, Y+4	; 0x04
    5300:	fd 81       	ldd	r31, Y+5	; 0x05
    5302:	86 89       	ldd	r24, Z+22	; 0x16
    5304:	80 93 79 04 	sts	0x0479, r24
    5308:	ec 81       	ldd	r30, Y+4	; 0x04
    530a:	fd 81       	ldd	r31, Y+5	; 0x05
    530c:	86 89       	ldd	r24, Z+22	; 0x16
    530e:	28 2f       	mov	r18, r24
    5310:	30 e0       	ldi	r19, 0x00	; 0
    5312:	c9 01       	movw	r24, r18
    5314:	88 0f       	add	r24, r24
    5316:	99 1f       	adc	r25, r25
    5318:	88 0f       	add	r24, r24
    531a:	99 1f       	adc	r25, r25
    531c:	88 0f       	add	r24, r24
    531e:	99 1f       	adc	r25, r25
    5320:	82 0f       	add	r24, r18
    5322:	93 1f       	adc	r25, r19
    5324:	ac 01       	movw	r20, r24
    5326:	4b 57       	subi	r20, 0x7B	; 123
    5328:	5b 4f       	sbci	r21, 0xFB	; 251
    532a:	8c 81       	ldd	r24, Y+4	; 0x04
    532c:	9d 81       	ldd	r25, Y+5	; 0x05
    532e:	9c 01       	movw	r18, r24
    5330:	2e 5f       	subi	r18, 0xFE	; 254
    5332:	3f 4f       	sbci	r19, 0xFF	; 255
    5334:	ca 01       	movw	r24, r20
    5336:	b9 01       	movw	r22, r18
    5338:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    533c:	89 81       	ldd	r24, Y+1	; 0x01
    533e:	88 23       	and	r24, r24
    5340:	11 f0       	breq	.+4      	; 0x5346 <vTaskPrioritySet+0x166>
				{
					taskYIELD_IF_USING_PREEMPTION();
    5342:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    5346:	0f 90       	pop	r0
    5348:	0f be       	out	0x3f, r0	; 63
	}
    534a:	2a 96       	adiw	r28, 0x0a	; 10
    534c:	0f b6       	in	r0, 0x3f	; 63
    534e:	f8 94       	cli
    5350:	de bf       	out	0x3e, r29	; 62
    5352:	0f be       	out	0x3f, r0	; 63
    5354:	cd bf       	out	0x3d, r28	; 61
    5356:	cf 91       	pop	r28
    5358:	df 91       	pop	r29
    535a:	08 95       	ret

0000535c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    535c:	df 93       	push	r29
    535e:	cf 93       	push	r28
    5360:	00 d0       	rcall	.+0      	; 0x5362 <vTaskSuspend+0x6>
    5362:	00 d0       	rcall	.+0      	; 0x5364 <vTaskSuspend+0x8>
    5364:	00 d0       	rcall	.+0      	; 0x5366 <vTaskSuspend+0xa>
    5366:	cd b7       	in	r28, 0x3d	; 61
    5368:	de b7       	in	r29, 0x3e	; 62
    536a:	9c 83       	std	Y+4, r25	; 0x04
    536c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    536e:	0f b6       	in	r0, 0x3f	; 63
    5370:	f8 94       	cli
    5372:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    5374:	8b 81       	ldd	r24, Y+3	; 0x03
    5376:	9c 81       	ldd	r25, Y+4	; 0x04
    5378:	00 97       	sbiw	r24, 0x00	; 0
    537a:	39 f4       	brne	.+14     	; 0x538a <vTaskSuspend+0x2e>
    537c:	80 91 73 04 	lds	r24, 0x0473
    5380:	90 91 74 04 	lds	r25, 0x0474
    5384:	9e 83       	std	Y+6, r25	; 0x06
    5386:	8d 83       	std	Y+5, r24	; 0x05
    5388:	04 c0       	rjmp	.+8      	; 0x5392 <vTaskSuspend+0x36>
    538a:	8b 81       	ldd	r24, Y+3	; 0x03
    538c:	9c 81       	ldd	r25, Y+4	; 0x04
    538e:	9e 83       	std	Y+6, r25	; 0x06
    5390:	8d 83       	std	Y+5, r24	; 0x05
    5392:	8d 81       	ldd	r24, Y+5	; 0x05
    5394:	9e 81       	ldd	r25, Y+6	; 0x06
    5396:	9a 83       	std	Y+2, r25	; 0x02
    5398:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    539a:	89 81       	ldd	r24, Y+1	; 0x01
    539c:	9a 81       	ldd	r25, Y+2	; 0x02
    539e:	02 96       	adiw	r24, 0x02	; 2
    53a0:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    53a4:	e9 81       	ldd	r30, Y+1	; 0x01
    53a6:	fa 81       	ldd	r31, Y+2	; 0x02
    53a8:	84 89       	ldd	r24, Z+20	; 0x14
    53aa:	95 89       	ldd	r25, Z+21	; 0x15
    53ac:	00 97       	sbiw	r24, 0x00	; 0
    53ae:	29 f0       	breq	.+10     	; 0x53ba <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    53b0:	89 81       	ldd	r24, Y+1	; 0x01
    53b2:	9a 81       	ldd	r25, Y+2	; 0x02
    53b4:	0c 96       	adiw	r24, 0x0c	; 12
    53b6:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    53ba:	89 81       	ldd	r24, Y+1	; 0x01
    53bc:	9a 81       	ldd	r25, Y+2	; 0x02
    53be:	9c 01       	movw	r18, r24
    53c0:	2e 5f       	subi	r18, 0xFE	; 254
    53c2:	3f 4f       	sbci	r19, 0xFF	; 255
    53c4:	8a ed       	ldi	r24, 0xDA	; 218
    53c6:	94 e0       	ldi	r25, 0x04	; 4
    53c8:	b9 01       	movw	r22, r18
    53ca:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    53ce:	e9 81       	ldd	r30, Y+1	; 0x01
    53d0:	fa 81       	ldd	r31, Y+2	; 0x02
    53d2:	85 a1       	ldd	r24, Z+37	; 0x25
    53d4:	81 30       	cpi	r24, 0x01	; 1
    53d6:	19 f4       	brne	.+6      	; 0x53de <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    53d8:	e9 81       	ldd	r30, Y+1	; 0x01
    53da:	fa 81       	ldd	r31, Y+2	; 0x02
    53dc:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    53de:	0f 90       	pop	r0
    53e0:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    53e2:	80 91 7a 04 	lds	r24, 0x047A
    53e6:	88 23       	and	r24, r24
    53e8:	39 f0       	breq	.+14     	; 0x53f8 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    53ea:	0f b6       	in	r0, 0x3f	; 63
    53ec:	f8 94       	cli
    53ee:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    53f0:	0e 94 2f 30 	call	0x605e	; 0x605e <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    53f4:	0f 90       	pop	r0
    53f6:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    53f8:	20 91 73 04 	lds	r18, 0x0473
    53fc:	30 91 74 04 	lds	r19, 0x0474
    5400:	89 81       	ldd	r24, Y+1	; 0x01
    5402:	9a 81       	ldd	r25, Y+2	; 0x02
    5404:	82 17       	cp	r24, r18
    5406:	93 07       	cpc	r25, r19
    5408:	a1 f4       	brne	.+40     	; 0x5432 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    540a:	80 91 7a 04 	lds	r24, 0x047A
    540e:	88 23       	and	r24, r24
    5410:	19 f0       	breq	.+6      	; 0x5418 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    5412:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
    5416:	0d c0       	rjmp	.+26     	; 0x5432 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    5418:	90 91 da 04 	lds	r25, 0x04DA
    541c:	80 91 76 04 	lds	r24, 0x0476
    5420:	98 17       	cp	r25, r24
    5422:	29 f4       	brne	.+10     	; 0x542e <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    5424:	10 92 74 04 	sts	0x0474, r1
    5428:	10 92 73 04 	sts	0x0473, r1
    542c:	02 c0       	rjmp	.+4      	; 0x5432 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    542e:	0e 94 6a 2d 	call	0x5ad4	; 0x5ad4 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5432:	26 96       	adiw	r28, 0x06	; 6
    5434:	0f b6       	in	r0, 0x3f	; 63
    5436:	f8 94       	cli
    5438:	de bf       	out	0x3e, r29	; 62
    543a:	0f be       	out	0x3f, r0	; 63
    543c:	cd bf       	out	0x3d, r28	; 61
    543e:	cf 91       	pop	r28
    5440:	df 91       	pop	r29
    5442:	08 95       	ret

00005444 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    5444:	df 93       	push	r29
    5446:	cf 93       	push	r28
    5448:	00 d0       	rcall	.+0      	; 0x544a <prvTaskIsTaskSuspended+0x6>
    544a:	00 d0       	rcall	.+0      	; 0x544c <prvTaskIsTaskSuspended+0x8>
    544c:	0f 92       	push	r0
    544e:	cd b7       	in	r28, 0x3d	; 61
    5450:	de b7       	in	r29, 0x3e	; 62
    5452:	9d 83       	std	Y+5, r25	; 0x05
    5454:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    5456:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    5458:	8c 81       	ldd	r24, Y+4	; 0x04
    545a:	9d 81       	ldd	r25, Y+5	; 0x05
    545c:	9a 83       	std	Y+2, r25	; 0x02
    545e:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    5460:	e9 81       	ldd	r30, Y+1	; 0x01
    5462:	fa 81       	ldd	r31, Y+2	; 0x02
    5464:	82 85       	ldd	r24, Z+10	; 0x0a
    5466:	93 85       	ldd	r25, Z+11	; 0x0b
    5468:	24 e0       	ldi	r18, 0x04	; 4
    546a:	8a 3d       	cpi	r24, 0xDA	; 218
    546c:	92 07       	cpc	r25, r18
    546e:	81 f4       	brne	.+32     	; 0x5490 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    5470:	e9 81       	ldd	r30, Y+1	; 0x01
    5472:	fa 81       	ldd	r31, Y+2	; 0x02
    5474:	84 89       	ldd	r24, Z+20	; 0x14
    5476:	95 89       	ldd	r25, Z+21	; 0x15
    5478:	24 e0       	ldi	r18, 0x04	; 4
    547a:	88 3c       	cpi	r24, 0xC8	; 200
    547c:	92 07       	cpc	r25, r18
    547e:	41 f0       	breq	.+16     	; 0x5490 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    5480:	e9 81       	ldd	r30, Y+1	; 0x01
    5482:	fa 81       	ldd	r31, Y+2	; 0x02
    5484:	84 89       	ldd	r24, Z+20	; 0x14
    5486:	95 89       	ldd	r25, Z+21	; 0x15
    5488:	00 97       	sbiw	r24, 0x00	; 0
    548a:	11 f4       	brne	.+4      	; 0x5490 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    548c:	81 e0       	ldi	r24, 0x01	; 1
    548e:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    5490:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    5492:	0f 90       	pop	r0
    5494:	0f 90       	pop	r0
    5496:	0f 90       	pop	r0
    5498:	0f 90       	pop	r0
    549a:	0f 90       	pop	r0
    549c:	cf 91       	pop	r28
    549e:	df 91       	pop	r29
    54a0:	08 95       	ret

000054a2 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    54a2:	df 93       	push	r29
    54a4:	cf 93       	push	r28
    54a6:	00 d0       	rcall	.+0      	; 0x54a8 <vTaskResume+0x6>
    54a8:	00 d0       	rcall	.+0      	; 0x54aa <vTaskResume+0x8>
    54aa:	cd b7       	in	r28, 0x3d	; 61
    54ac:	de b7       	in	r29, 0x3e	; 62
    54ae:	9c 83       	std	Y+4, r25	; 0x04
    54b0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    54b2:	8b 81       	ldd	r24, Y+3	; 0x03
    54b4:	9c 81       	ldd	r25, Y+4	; 0x04
    54b6:	9a 83       	std	Y+2, r25	; 0x02
    54b8:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    54ba:	20 91 73 04 	lds	r18, 0x0473
    54be:	30 91 74 04 	lds	r19, 0x0474
    54c2:	89 81       	ldd	r24, Y+1	; 0x01
    54c4:	9a 81       	ldd	r25, Y+2	; 0x02
    54c6:	82 17       	cp	r24, r18
    54c8:	93 07       	cpc	r25, r19
    54ca:	09 f4       	brne	.+2      	; 0x54ce <vTaskResume+0x2c>
    54cc:	47 c0       	rjmp	.+142    	; 0x555c <vTaskResume+0xba>
    54ce:	89 81       	ldd	r24, Y+1	; 0x01
    54d0:	9a 81       	ldd	r25, Y+2	; 0x02
    54d2:	00 97       	sbiw	r24, 0x00	; 0
    54d4:	09 f4       	brne	.+2      	; 0x54d8 <vTaskResume+0x36>
    54d6:	42 c0       	rjmp	.+132    	; 0x555c <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    54d8:	0f b6       	in	r0, 0x3f	; 63
    54da:	f8 94       	cli
    54dc:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    54de:	89 81       	ldd	r24, Y+1	; 0x01
    54e0:	9a 81       	ldd	r25, Y+2	; 0x02
    54e2:	0e 94 22 2a 	call	0x5444	; 0x5444 <prvTaskIsTaskSuspended>
    54e6:	88 23       	and	r24, r24
    54e8:	b9 f1       	breq	.+110    	; 0x5558 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    54ea:	89 81       	ldd	r24, Y+1	; 0x01
    54ec:	9a 81       	ldd	r25, Y+2	; 0x02
    54ee:	02 96       	adiw	r24, 0x02	; 2
    54f0:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    54f4:	e9 81       	ldd	r30, Y+1	; 0x01
    54f6:	fa 81       	ldd	r31, Y+2	; 0x02
    54f8:	96 89       	ldd	r25, Z+22	; 0x16
    54fa:	80 91 79 04 	lds	r24, 0x0479
    54fe:	89 17       	cp	r24, r25
    5500:	28 f4       	brcc	.+10     	; 0x550c <vTaskResume+0x6a>
    5502:	e9 81       	ldd	r30, Y+1	; 0x01
    5504:	fa 81       	ldd	r31, Y+2	; 0x02
    5506:	86 89       	ldd	r24, Z+22	; 0x16
    5508:	80 93 79 04 	sts	0x0479, r24
    550c:	e9 81       	ldd	r30, Y+1	; 0x01
    550e:	fa 81       	ldd	r31, Y+2	; 0x02
    5510:	86 89       	ldd	r24, Z+22	; 0x16
    5512:	28 2f       	mov	r18, r24
    5514:	30 e0       	ldi	r19, 0x00	; 0
    5516:	c9 01       	movw	r24, r18
    5518:	88 0f       	add	r24, r24
    551a:	99 1f       	adc	r25, r25
    551c:	88 0f       	add	r24, r24
    551e:	99 1f       	adc	r25, r25
    5520:	88 0f       	add	r24, r24
    5522:	99 1f       	adc	r25, r25
    5524:	82 0f       	add	r24, r18
    5526:	93 1f       	adc	r25, r19
    5528:	ac 01       	movw	r20, r24
    552a:	4b 57       	subi	r20, 0x7B	; 123
    552c:	5b 4f       	sbci	r21, 0xFB	; 251
    552e:	89 81       	ldd	r24, Y+1	; 0x01
    5530:	9a 81       	ldd	r25, Y+2	; 0x02
    5532:	9c 01       	movw	r18, r24
    5534:	2e 5f       	subi	r18, 0xFE	; 254
    5536:	3f 4f       	sbci	r19, 0xFF	; 255
    5538:	ca 01       	movw	r24, r20
    553a:	b9 01       	movw	r22, r18
    553c:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5540:	e9 81       	ldd	r30, Y+1	; 0x01
    5542:	fa 81       	ldd	r31, Y+2	; 0x02
    5544:	96 89       	ldd	r25, Z+22	; 0x16
    5546:	e0 91 73 04 	lds	r30, 0x0473
    554a:	f0 91 74 04 	lds	r31, 0x0474
    554e:	86 89       	ldd	r24, Z+22	; 0x16
    5550:	98 17       	cp	r25, r24
    5552:	10 f0       	brcs	.+4      	; 0x5558 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    5554:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    5558:	0f 90       	pop	r0
    555a:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    555c:	0f 90       	pop	r0
    555e:	0f 90       	pop	r0
    5560:	0f 90       	pop	r0
    5562:	0f 90       	pop	r0
    5564:	cf 91       	pop	r28
    5566:	df 91       	pop	r29
    5568:	08 95       	ret

0000556a <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    556a:	df 93       	push	r29
    556c:	cf 93       	push	r28
    556e:	00 d0       	rcall	.+0      	; 0x5570 <xTaskResumeFromISR+0x6>
    5570:	00 d0       	rcall	.+0      	; 0x5572 <xTaskResumeFromISR+0x8>
    5572:	00 d0       	rcall	.+0      	; 0x5574 <xTaskResumeFromISR+0xa>
    5574:	cd b7       	in	r28, 0x3d	; 61
    5576:	de b7       	in	r29, 0x3e	; 62
    5578:	9e 83       	std	Y+6, r25	; 0x06
    557a:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    557c:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    557e:	8d 81       	ldd	r24, Y+5	; 0x05
    5580:	9e 81       	ldd	r25, Y+6	; 0x06
    5582:	9b 83       	std	Y+3, r25	; 0x03
    5584:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5586:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    5588:	8a 81       	ldd	r24, Y+2	; 0x02
    558a:	9b 81       	ldd	r25, Y+3	; 0x03
    558c:	0e 94 22 2a 	call	0x5444	; 0x5444 <prvTaskIsTaskSuspended>
    5590:	88 23       	and	r24, r24
    5592:	09 f4       	brne	.+2      	; 0x5596 <xTaskResumeFromISR+0x2c>
    5594:	46 c0       	rjmp	.+140    	; 0x5622 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5596:	80 91 84 04 	lds	r24, 0x0484
    559a:	88 23       	and	r24, r24
    559c:	c1 f5       	brne	.+112    	; 0x560e <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    559e:	ea 81       	ldd	r30, Y+2	; 0x02
    55a0:	fb 81       	ldd	r31, Y+3	; 0x03
    55a2:	96 89       	ldd	r25, Z+22	; 0x16
    55a4:	e0 91 73 04 	lds	r30, 0x0473
    55a8:	f0 91 74 04 	lds	r31, 0x0474
    55ac:	86 89       	ldd	r24, Z+22	; 0x16
    55ae:	98 17       	cp	r25, r24
    55b0:	10 f0       	brcs	.+4      	; 0x55b6 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    55b2:	81 e0       	ldi	r24, 0x01	; 1
    55b4:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    55b6:	8a 81       	ldd	r24, Y+2	; 0x02
    55b8:	9b 81       	ldd	r25, Y+3	; 0x03
    55ba:	02 96       	adiw	r24, 0x02	; 2
    55bc:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    55c0:	ea 81       	ldd	r30, Y+2	; 0x02
    55c2:	fb 81       	ldd	r31, Y+3	; 0x03
    55c4:	96 89       	ldd	r25, Z+22	; 0x16
    55c6:	80 91 79 04 	lds	r24, 0x0479
    55ca:	89 17       	cp	r24, r25
    55cc:	28 f4       	brcc	.+10     	; 0x55d8 <xTaskResumeFromISR+0x6e>
    55ce:	ea 81       	ldd	r30, Y+2	; 0x02
    55d0:	fb 81       	ldd	r31, Y+3	; 0x03
    55d2:	86 89       	ldd	r24, Z+22	; 0x16
    55d4:	80 93 79 04 	sts	0x0479, r24
    55d8:	ea 81       	ldd	r30, Y+2	; 0x02
    55da:	fb 81       	ldd	r31, Y+3	; 0x03
    55dc:	86 89       	ldd	r24, Z+22	; 0x16
    55de:	28 2f       	mov	r18, r24
    55e0:	30 e0       	ldi	r19, 0x00	; 0
    55e2:	c9 01       	movw	r24, r18
    55e4:	88 0f       	add	r24, r24
    55e6:	99 1f       	adc	r25, r25
    55e8:	88 0f       	add	r24, r24
    55ea:	99 1f       	adc	r25, r25
    55ec:	88 0f       	add	r24, r24
    55ee:	99 1f       	adc	r25, r25
    55f0:	82 0f       	add	r24, r18
    55f2:	93 1f       	adc	r25, r19
    55f4:	ac 01       	movw	r20, r24
    55f6:	4b 57       	subi	r20, 0x7B	; 123
    55f8:	5b 4f       	sbci	r21, 0xFB	; 251
    55fa:	8a 81       	ldd	r24, Y+2	; 0x02
    55fc:	9b 81       	ldd	r25, Y+3	; 0x03
    55fe:	9c 01       	movw	r18, r24
    5600:	2e 5f       	subi	r18, 0xFE	; 254
    5602:	3f 4f       	sbci	r19, 0xFF	; 255
    5604:	ca 01       	movw	r24, r20
    5606:	b9 01       	movw	r22, r18
    5608:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
    560c:	0a c0       	rjmp	.+20     	; 0x5622 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    560e:	8a 81       	ldd	r24, Y+2	; 0x02
    5610:	9b 81       	ldd	r25, Y+3	; 0x03
    5612:	9c 01       	movw	r18, r24
    5614:	24 5f       	subi	r18, 0xF4	; 244
    5616:	3f 4f       	sbci	r19, 0xFF	; 255
    5618:	88 ec       	ldi	r24, 0xC8	; 200
    561a:	94 e0       	ldi	r25, 0x04	; 4
    561c:	b9 01       	movw	r22, r18
    561e:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    5622:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    5624:	26 96       	adiw	r28, 0x06	; 6
    5626:	0f b6       	in	r0, 0x3f	; 63
    5628:	f8 94       	cli
    562a:	de bf       	out	0x3e, r29	; 62
    562c:	0f be       	out	0x3f, r0	; 63
    562e:	cd bf       	out	0x3d, r28	; 61
    5630:	cf 91       	pop	r28
    5632:	df 91       	pop	r29
    5634:	08 95       	ret

00005636 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    5636:	ef 92       	push	r14
    5638:	ff 92       	push	r15
    563a:	0f 93       	push	r16
    563c:	df 93       	push	r29
    563e:	cf 93       	push	r28
    5640:	0f 92       	push	r0
    5642:	cd b7       	in	r28, 0x3d	; 61
    5644:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    5646:	8f e9       	ldi	r24, 0x9F	; 159
    5648:	9f e2       	ldi	r25, 0x2F	; 47
    564a:	28 e7       	ldi	r18, 0x78	; 120
    564c:	30 e0       	ldi	r19, 0x00	; 0
    564e:	e2 e8       	ldi	r30, 0x82	; 130
    5650:	f4 e0       	ldi	r31, 0x04	; 4
    5652:	b9 01       	movw	r22, r18
    5654:	45 e5       	ldi	r20, 0x55	; 85
    5656:	50 e0       	ldi	r21, 0x00	; 0
    5658:	20 e0       	ldi	r18, 0x00	; 0
    565a:	30 e0       	ldi	r19, 0x00	; 0
    565c:	00 e0       	ldi	r16, 0x00	; 0
    565e:	7f 01       	movw	r14, r30
    5660:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <xTaskCreate>
    5664:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    5666:	89 81       	ldd	r24, Y+1	; 0x01
    5668:	81 30       	cpi	r24, 0x01	; 1
    566a:	81 f4       	brne	.+32     	; 0x568c <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    566c:	f8 94       	cli
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    566e:	8f ef       	ldi	r24, 0xFF	; 255
    5670:	9f ef       	ldi	r25, 0xFF	; 255
    5672:	90 93 81 04 	sts	0x0481, r25
    5676:	80 93 80 04 	sts	0x0480, r24
		xSchedulerRunning = pdTRUE;
    567a:	81 e0       	ldi	r24, 0x01	; 1
    567c:	80 93 7a 04 	sts	0x047A, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    5680:	10 92 78 04 	sts	0x0478, r1
    5684:	10 92 77 04 	sts	0x0477, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    5688:	0e 94 6d 1d 	call	0x3ada	; 0x3ada <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    568c:	0f 90       	pop	r0
    568e:	cf 91       	pop	r28
    5690:	df 91       	pop	r29
    5692:	0f 91       	pop	r16
    5694:	ff 90       	pop	r15
    5696:	ef 90       	pop	r14
    5698:	08 95       	ret

0000569a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    569a:	df 93       	push	r29
    569c:	cf 93       	push	r28
    569e:	cd b7       	in	r28, 0x3d	; 61
    56a0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    56a2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    56a4:	10 92 7a 04 	sts	0x047A, r1
	vPortEndScheduler();
    56a8:	0e 94 a2 1d 	call	0x3b44	; 0x3b44 <vPortEndScheduler>
}
    56ac:	cf 91       	pop	r28
    56ae:	df 91       	pop	r29
    56b0:	08 95       	ret

000056b2 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    56b2:	df 93       	push	r29
    56b4:	cf 93       	push	r28
    56b6:	cd b7       	in	r28, 0x3d	; 61
    56b8:	de b7       	in	r29, 0x3e	; 62
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
    56ba:	80 91 84 04 	lds	r24, 0x0484
    56be:	8f 5f       	subi	r24, 0xFF	; 255
    56c0:	80 93 84 04 	sts	0x0484, r24

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
    56c4:	cf 91       	pop	r28
    56c6:	df 91       	pop	r29
    56c8:	08 95       	ret

000056ca <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    56ca:	df 93       	push	r29
    56cc:	cf 93       	push	r28
    56ce:	00 d0       	rcall	.+0      	; 0x56d0 <xTaskResumeAll+0x6>
    56d0:	00 d0       	rcall	.+0      	; 0x56d2 <xTaskResumeAll+0x8>
    56d2:	0f 92       	push	r0
    56d4:	cd b7       	in	r28, 0x3d	; 61
    56d6:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    56d8:	1d 82       	std	Y+5, r1	; 0x05
    56da:	1c 82       	std	Y+4, r1	; 0x04
BaseType_t xAlreadyYielded = pdFALSE;
    56dc:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    56de:	0f b6       	in	r0, 0x3f	; 63
    56e0:	f8 94       	cli
    56e2:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    56e4:	80 91 84 04 	lds	r24, 0x0484
    56e8:	81 50       	subi	r24, 0x01	; 1
    56ea:	80 93 84 04 	sts	0x0484, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    56ee:	80 91 84 04 	lds	r24, 0x0484
    56f2:	88 23       	and	r24, r24
    56f4:	09 f0       	breq	.+2      	; 0x56f8 <xTaskResumeAll+0x2e>
    56f6:	7c c0       	rjmp	.+248    	; 0x57f0 <xTaskResumeAll+0x126>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    56f8:	80 91 76 04 	lds	r24, 0x0476
    56fc:	88 23       	and	r24, r24
    56fe:	09 f4       	brne	.+2      	; 0x5702 <xTaskResumeAll+0x38>
    5700:	77 c0       	rjmp	.+238    	; 0x57f0 <xTaskResumeAll+0x126>
    5702:	45 c0       	rjmp	.+138    	; 0x578e <xTaskResumeAll+0xc4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5704:	e0 91 cd 04 	lds	r30, 0x04CD
    5708:	f0 91 ce 04 	lds	r31, 0x04CE
    570c:	86 81       	ldd	r24, Z+6	; 0x06
    570e:	97 81       	ldd	r25, Z+7	; 0x07
    5710:	9d 83       	std	Y+5, r25	; 0x05
    5712:	8c 83       	std	Y+4, r24	; 0x04
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5714:	8c 81       	ldd	r24, Y+4	; 0x04
    5716:	9d 81       	ldd	r25, Y+5	; 0x05
    5718:	0c 96       	adiw	r24, 0x0c	; 12
    571a:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    571e:	8c 81       	ldd	r24, Y+4	; 0x04
    5720:	9d 81       	ldd	r25, Y+5	; 0x05
    5722:	02 96       	adiw	r24, 0x02	; 2
    5724:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5728:	ec 81       	ldd	r30, Y+4	; 0x04
    572a:	fd 81       	ldd	r31, Y+5	; 0x05
    572c:	96 89       	ldd	r25, Z+22	; 0x16
    572e:	80 91 79 04 	lds	r24, 0x0479
    5732:	89 17       	cp	r24, r25
    5734:	28 f4       	brcc	.+10     	; 0x5740 <xTaskResumeAll+0x76>
    5736:	ec 81       	ldd	r30, Y+4	; 0x04
    5738:	fd 81       	ldd	r31, Y+5	; 0x05
    573a:	86 89       	ldd	r24, Z+22	; 0x16
    573c:	80 93 79 04 	sts	0x0479, r24
    5740:	ec 81       	ldd	r30, Y+4	; 0x04
    5742:	fd 81       	ldd	r31, Y+5	; 0x05
    5744:	86 89       	ldd	r24, Z+22	; 0x16
    5746:	28 2f       	mov	r18, r24
    5748:	30 e0       	ldi	r19, 0x00	; 0
    574a:	c9 01       	movw	r24, r18
    574c:	88 0f       	add	r24, r24
    574e:	99 1f       	adc	r25, r25
    5750:	88 0f       	add	r24, r24
    5752:	99 1f       	adc	r25, r25
    5754:	88 0f       	add	r24, r24
    5756:	99 1f       	adc	r25, r25
    5758:	82 0f       	add	r24, r18
    575a:	93 1f       	adc	r25, r19
    575c:	ac 01       	movw	r20, r24
    575e:	4b 57       	subi	r20, 0x7B	; 123
    5760:	5b 4f       	sbci	r21, 0xFB	; 251
    5762:	8c 81       	ldd	r24, Y+4	; 0x04
    5764:	9d 81       	ldd	r25, Y+5	; 0x05
    5766:	9c 01       	movw	r18, r24
    5768:	2e 5f       	subi	r18, 0xFE	; 254
    576a:	3f 4f       	sbci	r19, 0xFF	; 255
    576c:	ca 01       	movw	r24, r20
    576e:	b9 01       	movw	r22, r18
    5770:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5774:	ec 81       	ldd	r30, Y+4	; 0x04
    5776:	fd 81       	ldd	r31, Y+5	; 0x05
    5778:	96 89       	ldd	r25, Z+22	; 0x16
    577a:	e0 91 73 04 	lds	r30, 0x0473
    577e:	f0 91 74 04 	lds	r31, 0x0474
    5782:	86 89       	ldd	r24, Z+22	; 0x16
    5784:	98 17       	cp	r25, r24
    5786:	18 f0       	brcs	.+6      	; 0x578e <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    5788:	81 e0       	ldi	r24, 0x01	; 1
    578a:	80 93 7d 04 	sts	0x047D, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    578e:	80 91 c8 04 	lds	r24, 0x04C8
    5792:	88 23       	and	r24, r24
    5794:	09 f0       	breq	.+2      	; 0x5798 <xTaskResumeAll+0xce>
    5796:	b6 cf       	rjmp	.-148    	; 0x5704 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    5798:	8c 81       	ldd	r24, Y+4	; 0x04
    579a:	9d 81       	ldd	r25, Y+5	; 0x05
    579c:	00 97       	sbiw	r24, 0x00	; 0
    579e:	11 f0       	breq	.+4      	; 0x57a4 <xTaskResumeAll+0xda>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    57a0:	0e 94 2f 30 	call	0x605e	; 0x605e <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    57a4:	80 91 7b 04 	lds	r24, 0x047B
    57a8:	90 91 7c 04 	lds	r25, 0x047C
    57ac:	9a 83       	std	Y+2, r25	; 0x02
    57ae:	89 83       	std	Y+1, r24	; 0x01

					if( xPendedCounts > ( TickType_t ) 0U )
    57b0:	89 81       	ldd	r24, Y+1	; 0x01
    57b2:	9a 81       	ldd	r25, Y+2	; 0x02
    57b4:	00 97       	sbiw	r24, 0x00	; 0
    57b6:	a1 f0       	breq	.+40     	; 0x57e0 <xTaskResumeAll+0x116>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    57b8:	0e 94 81 2c 	call	0x5902	; 0x5902 <xTaskIncrementTick>
    57bc:	88 23       	and	r24, r24
    57be:	19 f0       	breq	.+6      	; 0x57c6 <xTaskResumeAll+0xfc>
							{
								xYieldPending = pdTRUE;
    57c0:	81 e0       	ldi	r24, 0x01	; 1
    57c2:	80 93 7d 04 	sts	0x047D, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
    57c6:	89 81       	ldd	r24, Y+1	; 0x01
    57c8:	9a 81       	ldd	r25, Y+2	; 0x02
    57ca:	01 97       	sbiw	r24, 0x01	; 1
    57cc:	9a 83       	std	Y+2, r25	; 0x02
    57ce:	89 83       	std	Y+1, r24	; 0x01
						} while( xPendedCounts > ( TickType_t ) 0U );
    57d0:	89 81       	ldd	r24, Y+1	; 0x01
    57d2:	9a 81       	ldd	r25, Y+2	; 0x02
    57d4:	00 97       	sbiw	r24, 0x00	; 0
    57d6:	81 f7       	brne	.-32     	; 0x57b8 <xTaskResumeAll+0xee>

						xPendedTicks = 0;
    57d8:	10 92 7c 04 	sts	0x047C, r1
    57dc:	10 92 7b 04 	sts	0x047B, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    57e0:	80 91 7d 04 	lds	r24, 0x047D
    57e4:	88 23       	and	r24, r24
    57e6:	21 f0       	breq	.+8      	; 0x57f0 <xTaskResumeAll+0x126>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    57e8:	81 e0       	ldi	r24, 0x01	; 1
    57ea:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    57ec:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    57f0:	0f 90       	pop	r0
    57f2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    57f4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    57f6:	0f 90       	pop	r0
    57f8:	0f 90       	pop	r0
    57fa:	0f 90       	pop	r0
    57fc:	0f 90       	pop	r0
    57fe:	0f 90       	pop	r0
    5800:	cf 91       	pop	r28
    5802:	df 91       	pop	r29
    5804:	08 95       	ret

00005806 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    5806:	df 93       	push	r29
    5808:	cf 93       	push	r28
    580a:	00 d0       	rcall	.+0      	; 0x580c <xTaskGetTickCount+0x6>
    580c:	cd b7       	in	r28, 0x3d	; 61
    580e:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    5810:	0f b6       	in	r0, 0x3f	; 63
    5812:	f8 94       	cli
    5814:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    5816:	80 91 77 04 	lds	r24, 0x0477
    581a:	90 91 78 04 	lds	r25, 0x0478
    581e:	9a 83       	std	Y+2, r25	; 0x02
    5820:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    5822:	0f 90       	pop	r0
    5824:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    5826:	89 81       	ldd	r24, Y+1	; 0x01
    5828:	9a 81       	ldd	r25, Y+2	; 0x02
}
    582a:	0f 90       	pop	r0
    582c:	0f 90       	pop	r0
    582e:	cf 91       	pop	r28
    5830:	df 91       	pop	r29
    5832:	08 95       	ret

00005834 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    5834:	df 93       	push	r29
    5836:	cf 93       	push	r28
    5838:	00 d0       	rcall	.+0      	; 0x583a <xTaskGetTickCountFromISR+0x6>
    583a:	0f 92       	push	r0
    583c:	cd b7       	in	r28, 0x3d	; 61
    583e:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    5840:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    5842:	80 91 77 04 	lds	r24, 0x0477
    5846:	90 91 78 04 	lds	r25, 0x0478
    584a:	9b 83       	std	Y+3, r25	; 0x03
    584c:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    584e:	8a 81       	ldd	r24, Y+2	; 0x02
    5850:	9b 81       	ldd	r25, Y+3	; 0x03
}
    5852:	0f 90       	pop	r0
    5854:	0f 90       	pop	r0
    5856:	0f 90       	pop	r0
    5858:	cf 91       	pop	r28
    585a:	df 91       	pop	r29
    585c:	08 95       	ret

0000585e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    585e:	df 93       	push	r29
    5860:	cf 93       	push	r28
    5862:	cd b7       	in	r28, 0x3d	; 61
    5864:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    5866:	80 91 76 04 	lds	r24, 0x0476
}
    586a:	cf 91       	pop	r28
    586c:	df 91       	pop	r29
    586e:	08 95       	ret

00005870 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    5870:	df 93       	push	r29
    5872:	cf 93       	push	r28
    5874:	00 d0       	rcall	.+0      	; 0x5876 <pcTaskGetName+0x6>
    5876:	00 d0       	rcall	.+0      	; 0x5878 <pcTaskGetName+0x8>
    5878:	00 d0       	rcall	.+0      	; 0x587a <pcTaskGetName+0xa>
    587a:	cd b7       	in	r28, 0x3d	; 61
    587c:	de b7       	in	r29, 0x3e	; 62
    587e:	9c 83       	std	Y+4, r25	; 0x04
    5880:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    5882:	8b 81       	ldd	r24, Y+3	; 0x03
    5884:	9c 81       	ldd	r25, Y+4	; 0x04
    5886:	00 97       	sbiw	r24, 0x00	; 0
    5888:	39 f4       	brne	.+14     	; 0x5898 <pcTaskGetName+0x28>
    588a:	80 91 73 04 	lds	r24, 0x0473
    588e:	90 91 74 04 	lds	r25, 0x0474
    5892:	9e 83       	std	Y+6, r25	; 0x06
    5894:	8d 83       	std	Y+5, r24	; 0x05
    5896:	04 c0       	rjmp	.+8      	; 0x58a0 <pcTaskGetName+0x30>
    5898:	8b 81       	ldd	r24, Y+3	; 0x03
    589a:	9c 81       	ldd	r25, Y+4	; 0x04
    589c:	9e 83       	std	Y+6, r25	; 0x06
    589e:	8d 83       	std	Y+5, r24	; 0x05
    58a0:	8d 81       	ldd	r24, Y+5	; 0x05
    58a2:	9e 81       	ldd	r25, Y+6	; 0x06
    58a4:	9a 83       	std	Y+2, r25	; 0x02
    58a6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    58a8:	89 81       	ldd	r24, Y+1	; 0x01
    58aa:	9a 81       	ldd	r25, Y+2	; 0x02
    58ac:	49 96       	adiw	r24, 0x19	; 25
}
    58ae:	26 96       	adiw	r28, 0x06	; 6
    58b0:	0f b6       	in	r0, 0x3f	; 63
    58b2:	f8 94       	cli
    58b4:	de bf       	out	0x3e, r29	; 62
    58b6:	0f be       	out	0x3f, r0	; 63
    58b8:	cd bf       	out	0x3d, r28	; 61
    58ba:	cf 91       	pop	r28
    58bc:	df 91       	pop	r29
    58be:	08 95       	ret

000058c0 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    58c0:	df 93       	push	r29
    58c2:	cf 93       	push	r28
    58c4:	00 d0       	rcall	.+0      	; 0x58c6 <xTaskCatchUpTicks+0x6>
    58c6:	0f 92       	push	r0
    58c8:	cd b7       	in	r28, 0x3d	; 61
    58ca:	de b7       	in	r29, 0x3e	; 62
    58cc:	9b 83       	std	Y+3, r25	; 0x03
    58ce:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xYieldRequired = pdFALSE;
    58d0:	19 82       	std	Y+1, r1	; 0x01
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
    58d2:	0e 94 59 2b 	call	0x56b2	; 0x56b2 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
    58d6:	20 91 7b 04 	lds	r18, 0x047B
    58da:	30 91 7c 04 	lds	r19, 0x047C
    58de:	8a 81       	ldd	r24, Y+2	; 0x02
    58e0:	9b 81       	ldd	r25, Y+3	; 0x03
    58e2:	82 0f       	add	r24, r18
    58e4:	93 1f       	adc	r25, r19
    58e6:	90 93 7c 04 	sts	0x047C, r25
    58ea:	80 93 7b 04 	sts	0x047B, r24
	xYieldRequired = xTaskResumeAll();
    58ee:	0e 94 65 2b 	call	0x56ca	; 0x56ca <xTaskResumeAll>
    58f2:	89 83       	std	Y+1, r24	; 0x01

	return xYieldRequired;
    58f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    58f6:	0f 90       	pop	r0
    58f8:	0f 90       	pop	r0
    58fa:	0f 90       	pop	r0
    58fc:	cf 91       	pop	r28
    58fe:	df 91       	pop	r29
    5900:	08 95       	ret

00005902 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5902:	df 93       	push	r29
    5904:	cf 93       	push	r28
    5906:	cd b7       	in	r28, 0x3d	; 61
    5908:	de b7       	in	r29, 0x3e	; 62
    590a:	29 97       	sbiw	r28, 0x09	; 9
    590c:	0f b6       	in	r0, 0x3f	; 63
    590e:	f8 94       	cli
    5910:	de bf       	out	0x3e, r29	; 62
    5912:	0f be       	out	0x3f, r0	; 63
    5914:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    5916:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5918:	80 91 84 04 	lds	r24, 0x0484
    591c:	88 23       	and	r24, r24
    591e:	09 f0       	breq	.+2      	; 0x5922 <xTaskIncrementTick+0x20>
    5920:	c6 c0       	rjmp	.+396    	; 0x5aae <xTaskIncrementTick+0x1ac>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    5922:	80 91 77 04 	lds	r24, 0x0477
    5926:	90 91 78 04 	lds	r25, 0x0478
    592a:	01 96       	adiw	r24, 0x01	; 1
    592c:	9c 83       	std	Y+4, r25	; 0x04
    592e:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    5930:	8b 81       	ldd	r24, Y+3	; 0x03
    5932:	9c 81       	ldd	r25, Y+4	; 0x04
    5934:	90 93 78 04 	sts	0x0478, r25
    5938:	80 93 77 04 	sts	0x0477, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    593c:	8b 81       	ldd	r24, Y+3	; 0x03
    593e:	9c 81       	ldd	r25, Y+4	; 0x04
    5940:	00 97       	sbiw	r24, 0x00	; 0
    5942:	d9 f4       	brne	.+54     	; 0x597a <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    5944:	80 91 c4 04 	lds	r24, 0x04C4
    5948:	90 91 c5 04 	lds	r25, 0x04C5
    594c:	9a 83       	std	Y+2, r25	; 0x02
    594e:	89 83       	std	Y+1, r24	; 0x01
    5950:	80 91 c6 04 	lds	r24, 0x04C6
    5954:	90 91 c7 04 	lds	r25, 0x04C7
    5958:	90 93 c5 04 	sts	0x04C5, r25
    595c:	80 93 c4 04 	sts	0x04C4, r24
    5960:	89 81       	ldd	r24, Y+1	; 0x01
    5962:	9a 81       	ldd	r25, Y+2	; 0x02
    5964:	90 93 c7 04 	sts	0x04C7, r25
    5968:	80 93 c6 04 	sts	0x04C6, r24
    596c:	80 91 7e 04 	lds	r24, 0x047E
    5970:	8f 5f       	subi	r24, 0xFF	; 255
    5972:	80 93 7e 04 	sts	0x047E, r24
    5976:	0e 94 2f 30 	call	0x605e	; 0x605e <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    597a:	20 91 80 04 	lds	r18, 0x0480
    597e:	30 91 81 04 	lds	r19, 0x0481
    5982:	8b 81       	ldd	r24, Y+3	; 0x03
    5984:	9c 81       	ldd	r25, Y+4	; 0x04
    5986:	82 17       	cp	r24, r18
    5988:	93 07       	cpc	r25, r19
    598a:	08 f4       	brcc	.+2      	; 0x598e <xTaskIncrementTick+0x8c>
    598c:	71 c0       	rjmp	.+226    	; 0x5a70 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    598e:	e0 91 c4 04 	lds	r30, 0x04C4
    5992:	f0 91 c5 04 	lds	r31, 0x04C5
    5996:	80 81       	ld	r24, Z
    5998:	88 23       	and	r24, r24
    599a:	39 f4       	brne	.+14     	; 0x59aa <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    599c:	8f ef       	ldi	r24, 0xFF	; 255
    599e:	9f ef       	ldi	r25, 0xFF	; 255
    59a0:	90 93 81 04 	sts	0x0481, r25
    59a4:	80 93 80 04 	sts	0x0480, r24
    59a8:	63 c0       	rjmp	.+198    	; 0x5a70 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    59aa:	e0 91 c4 04 	lds	r30, 0x04C4
    59ae:	f0 91 c5 04 	lds	r31, 0x04C5
    59b2:	05 80       	ldd	r0, Z+5	; 0x05
    59b4:	f6 81       	ldd	r31, Z+6	; 0x06
    59b6:	e0 2d       	mov	r30, r0
    59b8:	86 81       	ldd	r24, Z+6	; 0x06
    59ba:	97 81       	ldd	r25, Z+7	; 0x07
    59bc:	99 87       	std	Y+9, r25	; 0x09
    59be:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    59c0:	e8 85       	ldd	r30, Y+8	; 0x08
    59c2:	f9 85       	ldd	r31, Y+9	; 0x09
    59c4:	82 81       	ldd	r24, Z+2	; 0x02
    59c6:	93 81       	ldd	r25, Z+3	; 0x03
    59c8:	9f 83       	std	Y+7, r25	; 0x07
    59ca:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    59cc:	2b 81       	ldd	r18, Y+3	; 0x03
    59ce:	3c 81       	ldd	r19, Y+4	; 0x04
    59d0:	8e 81       	ldd	r24, Y+6	; 0x06
    59d2:	9f 81       	ldd	r25, Y+7	; 0x07
    59d4:	28 17       	cp	r18, r24
    59d6:	39 07       	cpc	r19, r25
    59d8:	38 f4       	brcc	.+14     	; 0x59e8 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    59da:	8e 81       	ldd	r24, Y+6	; 0x06
    59dc:	9f 81       	ldd	r25, Y+7	; 0x07
    59de:	90 93 81 04 	sts	0x0481, r25
    59e2:	80 93 80 04 	sts	0x0480, r24
    59e6:	44 c0       	rjmp	.+136    	; 0x5a70 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    59e8:	88 85       	ldd	r24, Y+8	; 0x08
    59ea:	99 85       	ldd	r25, Y+9	; 0x09
    59ec:	02 96       	adiw	r24, 0x02	; 2
    59ee:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    59f2:	e8 85       	ldd	r30, Y+8	; 0x08
    59f4:	f9 85       	ldd	r31, Y+9	; 0x09
    59f6:	84 89       	ldd	r24, Z+20	; 0x14
    59f8:	95 89       	ldd	r25, Z+21	; 0x15
    59fa:	00 97       	sbiw	r24, 0x00	; 0
    59fc:	29 f0       	breq	.+10     	; 0x5a08 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    59fe:	88 85       	ldd	r24, Y+8	; 0x08
    5a00:	99 85       	ldd	r25, Y+9	; 0x09
    5a02:	0c 96       	adiw	r24, 0x0c	; 12
    5a04:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    5a08:	e8 85       	ldd	r30, Y+8	; 0x08
    5a0a:	f9 85       	ldd	r31, Y+9	; 0x09
    5a0c:	96 89       	ldd	r25, Z+22	; 0x16
    5a0e:	80 91 79 04 	lds	r24, 0x0479
    5a12:	89 17       	cp	r24, r25
    5a14:	28 f4       	brcc	.+10     	; 0x5a20 <xTaskIncrementTick+0x11e>
    5a16:	e8 85       	ldd	r30, Y+8	; 0x08
    5a18:	f9 85       	ldd	r31, Y+9	; 0x09
    5a1a:	86 89       	ldd	r24, Z+22	; 0x16
    5a1c:	80 93 79 04 	sts	0x0479, r24
    5a20:	e8 85       	ldd	r30, Y+8	; 0x08
    5a22:	f9 85       	ldd	r31, Y+9	; 0x09
    5a24:	86 89       	ldd	r24, Z+22	; 0x16
    5a26:	28 2f       	mov	r18, r24
    5a28:	30 e0       	ldi	r19, 0x00	; 0
    5a2a:	c9 01       	movw	r24, r18
    5a2c:	88 0f       	add	r24, r24
    5a2e:	99 1f       	adc	r25, r25
    5a30:	88 0f       	add	r24, r24
    5a32:	99 1f       	adc	r25, r25
    5a34:	88 0f       	add	r24, r24
    5a36:	99 1f       	adc	r25, r25
    5a38:	82 0f       	add	r24, r18
    5a3a:	93 1f       	adc	r25, r19
    5a3c:	ac 01       	movw	r20, r24
    5a3e:	4b 57       	subi	r20, 0x7B	; 123
    5a40:	5b 4f       	sbci	r21, 0xFB	; 251
    5a42:	88 85       	ldd	r24, Y+8	; 0x08
    5a44:	99 85       	ldd	r25, Y+9	; 0x09
    5a46:	9c 01       	movw	r18, r24
    5a48:	2e 5f       	subi	r18, 0xFE	; 254
    5a4a:	3f 4f       	sbci	r19, 0xFF	; 255
    5a4c:	ca 01       	movw	r24, r20
    5a4e:	b9 01       	movw	r22, r18
    5a50:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5a54:	e8 85       	ldd	r30, Y+8	; 0x08
    5a56:	f9 85       	ldd	r31, Y+9	; 0x09
    5a58:	96 89       	ldd	r25, Z+22	; 0x16
    5a5a:	e0 91 73 04 	lds	r30, 0x0473
    5a5e:	f0 91 74 04 	lds	r31, 0x0474
    5a62:	86 89       	ldd	r24, Z+22	; 0x16
    5a64:	98 17       	cp	r25, r24
    5a66:	08 f4       	brcc	.+2      	; 0x5a6a <xTaskIncrementTick+0x168>
    5a68:	92 cf       	rjmp	.-220    	; 0x598e <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    5a6a:	81 e0       	ldi	r24, 0x01	; 1
    5a6c:	8d 83       	std	Y+5, r24	; 0x05
    5a6e:	8f cf       	rjmp	.-226    	; 0x598e <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    5a70:	e0 91 73 04 	lds	r30, 0x0473
    5a74:	f0 91 74 04 	lds	r31, 0x0474
    5a78:	86 89       	ldd	r24, Z+22	; 0x16
    5a7a:	28 2f       	mov	r18, r24
    5a7c:	30 e0       	ldi	r19, 0x00	; 0
    5a7e:	c9 01       	movw	r24, r18
    5a80:	88 0f       	add	r24, r24
    5a82:	99 1f       	adc	r25, r25
    5a84:	88 0f       	add	r24, r24
    5a86:	99 1f       	adc	r25, r25
    5a88:	88 0f       	add	r24, r24
    5a8a:	99 1f       	adc	r25, r25
    5a8c:	82 0f       	add	r24, r18
    5a8e:	93 1f       	adc	r25, r19
    5a90:	fc 01       	movw	r30, r24
    5a92:	eb 57       	subi	r30, 0x7B	; 123
    5a94:	fb 4f       	sbci	r31, 0xFB	; 251
    5a96:	80 81       	ld	r24, Z
    5a98:	82 30       	cpi	r24, 0x02	; 2
    5a9a:	10 f0       	brcs	.+4      	; 0x5aa0 <xTaskIncrementTick+0x19e>
			{
				xSwitchRequired = pdTRUE;
    5a9c:	81 e0       	ldi	r24, 0x01	; 1
    5a9e:	8d 83       	std	Y+5, r24	; 0x05
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
    5aa0:	80 91 7d 04 	lds	r24, 0x047D
    5aa4:	88 23       	and	r24, r24
    5aa6:	61 f0       	breq	.+24     	; 0x5ac0 <xTaskIncrementTick+0x1be>
			{
				xSwitchRequired = pdTRUE;
    5aa8:	81 e0       	ldi	r24, 0x01	; 1
    5aaa:	8d 83       	std	Y+5, r24	; 0x05
    5aac:	09 c0       	rjmp	.+18     	; 0x5ac0 <xTaskIncrementTick+0x1be>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
    5aae:	80 91 7b 04 	lds	r24, 0x047B
    5ab2:	90 91 7c 04 	lds	r25, 0x047C
    5ab6:	01 96       	adiw	r24, 0x01	; 1
    5ab8:	90 93 7c 04 	sts	0x047C, r25
    5abc:	80 93 7b 04 	sts	0x047B, r24
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
    5ac0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5ac2:	29 96       	adiw	r28, 0x09	; 9
    5ac4:	0f b6       	in	r0, 0x3f	; 63
    5ac6:	f8 94       	cli
    5ac8:	de bf       	out	0x3e, r29	; 62
    5aca:	0f be       	out	0x3f, r0	; 63
    5acc:	cd bf       	out	0x3d, r28	; 61
    5ace:	cf 91       	pop	r28
    5ad0:	df 91       	pop	r29
    5ad2:	08 95       	ret

00005ad4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5ad4:	df 93       	push	r29
    5ad6:	cf 93       	push	r28
    5ad8:	00 d0       	rcall	.+0      	; 0x5ada <vTaskSwitchContext+0x6>
    5ada:	0f 92       	push	r0
    5adc:	cd b7       	in	r28, 0x3d	; 61
    5ade:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    5ae0:	80 91 84 04 	lds	r24, 0x0484
    5ae4:	88 23       	and	r24, r24
    5ae6:	21 f0       	breq	.+8      	; 0x5af0 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5ae8:	81 e0       	ldi	r24, 0x01	; 1
    5aea:	80 93 7d 04 	sts	0x047D, r24
    5aee:	59 c0       	rjmp	.+178    	; 0x5ba2 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    5af0:	10 92 7d 04 	sts	0x047D, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5af4:	80 91 79 04 	lds	r24, 0x0479
    5af8:	8b 83       	std	Y+3, r24	; 0x03
    5afa:	03 c0       	rjmp	.+6      	; 0x5b02 <vTaskSwitchContext+0x2e>
    5afc:	8b 81       	ldd	r24, Y+3	; 0x03
    5afe:	81 50       	subi	r24, 0x01	; 1
    5b00:	8b 83       	std	Y+3, r24	; 0x03
    5b02:	8b 81       	ldd	r24, Y+3	; 0x03
    5b04:	28 2f       	mov	r18, r24
    5b06:	30 e0       	ldi	r19, 0x00	; 0
    5b08:	c9 01       	movw	r24, r18
    5b0a:	88 0f       	add	r24, r24
    5b0c:	99 1f       	adc	r25, r25
    5b0e:	88 0f       	add	r24, r24
    5b10:	99 1f       	adc	r25, r25
    5b12:	88 0f       	add	r24, r24
    5b14:	99 1f       	adc	r25, r25
    5b16:	82 0f       	add	r24, r18
    5b18:	93 1f       	adc	r25, r19
    5b1a:	fc 01       	movw	r30, r24
    5b1c:	eb 57       	subi	r30, 0x7B	; 123
    5b1e:	fb 4f       	sbci	r31, 0xFB	; 251
    5b20:	80 81       	ld	r24, Z
    5b22:	88 23       	and	r24, r24
    5b24:	59 f3       	breq	.-42     	; 0x5afc <vTaskSwitchContext+0x28>
    5b26:	8b 81       	ldd	r24, Y+3	; 0x03
    5b28:	28 2f       	mov	r18, r24
    5b2a:	30 e0       	ldi	r19, 0x00	; 0
    5b2c:	c9 01       	movw	r24, r18
    5b2e:	88 0f       	add	r24, r24
    5b30:	99 1f       	adc	r25, r25
    5b32:	88 0f       	add	r24, r24
    5b34:	99 1f       	adc	r25, r25
    5b36:	88 0f       	add	r24, r24
    5b38:	99 1f       	adc	r25, r25
    5b3a:	82 0f       	add	r24, r18
    5b3c:	93 1f       	adc	r25, r19
    5b3e:	8b 57       	subi	r24, 0x7B	; 123
    5b40:	9b 4f       	sbci	r25, 0xFB	; 251
    5b42:	9a 83       	std	Y+2, r25	; 0x02
    5b44:	89 83       	std	Y+1, r24	; 0x01
    5b46:	e9 81       	ldd	r30, Y+1	; 0x01
    5b48:	fa 81       	ldd	r31, Y+2	; 0x02
    5b4a:	01 80       	ldd	r0, Z+1	; 0x01
    5b4c:	f2 81       	ldd	r31, Z+2	; 0x02
    5b4e:	e0 2d       	mov	r30, r0
    5b50:	82 81       	ldd	r24, Z+2	; 0x02
    5b52:	93 81       	ldd	r25, Z+3	; 0x03
    5b54:	e9 81       	ldd	r30, Y+1	; 0x01
    5b56:	fa 81       	ldd	r31, Y+2	; 0x02
    5b58:	92 83       	std	Z+2, r25	; 0x02
    5b5a:	81 83       	std	Z+1, r24	; 0x01
    5b5c:	e9 81       	ldd	r30, Y+1	; 0x01
    5b5e:	fa 81       	ldd	r31, Y+2	; 0x02
    5b60:	21 81       	ldd	r18, Z+1	; 0x01
    5b62:	32 81       	ldd	r19, Z+2	; 0x02
    5b64:	89 81       	ldd	r24, Y+1	; 0x01
    5b66:	9a 81       	ldd	r25, Y+2	; 0x02
    5b68:	03 96       	adiw	r24, 0x03	; 3
    5b6a:	28 17       	cp	r18, r24
    5b6c:	39 07       	cpc	r19, r25
    5b6e:	59 f4       	brne	.+22     	; 0x5b86 <vTaskSwitchContext+0xb2>
    5b70:	e9 81       	ldd	r30, Y+1	; 0x01
    5b72:	fa 81       	ldd	r31, Y+2	; 0x02
    5b74:	01 80       	ldd	r0, Z+1	; 0x01
    5b76:	f2 81       	ldd	r31, Z+2	; 0x02
    5b78:	e0 2d       	mov	r30, r0
    5b7a:	82 81       	ldd	r24, Z+2	; 0x02
    5b7c:	93 81       	ldd	r25, Z+3	; 0x03
    5b7e:	e9 81       	ldd	r30, Y+1	; 0x01
    5b80:	fa 81       	ldd	r31, Y+2	; 0x02
    5b82:	92 83       	std	Z+2, r25	; 0x02
    5b84:	81 83       	std	Z+1, r24	; 0x01
    5b86:	e9 81       	ldd	r30, Y+1	; 0x01
    5b88:	fa 81       	ldd	r31, Y+2	; 0x02
    5b8a:	01 80       	ldd	r0, Z+1	; 0x01
    5b8c:	f2 81       	ldd	r31, Z+2	; 0x02
    5b8e:	e0 2d       	mov	r30, r0
    5b90:	86 81       	ldd	r24, Z+6	; 0x06
    5b92:	97 81       	ldd	r25, Z+7	; 0x07
    5b94:	90 93 74 04 	sts	0x0474, r25
    5b98:	80 93 73 04 	sts	0x0473, r24
    5b9c:	8b 81       	ldd	r24, Y+3	; 0x03
    5b9e:	80 93 79 04 	sts	0x0479, r24
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    5ba2:	0f 90       	pop	r0
    5ba4:	0f 90       	pop	r0
    5ba6:	0f 90       	pop	r0
    5ba8:	cf 91       	pop	r28
    5baa:	df 91       	pop	r29
    5bac:	08 95       	ret

00005bae <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    5bae:	df 93       	push	r29
    5bb0:	cf 93       	push	r28
    5bb2:	00 d0       	rcall	.+0      	; 0x5bb4 <vTaskPlaceOnEventList+0x6>
    5bb4:	00 d0       	rcall	.+0      	; 0x5bb6 <vTaskPlaceOnEventList+0x8>
    5bb6:	cd b7       	in	r28, 0x3d	; 61
    5bb8:	de b7       	in	r29, 0x3e	; 62
    5bba:	9a 83       	std	Y+2, r25	; 0x02
    5bbc:	89 83       	std	Y+1, r24	; 0x01
    5bbe:	7c 83       	std	Y+4, r23	; 0x04
    5bc0:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5bc2:	80 91 73 04 	lds	r24, 0x0473
    5bc6:	90 91 74 04 	lds	r25, 0x0474
    5bca:	9c 01       	movw	r18, r24
    5bcc:	24 5f       	subi	r18, 0xF4	; 244
    5bce:	3f 4f       	sbci	r19, 0xFF	; 255
    5bd0:	89 81       	ldd	r24, Y+1	; 0x01
    5bd2:	9a 81       	ldd	r25, Y+2	; 0x02
    5bd4:	b9 01       	movw	r22, r18
    5bd6:	0e 94 63 19 	call	0x32c6	; 0x32c6 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5bda:	8b 81       	ldd	r24, Y+3	; 0x03
    5bdc:	9c 81       	ldd	r25, Y+4	; 0x04
    5bde:	61 e0       	ldi	r22, 0x01	; 1
    5be0:	0e 94 84 34 	call	0x6908	; 0x6908 <prvAddCurrentTaskToDelayedList>
}
    5be4:	0f 90       	pop	r0
    5be6:	0f 90       	pop	r0
    5be8:	0f 90       	pop	r0
    5bea:	0f 90       	pop	r0
    5bec:	cf 91       	pop	r28
    5bee:	df 91       	pop	r29
    5bf0:	08 95       	ret

00005bf2 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    5bf2:	df 93       	push	r29
    5bf4:	cf 93       	push	r28
    5bf6:	00 d0       	rcall	.+0      	; 0x5bf8 <vTaskPlaceOnUnorderedEventList+0x6>
    5bf8:	00 d0       	rcall	.+0      	; 0x5bfa <vTaskPlaceOnUnorderedEventList+0x8>
    5bfa:	00 d0       	rcall	.+0      	; 0x5bfc <vTaskPlaceOnUnorderedEventList+0xa>
    5bfc:	cd b7       	in	r28, 0x3d	; 61
    5bfe:	de b7       	in	r29, 0x3e	; 62
    5c00:	9a 83       	std	Y+2, r25	; 0x02
    5c02:	89 83       	std	Y+1, r24	; 0x01
    5c04:	7c 83       	std	Y+4, r23	; 0x04
    5c06:	6b 83       	std	Y+3, r22	; 0x03
    5c08:	5e 83       	std	Y+6, r21	; 0x06
    5c0a:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5c0c:	e0 91 73 04 	lds	r30, 0x0473
    5c10:	f0 91 74 04 	lds	r31, 0x0474
    5c14:	8b 81       	ldd	r24, Y+3	; 0x03
    5c16:	9c 81       	ldd	r25, Y+4	; 0x04
    5c18:	90 68       	ori	r25, 0x80	; 128
    5c1a:	95 87       	std	Z+13, r25	; 0x0d
    5c1c:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5c1e:	80 91 73 04 	lds	r24, 0x0473
    5c22:	90 91 74 04 	lds	r25, 0x0474
    5c26:	9c 01       	movw	r18, r24
    5c28:	24 5f       	subi	r18, 0xF4	; 244
    5c2a:	3f 4f       	sbci	r19, 0xFF	; 255
    5c2c:	89 81       	ldd	r24, Y+1	; 0x01
    5c2e:	9a 81       	ldd	r25, Y+2	; 0x02
    5c30:	b9 01       	movw	r22, r18
    5c32:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5c36:	8d 81       	ldd	r24, Y+5	; 0x05
    5c38:	9e 81       	ldd	r25, Y+6	; 0x06
    5c3a:	61 e0       	ldi	r22, 0x01	; 1
    5c3c:	0e 94 84 34 	call	0x6908	; 0x6908 <prvAddCurrentTaskToDelayedList>
}
    5c40:	26 96       	adiw	r28, 0x06	; 6
    5c42:	0f b6       	in	r0, 0x3f	; 63
    5c44:	f8 94       	cli
    5c46:	de bf       	out	0x3e, r29	; 62
    5c48:	0f be       	out	0x3f, r0	; 63
    5c4a:	cd bf       	out	0x3d, r28	; 61
    5c4c:	cf 91       	pop	r28
    5c4e:	df 91       	pop	r29
    5c50:	08 95       	ret

00005c52 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5c52:	df 93       	push	r29
    5c54:	cf 93       	push	r28
    5c56:	00 d0       	rcall	.+0      	; 0x5c58 <xTaskRemoveFromEventList+0x6>
    5c58:	00 d0       	rcall	.+0      	; 0x5c5a <xTaskRemoveFromEventList+0x8>
    5c5a:	0f 92       	push	r0
    5c5c:	cd b7       	in	r28, 0x3d	; 61
    5c5e:	de b7       	in	r29, 0x3e	; 62
    5c60:	9d 83       	std	Y+5, r25	; 0x05
    5c62:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5c64:	ec 81       	ldd	r30, Y+4	; 0x04
    5c66:	fd 81       	ldd	r31, Y+5	; 0x05
    5c68:	05 80       	ldd	r0, Z+5	; 0x05
    5c6a:	f6 81       	ldd	r31, Z+6	; 0x06
    5c6c:	e0 2d       	mov	r30, r0
    5c6e:	86 81       	ldd	r24, Z+6	; 0x06
    5c70:	97 81       	ldd	r25, Z+7	; 0x07
    5c72:	9b 83       	std	Y+3, r25	; 0x03
    5c74:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5c76:	8a 81       	ldd	r24, Y+2	; 0x02
    5c78:	9b 81       	ldd	r25, Y+3	; 0x03
    5c7a:	0c 96       	adiw	r24, 0x0c	; 12
    5c7c:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5c80:	80 91 84 04 	lds	r24, 0x0484
    5c84:	88 23       	and	r24, r24
    5c86:	61 f5       	brne	.+88     	; 0x5ce0 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5c88:	8a 81       	ldd	r24, Y+2	; 0x02
    5c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    5c8c:	02 96       	adiw	r24, 0x02	; 2
    5c8e:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5c92:	ea 81       	ldd	r30, Y+2	; 0x02
    5c94:	fb 81       	ldd	r31, Y+3	; 0x03
    5c96:	96 89       	ldd	r25, Z+22	; 0x16
    5c98:	80 91 79 04 	lds	r24, 0x0479
    5c9c:	89 17       	cp	r24, r25
    5c9e:	28 f4       	brcc	.+10     	; 0x5caa <xTaskRemoveFromEventList+0x58>
    5ca0:	ea 81       	ldd	r30, Y+2	; 0x02
    5ca2:	fb 81       	ldd	r31, Y+3	; 0x03
    5ca4:	86 89       	ldd	r24, Z+22	; 0x16
    5ca6:	80 93 79 04 	sts	0x0479, r24
    5caa:	ea 81       	ldd	r30, Y+2	; 0x02
    5cac:	fb 81       	ldd	r31, Y+3	; 0x03
    5cae:	86 89       	ldd	r24, Z+22	; 0x16
    5cb0:	28 2f       	mov	r18, r24
    5cb2:	30 e0       	ldi	r19, 0x00	; 0
    5cb4:	c9 01       	movw	r24, r18
    5cb6:	88 0f       	add	r24, r24
    5cb8:	99 1f       	adc	r25, r25
    5cba:	88 0f       	add	r24, r24
    5cbc:	99 1f       	adc	r25, r25
    5cbe:	88 0f       	add	r24, r24
    5cc0:	99 1f       	adc	r25, r25
    5cc2:	82 0f       	add	r24, r18
    5cc4:	93 1f       	adc	r25, r19
    5cc6:	ac 01       	movw	r20, r24
    5cc8:	4b 57       	subi	r20, 0x7B	; 123
    5cca:	5b 4f       	sbci	r21, 0xFB	; 251
    5ccc:	8a 81       	ldd	r24, Y+2	; 0x02
    5cce:	9b 81       	ldd	r25, Y+3	; 0x03
    5cd0:	9c 01       	movw	r18, r24
    5cd2:	2e 5f       	subi	r18, 0xFE	; 254
    5cd4:	3f 4f       	sbci	r19, 0xFF	; 255
    5cd6:	ca 01       	movw	r24, r20
    5cd8:	b9 01       	movw	r22, r18
    5cda:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
    5cde:	0a c0       	rjmp	.+20     	; 0x5cf4 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5ce0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ce2:	9b 81       	ldd	r25, Y+3	; 0x03
    5ce4:	9c 01       	movw	r18, r24
    5ce6:	24 5f       	subi	r18, 0xF4	; 244
    5ce8:	3f 4f       	sbci	r19, 0xFF	; 255
    5cea:	88 ec       	ldi	r24, 0xC8	; 200
    5cec:	94 e0       	ldi	r25, 0x04	; 4
    5cee:	b9 01       	movw	r22, r18
    5cf0:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5cf4:	ea 81       	ldd	r30, Y+2	; 0x02
    5cf6:	fb 81       	ldd	r31, Y+3	; 0x03
    5cf8:	96 89       	ldd	r25, Z+22	; 0x16
    5cfa:	e0 91 73 04 	lds	r30, 0x0473
    5cfe:	f0 91 74 04 	lds	r31, 0x0474
    5d02:	86 89       	ldd	r24, Z+22	; 0x16
    5d04:	89 17       	cp	r24, r25
    5d06:	30 f4       	brcc	.+12     	; 0x5d14 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5d08:	81 e0       	ldi	r24, 0x01	; 1
    5d0a:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5d0c:	81 e0       	ldi	r24, 0x01	; 1
    5d0e:	80 93 7d 04 	sts	0x047D, r24
    5d12:	01 c0       	rjmp	.+2      	; 0x5d16 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    5d14:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5d16:	89 81       	ldd	r24, Y+1	; 0x01
}
    5d18:	0f 90       	pop	r0
    5d1a:	0f 90       	pop	r0
    5d1c:	0f 90       	pop	r0
    5d1e:	0f 90       	pop	r0
    5d20:	0f 90       	pop	r0
    5d22:	cf 91       	pop	r28
    5d24:	df 91       	pop	r29
    5d26:	08 95       	ret

00005d28 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5d28:	df 93       	push	r29
    5d2a:	cf 93       	push	r28
    5d2c:	00 d0       	rcall	.+0      	; 0x5d2e <vTaskRemoveFromUnorderedEventList+0x6>
    5d2e:	00 d0       	rcall	.+0      	; 0x5d30 <vTaskRemoveFromUnorderedEventList+0x8>
    5d30:	00 d0       	rcall	.+0      	; 0x5d32 <vTaskRemoveFromUnorderedEventList+0xa>
    5d32:	cd b7       	in	r28, 0x3d	; 61
    5d34:	de b7       	in	r29, 0x3e	; 62
    5d36:	9c 83       	std	Y+4, r25	; 0x04
    5d38:	8b 83       	std	Y+3, r24	; 0x03
    5d3a:	7e 83       	std	Y+6, r23	; 0x06
    5d3c:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5d3e:	8d 81       	ldd	r24, Y+5	; 0x05
    5d40:	9e 81       	ldd	r25, Y+6	; 0x06
    5d42:	90 68       	ori	r25, 0x80	; 128
    5d44:	eb 81       	ldd	r30, Y+3	; 0x03
    5d46:	fc 81       	ldd	r31, Y+4	; 0x04
    5d48:	91 83       	std	Z+1, r25	; 0x01
    5d4a:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5d4c:	eb 81       	ldd	r30, Y+3	; 0x03
    5d4e:	fc 81       	ldd	r31, Y+4	; 0x04
    5d50:	86 81       	ldd	r24, Z+6	; 0x06
    5d52:	97 81       	ldd	r25, Z+7	; 0x07
    5d54:	9a 83       	std	Y+2, r25	; 0x02
    5d56:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5d58:	8b 81       	ldd	r24, Y+3	; 0x03
    5d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    5d5c:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5d60:	89 81       	ldd	r24, Y+1	; 0x01
    5d62:	9a 81       	ldd	r25, Y+2	; 0x02
    5d64:	02 96       	adiw	r24, 0x02	; 2
    5d66:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5d6a:	e9 81       	ldd	r30, Y+1	; 0x01
    5d6c:	fa 81       	ldd	r31, Y+2	; 0x02
    5d6e:	96 89       	ldd	r25, Z+22	; 0x16
    5d70:	80 91 79 04 	lds	r24, 0x0479
    5d74:	89 17       	cp	r24, r25
    5d76:	28 f4       	brcc	.+10     	; 0x5d82 <vTaskRemoveFromUnorderedEventList+0x5a>
    5d78:	e9 81       	ldd	r30, Y+1	; 0x01
    5d7a:	fa 81       	ldd	r31, Y+2	; 0x02
    5d7c:	86 89       	ldd	r24, Z+22	; 0x16
    5d7e:	80 93 79 04 	sts	0x0479, r24
    5d82:	e9 81       	ldd	r30, Y+1	; 0x01
    5d84:	fa 81       	ldd	r31, Y+2	; 0x02
    5d86:	86 89       	ldd	r24, Z+22	; 0x16
    5d88:	28 2f       	mov	r18, r24
    5d8a:	30 e0       	ldi	r19, 0x00	; 0
    5d8c:	c9 01       	movw	r24, r18
    5d8e:	88 0f       	add	r24, r24
    5d90:	99 1f       	adc	r25, r25
    5d92:	88 0f       	add	r24, r24
    5d94:	99 1f       	adc	r25, r25
    5d96:	88 0f       	add	r24, r24
    5d98:	99 1f       	adc	r25, r25
    5d9a:	82 0f       	add	r24, r18
    5d9c:	93 1f       	adc	r25, r19
    5d9e:	ac 01       	movw	r20, r24
    5da0:	4b 57       	subi	r20, 0x7B	; 123
    5da2:	5b 4f       	sbci	r21, 0xFB	; 251
    5da4:	89 81       	ldd	r24, Y+1	; 0x01
    5da6:	9a 81       	ldd	r25, Y+2	; 0x02
    5da8:	9c 01       	movw	r18, r24
    5daa:	2e 5f       	subi	r18, 0xFE	; 254
    5dac:	3f 4f       	sbci	r19, 0xFF	; 255
    5dae:	ca 01       	movw	r24, r20
    5db0:	b9 01       	movw	r22, r18
    5db2:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5db6:	e9 81       	ldd	r30, Y+1	; 0x01
    5db8:	fa 81       	ldd	r31, Y+2	; 0x02
    5dba:	96 89       	ldd	r25, Z+22	; 0x16
    5dbc:	e0 91 73 04 	lds	r30, 0x0473
    5dc0:	f0 91 74 04 	lds	r31, 0x0474
    5dc4:	86 89       	ldd	r24, Z+22	; 0x16
    5dc6:	89 17       	cp	r24, r25
    5dc8:	18 f4       	brcc	.+6      	; 0x5dd0 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    5dca:	81 e0       	ldi	r24, 0x01	; 1
    5dcc:	80 93 7d 04 	sts	0x047D, r24
	}
}
    5dd0:	26 96       	adiw	r28, 0x06	; 6
    5dd2:	0f b6       	in	r0, 0x3f	; 63
    5dd4:	f8 94       	cli
    5dd6:	de bf       	out	0x3e, r29	; 62
    5dd8:	0f be       	out	0x3f, r0	; 63
    5dda:	cd bf       	out	0x3d, r28	; 61
    5ddc:	cf 91       	pop	r28
    5dde:	df 91       	pop	r29
    5de0:	08 95       	ret

00005de2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5de2:	df 93       	push	r29
    5de4:	cf 93       	push	r28
    5de6:	00 d0       	rcall	.+0      	; 0x5de8 <vTaskSetTimeOutState+0x6>
    5de8:	cd b7       	in	r28, 0x3d	; 61
    5dea:	de b7       	in	r29, 0x3e	; 62
    5dec:	9a 83       	std	Y+2, r25	; 0x02
    5dee:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5df0:	0f b6       	in	r0, 0x3f	; 63
    5df2:	f8 94       	cli
    5df4:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    5df6:	80 91 7e 04 	lds	r24, 0x047E
    5dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    5dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    5dfe:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    5e00:	80 91 77 04 	lds	r24, 0x0477
    5e04:	90 91 78 04 	lds	r25, 0x0478
    5e08:	e9 81       	ldd	r30, Y+1	; 0x01
    5e0a:	fa 81       	ldd	r31, Y+2	; 0x02
    5e0c:	92 83       	std	Z+2, r25	; 0x02
    5e0e:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5e10:	0f 90       	pop	r0
    5e12:	0f be       	out	0x3f, r0	; 63
}
    5e14:	0f 90       	pop	r0
    5e16:	0f 90       	pop	r0
    5e18:	cf 91       	pop	r28
    5e1a:	df 91       	pop	r29
    5e1c:	08 95       	ret

00005e1e <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5e1e:	df 93       	push	r29
    5e20:	cf 93       	push	r28
    5e22:	00 d0       	rcall	.+0      	; 0x5e24 <vTaskInternalSetTimeOutState+0x6>
    5e24:	cd b7       	in	r28, 0x3d	; 61
    5e26:	de b7       	in	r29, 0x3e	; 62
    5e28:	9a 83       	std	Y+2, r25	; 0x02
    5e2a:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5e2c:	80 91 7e 04 	lds	r24, 0x047E
    5e30:	e9 81       	ldd	r30, Y+1	; 0x01
    5e32:	fa 81       	ldd	r31, Y+2	; 0x02
    5e34:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5e36:	80 91 77 04 	lds	r24, 0x0477
    5e3a:	90 91 78 04 	lds	r25, 0x0478
    5e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    5e40:	fa 81       	ldd	r31, Y+2	; 0x02
    5e42:	92 83       	std	Z+2, r25	; 0x02
    5e44:	81 83       	std	Z+1, r24	; 0x01
}
    5e46:	0f 90       	pop	r0
    5e48:	0f 90       	pop	r0
    5e4a:	cf 91       	pop	r28
    5e4c:	df 91       	pop	r29
    5e4e:	08 95       	ret

00005e50 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5e50:	df 93       	push	r29
    5e52:	cf 93       	push	r28
    5e54:	cd b7       	in	r28, 0x3d	; 61
    5e56:	de b7       	in	r29, 0x3e	; 62
    5e58:	29 97       	sbiw	r28, 0x09	; 9
    5e5a:	0f b6       	in	r0, 0x3f	; 63
    5e5c:	f8 94       	cli
    5e5e:	de bf       	out	0x3e, r29	; 62
    5e60:	0f be       	out	0x3f, r0	; 63
    5e62:	cd bf       	out	0x3d, r28	; 61
    5e64:	9f 83       	std	Y+7, r25	; 0x07
    5e66:	8e 83       	std	Y+6, r24	; 0x06
    5e68:	79 87       	std	Y+9, r23	; 0x09
    5e6a:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5e6c:	0f b6       	in	r0, 0x3f	; 63
    5e6e:	f8 94       	cli
    5e70:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5e72:	80 91 77 04 	lds	r24, 0x0477
    5e76:	90 91 78 04 	lds	r25, 0x0478
    5e7a:	9c 83       	std	Y+4, r25	; 0x04
    5e7c:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5e7e:	ee 81       	ldd	r30, Y+6	; 0x06
    5e80:	ff 81       	ldd	r31, Y+7	; 0x07
    5e82:	21 81       	ldd	r18, Z+1	; 0x01
    5e84:	32 81       	ldd	r19, Z+2	; 0x02
    5e86:	8b 81       	ldd	r24, Y+3	; 0x03
    5e88:	9c 81       	ldd	r25, Y+4	; 0x04
    5e8a:	82 1b       	sub	r24, r18
    5e8c:	93 0b       	sbc	r25, r19
    5e8e:	9a 83       	std	Y+2, r25	; 0x02
    5e90:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    5e92:	e8 85       	ldd	r30, Y+8	; 0x08
    5e94:	f9 85       	ldd	r31, Y+9	; 0x09
    5e96:	80 81       	ld	r24, Z
    5e98:	91 81       	ldd	r25, Z+1	; 0x01
    5e9a:	2f ef       	ldi	r18, 0xFF	; 255
    5e9c:	8f 3f       	cpi	r24, 0xFF	; 255
    5e9e:	92 07       	cpc	r25, r18
    5ea0:	11 f4       	brne	.+4      	; 0x5ea6 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5ea2:	1d 82       	std	Y+5, r1	; 0x05
    5ea4:	36 c0       	rjmp	.+108    	; 0x5f12 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5ea6:	ee 81       	ldd	r30, Y+6	; 0x06
    5ea8:	ff 81       	ldd	r31, Y+7	; 0x07
    5eaa:	90 81       	ld	r25, Z
    5eac:	80 91 7e 04 	lds	r24, 0x047E
    5eb0:	98 17       	cp	r25, r24
    5eb2:	61 f0       	breq	.+24     	; 0x5ecc <xTaskCheckForTimeOut+0x7c>
    5eb4:	ee 81       	ldd	r30, Y+6	; 0x06
    5eb6:	ff 81       	ldd	r31, Y+7	; 0x07
    5eb8:	21 81       	ldd	r18, Z+1	; 0x01
    5eba:	32 81       	ldd	r19, Z+2	; 0x02
    5ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    5ebe:	9c 81       	ldd	r25, Y+4	; 0x04
    5ec0:	82 17       	cp	r24, r18
    5ec2:	93 07       	cpc	r25, r19
    5ec4:	18 f0       	brcs	.+6      	; 0x5ecc <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    5ec6:	81 e0       	ldi	r24, 0x01	; 1
    5ec8:	8d 83       	std	Y+5, r24	; 0x05
    5eca:	23 c0       	rjmp	.+70     	; 0x5f12 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5ecc:	e8 85       	ldd	r30, Y+8	; 0x08
    5ece:	f9 85       	ldd	r31, Y+9	; 0x09
    5ed0:	20 81       	ld	r18, Z
    5ed2:	31 81       	ldd	r19, Z+1	; 0x01
    5ed4:	89 81       	ldd	r24, Y+1	; 0x01
    5ed6:	9a 81       	ldd	r25, Y+2	; 0x02
    5ed8:	82 17       	cp	r24, r18
    5eda:	93 07       	cpc	r25, r19
    5edc:	a0 f4       	brcc	.+40     	; 0x5f06 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    5ede:	e8 85       	ldd	r30, Y+8	; 0x08
    5ee0:	f9 85       	ldd	r31, Y+9	; 0x09
    5ee2:	20 81       	ld	r18, Z
    5ee4:	31 81       	ldd	r19, Z+1	; 0x01
    5ee6:	89 81       	ldd	r24, Y+1	; 0x01
    5ee8:	9a 81       	ldd	r25, Y+2	; 0x02
    5eea:	a9 01       	movw	r20, r18
    5eec:	48 1b       	sub	r20, r24
    5eee:	59 0b       	sbc	r21, r25
    5ef0:	ca 01       	movw	r24, r20
    5ef2:	e8 85       	ldd	r30, Y+8	; 0x08
    5ef4:	f9 85       	ldd	r31, Y+9	; 0x09
    5ef6:	91 83       	std	Z+1, r25	; 0x01
    5ef8:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    5efa:	8e 81       	ldd	r24, Y+6	; 0x06
    5efc:	9f 81       	ldd	r25, Y+7	; 0x07
    5efe:	0e 94 0f 2f 	call	0x5e1e	; 0x5e1e <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    5f02:	1d 82       	std	Y+5, r1	; 0x05
    5f04:	06 c0       	rjmp	.+12     	; 0x5f12 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    5f06:	e8 85       	ldd	r30, Y+8	; 0x08
    5f08:	f9 85       	ldd	r31, Y+9	; 0x09
    5f0a:	11 82       	std	Z+1, r1	; 0x01
    5f0c:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    5f0e:	81 e0       	ldi	r24, 0x01	; 1
    5f10:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    5f12:	0f 90       	pop	r0
    5f14:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5f16:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5f18:	29 96       	adiw	r28, 0x09	; 9
    5f1a:	0f b6       	in	r0, 0x3f	; 63
    5f1c:	f8 94       	cli
    5f1e:	de bf       	out	0x3e, r29	; 62
    5f20:	0f be       	out	0x3f, r0	; 63
    5f22:	cd bf       	out	0x3d, r28	; 61
    5f24:	cf 91       	pop	r28
    5f26:	df 91       	pop	r29
    5f28:	08 95       	ret

00005f2a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5f2a:	df 93       	push	r29
    5f2c:	cf 93       	push	r28
    5f2e:	cd b7       	in	r28, 0x3d	; 61
    5f30:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5f32:	81 e0       	ldi	r24, 0x01	; 1
    5f34:	80 93 7d 04 	sts	0x047D, r24
}
    5f38:	cf 91       	pop	r28
    5f3a:	df 91       	pop	r29
    5f3c:	08 95       	ret

00005f3e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5f3e:	df 93       	push	r29
    5f40:	cf 93       	push	r28
    5f42:	00 d0       	rcall	.+0      	; 0x5f44 <prvIdleTask+0x6>
    5f44:	cd b7       	in	r28, 0x3d	; 61
    5f46:	de b7       	in	r29, 0x3e	; 62
    5f48:	9a 83       	std	Y+2, r25	; 0x02
    5f4a:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    5f4c:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <prvCheckTasksWaitingTermination>
    5f50:	fd cf       	rjmp	.-6      	; 0x5f4c <prvIdleTask+0xe>

00005f52 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5f52:	df 93       	push	r29
    5f54:	cf 93       	push	r28
    5f56:	0f 92       	push	r0
    5f58:	cd b7       	in	r28, 0x3d	; 61
    5f5a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5f5c:	19 82       	std	Y+1, r1	; 0x01
    5f5e:	13 c0       	rjmp	.+38     	; 0x5f86 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5f60:	89 81       	ldd	r24, Y+1	; 0x01
    5f62:	28 2f       	mov	r18, r24
    5f64:	30 e0       	ldi	r19, 0x00	; 0
    5f66:	c9 01       	movw	r24, r18
    5f68:	88 0f       	add	r24, r24
    5f6a:	99 1f       	adc	r25, r25
    5f6c:	88 0f       	add	r24, r24
    5f6e:	99 1f       	adc	r25, r25
    5f70:	88 0f       	add	r24, r24
    5f72:	99 1f       	adc	r25, r25
    5f74:	82 0f       	add	r24, r18
    5f76:	93 1f       	adc	r25, r19
    5f78:	8b 57       	subi	r24, 0x7B	; 123
    5f7a:	9b 4f       	sbci	r25, 0xFB	; 251
    5f7c:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5f80:	89 81       	ldd	r24, Y+1	; 0x01
    5f82:	8f 5f       	subi	r24, 0xFF	; 255
    5f84:	89 83       	std	Y+1, r24	; 0x01
    5f86:	89 81       	ldd	r24, Y+1	; 0x01
    5f88:	85 30       	cpi	r24, 0x05	; 5
    5f8a:	50 f3       	brcs	.-44     	; 0x5f60 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5f8c:	82 eb       	ldi	r24, 0xB2	; 178
    5f8e:	94 e0       	ldi	r25, 0x04	; 4
    5f90:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5f94:	8b eb       	ldi	r24, 0xBB	; 187
    5f96:	94 e0       	ldi	r25, 0x04	; 4
    5f98:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5f9c:	88 ec       	ldi	r24, 0xC8	; 200
    5f9e:	94 e0       	ldi	r25, 0x04	; 4
    5fa0:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5fa4:	81 ed       	ldi	r24, 0xD1	; 209
    5fa6:	94 e0       	ldi	r25, 0x04	; 4
    5fa8:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    5fac:	8a ed       	ldi	r24, 0xDA	; 218
    5fae:	94 e0       	ldi	r25, 0x04	; 4
    5fb0:	0e 94 e5 18 	call	0x31ca	; 0x31ca <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5fb4:	82 eb       	ldi	r24, 0xB2	; 178
    5fb6:	94 e0       	ldi	r25, 0x04	; 4
    5fb8:	90 93 c5 04 	sts	0x04C5, r25
    5fbc:	80 93 c4 04 	sts	0x04C4, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5fc0:	8b eb       	ldi	r24, 0xBB	; 187
    5fc2:	94 e0       	ldi	r25, 0x04	; 4
    5fc4:	90 93 c7 04 	sts	0x04C7, r25
    5fc8:	80 93 c6 04 	sts	0x04C6, r24
}
    5fcc:	0f 90       	pop	r0
    5fce:	cf 91       	pop	r28
    5fd0:	df 91       	pop	r29
    5fd2:	08 95       	ret

00005fd4 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5fd4:	df 93       	push	r29
    5fd6:	cf 93       	push	r28
    5fd8:	00 d0       	rcall	.+0      	; 0x5fda <prvCheckTasksWaitingTermination+0x6>
    5fda:	cd b7       	in	r28, 0x3d	; 61
    5fdc:	de b7       	in	r29, 0x3e	; 62
    5fde:	20 c0       	rjmp	.+64     	; 0x6020 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    5fe0:	0f b6       	in	r0, 0x3f	; 63
    5fe2:	f8 94       	cli
    5fe4:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5fe6:	e0 91 d6 04 	lds	r30, 0x04D6
    5fea:	f0 91 d7 04 	lds	r31, 0x04D7
    5fee:	86 81       	ldd	r24, Z+6	; 0x06
    5ff0:	97 81       	ldd	r25, Z+7	; 0x07
    5ff2:	9a 83       	std	Y+2, r25	; 0x02
    5ff4:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5ff6:	89 81       	ldd	r24, Y+1	; 0x01
    5ff8:	9a 81       	ldd	r25, Y+2	; 0x02
    5ffa:	02 96       	adiw	r24, 0x02	; 2
    5ffc:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
				--uxCurrentNumberOfTasks;
    6000:	80 91 76 04 	lds	r24, 0x0476
    6004:	81 50       	subi	r24, 0x01	; 1
    6006:	80 93 76 04 	sts	0x0476, r24
				--uxDeletedTasksWaitingCleanUp;
    600a:	80 91 75 04 	lds	r24, 0x0475
    600e:	81 50       	subi	r24, 0x01	; 1
    6010:	80 93 75 04 	sts	0x0475, r24
			}
			taskEXIT_CRITICAL();
    6014:	0f 90       	pop	r0
    6016:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    6018:	89 81       	ldd	r24, Y+1	; 0x01
    601a:	9a 81       	ldd	r25, Y+2	; 0x02
    601c:	0e 94 19 30 	call	0x6032	; 0x6032 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    6020:	80 91 75 04 	lds	r24, 0x0475
    6024:	88 23       	and	r24, r24
    6026:	e1 f6       	brne	.-72     	; 0x5fe0 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    6028:	0f 90       	pop	r0
    602a:	0f 90       	pop	r0
    602c:	cf 91       	pop	r28
    602e:	df 91       	pop	r29
    6030:	08 95       	ret

00006032 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    6032:	df 93       	push	r29
    6034:	cf 93       	push	r28
    6036:	00 d0       	rcall	.+0      	; 0x6038 <prvDeleteTCB+0x6>
    6038:	cd b7       	in	r28, 0x3d	; 61
    603a:	de b7       	in	r29, 0x3e	; 62
    603c:	9a 83       	std	Y+2, r25	; 0x02
    603e:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    6040:	e9 81       	ldd	r30, Y+1	; 0x01
    6042:	fa 81       	ldd	r31, Y+2	; 0x02
    6044:	87 89       	ldd	r24, Z+23	; 0x17
    6046:	90 8d       	ldd	r25, Z+24	; 0x18
    6048:	0e 94 bf 18 	call	0x317e	; 0x317e <vPortFree>
			vPortFree( pxTCB );
    604c:	89 81       	ldd	r24, Y+1	; 0x01
    604e:	9a 81       	ldd	r25, Y+2	; 0x02
    6050:	0e 94 bf 18 	call	0x317e	; 0x317e <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    6054:	0f 90       	pop	r0
    6056:	0f 90       	pop	r0
    6058:	cf 91       	pop	r28
    605a:	df 91       	pop	r29
    605c:	08 95       	ret

0000605e <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    605e:	df 93       	push	r29
    6060:	cf 93       	push	r28
    6062:	00 d0       	rcall	.+0      	; 0x6064 <prvResetNextTaskUnblockTime+0x6>
    6064:	cd b7       	in	r28, 0x3d	; 61
    6066:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6068:	e0 91 c4 04 	lds	r30, 0x04C4
    606c:	f0 91 c5 04 	lds	r31, 0x04C5
    6070:	80 81       	ld	r24, Z
    6072:	88 23       	and	r24, r24
    6074:	39 f4       	brne	.+14     	; 0x6084 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    6076:	8f ef       	ldi	r24, 0xFF	; 255
    6078:	9f ef       	ldi	r25, 0xFF	; 255
    607a:	90 93 81 04 	sts	0x0481, r25
    607e:	80 93 80 04 	sts	0x0480, r24
    6082:	13 c0       	rjmp	.+38     	; 0x60aa <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6084:	e0 91 c4 04 	lds	r30, 0x04C4
    6088:	f0 91 c5 04 	lds	r31, 0x04C5
    608c:	05 80       	ldd	r0, Z+5	; 0x05
    608e:	f6 81       	ldd	r31, Z+6	; 0x06
    6090:	e0 2d       	mov	r30, r0
    6092:	86 81       	ldd	r24, Z+6	; 0x06
    6094:	97 81       	ldd	r25, Z+7	; 0x07
    6096:	9a 83       	std	Y+2, r25	; 0x02
    6098:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    609a:	e9 81       	ldd	r30, Y+1	; 0x01
    609c:	fa 81       	ldd	r31, Y+2	; 0x02
    609e:	82 81       	ldd	r24, Z+2	; 0x02
    60a0:	93 81       	ldd	r25, Z+3	; 0x03
    60a2:	90 93 81 04 	sts	0x0481, r25
    60a6:	80 93 80 04 	sts	0x0480, r24
	}
}
    60aa:	0f 90       	pop	r0
    60ac:	0f 90       	pop	r0
    60ae:	cf 91       	pop	r28
    60b0:	df 91       	pop	r29
    60b2:	08 95       	ret

000060b4 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    60b4:	df 93       	push	r29
    60b6:	cf 93       	push	r28
    60b8:	00 d0       	rcall	.+0      	; 0x60ba <uxTaskResetEventItemValue+0x6>
    60ba:	cd b7       	in	r28, 0x3d	; 61
    60bc:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    60be:	e0 91 73 04 	lds	r30, 0x0473
    60c2:	f0 91 74 04 	lds	r31, 0x0474
    60c6:	84 85       	ldd	r24, Z+12	; 0x0c
    60c8:	95 85       	ldd	r25, Z+13	; 0x0d
    60ca:	9a 83       	std	Y+2, r25	; 0x02
    60cc:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    60ce:	a0 91 73 04 	lds	r26, 0x0473
    60d2:	b0 91 74 04 	lds	r27, 0x0474
    60d6:	e0 91 73 04 	lds	r30, 0x0473
    60da:	f0 91 74 04 	lds	r31, 0x0474
    60de:	86 89       	ldd	r24, Z+22	; 0x16
    60e0:	28 2f       	mov	r18, r24
    60e2:	30 e0       	ldi	r19, 0x00	; 0
    60e4:	85 e0       	ldi	r24, 0x05	; 5
    60e6:	90 e0       	ldi	r25, 0x00	; 0
    60e8:	82 1b       	sub	r24, r18
    60ea:	93 0b       	sbc	r25, r19
    60ec:	1d 96       	adiw	r26, 0x0d	; 13
    60ee:	9c 93       	st	X, r25
    60f0:	8e 93       	st	-X, r24
    60f2:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    60f4:	89 81       	ldd	r24, Y+1	; 0x01
    60f6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    60f8:	0f 90       	pop	r0
    60fa:	0f 90       	pop	r0
    60fc:	cf 91       	pop	r28
    60fe:	df 91       	pop	r29
    6100:	08 95       	ret

00006102 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    6102:	df 93       	push	r29
    6104:	cf 93       	push	r28
    6106:	cd b7       	in	r28, 0x3d	; 61
    6108:	de b7       	in	r29, 0x3e	; 62
    610a:	27 97       	sbiw	r28, 0x07	; 7
    610c:	0f b6       	in	r0, 0x3f	; 63
    610e:	f8 94       	cli
    6110:	de bf       	out	0x3e, r29	; 62
    6112:	0f be       	out	0x3f, r0	; 63
    6114:	cd bf       	out	0x3d, r28	; 61
    6116:	8d 83       	std	Y+5, r24	; 0x05
    6118:	7f 83       	std	Y+7, r23	; 0x07
    611a:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    611c:	0f b6       	in	r0, 0x3f	; 63
    611e:	f8 94       	cli
    6120:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    6122:	e0 91 73 04 	lds	r30, 0x0473
    6126:	f0 91 74 04 	lds	r31, 0x0474
    612a:	81 a1       	ldd	r24, Z+33	; 0x21
    612c:	92 a1       	ldd	r25, Z+34	; 0x22
    612e:	a3 a1       	ldd	r26, Z+35	; 0x23
    6130:	b4 a1       	ldd	r27, Z+36	; 0x24
    6132:	00 97       	sbiw	r24, 0x00	; 0
    6134:	a1 05       	cpc	r26, r1
    6136:	b1 05       	cpc	r27, r1
    6138:	89 f4       	brne	.+34     	; 0x615c <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    613a:	e0 91 73 04 	lds	r30, 0x0473
    613e:	f0 91 74 04 	lds	r31, 0x0474
    6142:	81 e0       	ldi	r24, 0x01	; 1
    6144:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    6146:	8e 81       	ldd	r24, Y+6	; 0x06
    6148:	9f 81       	ldd	r25, Y+7	; 0x07
    614a:	00 97       	sbiw	r24, 0x00	; 0
    614c:	39 f0       	breq	.+14     	; 0x615c <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    614e:	8e 81       	ldd	r24, Y+6	; 0x06
    6150:	9f 81       	ldd	r25, Y+7	; 0x07
    6152:	61 e0       	ldi	r22, 0x01	; 1
    6154:	0e 94 84 34 	call	0x6908	; 0x6908 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    6158:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    615c:	0f 90       	pop	r0
    615e:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    6160:	0f b6       	in	r0, 0x3f	; 63
    6162:	f8 94       	cli
    6164:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    6166:	e0 91 73 04 	lds	r30, 0x0473
    616a:	f0 91 74 04 	lds	r31, 0x0474
    616e:	81 a1       	ldd	r24, Z+33	; 0x21
    6170:	92 a1       	ldd	r25, Z+34	; 0x22
    6172:	a3 a1       	ldd	r26, Z+35	; 0x23
    6174:	b4 a1       	ldd	r27, Z+36	; 0x24
    6176:	89 83       	std	Y+1, r24	; 0x01
    6178:	9a 83       	std	Y+2, r25	; 0x02
    617a:	ab 83       	std	Y+3, r26	; 0x03
    617c:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    617e:	89 81       	ldd	r24, Y+1	; 0x01
    6180:	9a 81       	ldd	r25, Y+2	; 0x02
    6182:	ab 81       	ldd	r26, Y+3	; 0x03
    6184:	bc 81       	ldd	r27, Y+4	; 0x04
    6186:	00 97       	sbiw	r24, 0x00	; 0
    6188:	a1 05       	cpc	r26, r1
    618a:	b1 05       	cpc	r27, r1
    618c:	d9 f0       	breq	.+54     	; 0x61c4 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    618e:	8d 81       	ldd	r24, Y+5	; 0x05
    6190:	88 23       	and	r24, r24
    6192:	49 f0       	breq	.+18     	; 0x61a6 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    6194:	e0 91 73 04 	lds	r30, 0x0473
    6198:	f0 91 74 04 	lds	r31, 0x0474
    619c:	11 a2       	std	Z+33, r1	; 0x21
    619e:	12 a2       	std	Z+34, r1	; 0x22
    61a0:	13 a2       	std	Z+35, r1	; 0x23
    61a2:	14 a2       	std	Z+36, r1	; 0x24
    61a4:	0f c0       	rjmp	.+30     	; 0x61c4 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    61a6:	e0 91 73 04 	lds	r30, 0x0473
    61aa:	f0 91 74 04 	lds	r31, 0x0474
    61ae:	89 81       	ldd	r24, Y+1	; 0x01
    61b0:	9a 81       	ldd	r25, Y+2	; 0x02
    61b2:	ab 81       	ldd	r26, Y+3	; 0x03
    61b4:	bc 81       	ldd	r27, Y+4	; 0x04
    61b6:	01 97       	sbiw	r24, 0x01	; 1
    61b8:	a1 09       	sbc	r26, r1
    61ba:	b1 09       	sbc	r27, r1
    61bc:	81 a3       	std	Z+33, r24	; 0x21
    61be:	92 a3       	std	Z+34, r25	; 0x22
    61c0:	a3 a3       	std	Z+35, r26	; 0x23
    61c2:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    61c4:	e0 91 73 04 	lds	r30, 0x0473
    61c8:	f0 91 74 04 	lds	r31, 0x0474
    61cc:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    61ce:	0f 90       	pop	r0
    61d0:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    61d2:	89 81       	ldd	r24, Y+1	; 0x01
    61d4:	9a 81       	ldd	r25, Y+2	; 0x02
    61d6:	ab 81       	ldd	r26, Y+3	; 0x03
    61d8:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    61da:	bc 01       	movw	r22, r24
    61dc:	cd 01       	movw	r24, r26
    61de:	27 96       	adiw	r28, 0x07	; 7
    61e0:	0f b6       	in	r0, 0x3f	; 63
    61e2:	f8 94       	cli
    61e4:	de bf       	out	0x3e, r29	; 62
    61e6:	0f be       	out	0x3f, r0	; 63
    61e8:	cd bf       	out	0x3d, r28	; 61
    61ea:	cf 91       	pop	r28
    61ec:	df 91       	pop	r29
    61ee:	08 95       	ret

000061f0 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    61f0:	ef 92       	push	r14
    61f2:	ff 92       	push	r15
    61f4:	0f 93       	push	r16
    61f6:	1f 93       	push	r17
    61f8:	df 93       	push	r29
    61fa:	cf 93       	push	r28
    61fc:	cd b7       	in	r28, 0x3d	; 61
    61fe:	de b7       	in	r29, 0x3e	; 62
    6200:	2d 97       	sbiw	r28, 0x0d	; 13
    6202:	0f b6       	in	r0, 0x3f	; 63
    6204:	f8 94       	cli
    6206:	de bf       	out	0x3e, r29	; 62
    6208:	0f be       	out	0x3f, r0	; 63
    620a:	cd bf       	out	0x3d, r28	; 61
    620c:	6a 83       	std	Y+2, r22	; 0x02
    620e:	7b 83       	std	Y+3, r23	; 0x03
    6210:	8c 83       	std	Y+4, r24	; 0x04
    6212:	9d 83       	std	Y+5, r25	; 0x05
    6214:	2e 83       	std	Y+6, r18	; 0x06
    6216:	3f 83       	std	Y+7, r19	; 0x07
    6218:	48 87       	std	Y+8, r20	; 0x08
    621a:	59 87       	std	Y+9, r21	; 0x09
    621c:	1b 87       	std	Y+11, r17	; 0x0b
    621e:	0a 87       	std	Y+10, r16	; 0x0a
    6220:	fd 86       	std	Y+13, r15	; 0x0d
    6222:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    6224:	0f b6       	in	r0, 0x3f	; 63
    6226:	f8 94       	cli
    6228:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    622a:	e0 91 73 04 	lds	r30, 0x0473
    622e:	f0 91 74 04 	lds	r31, 0x0474
    6232:	85 a1       	ldd	r24, Z+37	; 0x25
    6234:	82 30       	cpi	r24, 0x02	; 2
    6236:	49 f1       	breq	.+82     	; 0x628a <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    6238:	e0 91 73 04 	lds	r30, 0x0473
    623c:	f0 91 74 04 	lds	r31, 0x0474
    6240:	21 a1       	ldd	r18, Z+33	; 0x21
    6242:	32 a1       	ldd	r19, Z+34	; 0x22
    6244:	43 a1       	ldd	r20, Z+35	; 0x23
    6246:	54 a1       	ldd	r21, Z+36	; 0x24
    6248:	8a 81       	ldd	r24, Y+2	; 0x02
    624a:	9b 81       	ldd	r25, Y+3	; 0x03
    624c:	ac 81       	ldd	r26, Y+4	; 0x04
    624e:	bd 81       	ldd	r27, Y+5	; 0x05
    6250:	80 95       	com	r24
    6252:	90 95       	com	r25
    6254:	a0 95       	com	r26
    6256:	b0 95       	com	r27
    6258:	82 23       	and	r24, r18
    625a:	93 23       	and	r25, r19
    625c:	a4 23       	and	r26, r20
    625e:	b5 23       	and	r27, r21
    6260:	81 a3       	std	Z+33, r24	; 0x21
    6262:	92 a3       	std	Z+34, r25	; 0x22
    6264:	a3 a3       	std	Z+35, r26	; 0x23
    6266:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    6268:	e0 91 73 04 	lds	r30, 0x0473
    626c:	f0 91 74 04 	lds	r31, 0x0474
    6270:	81 e0       	ldi	r24, 0x01	; 1
    6272:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    6274:	8c 85       	ldd	r24, Y+12	; 0x0c
    6276:	9d 85       	ldd	r25, Y+13	; 0x0d
    6278:	00 97       	sbiw	r24, 0x00	; 0
    627a:	39 f0       	breq	.+14     	; 0x628a <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    627c:	8c 85       	ldd	r24, Y+12	; 0x0c
    627e:	9d 85       	ldd	r25, Y+13	; 0x0d
    6280:	61 e0       	ldi	r22, 0x01	; 1
    6282:	0e 94 84 34 	call	0x6908	; 0x6908 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    6286:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    628a:	0f 90       	pop	r0
    628c:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    628e:	0f b6       	in	r0, 0x3f	; 63
    6290:	f8 94       	cli
    6292:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    6294:	8a 85       	ldd	r24, Y+10	; 0x0a
    6296:	9b 85       	ldd	r25, Y+11	; 0x0b
    6298:	00 97       	sbiw	r24, 0x00	; 0
    629a:	71 f0       	breq	.+28     	; 0x62b8 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    629c:	e0 91 73 04 	lds	r30, 0x0473
    62a0:	f0 91 74 04 	lds	r31, 0x0474
    62a4:	81 a1       	ldd	r24, Z+33	; 0x21
    62a6:	92 a1       	ldd	r25, Z+34	; 0x22
    62a8:	a3 a1       	ldd	r26, Z+35	; 0x23
    62aa:	b4 a1       	ldd	r27, Z+36	; 0x24
    62ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    62ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    62b0:	80 83       	st	Z, r24
    62b2:	91 83       	std	Z+1, r25	; 0x01
    62b4:	a2 83       	std	Z+2, r26	; 0x02
    62b6:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    62b8:	e0 91 73 04 	lds	r30, 0x0473
    62bc:	f0 91 74 04 	lds	r31, 0x0474
    62c0:	85 a1       	ldd	r24, Z+37	; 0x25
    62c2:	82 30       	cpi	r24, 0x02	; 2
    62c4:	11 f0       	breq	.+4      	; 0x62ca <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    62c6:	19 82       	std	Y+1, r1	; 0x01
    62c8:	1a c0       	rjmp	.+52     	; 0x62fe <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    62ca:	e0 91 73 04 	lds	r30, 0x0473
    62ce:	f0 91 74 04 	lds	r31, 0x0474
    62d2:	21 a1       	ldd	r18, Z+33	; 0x21
    62d4:	32 a1       	ldd	r19, Z+34	; 0x22
    62d6:	43 a1       	ldd	r20, Z+35	; 0x23
    62d8:	54 a1       	ldd	r21, Z+36	; 0x24
    62da:	8e 81       	ldd	r24, Y+6	; 0x06
    62dc:	9f 81       	ldd	r25, Y+7	; 0x07
    62de:	a8 85       	ldd	r26, Y+8	; 0x08
    62e0:	b9 85       	ldd	r27, Y+9	; 0x09
    62e2:	80 95       	com	r24
    62e4:	90 95       	com	r25
    62e6:	a0 95       	com	r26
    62e8:	b0 95       	com	r27
    62ea:	82 23       	and	r24, r18
    62ec:	93 23       	and	r25, r19
    62ee:	a4 23       	and	r26, r20
    62f0:	b5 23       	and	r27, r21
    62f2:	81 a3       	std	Z+33, r24	; 0x21
    62f4:	92 a3       	std	Z+34, r25	; 0x22
    62f6:	a3 a3       	std	Z+35, r26	; 0x23
    62f8:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    62fa:	81 e0       	ldi	r24, 0x01	; 1
    62fc:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    62fe:	e0 91 73 04 	lds	r30, 0x0473
    6302:	f0 91 74 04 	lds	r31, 0x0474
    6306:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    6308:	0f 90       	pop	r0
    630a:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    630c:	89 81       	ldd	r24, Y+1	; 0x01
	}
    630e:	2d 96       	adiw	r28, 0x0d	; 13
    6310:	0f b6       	in	r0, 0x3f	; 63
    6312:	f8 94       	cli
    6314:	de bf       	out	0x3e, r29	; 62
    6316:	0f be       	out	0x3f, r0	; 63
    6318:	cd bf       	out	0x3d, r28	; 61
    631a:	cf 91       	pop	r28
    631c:	df 91       	pop	r29
    631e:	1f 91       	pop	r17
    6320:	0f 91       	pop	r16
    6322:	ff 90       	pop	r15
    6324:	ef 90       	pop	r14
    6326:	08 95       	ret

00006328 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    6328:	0f 93       	push	r16
    632a:	1f 93       	push	r17
    632c:	df 93       	push	r29
    632e:	cf 93       	push	r28
    6330:	cd b7       	in	r28, 0x3d	; 61
    6332:	de b7       	in	r29, 0x3e	; 62
    6334:	2f 97       	sbiw	r28, 0x0f	; 15
    6336:	0f b6       	in	r0, 0x3f	; 63
    6338:	f8 94       	cli
    633a:	de bf       	out	0x3e, r29	; 62
    633c:	0f be       	out	0x3f, r0	; 63
    633e:	cd bf       	out	0x3d, r28	; 61
    6340:	9e 83       	std	Y+6, r25	; 0x06
    6342:	8d 83       	std	Y+5, r24	; 0x05
    6344:	4f 83       	std	Y+7, r20	; 0x07
    6346:	58 87       	std	Y+8, r21	; 0x08
    6348:	69 87       	std	Y+9, r22	; 0x09
    634a:	7a 87       	std	Y+10, r23	; 0x0a
    634c:	2b 87       	std	Y+11, r18	; 0x0b
    634e:	1d 87       	std	Y+13, r17	; 0x0d
    6350:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    6352:	81 e0       	ldi	r24, 0x01	; 1
    6354:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    6356:	8d 81       	ldd	r24, Y+5	; 0x05
    6358:	9e 81       	ldd	r25, Y+6	; 0x06
    635a:	9c 83       	std	Y+4, r25	; 0x04
    635c:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    635e:	0f b6       	in	r0, 0x3f	; 63
    6360:	f8 94       	cli
    6362:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    6364:	8c 85       	ldd	r24, Y+12	; 0x0c
    6366:	9d 85       	ldd	r25, Y+13	; 0x0d
    6368:	00 97       	sbiw	r24, 0x00	; 0
    636a:	61 f0       	breq	.+24     	; 0x6384 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    636c:	eb 81       	ldd	r30, Y+3	; 0x03
    636e:	fc 81       	ldd	r31, Y+4	; 0x04
    6370:	81 a1       	ldd	r24, Z+33	; 0x21
    6372:	92 a1       	ldd	r25, Z+34	; 0x22
    6374:	a3 a1       	ldd	r26, Z+35	; 0x23
    6376:	b4 a1       	ldd	r27, Z+36	; 0x24
    6378:	ec 85       	ldd	r30, Y+12	; 0x0c
    637a:	fd 85       	ldd	r31, Y+13	; 0x0d
    637c:	80 83       	st	Z, r24
    637e:	91 83       	std	Z+1, r25	; 0x01
    6380:	a2 83       	std	Z+2, r26	; 0x02
    6382:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6384:	eb 81       	ldd	r30, Y+3	; 0x03
    6386:	fc 81       	ldd	r31, Y+4	; 0x04
    6388:	85 a1       	ldd	r24, Z+37	; 0x25
    638a:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    638c:	eb 81       	ldd	r30, Y+3	; 0x03
    638e:	fc 81       	ldd	r31, Y+4	; 0x04
    6390:	82 e0       	ldi	r24, 0x02	; 2
    6392:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    6394:	8b 85       	ldd	r24, Y+11	; 0x0b
    6396:	28 2f       	mov	r18, r24
    6398:	30 e0       	ldi	r19, 0x00	; 0
    639a:	3f 87       	std	Y+15, r19	; 0x0f
    639c:	2e 87       	std	Y+14, r18	; 0x0e
    639e:	8e 85       	ldd	r24, Y+14	; 0x0e
    63a0:	9f 85       	ldd	r25, Y+15	; 0x0f
    63a2:	82 30       	cpi	r24, 0x02	; 2
    63a4:	91 05       	cpc	r25, r1
    63a6:	59 f1       	breq	.+86     	; 0x63fe <xTaskGenericNotify+0xd6>
    63a8:	2e 85       	ldd	r18, Y+14	; 0x0e
    63aa:	3f 85       	ldd	r19, Y+15	; 0x0f
    63ac:	23 30       	cpi	r18, 0x03	; 3
    63ae:	31 05       	cpc	r19, r1
    63b0:	34 f4       	brge	.+12     	; 0x63be <xTaskGenericNotify+0x96>
    63b2:	8e 85       	ldd	r24, Y+14	; 0x0e
    63b4:	9f 85       	ldd	r25, Y+15	; 0x0f
    63b6:	81 30       	cpi	r24, 0x01	; 1
    63b8:	91 05       	cpc	r25, r1
    63ba:	61 f0       	breq	.+24     	; 0x63d4 <xTaskGenericNotify+0xac>
    63bc:	4a c0       	rjmp	.+148    	; 0x6452 <xTaskGenericNotify+0x12a>
    63be:	2e 85       	ldd	r18, Y+14	; 0x0e
    63c0:	3f 85       	ldd	r19, Y+15	; 0x0f
    63c2:	23 30       	cpi	r18, 0x03	; 3
    63c4:	31 05       	cpc	r19, r1
    63c6:	59 f1       	breq	.+86     	; 0x641e <xTaskGenericNotify+0xf6>
    63c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    63ca:	9f 85       	ldd	r25, Y+15	; 0x0f
    63cc:	84 30       	cpi	r24, 0x04	; 4
    63ce:	91 05       	cpc	r25, r1
    63d0:	89 f1       	breq	.+98     	; 0x6434 <xTaskGenericNotify+0x10c>
    63d2:	3f c0       	rjmp	.+126    	; 0x6452 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    63d4:	eb 81       	ldd	r30, Y+3	; 0x03
    63d6:	fc 81       	ldd	r31, Y+4	; 0x04
    63d8:	21 a1       	ldd	r18, Z+33	; 0x21
    63da:	32 a1       	ldd	r19, Z+34	; 0x22
    63dc:	43 a1       	ldd	r20, Z+35	; 0x23
    63de:	54 a1       	ldd	r21, Z+36	; 0x24
    63e0:	8f 81       	ldd	r24, Y+7	; 0x07
    63e2:	98 85       	ldd	r25, Y+8	; 0x08
    63e4:	a9 85       	ldd	r26, Y+9	; 0x09
    63e6:	ba 85       	ldd	r27, Y+10	; 0x0a
    63e8:	82 2b       	or	r24, r18
    63ea:	93 2b       	or	r25, r19
    63ec:	a4 2b       	or	r26, r20
    63ee:	b5 2b       	or	r27, r21
    63f0:	eb 81       	ldd	r30, Y+3	; 0x03
    63f2:	fc 81       	ldd	r31, Y+4	; 0x04
    63f4:	81 a3       	std	Z+33, r24	; 0x21
    63f6:	92 a3       	std	Z+34, r25	; 0x22
    63f8:	a3 a3       	std	Z+35, r26	; 0x23
    63fa:	b4 a3       	std	Z+36, r27	; 0x24
    63fc:	2a c0       	rjmp	.+84     	; 0x6452 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    63fe:	eb 81       	ldd	r30, Y+3	; 0x03
    6400:	fc 81       	ldd	r31, Y+4	; 0x04
    6402:	81 a1       	ldd	r24, Z+33	; 0x21
    6404:	92 a1       	ldd	r25, Z+34	; 0x22
    6406:	a3 a1       	ldd	r26, Z+35	; 0x23
    6408:	b4 a1       	ldd	r27, Z+36	; 0x24
    640a:	01 96       	adiw	r24, 0x01	; 1
    640c:	a1 1d       	adc	r26, r1
    640e:	b1 1d       	adc	r27, r1
    6410:	eb 81       	ldd	r30, Y+3	; 0x03
    6412:	fc 81       	ldd	r31, Y+4	; 0x04
    6414:	81 a3       	std	Z+33, r24	; 0x21
    6416:	92 a3       	std	Z+34, r25	; 0x22
    6418:	a3 a3       	std	Z+35, r26	; 0x23
    641a:	b4 a3       	std	Z+36, r27	; 0x24
    641c:	1a c0       	rjmp	.+52     	; 0x6452 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    641e:	eb 81       	ldd	r30, Y+3	; 0x03
    6420:	fc 81       	ldd	r31, Y+4	; 0x04
    6422:	8f 81       	ldd	r24, Y+7	; 0x07
    6424:	98 85       	ldd	r25, Y+8	; 0x08
    6426:	a9 85       	ldd	r26, Y+9	; 0x09
    6428:	ba 85       	ldd	r27, Y+10	; 0x0a
    642a:	81 a3       	std	Z+33, r24	; 0x21
    642c:	92 a3       	std	Z+34, r25	; 0x22
    642e:	a3 a3       	std	Z+35, r26	; 0x23
    6430:	b4 a3       	std	Z+36, r27	; 0x24
    6432:	0f c0       	rjmp	.+30     	; 0x6452 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    6434:	89 81       	ldd	r24, Y+1	; 0x01
    6436:	82 30       	cpi	r24, 0x02	; 2
    6438:	59 f0       	breq	.+22     	; 0x6450 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    643a:	eb 81       	ldd	r30, Y+3	; 0x03
    643c:	fc 81       	ldd	r31, Y+4	; 0x04
    643e:	8f 81       	ldd	r24, Y+7	; 0x07
    6440:	98 85       	ldd	r25, Y+8	; 0x08
    6442:	a9 85       	ldd	r26, Y+9	; 0x09
    6444:	ba 85       	ldd	r27, Y+10	; 0x0a
    6446:	81 a3       	std	Z+33, r24	; 0x21
    6448:	92 a3       	std	Z+34, r25	; 0x22
    644a:	a3 a3       	std	Z+35, r26	; 0x23
    644c:	b4 a3       	std	Z+36, r27	; 0x24
    644e:	01 c0       	rjmp	.+2      	; 0x6452 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    6450:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6452:	89 81       	ldd	r24, Y+1	; 0x01
    6454:	81 30       	cpi	r24, 0x01	; 1
    6456:	b9 f5       	brne	.+110    	; 0x64c6 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6458:	8b 81       	ldd	r24, Y+3	; 0x03
    645a:	9c 81       	ldd	r25, Y+4	; 0x04
    645c:	02 96       	adiw	r24, 0x02	; 2
    645e:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    6462:	eb 81       	ldd	r30, Y+3	; 0x03
    6464:	fc 81       	ldd	r31, Y+4	; 0x04
    6466:	96 89       	ldd	r25, Z+22	; 0x16
    6468:	80 91 79 04 	lds	r24, 0x0479
    646c:	89 17       	cp	r24, r25
    646e:	28 f4       	brcc	.+10     	; 0x647a <xTaskGenericNotify+0x152>
    6470:	eb 81       	ldd	r30, Y+3	; 0x03
    6472:	fc 81       	ldd	r31, Y+4	; 0x04
    6474:	86 89       	ldd	r24, Z+22	; 0x16
    6476:	80 93 79 04 	sts	0x0479, r24
    647a:	eb 81       	ldd	r30, Y+3	; 0x03
    647c:	fc 81       	ldd	r31, Y+4	; 0x04
    647e:	86 89       	ldd	r24, Z+22	; 0x16
    6480:	28 2f       	mov	r18, r24
    6482:	30 e0       	ldi	r19, 0x00	; 0
    6484:	c9 01       	movw	r24, r18
    6486:	88 0f       	add	r24, r24
    6488:	99 1f       	adc	r25, r25
    648a:	88 0f       	add	r24, r24
    648c:	99 1f       	adc	r25, r25
    648e:	88 0f       	add	r24, r24
    6490:	99 1f       	adc	r25, r25
    6492:	82 0f       	add	r24, r18
    6494:	93 1f       	adc	r25, r19
    6496:	ac 01       	movw	r20, r24
    6498:	4b 57       	subi	r20, 0x7B	; 123
    649a:	5b 4f       	sbci	r21, 0xFB	; 251
    649c:	8b 81       	ldd	r24, Y+3	; 0x03
    649e:	9c 81       	ldd	r25, Y+4	; 0x04
    64a0:	9c 01       	movw	r18, r24
    64a2:	2e 5f       	subi	r18, 0xFE	; 254
    64a4:	3f 4f       	sbci	r19, 0xFF	; 255
    64a6:	ca 01       	movw	r24, r20
    64a8:	b9 01       	movw	r22, r18
    64aa:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    64ae:	eb 81       	ldd	r30, Y+3	; 0x03
    64b0:	fc 81       	ldd	r31, Y+4	; 0x04
    64b2:	96 89       	ldd	r25, Z+22	; 0x16
    64b4:	e0 91 73 04 	lds	r30, 0x0473
    64b8:	f0 91 74 04 	lds	r31, 0x0474
    64bc:	86 89       	ldd	r24, Z+22	; 0x16
    64be:	89 17       	cp	r24, r25
    64c0:	10 f4       	brcc	.+4      	; 0x64c6 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    64c2:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    64c6:	0f 90       	pop	r0
    64c8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    64ca:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    64cc:	2f 96       	adiw	r28, 0x0f	; 15
    64ce:	0f b6       	in	r0, 0x3f	; 63
    64d0:	f8 94       	cli
    64d2:	de bf       	out	0x3e, r29	; 62
    64d4:	0f be       	out	0x3f, r0	; 63
    64d6:	cd bf       	out	0x3d, r28	; 61
    64d8:	cf 91       	pop	r28
    64da:	df 91       	pop	r29
    64dc:	1f 91       	pop	r17
    64de:	0f 91       	pop	r16
    64e0:	08 95       	ret

000064e2 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    64e2:	ef 92       	push	r14
    64e4:	ff 92       	push	r15
    64e6:	0f 93       	push	r16
    64e8:	1f 93       	push	r17
    64ea:	df 93       	push	r29
    64ec:	cf 93       	push	r28
    64ee:	cd b7       	in	r28, 0x3d	; 61
    64f0:	de b7       	in	r29, 0x3e	; 62
    64f2:	62 97       	sbiw	r28, 0x12	; 18
    64f4:	0f b6       	in	r0, 0x3f	; 63
    64f6:	f8 94       	cli
    64f8:	de bf       	out	0x3e, r29	; 62
    64fa:	0f be       	out	0x3f, r0	; 63
    64fc:	cd bf       	out	0x3d, r28	; 61
    64fe:	9f 83       	std	Y+7, r25	; 0x07
    6500:	8e 83       	std	Y+6, r24	; 0x06
    6502:	48 87       	std	Y+8, r20	; 0x08
    6504:	59 87       	std	Y+9, r21	; 0x09
    6506:	6a 87       	std	Y+10, r22	; 0x0a
    6508:	7b 87       	std	Y+11, r23	; 0x0b
    650a:	2c 87       	std	Y+12, r18	; 0x0c
    650c:	1e 87       	std	Y+14, r17	; 0x0e
    650e:	0d 87       	std	Y+13, r16	; 0x0d
    6510:	f8 8a       	std	Y+16, r15	; 0x10
    6512:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    6514:	81 e0       	ldi	r24, 0x01	; 1
    6516:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    6518:	8e 81       	ldd	r24, Y+6	; 0x06
    651a:	9f 81       	ldd	r25, Y+7	; 0x07
    651c:	9d 83       	std	Y+5, r25	; 0x05
    651e:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    6520:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    6522:	8d 85       	ldd	r24, Y+13	; 0x0d
    6524:	9e 85       	ldd	r25, Y+14	; 0x0e
    6526:	00 97       	sbiw	r24, 0x00	; 0
    6528:	61 f0       	breq	.+24     	; 0x6542 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    652a:	ec 81       	ldd	r30, Y+4	; 0x04
    652c:	fd 81       	ldd	r31, Y+5	; 0x05
    652e:	81 a1       	ldd	r24, Z+33	; 0x21
    6530:	92 a1       	ldd	r25, Z+34	; 0x22
    6532:	a3 a1       	ldd	r26, Z+35	; 0x23
    6534:	b4 a1       	ldd	r27, Z+36	; 0x24
    6536:	ed 85       	ldd	r30, Y+13	; 0x0d
    6538:	fe 85       	ldd	r31, Y+14	; 0x0e
    653a:	80 83       	st	Z, r24
    653c:	91 83       	std	Z+1, r25	; 0x01
    653e:	a2 83       	std	Z+2, r26	; 0x02
    6540:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6542:	ec 81       	ldd	r30, Y+4	; 0x04
    6544:	fd 81       	ldd	r31, Y+5	; 0x05
    6546:	85 a1       	ldd	r24, Z+37	; 0x25
    6548:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    654a:	ec 81       	ldd	r30, Y+4	; 0x04
    654c:	fd 81       	ldd	r31, Y+5	; 0x05
    654e:	82 e0       	ldi	r24, 0x02	; 2
    6550:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    6552:	8c 85       	ldd	r24, Y+12	; 0x0c
    6554:	28 2f       	mov	r18, r24
    6556:	30 e0       	ldi	r19, 0x00	; 0
    6558:	3a 8b       	std	Y+18, r19	; 0x12
    655a:	29 8b       	std	Y+17, r18	; 0x11
    655c:	89 89       	ldd	r24, Y+17	; 0x11
    655e:	9a 89       	ldd	r25, Y+18	; 0x12
    6560:	82 30       	cpi	r24, 0x02	; 2
    6562:	91 05       	cpc	r25, r1
    6564:	59 f1       	breq	.+86     	; 0x65bc <xTaskGenericNotifyFromISR+0xda>
    6566:	29 89       	ldd	r18, Y+17	; 0x11
    6568:	3a 89       	ldd	r19, Y+18	; 0x12
    656a:	23 30       	cpi	r18, 0x03	; 3
    656c:	31 05       	cpc	r19, r1
    656e:	34 f4       	brge	.+12     	; 0x657c <xTaskGenericNotifyFromISR+0x9a>
    6570:	89 89       	ldd	r24, Y+17	; 0x11
    6572:	9a 89       	ldd	r25, Y+18	; 0x12
    6574:	81 30       	cpi	r24, 0x01	; 1
    6576:	91 05       	cpc	r25, r1
    6578:	61 f0       	breq	.+24     	; 0x6592 <xTaskGenericNotifyFromISR+0xb0>
    657a:	4a c0       	rjmp	.+148    	; 0x6610 <xTaskGenericNotifyFromISR+0x12e>
    657c:	29 89       	ldd	r18, Y+17	; 0x11
    657e:	3a 89       	ldd	r19, Y+18	; 0x12
    6580:	23 30       	cpi	r18, 0x03	; 3
    6582:	31 05       	cpc	r19, r1
    6584:	59 f1       	breq	.+86     	; 0x65dc <xTaskGenericNotifyFromISR+0xfa>
    6586:	89 89       	ldd	r24, Y+17	; 0x11
    6588:	9a 89       	ldd	r25, Y+18	; 0x12
    658a:	84 30       	cpi	r24, 0x04	; 4
    658c:	91 05       	cpc	r25, r1
    658e:	89 f1       	breq	.+98     	; 0x65f2 <xTaskGenericNotifyFromISR+0x110>
    6590:	3f c0       	rjmp	.+126    	; 0x6610 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    6592:	ec 81       	ldd	r30, Y+4	; 0x04
    6594:	fd 81       	ldd	r31, Y+5	; 0x05
    6596:	21 a1       	ldd	r18, Z+33	; 0x21
    6598:	32 a1       	ldd	r19, Z+34	; 0x22
    659a:	43 a1       	ldd	r20, Z+35	; 0x23
    659c:	54 a1       	ldd	r21, Z+36	; 0x24
    659e:	88 85       	ldd	r24, Y+8	; 0x08
    65a0:	99 85       	ldd	r25, Y+9	; 0x09
    65a2:	aa 85       	ldd	r26, Y+10	; 0x0a
    65a4:	bb 85       	ldd	r27, Y+11	; 0x0b
    65a6:	82 2b       	or	r24, r18
    65a8:	93 2b       	or	r25, r19
    65aa:	a4 2b       	or	r26, r20
    65ac:	b5 2b       	or	r27, r21
    65ae:	ec 81       	ldd	r30, Y+4	; 0x04
    65b0:	fd 81       	ldd	r31, Y+5	; 0x05
    65b2:	81 a3       	std	Z+33, r24	; 0x21
    65b4:	92 a3       	std	Z+34, r25	; 0x22
    65b6:	a3 a3       	std	Z+35, r26	; 0x23
    65b8:	b4 a3       	std	Z+36, r27	; 0x24
    65ba:	2a c0       	rjmp	.+84     	; 0x6610 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    65bc:	ec 81       	ldd	r30, Y+4	; 0x04
    65be:	fd 81       	ldd	r31, Y+5	; 0x05
    65c0:	81 a1       	ldd	r24, Z+33	; 0x21
    65c2:	92 a1       	ldd	r25, Z+34	; 0x22
    65c4:	a3 a1       	ldd	r26, Z+35	; 0x23
    65c6:	b4 a1       	ldd	r27, Z+36	; 0x24
    65c8:	01 96       	adiw	r24, 0x01	; 1
    65ca:	a1 1d       	adc	r26, r1
    65cc:	b1 1d       	adc	r27, r1
    65ce:	ec 81       	ldd	r30, Y+4	; 0x04
    65d0:	fd 81       	ldd	r31, Y+5	; 0x05
    65d2:	81 a3       	std	Z+33, r24	; 0x21
    65d4:	92 a3       	std	Z+34, r25	; 0x22
    65d6:	a3 a3       	std	Z+35, r26	; 0x23
    65d8:	b4 a3       	std	Z+36, r27	; 0x24
    65da:	1a c0       	rjmp	.+52     	; 0x6610 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    65dc:	ec 81       	ldd	r30, Y+4	; 0x04
    65de:	fd 81       	ldd	r31, Y+5	; 0x05
    65e0:	88 85       	ldd	r24, Y+8	; 0x08
    65e2:	99 85       	ldd	r25, Y+9	; 0x09
    65e4:	aa 85       	ldd	r26, Y+10	; 0x0a
    65e6:	bb 85       	ldd	r27, Y+11	; 0x0b
    65e8:	81 a3       	std	Z+33, r24	; 0x21
    65ea:	92 a3       	std	Z+34, r25	; 0x22
    65ec:	a3 a3       	std	Z+35, r26	; 0x23
    65ee:	b4 a3       	std	Z+36, r27	; 0x24
    65f0:	0f c0       	rjmp	.+30     	; 0x6610 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    65f2:	8b 81       	ldd	r24, Y+3	; 0x03
    65f4:	82 30       	cpi	r24, 0x02	; 2
    65f6:	59 f0       	breq	.+22     	; 0x660e <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    65f8:	ec 81       	ldd	r30, Y+4	; 0x04
    65fa:	fd 81       	ldd	r31, Y+5	; 0x05
    65fc:	88 85       	ldd	r24, Y+8	; 0x08
    65fe:	99 85       	ldd	r25, Y+9	; 0x09
    6600:	aa 85       	ldd	r26, Y+10	; 0x0a
    6602:	bb 85       	ldd	r27, Y+11	; 0x0b
    6604:	81 a3       	std	Z+33, r24	; 0x21
    6606:	92 a3       	std	Z+34, r25	; 0x22
    6608:	a3 a3       	std	Z+35, r26	; 0x23
    660a:	b4 a3       	std	Z+36, r27	; 0x24
    660c:	01 c0       	rjmp	.+2      	; 0x6610 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    660e:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6610:	8b 81       	ldd	r24, Y+3	; 0x03
    6612:	81 30       	cpi	r24, 0x01	; 1
    6614:	09 f0       	breq	.+2      	; 0x6618 <xTaskGenericNotifyFromISR+0x136>
    6616:	4f c0       	rjmp	.+158    	; 0x66b6 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6618:	80 91 84 04 	lds	r24, 0x0484
    661c:	88 23       	and	r24, r24
    661e:	61 f5       	brne	.+88     	; 0x6678 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6620:	8c 81       	ldd	r24, Y+4	; 0x04
    6622:	9d 81       	ldd	r25, Y+5	; 0x05
    6624:	02 96       	adiw	r24, 0x02	; 2
    6626:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    662a:	ec 81       	ldd	r30, Y+4	; 0x04
    662c:	fd 81       	ldd	r31, Y+5	; 0x05
    662e:	96 89       	ldd	r25, Z+22	; 0x16
    6630:	80 91 79 04 	lds	r24, 0x0479
    6634:	89 17       	cp	r24, r25
    6636:	28 f4       	brcc	.+10     	; 0x6642 <xTaskGenericNotifyFromISR+0x160>
    6638:	ec 81       	ldd	r30, Y+4	; 0x04
    663a:	fd 81       	ldd	r31, Y+5	; 0x05
    663c:	86 89       	ldd	r24, Z+22	; 0x16
    663e:	80 93 79 04 	sts	0x0479, r24
    6642:	ec 81       	ldd	r30, Y+4	; 0x04
    6644:	fd 81       	ldd	r31, Y+5	; 0x05
    6646:	86 89       	ldd	r24, Z+22	; 0x16
    6648:	28 2f       	mov	r18, r24
    664a:	30 e0       	ldi	r19, 0x00	; 0
    664c:	c9 01       	movw	r24, r18
    664e:	88 0f       	add	r24, r24
    6650:	99 1f       	adc	r25, r25
    6652:	88 0f       	add	r24, r24
    6654:	99 1f       	adc	r25, r25
    6656:	88 0f       	add	r24, r24
    6658:	99 1f       	adc	r25, r25
    665a:	82 0f       	add	r24, r18
    665c:	93 1f       	adc	r25, r19
    665e:	ac 01       	movw	r20, r24
    6660:	4b 57       	subi	r20, 0x7B	; 123
    6662:	5b 4f       	sbci	r21, 0xFB	; 251
    6664:	8c 81       	ldd	r24, Y+4	; 0x04
    6666:	9d 81       	ldd	r25, Y+5	; 0x05
    6668:	9c 01       	movw	r18, r24
    666a:	2e 5f       	subi	r18, 0xFE	; 254
    666c:	3f 4f       	sbci	r19, 0xFF	; 255
    666e:	ca 01       	movw	r24, r20
    6670:	b9 01       	movw	r22, r18
    6672:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
    6676:	0a c0       	rjmp	.+20     	; 0x668c <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6678:	8c 81       	ldd	r24, Y+4	; 0x04
    667a:	9d 81       	ldd	r25, Y+5	; 0x05
    667c:	9c 01       	movw	r18, r24
    667e:	24 5f       	subi	r18, 0xF4	; 244
    6680:	3f 4f       	sbci	r19, 0xFF	; 255
    6682:	88 ec       	ldi	r24, 0xC8	; 200
    6684:	94 e0       	ldi	r25, 0x04	; 4
    6686:	b9 01       	movw	r22, r18
    6688:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    668c:	ec 81       	ldd	r30, Y+4	; 0x04
    668e:	fd 81       	ldd	r31, Y+5	; 0x05
    6690:	96 89       	ldd	r25, Z+22	; 0x16
    6692:	e0 91 73 04 	lds	r30, 0x0473
    6696:	f0 91 74 04 	lds	r31, 0x0474
    669a:	86 89       	ldd	r24, Z+22	; 0x16
    669c:	89 17       	cp	r24, r25
    669e:	58 f4       	brcc	.+22     	; 0x66b6 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    66a0:	8f 85       	ldd	r24, Y+15	; 0x0f
    66a2:	98 89       	ldd	r25, Y+16	; 0x10
    66a4:	00 97       	sbiw	r24, 0x00	; 0
    66a6:	21 f0       	breq	.+8      	; 0x66b0 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    66a8:	ef 85       	ldd	r30, Y+15	; 0x0f
    66aa:	f8 89       	ldd	r31, Y+16	; 0x10
    66ac:	81 e0       	ldi	r24, 0x01	; 1
    66ae:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    66b0:	81 e0       	ldi	r24, 0x01	; 1
    66b2:	80 93 7d 04 	sts	0x047D, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    66b6:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    66b8:	62 96       	adiw	r28, 0x12	; 18
    66ba:	0f b6       	in	r0, 0x3f	; 63
    66bc:	f8 94       	cli
    66be:	de bf       	out	0x3e, r29	; 62
    66c0:	0f be       	out	0x3f, r0	; 63
    66c2:	cd bf       	out	0x3d, r28	; 61
    66c4:	cf 91       	pop	r28
    66c6:	df 91       	pop	r29
    66c8:	1f 91       	pop	r17
    66ca:	0f 91       	pop	r16
    66cc:	ff 90       	pop	r15
    66ce:	ef 90       	pop	r14
    66d0:	08 95       	ret

000066d2 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    66d2:	df 93       	push	r29
    66d4:	cf 93       	push	r28
    66d6:	cd b7       	in	r28, 0x3d	; 61
    66d8:	de b7       	in	r29, 0x3e	; 62
    66da:	28 97       	sbiw	r28, 0x08	; 8
    66dc:	0f b6       	in	r0, 0x3f	; 63
    66de:	f8 94       	cli
    66e0:	de bf       	out	0x3e, r29	; 62
    66e2:	0f be       	out	0x3f, r0	; 63
    66e4:	cd bf       	out	0x3d, r28	; 61
    66e6:	9e 83       	std	Y+6, r25	; 0x06
    66e8:	8d 83       	std	Y+5, r24	; 0x05
    66ea:	78 87       	std	Y+8, r23	; 0x08
    66ec:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    66ee:	8d 81       	ldd	r24, Y+5	; 0x05
    66f0:	9e 81       	ldd	r25, Y+6	; 0x06
    66f2:	9c 83       	std	Y+4, r25	; 0x04
    66f4:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    66f6:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    66f8:	eb 81       	ldd	r30, Y+3	; 0x03
    66fa:	fc 81       	ldd	r31, Y+4	; 0x04
    66fc:	85 a1       	ldd	r24, Z+37	; 0x25
    66fe:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    6700:	eb 81       	ldd	r30, Y+3	; 0x03
    6702:	fc 81       	ldd	r31, Y+4	; 0x04
    6704:	82 e0       	ldi	r24, 0x02	; 2
    6706:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    6708:	eb 81       	ldd	r30, Y+3	; 0x03
    670a:	fc 81       	ldd	r31, Y+4	; 0x04
    670c:	81 a1       	ldd	r24, Z+33	; 0x21
    670e:	92 a1       	ldd	r25, Z+34	; 0x22
    6710:	a3 a1       	ldd	r26, Z+35	; 0x23
    6712:	b4 a1       	ldd	r27, Z+36	; 0x24
    6714:	01 96       	adiw	r24, 0x01	; 1
    6716:	a1 1d       	adc	r26, r1
    6718:	b1 1d       	adc	r27, r1
    671a:	eb 81       	ldd	r30, Y+3	; 0x03
    671c:	fc 81       	ldd	r31, Y+4	; 0x04
    671e:	81 a3       	std	Z+33, r24	; 0x21
    6720:	92 a3       	std	Z+34, r25	; 0x22
    6722:	a3 a3       	std	Z+35, r26	; 0x23
    6724:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6726:	8a 81       	ldd	r24, Y+2	; 0x02
    6728:	81 30       	cpi	r24, 0x01	; 1
    672a:	09 f0       	breq	.+2      	; 0x672e <vTaskNotifyGiveFromISR+0x5c>
    672c:	4f c0       	rjmp	.+158    	; 0x67cc <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    672e:	80 91 84 04 	lds	r24, 0x0484
    6732:	88 23       	and	r24, r24
    6734:	61 f5       	brne	.+88     	; 0x678e <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6736:	8b 81       	ldd	r24, Y+3	; 0x03
    6738:	9c 81       	ldd	r25, Y+4	; 0x04
    673a:	02 96       	adiw	r24, 0x02	; 2
    673c:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6740:	eb 81       	ldd	r30, Y+3	; 0x03
    6742:	fc 81       	ldd	r31, Y+4	; 0x04
    6744:	96 89       	ldd	r25, Z+22	; 0x16
    6746:	80 91 79 04 	lds	r24, 0x0479
    674a:	89 17       	cp	r24, r25
    674c:	28 f4       	brcc	.+10     	; 0x6758 <vTaskNotifyGiveFromISR+0x86>
    674e:	eb 81       	ldd	r30, Y+3	; 0x03
    6750:	fc 81       	ldd	r31, Y+4	; 0x04
    6752:	86 89       	ldd	r24, Z+22	; 0x16
    6754:	80 93 79 04 	sts	0x0479, r24
    6758:	eb 81       	ldd	r30, Y+3	; 0x03
    675a:	fc 81       	ldd	r31, Y+4	; 0x04
    675c:	86 89       	ldd	r24, Z+22	; 0x16
    675e:	28 2f       	mov	r18, r24
    6760:	30 e0       	ldi	r19, 0x00	; 0
    6762:	c9 01       	movw	r24, r18
    6764:	88 0f       	add	r24, r24
    6766:	99 1f       	adc	r25, r25
    6768:	88 0f       	add	r24, r24
    676a:	99 1f       	adc	r25, r25
    676c:	88 0f       	add	r24, r24
    676e:	99 1f       	adc	r25, r25
    6770:	82 0f       	add	r24, r18
    6772:	93 1f       	adc	r25, r19
    6774:	ac 01       	movw	r20, r24
    6776:	4b 57       	subi	r20, 0x7B	; 123
    6778:	5b 4f       	sbci	r21, 0xFB	; 251
    677a:	8b 81       	ldd	r24, Y+3	; 0x03
    677c:	9c 81       	ldd	r25, Y+4	; 0x04
    677e:	9c 01       	movw	r18, r24
    6780:	2e 5f       	subi	r18, 0xFE	; 254
    6782:	3f 4f       	sbci	r19, 0xFF	; 255
    6784:	ca 01       	movw	r24, r20
    6786:	b9 01       	movw	r22, r18
    6788:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
    678c:	0a c0       	rjmp	.+20     	; 0x67a2 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    678e:	8b 81       	ldd	r24, Y+3	; 0x03
    6790:	9c 81       	ldd	r25, Y+4	; 0x04
    6792:	9c 01       	movw	r18, r24
    6794:	24 5f       	subi	r18, 0xF4	; 244
    6796:	3f 4f       	sbci	r19, 0xFF	; 255
    6798:	88 ec       	ldi	r24, 0xC8	; 200
    679a:	94 e0       	ldi	r25, 0x04	; 4
    679c:	b9 01       	movw	r22, r18
    679e:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    67a2:	eb 81       	ldd	r30, Y+3	; 0x03
    67a4:	fc 81       	ldd	r31, Y+4	; 0x04
    67a6:	96 89       	ldd	r25, Z+22	; 0x16
    67a8:	e0 91 73 04 	lds	r30, 0x0473
    67ac:	f0 91 74 04 	lds	r31, 0x0474
    67b0:	86 89       	ldd	r24, Z+22	; 0x16
    67b2:	89 17       	cp	r24, r25
    67b4:	58 f4       	brcc	.+22     	; 0x67cc <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    67b6:	8f 81       	ldd	r24, Y+7	; 0x07
    67b8:	98 85       	ldd	r25, Y+8	; 0x08
    67ba:	00 97       	sbiw	r24, 0x00	; 0
    67bc:	21 f0       	breq	.+8      	; 0x67c6 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    67be:	ef 81       	ldd	r30, Y+7	; 0x07
    67c0:	f8 85       	ldd	r31, Y+8	; 0x08
    67c2:	81 e0       	ldi	r24, 0x01	; 1
    67c4:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    67c6:	81 e0       	ldi	r24, 0x01	; 1
    67c8:	80 93 7d 04 	sts	0x047D, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    67cc:	28 96       	adiw	r28, 0x08	; 8
    67ce:	0f b6       	in	r0, 0x3f	; 63
    67d0:	f8 94       	cli
    67d2:	de bf       	out	0x3e, r29	; 62
    67d4:	0f be       	out	0x3f, r0	; 63
    67d6:	cd bf       	out	0x3d, r28	; 61
    67d8:	cf 91       	pop	r28
    67da:	df 91       	pop	r29
    67dc:	08 95       	ret

000067de <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    67de:	df 93       	push	r29
    67e0:	cf 93       	push	r28
    67e2:	cd b7       	in	r28, 0x3d	; 61
    67e4:	de b7       	in	r29, 0x3e	; 62
    67e6:	27 97       	sbiw	r28, 0x07	; 7
    67e8:	0f b6       	in	r0, 0x3f	; 63
    67ea:	f8 94       	cli
    67ec:	de bf       	out	0x3e, r29	; 62
    67ee:	0f be       	out	0x3f, r0	; 63
    67f0:	cd bf       	out	0x3d, r28	; 61
    67f2:	9d 83       	std	Y+5, r25	; 0x05
    67f4:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    67f6:	8c 81       	ldd	r24, Y+4	; 0x04
    67f8:	9d 81       	ldd	r25, Y+5	; 0x05
    67fa:	00 97       	sbiw	r24, 0x00	; 0
    67fc:	39 f4       	brne	.+14     	; 0x680c <xTaskNotifyStateClear+0x2e>
    67fe:	80 91 73 04 	lds	r24, 0x0473
    6802:	90 91 74 04 	lds	r25, 0x0474
    6806:	9f 83       	std	Y+7, r25	; 0x07
    6808:	8e 83       	std	Y+6, r24	; 0x06
    680a:	04 c0       	rjmp	.+8      	; 0x6814 <xTaskNotifyStateClear+0x36>
    680c:	8c 81       	ldd	r24, Y+4	; 0x04
    680e:	9d 81       	ldd	r25, Y+5	; 0x05
    6810:	9f 83       	std	Y+7, r25	; 0x07
    6812:	8e 83       	std	Y+6, r24	; 0x06
    6814:	8e 81       	ldd	r24, Y+6	; 0x06
    6816:	9f 81       	ldd	r25, Y+7	; 0x07
    6818:	9b 83       	std	Y+3, r25	; 0x03
    681a:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    681c:	0f b6       	in	r0, 0x3f	; 63
    681e:	f8 94       	cli
    6820:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    6822:	ea 81       	ldd	r30, Y+2	; 0x02
    6824:	fb 81       	ldd	r31, Y+3	; 0x03
    6826:	85 a1       	ldd	r24, Z+37	; 0x25
    6828:	82 30       	cpi	r24, 0x02	; 2
    682a:	31 f4       	brne	.+12     	; 0x6838 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    682c:	ea 81       	ldd	r30, Y+2	; 0x02
    682e:	fb 81       	ldd	r31, Y+3	; 0x03
    6830:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    6832:	81 e0       	ldi	r24, 0x01	; 1
    6834:	89 83       	std	Y+1, r24	; 0x01
    6836:	01 c0       	rjmp	.+2      	; 0x683a <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    6838:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    683a:	0f 90       	pop	r0
    683c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    683e:	89 81       	ldd	r24, Y+1	; 0x01
	}
    6840:	27 96       	adiw	r28, 0x07	; 7
    6842:	0f b6       	in	r0, 0x3f	; 63
    6844:	f8 94       	cli
    6846:	de bf       	out	0x3e, r29	; 62
    6848:	0f be       	out	0x3f, r0	; 63
    684a:	cd bf       	out	0x3d, r28	; 61
    684c:	cf 91       	pop	r28
    684e:	df 91       	pop	r29
    6850:	08 95       	ret

00006852 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
    6852:	df 93       	push	r29
    6854:	cf 93       	push	r28
    6856:	cd b7       	in	r28, 0x3d	; 61
    6858:	de b7       	in	r29, 0x3e	; 62
    685a:	2e 97       	sbiw	r28, 0x0e	; 14
    685c:	0f b6       	in	r0, 0x3f	; 63
    685e:	f8 94       	cli
    6860:	de bf       	out	0x3e, r29	; 62
    6862:	0f be       	out	0x3f, r0	; 63
    6864:	cd bf       	out	0x3d, r28	; 61
    6866:	98 87       	std	Y+8, r25	; 0x08
    6868:	8f 83       	std	Y+7, r24	; 0x07
    686a:	49 87       	std	Y+9, r20	; 0x09
    686c:	5a 87       	std	Y+10, r21	; 0x0a
    686e:	6b 87       	std	Y+11, r22	; 0x0b
    6870:	7c 87       	std	Y+12, r23	; 0x0c
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    6872:	8f 81       	ldd	r24, Y+7	; 0x07
    6874:	98 85       	ldd	r25, Y+8	; 0x08
    6876:	00 97       	sbiw	r24, 0x00	; 0
    6878:	39 f4       	brne	.+14     	; 0x6888 <ulTaskNotifyValueClear+0x36>
    687a:	80 91 73 04 	lds	r24, 0x0473
    687e:	90 91 74 04 	lds	r25, 0x0474
    6882:	9e 87       	std	Y+14, r25	; 0x0e
    6884:	8d 87       	std	Y+13, r24	; 0x0d
    6886:	04 c0       	rjmp	.+8      	; 0x6890 <ulTaskNotifyValueClear+0x3e>
    6888:	8f 81       	ldd	r24, Y+7	; 0x07
    688a:	98 85       	ldd	r25, Y+8	; 0x08
    688c:	9e 87       	std	Y+14, r25	; 0x0e
    688e:	8d 87       	std	Y+13, r24	; 0x0d
    6890:	8d 85       	ldd	r24, Y+13	; 0x0d
    6892:	9e 85       	ldd	r25, Y+14	; 0x0e
    6894:	9e 83       	std	Y+6, r25	; 0x06
    6896:	8d 83       	std	Y+5, r24	; 0x05

		taskENTER_CRITICAL();
    6898:	0f b6       	in	r0, 0x3f	; 63
    689a:	f8 94       	cli
    689c:	0f 92       	push	r0
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    689e:	e0 91 73 04 	lds	r30, 0x0473
    68a2:	f0 91 74 04 	lds	r31, 0x0474
    68a6:	81 a1       	ldd	r24, Z+33	; 0x21
    68a8:	92 a1       	ldd	r25, Z+34	; 0x22
    68aa:	a3 a1       	ldd	r26, Z+35	; 0x23
    68ac:	b4 a1       	ldd	r27, Z+36	; 0x24
    68ae:	89 83       	std	Y+1, r24	; 0x01
    68b0:	9a 83       	std	Y+2, r25	; 0x02
    68b2:	ab 83       	std	Y+3, r26	; 0x03
    68b4:	bc 83       	std	Y+4, r27	; 0x04
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
    68b6:	ed 81       	ldd	r30, Y+5	; 0x05
    68b8:	fe 81       	ldd	r31, Y+6	; 0x06
    68ba:	21 a1       	ldd	r18, Z+33	; 0x21
    68bc:	32 a1       	ldd	r19, Z+34	; 0x22
    68be:	43 a1       	ldd	r20, Z+35	; 0x23
    68c0:	54 a1       	ldd	r21, Z+36	; 0x24
    68c2:	89 85       	ldd	r24, Y+9	; 0x09
    68c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    68c6:	ab 85       	ldd	r26, Y+11	; 0x0b
    68c8:	bc 85       	ldd	r27, Y+12	; 0x0c
    68ca:	80 95       	com	r24
    68cc:	90 95       	com	r25
    68ce:	a0 95       	com	r26
    68d0:	b0 95       	com	r27
    68d2:	82 23       	and	r24, r18
    68d4:	93 23       	and	r25, r19
    68d6:	a4 23       	and	r26, r20
    68d8:	b5 23       	and	r27, r21
    68da:	ed 81       	ldd	r30, Y+5	; 0x05
    68dc:	fe 81       	ldd	r31, Y+6	; 0x06
    68de:	81 a3       	std	Z+33, r24	; 0x21
    68e0:	92 a3       	std	Z+34, r25	; 0x22
    68e2:	a3 a3       	std	Z+35, r26	; 0x23
    68e4:	b4 a3       	std	Z+36, r27	; 0x24
		}
		taskEXIT_CRITICAL();
    68e6:	0f 90       	pop	r0
    68e8:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    68ea:	89 81       	ldd	r24, Y+1	; 0x01
    68ec:	9a 81       	ldd	r25, Y+2	; 0x02
    68ee:	ab 81       	ldd	r26, Y+3	; 0x03
    68f0:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    68f2:	bc 01       	movw	r22, r24
    68f4:	cd 01       	movw	r24, r26
    68f6:	2e 96       	adiw	r28, 0x0e	; 14
    68f8:	0f b6       	in	r0, 0x3f	; 63
    68fa:	f8 94       	cli
    68fc:	de bf       	out	0x3e, r29	; 62
    68fe:	0f be       	out	0x3f, r0	; 63
    6900:	cd bf       	out	0x3d, r28	; 61
    6902:	cf 91       	pop	r28
    6904:	df 91       	pop	r29
    6906:	08 95       	ret

00006908 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    6908:	df 93       	push	r29
    690a:	cf 93       	push	r28
    690c:	cd b7       	in	r28, 0x3d	; 61
    690e:	de b7       	in	r29, 0x3e	; 62
    6910:	27 97       	sbiw	r28, 0x07	; 7
    6912:	0f b6       	in	r0, 0x3f	; 63
    6914:	f8 94       	cli
    6916:	de bf       	out	0x3e, r29	; 62
    6918:	0f be       	out	0x3f, r0	; 63
    691a:	cd bf       	out	0x3d, r28	; 61
    691c:	9e 83       	std	Y+6, r25	; 0x06
    691e:	8d 83       	std	Y+5, r24	; 0x05
    6920:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    6922:	80 91 77 04 	lds	r24, 0x0477
    6926:	90 91 78 04 	lds	r25, 0x0478
    692a:	9a 83       	std	Y+2, r25	; 0x02
    692c:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    692e:	80 91 73 04 	lds	r24, 0x0473
    6932:	90 91 74 04 	lds	r25, 0x0474
    6936:	02 96       	adiw	r24, 0x02	; 2
    6938:	0e 94 cf 19 	call	0x339e	; 0x339e <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    693c:	8d 81       	ldd	r24, Y+5	; 0x05
    693e:	9e 81       	ldd	r25, Y+6	; 0x06
    6940:	2f ef       	ldi	r18, 0xFF	; 255
    6942:	8f 3f       	cpi	r24, 0xFF	; 255
    6944:	92 07       	cpc	r25, r18
    6946:	81 f4       	brne	.+32     	; 0x6968 <prvAddCurrentTaskToDelayedList+0x60>
    6948:	8f 81       	ldd	r24, Y+7	; 0x07
    694a:	88 23       	and	r24, r24
    694c:	69 f0       	breq	.+26     	; 0x6968 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    694e:	80 91 73 04 	lds	r24, 0x0473
    6952:	90 91 74 04 	lds	r25, 0x0474
    6956:	9c 01       	movw	r18, r24
    6958:	2e 5f       	subi	r18, 0xFE	; 254
    695a:	3f 4f       	sbci	r19, 0xFF	; 255
    695c:	8a ed       	ldi	r24, 0xDA	; 218
    695e:	94 e0       	ldi	r25, 0x04	; 4
    6960:	b9 01       	movw	r22, r18
    6962:	0e 94 1f 19 	call	0x323e	; 0x323e <vListInsertEnd>
    6966:	43 c0       	rjmp	.+134    	; 0x69ee <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    6968:	29 81       	ldd	r18, Y+1	; 0x01
    696a:	3a 81       	ldd	r19, Y+2	; 0x02
    696c:	8d 81       	ldd	r24, Y+5	; 0x05
    696e:	9e 81       	ldd	r25, Y+6	; 0x06
    6970:	82 0f       	add	r24, r18
    6972:	93 1f       	adc	r25, r19
    6974:	9c 83       	std	Y+4, r25	; 0x04
    6976:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    6978:	e0 91 73 04 	lds	r30, 0x0473
    697c:	f0 91 74 04 	lds	r31, 0x0474
    6980:	8b 81       	ldd	r24, Y+3	; 0x03
    6982:	9c 81       	ldd	r25, Y+4	; 0x04
    6984:	93 83       	std	Z+3, r25	; 0x03
    6986:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    6988:	2b 81       	ldd	r18, Y+3	; 0x03
    698a:	3c 81       	ldd	r19, Y+4	; 0x04
    698c:	89 81       	ldd	r24, Y+1	; 0x01
    698e:	9a 81       	ldd	r25, Y+2	; 0x02
    6990:	28 17       	cp	r18, r24
    6992:	39 07       	cpc	r19, r25
    6994:	70 f4       	brcc	.+28     	; 0x69b2 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6996:	80 91 c6 04 	lds	r24, 0x04C6
    699a:	90 91 c7 04 	lds	r25, 0x04C7
    699e:	20 91 73 04 	lds	r18, 0x0473
    69a2:	30 91 74 04 	lds	r19, 0x0474
    69a6:	2e 5f       	subi	r18, 0xFE	; 254
    69a8:	3f 4f       	sbci	r19, 0xFF	; 255
    69aa:	b9 01       	movw	r22, r18
    69ac:	0e 94 63 19 	call	0x32c6	; 0x32c6 <vListInsert>
    69b0:	1e c0       	rjmp	.+60     	; 0x69ee <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    69b2:	40 91 c4 04 	lds	r20, 0x04C4
    69b6:	50 91 c5 04 	lds	r21, 0x04C5
    69ba:	80 91 73 04 	lds	r24, 0x0473
    69be:	90 91 74 04 	lds	r25, 0x0474
    69c2:	9c 01       	movw	r18, r24
    69c4:	2e 5f       	subi	r18, 0xFE	; 254
    69c6:	3f 4f       	sbci	r19, 0xFF	; 255
    69c8:	ca 01       	movw	r24, r20
    69ca:	b9 01       	movw	r22, r18
    69cc:	0e 94 63 19 	call	0x32c6	; 0x32c6 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    69d0:	20 91 80 04 	lds	r18, 0x0480
    69d4:	30 91 81 04 	lds	r19, 0x0481
    69d8:	8b 81       	ldd	r24, Y+3	; 0x03
    69da:	9c 81       	ldd	r25, Y+4	; 0x04
    69dc:	82 17       	cp	r24, r18
    69de:	93 07       	cpc	r25, r19
    69e0:	30 f4       	brcc	.+12     	; 0x69ee <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    69e2:	8b 81       	ldd	r24, Y+3	; 0x03
    69e4:	9c 81       	ldd	r25, Y+4	; 0x04
    69e6:	90 93 81 04 	sts	0x0481, r25
    69ea:	80 93 80 04 	sts	0x0480, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    69ee:	27 96       	adiw	r28, 0x07	; 7
    69f0:	0f b6       	in	r0, 0x3f	; 63
    69f2:	f8 94       	cli
    69f4:	de bf       	out	0x3e, r29	; 62
    69f6:	0f be       	out	0x3f, r0	; 63
    69f8:	cd bf       	out	0x3d, r28	; 61
    69fa:	cf 91       	pop	r28
    69fc:	df 91       	pop	r29
    69fe:	08 95       	ret

00006a00 <__udivmodsi4>:
    6a00:	a1 e2       	ldi	r26, 0x21	; 33
    6a02:	1a 2e       	mov	r1, r26
    6a04:	aa 1b       	sub	r26, r26
    6a06:	bb 1b       	sub	r27, r27
    6a08:	fd 01       	movw	r30, r26
    6a0a:	0d c0       	rjmp	.+26     	; 0x6a26 <__udivmodsi4_ep>

00006a0c <__udivmodsi4_loop>:
    6a0c:	aa 1f       	adc	r26, r26
    6a0e:	bb 1f       	adc	r27, r27
    6a10:	ee 1f       	adc	r30, r30
    6a12:	ff 1f       	adc	r31, r31
    6a14:	a2 17       	cp	r26, r18
    6a16:	b3 07       	cpc	r27, r19
    6a18:	e4 07       	cpc	r30, r20
    6a1a:	f5 07       	cpc	r31, r21
    6a1c:	20 f0       	brcs	.+8      	; 0x6a26 <__udivmodsi4_ep>
    6a1e:	a2 1b       	sub	r26, r18
    6a20:	b3 0b       	sbc	r27, r19
    6a22:	e4 0b       	sbc	r30, r20
    6a24:	f5 0b       	sbc	r31, r21

00006a26 <__udivmodsi4_ep>:
    6a26:	66 1f       	adc	r22, r22
    6a28:	77 1f       	adc	r23, r23
    6a2a:	88 1f       	adc	r24, r24
    6a2c:	99 1f       	adc	r25, r25
    6a2e:	1a 94       	dec	r1
    6a30:	69 f7       	brne	.-38     	; 0x6a0c <__udivmodsi4_loop>
    6a32:	60 95       	com	r22
    6a34:	70 95       	com	r23
    6a36:	80 95       	com	r24
    6a38:	90 95       	com	r25
    6a3a:	9b 01       	movw	r18, r22
    6a3c:	ac 01       	movw	r20, r24
    6a3e:	bd 01       	movw	r22, r26
    6a40:	cf 01       	movw	r24, r30
    6a42:	08 95       	ret

00006a44 <__prologue_saves__>:
    6a44:	2f 92       	push	r2
    6a46:	3f 92       	push	r3
    6a48:	4f 92       	push	r4
    6a4a:	5f 92       	push	r5
    6a4c:	6f 92       	push	r6
    6a4e:	7f 92       	push	r7
    6a50:	8f 92       	push	r8
    6a52:	9f 92       	push	r9
    6a54:	af 92       	push	r10
    6a56:	bf 92       	push	r11
    6a58:	cf 92       	push	r12
    6a5a:	df 92       	push	r13
    6a5c:	ef 92       	push	r14
    6a5e:	ff 92       	push	r15
    6a60:	0f 93       	push	r16
    6a62:	1f 93       	push	r17
    6a64:	cf 93       	push	r28
    6a66:	df 93       	push	r29
    6a68:	cd b7       	in	r28, 0x3d	; 61
    6a6a:	de b7       	in	r29, 0x3e	; 62
    6a6c:	ca 1b       	sub	r28, r26
    6a6e:	db 0b       	sbc	r29, r27
    6a70:	0f b6       	in	r0, 0x3f	; 63
    6a72:	f8 94       	cli
    6a74:	de bf       	out	0x3e, r29	; 62
    6a76:	0f be       	out	0x3f, r0	; 63
    6a78:	cd bf       	out	0x3d, r28	; 61
    6a7a:	09 94       	ijmp

00006a7c <__epilogue_restores__>:
    6a7c:	2a 88       	ldd	r2, Y+18	; 0x12
    6a7e:	39 88       	ldd	r3, Y+17	; 0x11
    6a80:	48 88       	ldd	r4, Y+16	; 0x10
    6a82:	5f 84       	ldd	r5, Y+15	; 0x0f
    6a84:	6e 84       	ldd	r6, Y+14	; 0x0e
    6a86:	7d 84       	ldd	r7, Y+13	; 0x0d
    6a88:	8c 84       	ldd	r8, Y+12	; 0x0c
    6a8a:	9b 84       	ldd	r9, Y+11	; 0x0b
    6a8c:	aa 84       	ldd	r10, Y+10	; 0x0a
    6a8e:	b9 84       	ldd	r11, Y+9	; 0x09
    6a90:	c8 84       	ldd	r12, Y+8	; 0x08
    6a92:	df 80       	ldd	r13, Y+7	; 0x07
    6a94:	ee 80       	ldd	r14, Y+6	; 0x06
    6a96:	fd 80       	ldd	r15, Y+5	; 0x05
    6a98:	0c 81       	ldd	r16, Y+4	; 0x04
    6a9a:	1b 81       	ldd	r17, Y+3	; 0x03
    6a9c:	aa 81       	ldd	r26, Y+2	; 0x02
    6a9e:	b9 81       	ldd	r27, Y+1	; 0x01
    6aa0:	ce 0f       	add	r28, r30
    6aa2:	d1 1d       	adc	r29, r1
    6aa4:	0f b6       	in	r0, 0x3f	; 63
    6aa6:	f8 94       	cli
    6aa8:	de bf       	out	0x3e, r29	; 62
    6aaa:	0f be       	out	0x3f, r0	; 63
    6aac:	cd bf       	out	0x3d, r28	; 61
    6aae:	ed 01       	movw	r28, r26
    6ab0:	08 95       	ret

00006ab2 <memcpy>:
    6ab2:	fb 01       	movw	r30, r22
    6ab4:	dc 01       	movw	r26, r24
    6ab6:	02 c0       	rjmp	.+4      	; 0x6abc <memcpy+0xa>
    6ab8:	01 90       	ld	r0, Z+
    6aba:	0d 92       	st	X+, r0
    6abc:	41 50       	subi	r20, 0x01	; 1
    6abe:	50 40       	sbci	r21, 0x00	; 0
    6ac0:	d8 f7       	brcc	.-10     	; 0x6ab8 <memcpy+0x6>
    6ac2:	08 95       	ret

00006ac4 <_exit>:
    6ac4:	f8 94       	cli

00006ac6 <__stop_program>:
    6ac6:	ff cf       	rjmp	.-2      	; 0x6ac6 <__stop_program>
