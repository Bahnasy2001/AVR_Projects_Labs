
Free_RTOS_Lab2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006a4c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  00006a4c  00006ae0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000045e  00800090  00800090  00006b10  2**0
                  ALLOC
  3 .stab         00008868  00000000  00000000  00006b10  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000047ef  00000000  00000000  0000f378  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  00013b67  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  00013cc7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002045  00000000  00000000  00013e56  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001101  00000000  00000000  00015e9b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f82  00000000  00000000  00016f9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  00017f20  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002c2  00000000  00000000  000180a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000088e  00000000  00000000  00018362  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00018bf0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 7d 1e 	jmp	0x3cfa	; 0x3cfa <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e4       	ldi	r30, 0x4C	; 76
      68:	fa e6       	ldi	r31, 0x6A	; 106
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 39       	cpi	r26, 0x90	; 144
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a0 e9       	ldi	r26, 0x90	; 144
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 3e       	cpi	r26, 0xEE	; 238
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 1a 1a 	call	0x3434	; 0x3434 <main>
      8a:	0c 94 24 35 	jmp	0x6a48	; 0x6a48 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 e4 34 	jmp	0x69c8	; 0x69c8 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a7 e8       	ldi	r26, 0x87	; 135
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 00 35 	jmp	0x6a00	; 0x6a00 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 f0 34 	jmp	0x69e0	; 0x69e0 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 0c 35 	jmp	0x6a18	; 0x6a18 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 f0 34 	jmp	0x69e0	; 0x69e0 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 0c 35 	jmp	0x6a18	; 0x6a18 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 e4 34 	jmp	0x69c8	; 0x69c8 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	87 e8       	ldi	r24, 0x87	; 135
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 00 35 	jmp	0x6a00	; 0x6a00 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 ec 34 	jmp	0x69d8	; 0x69d8 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	67 e8       	ldi	r22, 0x87	; 135
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 08 35 	jmp	0x6a10	; 0x6a10 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 f0 34 	jmp	0x69e0	; 0x69e0 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 0c 35 	jmp	0x6a18	; 0x6a18 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 f0 34 	jmp	0x69e0	; 0x69e0 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 0c 35 	jmp	0x6a18	; 0x6a18 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 f0 34 	jmp	0x69e0	; 0x69e0 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 0c 35 	jmp	0x6a18	; 0x6a18 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 f4 34 	jmp	0x69e8	; 0x69e8 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 10 35 	jmp	0x6a20	; 0x6a20 <__epilogue_restores__+0x20>

00000952 <__pack_f>:
     952:	df 92       	push	r13
     954:	ef 92       	push	r14
     956:	ff 92       	push	r15
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	fc 01       	movw	r30, r24
     95e:	e4 80       	ldd	r14, Z+4	; 0x04
     960:	f5 80       	ldd	r15, Z+5	; 0x05
     962:	06 81       	ldd	r16, Z+6	; 0x06
     964:	17 81       	ldd	r17, Z+7	; 0x07
     966:	d1 80       	ldd	r13, Z+1	; 0x01
     968:	80 81       	ld	r24, Z
     96a:	82 30       	cpi	r24, 0x02	; 2
     96c:	48 f4       	brcc	.+18     	; 0x980 <__pack_f+0x2e>
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	a0 e1       	ldi	r26, 0x10	; 16
     974:	b0 e0       	ldi	r27, 0x00	; 0
     976:	e8 2a       	or	r14, r24
     978:	f9 2a       	or	r15, r25
     97a:	0a 2b       	or	r16, r26
     97c:	1b 2b       	or	r17, r27
     97e:	a5 c0       	rjmp	.+330    	; 0xaca <__pack_f+0x178>
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	09 f4       	brne	.+2      	; 0x986 <__pack_f+0x34>
     984:	9f c0       	rjmp	.+318    	; 0xac4 <__pack_f+0x172>
     986:	82 30       	cpi	r24, 0x02	; 2
     988:	21 f4       	brne	.+8      	; 0x992 <__pack_f+0x40>
     98a:	ee 24       	eor	r14, r14
     98c:	ff 24       	eor	r15, r15
     98e:	87 01       	movw	r16, r14
     990:	05 c0       	rjmp	.+10     	; 0x99c <__pack_f+0x4a>
     992:	e1 14       	cp	r14, r1
     994:	f1 04       	cpc	r15, r1
     996:	01 05       	cpc	r16, r1
     998:	11 05       	cpc	r17, r1
     99a:	19 f4       	brne	.+6      	; 0x9a2 <__pack_f+0x50>
     99c:	e0 e0       	ldi	r30, 0x00	; 0
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	96 c0       	rjmp	.+300    	; 0xace <__pack_f+0x17c>
     9a2:	62 81       	ldd	r22, Z+2	; 0x02
     9a4:	73 81       	ldd	r23, Z+3	; 0x03
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
     9a8:	62 38       	cpi	r22, 0x82	; 130
     9aa:	79 07       	cpc	r23, r25
     9ac:	0c f0       	brlt	.+2      	; 0x9b0 <__pack_f+0x5e>
     9ae:	5b c0       	rjmp	.+182    	; 0xa66 <__pack_f+0x114>
     9b0:	22 e8       	ldi	r18, 0x82	; 130
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	26 1b       	sub	r18, r22
     9b6:	37 0b       	sbc	r19, r23
     9b8:	2a 31       	cpi	r18, 0x1A	; 26
     9ba:	31 05       	cpc	r19, r1
     9bc:	2c f0       	brlt	.+10     	; 0x9c8 <__pack_f+0x76>
     9be:	20 e0       	ldi	r18, 0x00	; 0
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	2a c0       	rjmp	.+84     	; 0xa1c <__pack_f+0xca>
     9c8:	b8 01       	movw	r22, r16
     9ca:	a7 01       	movw	r20, r14
     9cc:	02 2e       	mov	r0, r18
     9ce:	04 c0       	rjmp	.+8      	; 0x9d8 <__pack_f+0x86>
     9d0:	76 95       	lsr	r23
     9d2:	67 95       	ror	r22
     9d4:	57 95       	ror	r21
     9d6:	47 95       	ror	r20
     9d8:	0a 94       	dec	r0
     9da:	d2 f7       	brpl	.-12     	; 0x9d0 <__pack_f+0x7e>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	a0 e0       	ldi	r26, 0x00	; 0
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <__pack_f+0x9c>
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	aa 1f       	adc	r26, r26
     9ec:	bb 1f       	adc	r27, r27
     9ee:	2a 95       	dec	r18
     9f0:	d2 f7       	brpl	.-12     	; 0x9e6 <__pack_f+0x94>
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	a1 09       	sbc	r26, r1
     9f6:	b1 09       	sbc	r27, r1
     9f8:	8e 21       	and	r24, r14
     9fa:	9f 21       	and	r25, r15
     9fc:	a0 23       	and	r26, r16
     9fe:	b1 23       	and	r27, r17
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	a1 05       	cpc	r26, r1
     a04:	b1 05       	cpc	r27, r1
     a06:	21 f0       	breq	.+8      	; 0xa10 <__pack_f+0xbe>
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e0       	ldi	r26, 0x00	; 0
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	9a 01       	movw	r18, r20
     a12:	ab 01       	movw	r20, r22
     a14:	28 2b       	or	r18, r24
     a16:	39 2b       	or	r19, r25
     a18:	4a 2b       	or	r20, r26
     a1a:	5b 2b       	or	r21, r27
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	90 70       	andi	r25, 0x00	; 0
     a24:	a0 70       	andi	r26, 0x00	; 0
     a26:	b0 70       	andi	r27, 0x00	; 0
     a28:	80 34       	cpi	r24, 0x40	; 64
     a2a:	91 05       	cpc	r25, r1
     a2c:	a1 05       	cpc	r26, r1
     a2e:	b1 05       	cpc	r27, r1
     a30:	39 f4       	brne	.+14     	; 0xa40 <__pack_f+0xee>
     a32:	27 ff       	sbrs	r18, 7
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__pack_f+0xf6>
     a36:	20 5c       	subi	r18, 0xC0	; 192
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	4f 4f       	sbci	r20, 0xFF	; 255
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <__pack_f+0xf6>
     a40:	21 5c       	subi	r18, 0xC1	; 193
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	4f 4f       	sbci	r20, 0xFF	; 255
     a46:	5f 4f       	sbci	r21, 0xFF	; 255
     a48:	e0 e0       	ldi	r30, 0x00	; 0
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	20 30       	cpi	r18, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	3a 07       	cpc	r19, r26
     a52:	a0 e0       	ldi	r26, 0x00	; 0
     a54:	4a 07       	cpc	r20, r26
     a56:	a0 e4       	ldi	r26, 0x40	; 64
     a58:	5a 07       	cpc	r21, r26
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <__pack_f+0x10e>
     a5c:	e1 e0       	ldi	r30, 0x01	; 1
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	79 01       	movw	r14, r18
     a62:	8a 01       	movw	r16, r20
     a64:	27 c0       	rjmp	.+78     	; 0xab4 <__pack_f+0x162>
     a66:	60 38       	cpi	r22, 0x80	; 128
     a68:	71 05       	cpc	r23, r1
     a6a:	64 f5       	brge	.+88     	; 0xac4 <__pack_f+0x172>
     a6c:	fb 01       	movw	r30, r22
     a6e:	e1 58       	subi	r30, 0x81	; 129
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
     a72:	d8 01       	movw	r26, r16
     a74:	c7 01       	movw	r24, r14
     a76:	8f 77       	andi	r24, 0x7F	; 127
     a78:	90 70       	andi	r25, 0x00	; 0
     a7a:	a0 70       	andi	r26, 0x00	; 0
     a7c:	b0 70       	andi	r27, 0x00	; 0
     a7e:	80 34       	cpi	r24, 0x40	; 64
     a80:	91 05       	cpc	r25, r1
     a82:	a1 05       	cpc	r26, r1
     a84:	b1 05       	cpc	r27, r1
     a86:	39 f4       	brne	.+14     	; 0xa96 <__pack_f+0x144>
     a88:	e7 fe       	sbrs	r14, 7
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <__pack_f+0x154>
     a8c:	80 e4       	ldi	r24, 0x40	; 64
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	a0 e0       	ldi	r26, 0x00	; 0
     a92:	b0 e0       	ldi	r27, 0x00	; 0
     a94:	04 c0       	rjmp	.+8      	; 0xa9e <__pack_f+0x14c>
     a96:	8f e3       	ldi	r24, 0x3F	; 63
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	e8 0e       	add	r14, r24
     aa0:	f9 1e       	adc	r15, r25
     aa2:	0a 1f       	adc	r16, r26
     aa4:	1b 1f       	adc	r17, r27
     aa6:	17 ff       	sbrs	r17, 7
     aa8:	05 c0       	rjmp	.+10     	; 0xab4 <__pack_f+0x162>
     aaa:	16 95       	lsr	r17
     aac:	07 95       	ror	r16
     aae:	f7 94       	ror	r15
     ab0:	e7 94       	ror	r14
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	87 e0       	ldi	r24, 0x07	; 7
     ab6:	16 95       	lsr	r17
     ab8:	07 95       	ror	r16
     aba:	f7 94       	ror	r15
     abc:	e7 94       	ror	r14
     abe:	8a 95       	dec	r24
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <__pack_f+0x164>
     ac2:	05 c0       	rjmp	.+10     	; 0xace <__pack_f+0x17c>
     ac4:	ee 24       	eor	r14, r14
     ac6:	ff 24       	eor	r15, r15
     ac8:	87 01       	movw	r16, r14
     aca:	ef ef       	ldi	r30, 0xFF	; 255
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	6e 2f       	mov	r22, r30
     ad0:	67 95       	ror	r22
     ad2:	66 27       	eor	r22, r22
     ad4:	67 95       	ror	r22
     ad6:	90 2f       	mov	r25, r16
     ad8:	9f 77       	andi	r25, 0x7F	; 127
     ada:	d7 94       	ror	r13
     adc:	dd 24       	eor	r13, r13
     ade:	d7 94       	ror	r13
     ae0:	8e 2f       	mov	r24, r30
     ae2:	86 95       	lsr	r24
     ae4:	49 2f       	mov	r20, r25
     ae6:	46 2b       	or	r20, r22
     ae8:	58 2f       	mov	r21, r24
     aea:	5d 29       	or	r21, r13
     aec:	b7 01       	movw	r22, r14
     aee:	ca 01       	movw	r24, r20
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	08 95       	ret

00000afc <__unpack_f>:
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22
     b00:	40 81       	ld	r20, Z
     b02:	51 81       	ldd	r21, Z+1	; 0x01
     b04:	22 81       	ldd	r18, Z+2	; 0x02
     b06:	62 2f       	mov	r22, r18
     b08:	6f 77       	andi	r22, 0x7F	; 127
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	22 1f       	adc	r18, r18
     b0e:	22 27       	eor	r18, r18
     b10:	22 1f       	adc	r18, r18
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	89 2f       	mov	r24, r25
     b16:	88 0f       	add	r24, r24
     b18:	82 2b       	or	r24, r18
     b1a:	28 2f       	mov	r18, r24
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	99 1f       	adc	r25, r25
     b20:	99 27       	eor	r25, r25
     b22:	99 1f       	adc	r25, r25
     b24:	11 96       	adiw	r26, 0x01	; 1
     b26:	9c 93       	st	X, r25
     b28:	11 97       	sbiw	r26, 0x01	; 1
     b2a:	21 15       	cp	r18, r1
     b2c:	31 05       	cpc	r19, r1
     b2e:	a9 f5       	brne	.+106    	; 0xb9a <__unpack_f+0x9e>
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	61 05       	cpc	r22, r1
     b36:	71 05       	cpc	r23, r1
     b38:	11 f4       	brne	.+4      	; 0xb3e <__unpack_f+0x42>
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	37 c0       	rjmp	.+110    	; 0xbac <__unpack_f+0xb0>
     b3e:	82 e8       	ldi	r24, 0x82	; 130
     b40:	9f ef       	ldi	r25, 0xFF	; 255
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	9c 93       	st	X, r25
     b46:	8e 93       	st	-X, r24
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	9a 01       	movw	r18, r20
     b4c:	ab 01       	movw	r20, r22
     b4e:	67 e0       	ldi	r22, 0x07	; 7
     b50:	22 0f       	add	r18, r18
     b52:	33 1f       	adc	r19, r19
     b54:	44 1f       	adc	r20, r20
     b56:	55 1f       	adc	r21, r21
     b58:	6a 95       	dec	r22
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__unpack_f+0x54>
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	8c 93       	st	X, r24
     b60:	0d c0       	rjmp	.+26     	; 0xb7c <__unpack_f+0x80>
     b62:	22 0f       	add	r18, r18
     b64:	33 1f       	adc	r19, r19
     b66:	44 1f       	adc	r20, r20
     b68:	55 1f       	adc	r21, r21
     b6a:	12 96       	adiw	r26, 0x02	; 2
     b6c:	8d 91       	ld	r24, X+
     b6e:	9c 91       	ld	r25, X
     b70:	13 97       	sbiw	r26, 0x03	; 3
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	13 96       	adiw	r26, 0x03	; 3
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	20 30       	cpi	r18, 0x00	; 0
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	38 07       	cpc	r19, r24
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	48 07       	cpc	r20, r24
     b86:	80 e4       	ldi	r24, 0x40	; 64
     b88:	58 07       	cpc	r21, r24
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <__unpack_f+0x66>
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	2d 93       	st	X+, r18
     b90:	3d 93       	st	X+, r19
     b92:	4d 93       	st	X+, r20
     b94:	5c 93       	st	X, r21
     b96:	17 97       	sbiw	r26, 0x07	; 7
     b98:	08 95       	ret
     b9a:	2f 3f       	cpi	r18, 0xFF	; 255
     b9c:	31 05       	cpc	r19, r1
     b9e:	79 f4       	brne	.+30     	; 0xbbe <__unpack_f+0xc2>
     ba0:	41 15       	cp	r20, r1
     ba2:	51 05       	cpc	r21, r1
     ba4:	61 05       	cpc	r22, r1
     ba6:	71 05       	cpc	r23, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <__unpack_f+0xb4>
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	8c 93       	st	X, r24
     bae:	08 95       	ret
     bb0:	64 ff       	sbrs	r22, 4
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <__unpack_f+0xbe>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	12 c0       	rjmp	.+36     	; 0xbde <__unpack_f+0xe2>
     bba:	1c 92       	st	X, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <__unpack_f+0xe2>
     bbe:	2f 57       	subi	r18, 0x7F	; 127
     bc0:	30 40       	sbci	r19, 0x00	; 0
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	3c 93       	st	X, r19
     bc6:	2e 93       	st	-X, r18
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	8c 93       	st	X, r24
     bce:	87 e0       	ldi	r24, 0x07	; 7
     bd0:	44 0f       	add	r20, r20
     bd2:	55 1f       	adc	r21, r21
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	8a 95       	dec	r24
     bda:	d1 f7       	brne	.-12     	; 0xbd0 <__unpack_f+0xd4>
     bdc:	70 64       	ori	r23, 0x40	; 64
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	4d 93       	st	X+, r20
     be2:	5d 93       	st	X+, r21
     be4:	6d 93       	st	X+, r22
     be6:	7c 93       	st	X, r23
     be8:	17 97       	sbiw	r26, 0x07	; 7
     bea:	08 95       	ret

00000bec <__fpcmp_parts_f>:
     bec:	1f 93       	push	r17
     bee:	dc 01       	movw	r26, r24
     bf0:	fb 01       	movw	r30, r22
     bf2:	9c 91       	ld	r25, X
     bf4:	92 30       	cpi	r25, 0x02	; 2
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <__fpcmp_parts_f+0xe>
     bf8:	47 c0       	rjmp	.+142    	; 0xc88 <__fpcmp_parts_f+0x9c>
     bfa:	80 81       	ld	r24, Z
     bfc:	82 30       	cpi	r24, 0x02	; 2
     bfe:	08 f4       	brcc	.+2      	; 0xc02 <__fpcmp_parts_f+0x16>
     c00:	43 c0       	rjmp	.+134    	; 0xc88 <__fpcmp_parts_f+0x9c>
     c02:	94 30       	cpi	r25, 0x04	; 4
     c04:	51 f4       	brne	.+20     	; 0xc1a <__fpcmp_parts_f+0x2e>
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	1c 91       	ld	r17, X
     c0a:	84 30       	cpi	r24, 0x04	; 4
     c0c:	99 f5       	brne	.+102    	; 0xc74 <__fpcmp_parts_f+0x88>
     c0e:	81 81       	ldd	r24, Z+1	; 0x01
     c10:	68 2f       	mov	r22, r24
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	61 1b       	sub	r22, r17
     c16:	71 09       	sbc	r23, r1
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <__fpcmp_parts_f+0xac>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	21 f0       	breq	.+8      	; 0xc26 <__fpcmp_parts_f+0x3a>
     c1e:	92 30       	cpi	r25, 0x02	; 2
     c20:	31 f4       	brne	.+12     	; 0xc2e <__fpcmp_parts_f+0x42>
     c22:	82 30       	cpi	r24, 0x02	; 2
     c24:	b9 f1       	breq	.+110    	; 0xc94 <__fpcmp_parts_f+0xa8>
     c26:	81 81       	ldd	r24, Z+1	; 0x01
     c28:	88 23       	and	r24, r24
     c2a:	89 f1       	breq	.+98     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c2c:	2d c0       	rjmp	.+90     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	1c 91       	ld	r17, X
     c32:	11 97       	sbiw	r26, 0x01	; 1
     c34:	82 30       	cpi	r24, 0x02	; 2
     c36:	f1 f0       	breq	.+60     	; 0xc74 <__fpcmp_parts_f+0x88>
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	18 17       	cp	r17, r24
     c3c:	d9 f4       	brne	.+54     	; 0xc74 <__fpcmp_parts_f+0x88>
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	2d 91       	ld	r18, X+
     c42:	3c 91       	ld	r19, X
     c44:	13 97       	sbiw	r26, 0x03	; 3
     c46:	82 81       	ldd	r24, Z+2	; 0x02
     c48:	93 81       	ldd	r25, Z+3	; 0x03
     c4a:	82 17       	cp	r24, r18
     c4c:	93 07       	cpc	r25, r19
     c4e:	94 f0       	brlt	.+36     	; 0xc74 <__fpcmp_parts_f+0x88>
     c50:	28 17       	cp	r18, r24
     c52:	39 07       	cpc	r19, r25
     c54:	bc f0       	brlt	.+46     	; 0xc84 <__fpcmp_parts_f+0x98>
     c56:	14 96       	adiw	r26, 0x04	; 4
     c58:	8d 91       	ld	r24, X+
     c5a:	9d 91       	ld	r25, X+
     c5c:	0d 90       	ld	r0, X+
     c5e:	bc 91       	ld	r27, X
     c60:	a0 2d       	mov	r26, r0
     c62:	24 81       	ldd	r18, Z+4	; 0x04
     c64:	35 81       	ldd	r19, Z+5	; 0x05
     c66:	46 81       	ldd	r20, Z+6	; 0x06
     c68:	57 81       	ldd	r21, Z+7	; 0x07
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	4a 07       	cpc	r20, r26
     c70:	5b 07       	cpc	r21, r27
     c72:	18 f4       	brcc	.+6      	; 0xc7a <__fpcmp_parts_f+0x8e>
     c74:	11 23       	and	r17, r17
     c76:	41 f0       	breq	.+16     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c78:	0a c0       	rjmp	.+20     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c7a:	82 17       	cp	r24, r18
     c7c:	93 07       	cpc	r25, r19
     c7e:	a4 07       	cpc	r26, r20
     c80:	b5 07       	cpc	r27, r21
     c82:	40 f4       	brcc	.+16     	; 0xc94 <__fpcmp_parts_f+0xa8>
     c84:	11 23       	and	r17, r17
     c86:	19 f0       	breq	.+6      	; 0xc8e <__fpcmp_parts_f+0xa2>
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	70 e0       	ldi	r23, 0x00	; 0
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <__fpcmp_parts_f+0xac>
     c8e:	6f ef       	ldi	r22, 0xFF	; 255
     c90:	7f ef       	ldi	r23, 0xFF	; 255
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <__fpcmp_parts_f+0xac>
     c94:	60 e0       	ldi	r22, 0x00	; 0
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	cb 01       	movw	r24, r22
     c9a:	1f 91       	pop	r17
     c9c:	08 95       	ret

00000c9e <DIO_voidInit>:
#include "DIO_interface.h"
#include "DIO_private.h"
#include "DIO_config.h"

void DIO_voidInit(void)
{
     c9e:	df 93       	push	r29
     ca0:	cf 93       	push	r28
     ca2:	cd b7       	in	r28, 0x3d	; 61
     ca4:	de b7       	in	r29, 0x3e	; 62
	DIO_u8_DDRA_REG = Conc(DIO_u8_PA7_INTIAL_DIRECTION, DIO_u8_PA6_INTIAL_DIRECTION, DIO_u8_PA5_INTIAL_DIRECTION, DIO_u8_PA4_INTIAL_DIRECTION,DIO_u8_PA3_INTIAL_DIRECTION, DIO_u8_PA2_INTIAL_DIRECTION, DIO_u8_PA1_INTIAL_DIRECTION, DIO_u8_PA0_INTIAL_DIRECTION);
     ca6:	ea e3       	ldi	r30, 0x3A	; 58
     ca8:	f0 e0       	ldi	r31, 0x00	; 0
     caa:	87 e0       	ldi	r24, 0x07	; 7
     cac:	80 83       	st	Z, r24

	DIO_u8_DDRB_REG = Conc(DIO_u8_PB7_INTIAL_DIRECTION, DIO_u8_PB6_INTIAL_DIRECTION, DIO_u8_PB5_INTIAL_DIRECTION, DIO_u8_PB4_INTIAL_DIRECTION,DIO_u8_PB3_INTIAL_DIRECTION, DIO_u8_PB2_INTIAL_DIRECTION, DIO_u8_PB1_INTIAL_DIRECTION, DIO_u8_PB0_INTIAL_DIRECTION);
     cae:	e7 e3       	ldi	r30, 0x37	; 55
     cb0:	f0 e0       	ldi	r31, 0x00	; 0
     cb2:	10 82       	st	Z, r1

	DIO_u8_DDRC_REG = Conc(DIO_u8_PC7_INTIAL_DIRECTION, DIO_u8_PC6_INTIAL_DIRECTION, DIO_u8_PC5_INTIAL_DIRECTION, DIO_u8_PC4_INTIAL_DIRECTION,DIO_u8_PC3_INTIAL_DIRECTION, DIO_u8_PC2_INTIAL_DIRECTION, DIO_u8_PC1_INTIAL_DIRECTION, DIO_u8_PC0_INTIAL_DIRECTION);
     cb4:	e4 e3       	ldi	r30, 0x34	; 52
     cb6:	f0 e0       	ldi	r31, 0x00	; 0
     cb8:	8f ef       	ldi	r24, 0xFF	; 255
     cba:	80 83       	st	Z, r24

	DIO_u8_DDRD_REG = Conc(DIO_u8_PD7_INTIAL_DIRECTION, DIO_u8_PD6_INTIAL_DIRECTION, DIO_u8_PD5_INTIAL_DIRECTION, DIO_u8_PD4_INTIAL_DIRECTION,DIO_u8_PD3_INTIAL_DIRECTION, DIO_u8_PD2_INTIAL_DIRECTION, DIO_u8_PD1_INTIAL_DIRECTION, DIO_u8_PD0_INTIAL_DIRECTION);
     cbc:	e1 e3       	ldi	r30, 0x31	; 49
     cbe:	f0 e0       	ldi	r31, 0x00	; 0
     cc0:	10 82       	st	Z, r1


	DIO_u8_PORTA_REG = Conc(DIO_u8_PA7_INTIAL_VALUE, DIO_u8_PA6_INTIAL_VALUE, DIO_u8_PA5_INTIAL_VALUE, DIO_u8_PA4_INTIAL_VALUE,DIO_u8_PA3_INTIAL_VALUE, DIO_u8_PA2_INTIAL_VALUE, DIO_u8_PA1_INTIAL_VALUE, DIO_u8_PA0_INTIAL_VALUE);
     cc2:	eb e3       	ldi	r30, 0x3B	; 59
     cc4:	f0 e0       	ldi	r31, 0x00	; 0
     cc6:	10 82       	st	Z, r1

	DIO_u8_PORTB_REG = Conc(DIO_u8_PB7_INTIAL_VALUE, DIO_u8_PB6_INTIAL_VALUE, DIO_u8_PB5_INTIAL_VALUE, DIO_u8_PB4_INTIAL_VALUE,DIO_u8_PB3_INTIAL_VALUE, DIO_u8_PB2_INTIAL_VALUE, DIO_u8_PB1_INTIAL_VALUE, DIO_u8_PB0_INTIAL_VALUE);
     cc8:	e8 e3       	ldi	r30, 0x38	; 56
     cca:	f0 e0       	ldi	r31, 0x00	; 0
     ccc:	10 82       	st	Z, r1

	DIO_u8_PORTC_REG = Conc(DIO_u8_PC7_INTIAL_VALUE, DIO_u8_PC6_INTIAL_VALUE, DIO_u8_PC5_INTIAL_VALUE, DIO_u8_PC4_INTIAL_VALUE,DIO_u8_PC3_INTIAL_VALUE, DIO_u8_PC2_INTIAL_VALUE, DIO_u8_PC1_INTIAL_VALUE, DIO_u8_PC0_INTIAL_VALUE);
     cce:	e5 e3       	ldi	r30, 0x35	; 53
     cd0:	f0 e0       	ldi	r31, 0x00	; 0
     cd2:	10 82       	st	Z, r1

	DIO_u8_PORTD_REG = Conc(DIO_u8_PD7_INTIAL_VALUE, DIO_u8_PD6_INTIAL_VALUE, DIO_u8_PD5_INTIAL_VALUE, DIO_u8_PD4_INTIAL_VALUE,DIO_u8_PD3_INTIAL_VALUE, DIO_u8_PD2_INTIAL_VALUE, DIO_u8_PD1_INTIAL_VALUE, DIO_u8_PD0_INTIAL_VALUE);
     cd4:	e2 e3       	ldi	r30, 0x32	; 50
     cd6:	f0 e0       	ldi	r31, 0x00	; 0
     cd8:	10 82       	st	Z, r1

}
     cda:	cf 91       	pop	r28
     cdc:	df 91       	pop	r29
     cde:	08 95       	ret

00000ce0 <DIO_u8SetPinDirection>:


u8 DIO_u8SetPinDirection(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8PinDirection)
{
     ce0:	df 93       	push	r29
     ce2:	cf 93       	push	r28
     ce4:	cd b7       	in	r28, 0x3d	; 61
     ce6:	de b7       	in	r29, 0x3e	; 62
     ce8:	2e 97       	sbiw	r28, 0x0e	; 14
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	de bf       	out	0x3e, r29	; 62
     cf0:	0f be       	out	0x3f, r0	; 63
     cf2:	cd bf       	out	0x3d, r28	; 61
     cf4:	8a 83       	std	Y+2, r24	; 0x02
     cf6:	6b 83       	std	Y+3, r22	; 0x03
     cf8:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState = STD_TYPES_OK;
     cfa:	81 e0       	ldi	r24, 0x01	; 1
     cfc:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortId <= DIO_u8_PORTD) && (Copy_u8PinId <= DIO_u8_PIN7)&&((Copy_u8PinDirection == DIO_u8_INPUT)||(Copy_u8PinDirection == DIO_u8_OUTPUT)))
     cfe:	8a 81       	ldd	r24, Y+2	; 0x02
     d00:	84 30       	cpi	r24, 0x04	; 4
     d02:	08 f0       	brcs	.+2      	; 0xd06 <DIO_u8SetPinDirection+0x26>
     d04:	0d c1       	rjmp	.+538    	; 0xf20 <DIO_u8SetPinDirection+0x240>
     d06:	8b 81       	ldd	r24, Y+3	; 0x03
     d08:	88 30       	cpi	r24, 0x08	; 8
     d0a:	08 f0       	brcs	.+2      	; 0xd0e <DIO_u8SetPinDirection+0x2e>
     d0c:	09 c1       	rjmp	.+530    	; 0xf20 <DIO_u8SetPinDirection+0x240>
     d0e:	8c 81       	ldd	r24, Y+4	; 0x04
     d10:	88 23       	and	r24, r24
     d12:	21 f0       	breq	.+8      	; 0xd1c <DIO_u8SetPinDirection+0x3c>
     d14:	8c 81       	ldd	r24, Y+4	; 0x04
     d16:	81 30       	cpi	r24, 0x01	; 1
     d18:	09 f0       	breq	.+2      	; 0xd1c <DIO_u8SetPinDirection+0x3c>
     d1a:	02 c1       	rjmp	.+516    	; 0xf20 <DIO_u8SetPinDirection+0x240>
	{
		switch(Copy_u8PortId)
     d1c:	8a 81       	ldd	r24, Y+2	; 0x02
     d1e:	28 2f       	mov	r18, r24
     d20:	30 e0       	ldi	r19, 0x00	; 0
     d22:	3e 87       	std	Y+14, r19	; 0x0e
     d24:	2d 87       	std	Y+13, r18	; 0x0d
     d26:	8d 85       	ldd	r24, Y+13	; 0x0d
     d28:	9e 85       	ldd	r25, Y+14	; 0x0e
     d2a:	81 30       	cpi	r24, 0x01	; 1
     d2c:	91 05       	cpc	r25, r1
     d2e:	09 f4       	brne	.+2      	; 0xd32 <DIO_u8SetPinDirection+0x52>
     d30:	4f c0       	rjmp	.+158    	; 0xdd0 <DIO_u8SetPinDirection+0xf0>
     d32:	2d 85       	ldd	r18, Y+13	; 0x0d
     d34:	3e 85       	ldd	r19, Y+14	; 0x0e
     d36:	22 30       	cpi	r18, 0x02	; 2
     d38:	31 05       	cpc	r19, r1
     d3a:	2c f4       	brge	.+10     	; 0xd46 <DIO_u8SetPinDirection+0x66>
     d3c:	8d 85       	ldd	r24, Y+13	; 0x0d
     d3e:	9e 85       	ldd	r25, Y+14	; 0x0e
     d40:	00 97       	sbiw	r24, 0x00	; 0
     d42:	71 f0       	breq	.+28     	; 0xd60 <DIO_u8SetPinDirection+0x80>
     d44:	ee c0       	rjmp	.+476    	; 0xf22 <DIO_u8SetPinDirection+0x242>
     d46:	2d 85       	ldd	r18, Y+13	; 0x0d
     d48:	3e 85       	ldd	r19, Y+14	; 0x0e
     d4a:	22 30       	cpi	r18, 0x02	; 2
     d4c:	31 05       	cpc	r19, r1
     d4e:	09 f4       	brne	.+2      	; 0xd52 <DIO_u8SetPinDirection+0x72>
     d50:	77 c0       	rjmp	.+238    	; 0xe40 <DIO_u8SetPinDirection+0x160>
     d52:	8d 85       	ldd	r24, Y+13	; 0x0d
     d54:	9e 85       	ldd	r25, Y+14	; 0x0e
     d56:	83 30       	cpi	r24, 0x03	; 3
     d58:	91 05       	cpc	r25, r1
     d5a:	09 f4       	brne	.+2      	; 0xd5e <DIO_u8SetPinDirection+0x7e>
     d5c:	a9 c0       	rjmp	.+338    	; 0xeb0 <DIO_u8SetPinDirection+0x1d0>
     d5e:	e1 c0       	rjmp	.+450    	; 0xf22 <DIO_u8SetPinDirection+0x242>
		{
			case DIO_u8_PORTA:
				switch(Copy_u8PinId)
     d60:	8b 81       	ldd	r24, Y+3	; 0x03
     d62:	28 2f       	mov	r18, r24
     d64:	30 e0       	ldi	r19, 0x00	; 0
     d66:	3c 87       	std	Y+12, r19	; 0x0c
     d68:	2b 87       	std	Y+11, r18	; 0x0b
     d6a:	8b 85       	ldd	r24, Y+11	; 0x0b
     d6c:	9c 85       	ldd	r25, Y+12	; 0x0c
     d6e:	00 97       	sbiw	r24, 0x00	; 0
     d70:	31 f0       	breq	.+12     	; 0xd7e <DIO_u8SetPinDirection+0x9e>
     d72:	2b 85       	ldd	r18, Y+11	; 0x0b
     d74:	3c 85       	ldd	r19, Y+12	; 0x0c
     d76:	21 30       	cpi	r18, 0x01	; 1
     d78:	31 05       	cpc	r19, r1
     d7a:	b1 f0       	breq	.+44     	; 0xda8 <DIO_u8SetPinDirection+0xc8>
     d7c:	d2 c0       	rjmp	.+420    	; 0xf22 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRA_REG,Copy_u8PinId);break;
     d7e:	aa e3       	ldi	r26, 0x3A	; 58
     d80:	b0 e0       	ldi	r27, 0x00	; 0
     d82:	ea e3       	ldi	r30, 0x3A	; 58
     d84:	f0 e0       	ldi	r31, 0x00	; 0
     d86:	80 81       	ld	r24, Z
     d88:	48 2f       	mov	r20, r24
     d8a:	8b 81       	ldd	r24, Y+3	; 0x03
     d8c:	28 2f       	mov	r18, r24
     d8e:	30 e0       	ldi	r19, 0x00	; 0
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	90 e0       	ldi	r25, 0x00	; 0
     d94:	02 2e       	mov	r0, r18
     d96:	02 c0       	rjmp	.+4      	; 0xd9c <DIO_u8SetPinDirection+0xbc>
     d98:	88 0f       	add	r24, r24
     d9a:	99 1f       	adc	r25, r25
     d9c:	0a 94       	dec	r0
     d9e:	e2 f7       	brpl	.-8      	; 0xd98 <DIO_u8SetPinDirection+0xb8>
     da0:	80 95       	com	r24
     da2:	84 23       	and	r24, r20
     da4:	8c 93       	st	X, r24
     da6:	bd c0       	rjmp	.+378    	; 0xf22 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRA_REG,Copy_u8PinId);break;
     da8:	aa e3       	ldi	r26, 0x3A	; 58
     daa:	b0 e0       	ldi	r27, 0x00	; 0
     dac:	ea e3       	ldi	r30, 0x3A	; 58
     dae:	f0 e0       	ldi	r31, 0x00	; 0
     db0:	80 81       	ld	r24, Z
     db2:	48 2f       	mov	r20, r24
     db4:	8b 81       	ldd	r24, Y+3	; 0x03
     db6:	28 2f       	mov	r18, r24
     db8:	30 e0       	ldi	r19, 0x00	; 0
     dba:	81 e0       	ldi	r24, 0x01	; 1
     dbc:	90 e0       	ldi	r25, 0x00	; 0
     dbe:	02 2e       	mov	r0, r18
     dc0:	02 c0       	rjmp	.+4      	; 0xdc6 <DIO_u8SetPinDirection+0xe6>
     dc2:	88 0f       	add	r24, r24
     dc4:	99 1f       	adc	r25, r25
     dc6:	0a 94       	dec	r0
     dc8:	e2 f7       	brpl	.-8      	; 0xdc2 <DIO_u8SetPinDirection+0xe2>
     dca:	84 2b       	or	r24, r20
     dcc:	8c 93       	st	X, r24
     dce:	a9 c0       	rjmp	.+338    	; 0xf22 <DIO_u8SetPinDirection+0x242>
				}
			break;
			case DIO_u8_PORTB:
				switch(Copy_u8PinId)
     dd0:	8b 81       	ldd	r24, Y+3	; 0x03
     dd2:	28 2f       	mov	r18, r24
     dd4:	30 e0       	ldi	r19, 0x00	; 0
     dd6:	3a 87       	std	Y+10, r19	; 0x0a
     dd8:	29 87       	std	Y+9, r18	; 0x09
     dda:	89 85       	ldd	r24, Y+9	; 0x09
     ddc:	9a 85       	ldd	r25, Y+10	; 0x0a
     dde:	00 97       	sbiw	r24, 0x00	; 0
     de0:	31 f0       	breq	.+12     	; 0xdee <DIO_u8SetPinDirection+0x10e>
     de2:	29 85       	ldd	r18, Y+9	; 0x09
     de4:	3a 85       	ldd	r19, Y+10	; 0x0a
     de6:	21 30       	cpi	r18, 0x01	; 1
     de8:	31 05       	cpc	r19, r1
     dea:	b1 f0       	breq	.+44     	; 0xe18 <DIO_u8SetPinDirection+0x138>
     dec:	9a c0       	rjmp	.+308    	; 0xf22 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRB_REG,Copy_u8PinId);break;
     dee:	a7 e3       	ldi	r26, 0x37	; 55
     df0:	b0 e0       	ldi	r27, 0x00	; 0
     df2:	e7 e3       	ldi	r30, 0x37	; 55
     df4:	f0 e0       	ldi	r31, 0x00	; 0
     df6:	80 81       	ld	r24, Z
     df8:	48 2f       	mov	r20, r24
     dfa:	8b 81       	ldd	r24, Y+3	; 0x03
     dfc:	28 2f       	mov	r18, r24
     dfe:	30 e0       	ldi	r19, 0x00	; 0
     e00:	81 e0       	ldi	r24, 0x01	; 1
     e02:	90 e0       	ldi	r25, 0x00	; 0
     e04:	02 2e       	mov	r0, r18
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <DIO_u8SetPinDirection+0x12c>
     e08:	88 0f       	add	r24, r24
     e0a:	99 1f       	adc	r25, r25
     e0c:	0a 94       	dec	r0
     e0e:	e2 f7       	brpl	.-8      	; 0xe08 <DIO_u8SetPinDirection+0x128>
     e10:	80 95       	com	r24
     e12:	84 23       	and	r24, r20
     e14:	8c 93       	st	X, r24
     e16:	85 c0       	rjmp	.+266    	; 0xf22 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRB_REG,Copy_u8PinId);break;
     e18:	a7 e3       	ldi	r26, 0x37	; 55
     e1a:	b0 e0       	ldi	r27, 0x00	; 0
     e1c:	e7 e3       	ldi	r30, 0x37	; 55
     e1e:	f0 e0       	ldi	r31, 0x00	; 0
     e20:	80 81       	ld	r24, Z
     e22:	48 2f       	mov	r20, r24
     e24:	8b 81       	ldd	r24, Y+3	; 0x03
     e26:	28 2f       	mov	r18, r24
     e28:	30 e0       	ldi	r19, 0x00	; 0
     e2a:	81 e0       	ldi	r24, 0x01	; 1
     e2c:	90 e0       	ldi	r25, 0x00	; 0
     e2e:	02 2e       	mov	r0, r18
     e30:	02 c0       	rjmp	.+4      	; 0xe36 <DIO_u8SetPinDirection+0x156>
     e32:	88 0f       	add	r24, r24
     e34:	99 1f       	adc	r25, r25
     e36:	0a 94       	dec	r0
     e38:	e2 f7       	brpl	.-8      	; 0xe32 <DIO_u8SetPinDirection+0x152>
     e3a:	84 2b       	or	r24, r20
     e3c:	8c 93       	st	X, r24
     e3e:	71 c0       	rjmp	.+226    	; 0xf22 <DIO_u8SetPinDirection+0x242>
				}
			break;
			case DIO_u8_PORTC:
				switch(Copy_u8PinId)
     e40:	8b 81       	ldd	r24, Y+3	; 0x03
     e42:	28 2f       	mov	r18, r24
     e44:	30 e0       	ldi	r19, 0x00	; 0
     e46:	38 87       	std	Y+8, r19	; 0x08
     e48:	2f 83       	std	Y+7, r18	; 0x07
     e4a:	8f 81       	ldd	r24, Y+7	; 0x07
     e4c:	98 85       	ldd	r25, Y+8	; 0x08
     e4e:	00 97       	sbiw	r24, 0x00	; 0
     e50:	31 f0       	breq	.+12     	; 0xe5e <DIO_u8SetPinDirection+0x17e>
     e52:	2f 81       	ldd	r18, Y+7	; 0x07
     e54:	38 85       	ldd	r19, Y+8	; 0x08
     e56:	21 30       	cpi	r18, 0x01	; 1
     e58:	31 05       	cpc	r19, r1
     e5a:	b1 f0       	breq	.+44     	; 0xe88 <DIO_u8SetPinDirection+0x1a8>
     e5c:	62 c0       	rjmp	.+196    	; 0xf22 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRC_REG,Copy_u8PinId);break;
     e5e:	a4 e3       	ldi	r26, 0x34	; 52
     e60:	b0 e0       	ldi	r27, 0x00	; 0
     e62:	e4 e3       	ldi	r30, 0x34	; 52
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	48 2f       	mov	r20, r24
     e6a:	8b 81       	ldd	r24, Y+3	; 0x03
     e6c:	28 2f       	mov	r18, r24
     e6e:	30 e0       	ldi	r19, 0x00	; 0
     e70:	81 e0       	ldi	r24, 0x01	; 1
     e72:	90 e0       	ldi	r25, 0x00	; 0
     e74:	02 2e       	mov	r0, r18
     e76:	02 c0       	rjmp	.+4      	; 0xe7c <DIO_u8SetPinDirection+0x19c>
     e78:	88 0f       	add	r24, r24
     e7a:	99 1f       	adc	r25, r25
     e7c:	0a 94       	dec	r0
     e7e:	e2 f7       	brpl	.-8      	; 0xe78 <DIO_u8SetPinDirection+0x198>
     e80:	80 95       	com	r24
     e82:	84 23       	and	r24, r20
     e84:	8c 93       	st	X, r24
     e86:	4d c0       	rjmp	.+154    	; 0xf22 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRC_REG,Copy_u8PinId);break;
     e88:	a4 e3       	ldi	r26, 0x34	; 52
     e8a:	b0 e0       	ldi	r27, 0x00	; 0
     e8c:	e4 e3       	ldi	r30, 0x34	; 52
     e8e:	f0 e0       	ldi	r31, 0x00	; 0
     e90:	80 81       	ld	r24, Z
     e92:	48 2f       	mov	r20, r24
     e94:	8b 81       	ldd	r24, Y+3	; 0x03
     e96:	28 2f       	mov	r18, r24
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	81 e0       	ldi	r24, 0x01	; 1
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	02 2e       	mov	r0, r18
     ea0:	02 c0       	rjmp	.+4      	; 0xea6 <DIO_u8SetPinDirection+0x1c6>
     ea2:	88 0f       	add	r24, r24
     ea4:	99 1f       	adc	r25, r25
     ea6:	0a 94       	dec	r0
     ea8:	e2 f7       	brpl	.-8      	; 0xea2 <DIO_u8SetPinDirection+0x1c2>
     eaa:	84 2b       	or	r24, r20
     eac:	8c 93       	st	X, r24
     eae:	39 c0       	rjmp	.+114    	; 0xf22 <DIO_u8SetPinDirection+0x242>
				}
			break;
			case DIO_u8_PORTD:
				switch(Copy_u8PinId)
     eb0:	8b 81       	ldd	r24, Y+3	; 0x03
     eb2:	28 2f       	mov	r18, r24
     eb4:	30 e0       	ldi	r19, 0x00	; 0
     eb6:	3e 83       	std	Y+6, r19	; 0x06
     eb8:	2d 83       	std	Y+5, r18	; 0x05
     eba:	8d 81       	ldd	r24, Y+5	; 0x05
     ebc:	9e 81       	ldd	r25, Y+6	; 0x06
     ebe:	00 97       	sbiw	r24, 0x00	; 0
     ec0:	31 f0       	breq	.+12     	; 0xece <DIO_u8SetPinDirection+0x1ee>
     ec2:	2d 81       	ldd	r18, Y+5	; 0x05
     ec4:	3e 81       	ldd	r19, Y+6	; 0x06
     ec6:	21 30       	cpi	r18, 0x01	; 1
     ec8:	31 05       	cpc	r19, r1
     eca:	b1 f0       	breq	.+44     	; 0xef8 <DIO_u8SetPinDirection+0x218>
     ecc:	2a c0       	rjmp	.+84     	; 0xf22 <DIO_u8SetPinDirection+0x242>
				{
					case DIO_u8_INPUT:CLR_BIT(DIO_u8_DDRD_REG,Copy_u8PinId);break;
     ece:	a1 e3       	ldi	r26, 0x31	; 49
     ed0:	b0 e0       	ldi	r27, 0x00	; 0
     ed2:	e1 e3       	ldi	r30, 0x31	; 49
     ed4:	f0 e0       	ldi	r31, 0x00	; 0
     ed6:	80 81       	ld	r24, Z
     ed8:	48 2f       	mov	r20, r24
     eda:	8b 81       	ldd	r24, Y+3	; 0x03
     edc:	28 2f       	mov	r18, r24
     ede:	30 e0       	ldi	r19, 0x00	; 0
     ee0:	81 e0       	ldi	r24, 0x01	; 1
     ee2:	90 e0       	ldi	r25, 0x00	; 0
     ee4:	02 2e       	mov	r0, r18
     ee6:	02 c0       	rjmp	.+4      	; 0xeec <DIO_u8SetPinDirection+0x20c>
     ee8:	88 0f       	add	r24, r24
     eea:	99 1f       	adc	r25, r25
     eec:	0a 94       	dec	r0
     eee:	e2 f7       	brpl	.-8      	; 0xee8 <DIO_u8SetPinDirection+0x208>
     ef0:	80 95       	com	r24
     ef2:	84 23       	and	r24, r20
     ef4:	8c 93       	st	X, r24
     ef6:	15 c0       	rjmp	.+42     	; 0xf22 <DIO_u8SetPinDirection+0x242>
					case DIO_u8_OUTPUT:SET_BIT(DIO_u8_DDRD_REG,Copy_u8PinId);break;
     ef8:	a1 e3       	ldi	r26, 0x31	; 49
     efa:	b0 e0       	ldi	r27, 0x00	; 0
     efc:	e1 e3       	ldi	r30, 0x31	; 49
     efe:	f0 e0       	ldi	r31, 0x00	; 0
     f00:	80 81       	ld	r24, Z
     f02:	48 2f       	mov	r20, r24
     f04:	8b 81       	ldd	r24, Y+3	; 0x03
     f06:	28 2f       	mov	r18, r24
     f08:	30 e0       	ldi	r19, 0x00	; 0
     f0a:	81 e0       	ldi	r24, 0x01	; 1
     f0c:	90 e0       	ldi	r25, 0x00	; 0
     f0e:	02 2e       	mov	r0, r18
     f10:	02 c0       	rjmp	.+4      	; 0xf16 <DIO_u8SetPinDirection+0x236>
     f12:	88 0f       	add	r24, r24
     f14:	99 1f       	adc	r25, r25
     f16:	0a 94       	dec	r0
     f18:	e2 f7       	brpl	.-8      	; 0xf12 <DIO_u8SetPinDirection+0x232>
     f1a:	84 2b       	or	r24, r20
     f1c:	8c 93       	st	X, r24
     f1e:	01 c0       	rjmp	.+2      	; 0xf22 <DIO_u8SetPinDirection+0x242>
			break;
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
     f20:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
     f22:	89 81       	ldd	r24, Y+1	; 0x01
}
     f24:	2e 96       	adiw	r28, 0x0e	; 14
     f26:	0f b6       	in	r0, 0x3f	; 63
     f28:	f8 94       	cli
     f2a:	de bf       	out	0x3e, r29	; 62
     f2c:	0f be       	out	0x3f, r0	; 63
     f2e:	cd bf       	out	0x3d, r28	; 61
     f30:	cf 91       	pop	r28
     f32:	df 91       	pop	r29
     f34:	08 95       	ret

00000f36 <DIO_u8SetPinValue>:

u8 DIO_u8SetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 Copy_u8PinValue)
{
     f36:	df 93       	push	r29
     f38:	cf 93       	push	r28
     f3a:	cd b7       	in	r28, 0x3d	; 61
     f3c:	de b7       	in	r29, 0x3e	; 62
     f3e:	2e 97       	sbiw	r28, 0x0e	; 14
     f40:	0f b6       	in	r0, 0x3f	; 63
     f42:	f8 94       	cli
     f44:	de bf       	out	0x3e, r29	; 62
     f46:	0f be       	out	0x3f, r0	; 63
     f48:	cd bf       	out	0x3d, r28	; 61
     f4a:	8a 83       	std	Y+2, r24	; 0x02
     f4c:	6b 83       	std	Y+3, r22	; 0x03
     f4e:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState = STD_TYPES_OK;
     f50:	81 e0       	ldi	r24, 0x01	; 1
     f52:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8PinId <= DIO_u8_PIN7)
     f54:	8b 81       	ldd	r24, Y+3	; 0x03
     f56:	88 30       	cpi	r24, 0x08	; 8
     f58:	08 f0       	brcs	.+2      	; 0xf5c <DIO_u8SetPinValue+0x26>
     f5a:	0c c1       	rjmp	.+536    	; 0x1174 <DIO_u8SetPinValue+0x23e>
	{
		switch(Copy_u8PortId)
     f5c:	8a 81       	ldd	r24, Y+2	; 0x02
     f5e:	28 2f       	mov	r18, r24
     f60:	30 e0       	ldi	r19, 0x00	; 0
     f62:	3e 87       	std	Y+14, r19	; 0x0e
     f64:	2d 87       	std	Y+13, r18	; 0x0d
     f66:	8d 85       	ldd	r24, Y+13	; 0x0d
     f68:	9e 85       	ldd	r25, Y+14	; 0x0e
     f6a:	81 30       	cpi	r24, 0x01	; 1
     f6c:	91 05       	cpc	r25, r1
     f6e:	09 f4       	brne	.+2      	; 0xf72 <DIO_u8SetPinValue+0x3c>
     f70:	51 c0       	rjmp	.+162    	; 0x1014 <DIO_u8SetPinValue+0xde>
     f72:	2d 85       	ldd	r18, Y+13	; 0x0d
     f74:	3e 85       	ldd	r19, Y+14	; 0x0e
     f76:	22 30       	cpi	r18, 0x02	; 2
     f78:	31 05       	cpc	r19, r1
     f7a:	2c f4       	brge	.+10     	; 0xf86 <DIO_u8SetPinValue+0x50>
     f7c:	8d 85       	ldd	r24, Y+13	; 0x0d
     f7e:	9e 85       	ldd	r25, Y+14	; 0x0e
     f80:	00 97       	sbiw	r24, 0x00	; 0
     f82:	71 f0       	breq	.+28     	; 0xfa0 <DIO_u8SetPinValue+0x6a>
     f84:	f5 c0       	rjmp	.+490    	; 0x1170 <DIO_u8SetPinValue+0x23a>
     f86:	2d 85       	ldd	r18, Y+13	; 0x0d
     f88:	3e 85       	ldd	r19, Y+14	; 0x0e
     f8a:	22 30       	cpi	r18, 0x02	; 2
     f8c:	31 05       	cpc	r19, r1
     f8e:	09 f4       	brne	.+2      	; 0xf92 <DIO_u8SetPinValue+0x5c>
     f90:	7b c0       	rjmp	.+246    	; 0x1088 <DIO_u8SetPinValue+0x152>
     f92:	8d 85       	ldd	r24, Y+13	; 0x0d
     f94:	9e 85       	ldd	r25, Y+14	; 0x0e
     f96:	83 30       	cpi	r24, 0x03	; 3
     f98:	91 05       	cpc	r25, r1
     f9a:	09 f4       	brne	.+2      	; 0xf9e <DIO_u8SetPinValue+0x68>
     f9c:	af c0       	rjmp	.+350    	; 0x10fc <DIO_u8SetPinValue+0x1c6>
     f9e:	e8 c0       	rjmp	.+464    	; 0x1170 <DIO_u8SetPinValue+0x23a>
		{
			case DIO_u8_PORTA:
				switch(Copy_u8PinValue)
     fa0:	8c 81       	ldd	r24, Y+4	; 0x04
     fa2:	28 2f       	mov	r18, r24
     fa4:	30 e0       	ldi	r19, 0x00	; 0
     fa6:	3c 87       	std	Y+12, r19	; 0x0c
     fa8:	2b 87       	std	Y+11, r18	; 0x0b
     faa:	8b 85       	ldd	r24, Y+11	; 0x0b
     fac:	9c 85       	ldd	r25, Y+12	; 0x0c
     fae:	00 97       	sbiw	r24, 0x00	; 0
     fb0:	31 f0       	breq	.+12     	; 0xfbe <DIO_u8SetPinValue+0x88>
     fb2:	2b 85       	ldd	r18, Y+11	; 0x0b
     fb4:	3c 85       	ldd	r19, Y+12	; 0x0c
     fb6:	21 30       	cpi	r18, 0x01	; 1
     fb8:	31 05       	cpc	r19, r1
     fba:	b1 f0       	breq	.+44     	; 0xfe8 <DIO_u8SetPinValue+0xb2>
     fbc:	29 c0       	rjmp	.+82     	; 0x1010 <DIO_u8SetPinValue+0xda>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTA_REG,Copy_u8PinId);break;
     fbe:	ab e3       	ldi	r26, 0x3B	; 59
     fc0:	b0 e0       	ldi	r27, 0x00	; 0
     fc2:	eb e3       	ldi	r30, 0x3B	; 59
     fc4:	f0 e0       	ldi	r31, 0x00	; 0
     fc6:	80 81       	ld	r24, Z
     fc8:	48 2f       	mov	r20, r24
     fca:	8b 81       	ldd	r24, Y+3	; 0x03
     fcc:	28 2f       	mov	r18, r24
     fce:	30 e0       	ldi	r19, 0x00	; 0
     fd0:	81 e0       	ldi	r24, 0x01	; 1
     fd2:	90 e0       	ldi	r25, 0x00	; 0
     fd4:	02 2e       	mov	r0, r18
     fd6:	02 c0       	rjmp	.+4      	; 0xfdc <DIO_u8SetPinValue+0xa6>
     fd8:	88 0f       	add	r24, r24
     fda:	99 1f       	adc	r25, r25
     fdc:	0a 94       	dec	r0
     fde:	e2 f7       	brpl	.-8      	; 0xfd8 <DIO_u8SetPinValue+0xa2>
     fe0:	80 95       	com	r24
     fe2:	84 23       	and	r24, r20
     fe4:	8c 93       	st	X, r24
     fe6:	c7 c0       	rjmp	.+398    	; 0x1176 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTA_REG,Copy_u8PinId);break;
     fe8:	ab e3       	ldi	r26, 0x3B	; 59
     fea:	b0 e0       	ldi	r27, 0x00	; 0
     fec:	eb e3       	ldi	r30, 0x3B	; 59
     fee:	f0 e0       	ldi	r31, 0x00	; 0
     ff0:	80 81       	ld	r24, Z
     ff2:	48 2f       	mov	r20, r24
     ff4:	8b 81       	ldd	r24, Y+3	; 0x03
     ff6:	28 2f       	mov	r18, r24
     ff8:	30 e0       	ldi	r19, 0x00	; 0
     ffa:	81 e0       	ldi	r24, 0x01	; 1
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	02 2e       	mov	r0, r18
    1000:	02 c0       	rjmp	.+4      	; 0x1006 <DIO_u8SetPinValue+0xd0>
    1002:	88 0f       	add	r24, r24
    1004:	99 1f       	adc	r25, r25
    1006:	0a 94       	dec	r0
    1008:	e2 f7       	brpl	.-8      	; 0x1002 <DIO_u8SetPinValue+0xcc>
    100a:	84 2b       	or	r24, r20
    100c:	8c 93       	st	X, r24
    100e:	b3 c0       	rjmp	.+358    	; 0x1176 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
    1010:	19 82       	std	Y+1, r1	; 0x01
    1012:	b1 c0       	rjmp	.+354    	; 0x1176 <DIO_u8SetPinValue+0x240>
				}
			break;
			case DIO_u8_PORTB:
				switch(Copy_u8PinValue)
    1014:	8c 81       	ldd	r24, Y+4	; 0x04
    1016:	28 2f       	mov	r18, r24
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	3a 87       	std	Y+10, r19	; 0x0a
    101c:	29 87       	std	Y+9, r18	; 0x09
    101e:	89 85       	ldd	r24, Y+9	; 0x09
    1020:	9a 85       	ldd	r25, Y+10	; 0x0a
    1022:	00 97       	sbiw	r24, 0x00	; 0
    1024:	31 f0       	breq	.+12     	; 0x1032 <DIO_u8SetPinValue+0xfc>
    1026:	29 85       	ldd	r18, Y+9	; 0x09
    1028:	3a 85       	ldd	r19, Y+10	; 0x0a
    102a:	21 30       	cpi	r18, 0x01	; 1
    102c:	31 05       	cpc	r19, r1
    102e:	b1 f0       	breq	.+44     	; 0x105c <DIO_u8SetPinValue+0x126>
    1030:	29 c0       	rjmp	.+82     	; 0x1084 <DIO_u8SetPinValue+0x14e>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTB_REG,Copy_u8PinId);break;
    1032:	a8 e3       	ldi	r26, 0x38	; 56
    1034:	b0 e0       	ldi	r27, 0x00	; 0
    1036:	e8 e3       	ldi	r30, 0x38	; 56
    1038:	f0 e0       	ldi	r31, 0x00	; 0
    103a:	80 81       	ld	r24, Z
    103c:	48 2f       	mov	r20, r24
    103e:	8b 81       	ldd	r24, Y+3	; 0x03
    1040:	28 2f       	mov	r18, r24
    1042:	30 e0       	ldi	r19, 0x00	; 0
    1044:	81 e0       	ldi	r24, 0x01	; 1
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	02 2e       	mov	r0, r18
    104a:	02 c0       	rjmp	.+4      	; 0x1050 <DIO_u8SetPinValue+0x11a>
    104c:	88 0f       	add	r24, r24
    104e:	99 1f       	adc	r25, r25
    1050:	0a 94       	dec	r0
    1052:	e2 f7       	brpl	.-8      	; 0x104c <DIO_u8SetPinValue+0x116>
    1054:	80 95       	com	r24
    1056:	84 23       	and	r24, r20
    1058:	8c 93       	st	X, r24
    105a:	8d c0       	rjmp	.+282    	; 0x1176 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTB_REG,Copy_u8PinId);break;
    105c:	a8 e3       	ldi	r26, 0x38	; 56
    105e:	b0 e0       	ldi	r27, 0x00	; 0
    1060:	e8 e3       	ldi	r30, 0x38	; 56
    1062:	f0 e0       	ldi	r31, 0x00	; 0
    1064:	80 81       	ld	r24, Z
    1066:	48 2f       	mov	r20, r24
    1068:	8b 81       	ldd	r24, Y+3	; 0x03
    106a:	28 2f       	mov	r18, r24
    106c:	30 e0       	ldi	r19, 0x00	; 0
    106e:	81 e0       	ldi	r24, 0x01	; 1
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	02 2e       	mov	r0, r18
    1074:	02 c0       	rjmp	.+4      	; 0x107a <DIO_u8SetPinValue+0x144>
    1076:	88 0f       	add	r24, r24
    1078:	99 1f       	adc	r25, r25
    107a:	0a 94       	dec	r0
    107c:	e2 f7       	brpl	.-8      	; 0x1076 <DIO_u8SetPinValue+0x140>
    107e:	84 2b       	or	r24, r20
    1080:	8c 93       	st	X, r24
    1082:	79 c0       	rjmp	.+242    	; 0x1176 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
    1084:	19 82       	std	Y+1, r1	; 0x01
    1086:	77 c0       	rjmp	.+238    	; 0x1176 <DIO_u8SetPinValue+0x240>
				}
			break;
			case DIO_u8_PORTC:
				switch(Copy_u8PinValue)
    1088:	8c 81       	ldd	r24, Y+4	; 0x04
    108a:	28 2f       	mov	r18, r24
    108c:	30 e0       	ldi	r19, 0x00	; 0
    108e:	38 87       	std	Y+8, r19	; 0x08
    1090:	2f 83       	std	Y+7, r18	; 0x07
    1092:	8f 81       	ldd	r24, Y+7	; 0x07
    1094:	98 85       	ldd	r25, Y+8	; 0x08
    1096:	00 97       	sbiw	r24, 0x00	; 0
    1098:	31 f0       	breq	.+12     	; 0x10a6 <DIO_u8SetPinValue+0x170>
    109a:	2f 81       	ldd	r18, Y+7	; 0x07
    109c:	38 85       	ldd	r19, Y+8	; 0x08
    109e:	21 30       	cpi	r18, 0x01	; 1
    10a0:	31 05       	cpc	r19, r1
    10a2:	b1 f0       	breq	.+44     	; 0x10d0 <DIO_u8SetPinValue+0x19a>
    10a4:	29 c0       	rjmp	.+82     	; 0x10f8 <DIO_u8SetPinValue+0x1c2>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTC_REG,Copy_u8PinId);break;
    10a6:	a5 e3       	ldi	r26, 0x35	; 53
    10a8:	b0 e0       	ldi	r27, 0x00	; 0
    10aa:	e5 e3       	ldi	r30, 0x35	; 53
    10ac:	f0 e0       	ldi	r31, 0x00	; 0
    10ae:	80 81       	ld	r24, Z
    10b0:	48 2f       	mov	r20, r24
    10b2:	8b 81       	ldd	r24, Y+3	; 0x03
    10b4:	28 2f       	mov	r18, r24
    10b6:	30 e0       	ldi	r19, 0x00	; 0
    10b8:	81 e0       	ldi	r24, 0x01	; 1
    10ba:	90 e0       	ldi	r25, 0x00	; 0
    10bc:	02 2e       	mov	r0, r18
    10be:	02 c0       	rjmp	.+4      	; 0x10c4 <DIO_u8SetPinValue+0x18e>
    10c0:	88 0f       	add	r24, r24
    10c2:	99 1f       	adc	r25, r25
    10c4:	0a 94       	dec	r0
    10c6:	e2 f7       	brpl	.-8      	; 0x10c0 <DIO_u8SetPinValue+0x18a>
    10c8:	80 95       	com	r24
    10ca:	84 23       	and	r24, r20
    10cc:	8c 93       	st	X, r24
    10ce:	53 c0       	rjmp	.+166    	; 0x1176 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTC_REG,Copy_u8PinId);break;
    10d0:	a5 e3       	ldi	r26, 0x35	; 53
    10d2:	b0 e0       	ldi	r27, 0x00	; 0
    10d4:	e5 e3       	ldi	r30, 0x35	; 53
    10d6:	f0 e0       	ldi	r31, 0x00	; 0
    10d8:	80 81       	ld	r24, Z
    10da:	48 2f       	mov	r20, r24
    10dc:	8b 81       	ldd	r24, Y+3	; 0x03
    10de:	28 2f       	mov	r18, r24
    10e0:	30 e0       	ldi	r19, 0x00	; 0
    10e2:	81 e0       	ldi	r24, 0x01	; 1
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	02 2e       	mov	r0, r18
    10e8:	02 c0       	rjmp	.+4      	; 0x10ee <DIO_u8SetPinValue+0x1b8>
    10ea:	88 0f       	add	r24, r24
    10ec:	99 1f       	adc	r25, r25
    10ee:	0a 94       	dec	r0
    10f0:	e2 f7       	brpl	.-8      	; 0x10ea <DIO_u8SetPinValue+0x1b4>
    10f2:	84 2b       	or	r24, r20
    10f4:	8c 93       	st	X, r24
    10f6:	3f c0       	rjmp	.+126    	; 0x1176 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
    10f8:	19 82       	std	Y+1, r1	; 0x01
    10fa:	3d c0       	rjmp	.+122    	; 0x1176 <DIO_u8SetPinValue+0x240>
				}
			break;
			case DIO_u8_PORTD:
				switch(Copy_u8PinValue)
    10fc:	8c 81       	ldd	r24, Y+4	; 0x04
    10fe:	28 2f       	mov	r18, r24
    1100:	30 e0       	ldi	r19, 0x00	; 0
    1102:	3e 83       	std	Y+6, r19	; 0x06
    1104:	2d 83       	std	Y+5, r18	; 0x05
    1106:	8d 81       	ldd	r24, Y+5	; 0x05
    1108:	9e 81       	ldd	r25, Y+6	; 0x06
    110a:	00 97       	sbiw	r24, 0x00	; 0
    110c:	31 f0       	breq	.+12     	; 0x111a <DIO_u8SetPinValue+0x1e4>
    110e:	2d 81       	ldd	r18, Y+5	; 0x05
    1110:	3e 81       	ldd	r19, Y+6	; 0x06
    1112:	21 30       	cpi	r18, 0x01	; 1
    1114:	31 05       	cpc	r19, r1
    1116:	b1 f0       	breq	.+44     	; 0x1144 <DIO_u8SetPinValue+0x20e>
    1118:	29 c0       	rjmp	.+82     	; 0x116c <DIO_u8SetPinValue+0x236>
				{
					case DIO_u8_LOW:CLR_BIT(DIO_u8_PORTD_REG,Copy_u8PinId);break;
    111a:	a2 e3       	ldi	r26, 0x32	; 50
    111c:	b0 e0       	ldi	r27, 0x00	; 0
    111e:	e2 e3       	ldi	r30, 0x32	; 50
    1120:	f0 e0       	ldi	r31, 0x00	; 0
    1122:	80 81       	ld	r24, Z
    1124:	48 2f       	mov	r20, r24
    1126:	8b 81       	ldd	r24, Y+3	; 0x03
    1128:	28 2f       	mov	r18, r24
    112a:	30 e0       	ldi	r19, 0x00	; 0
    112c:	81 e0       	ldi	r24, 0x01	; 1
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	02 2e       	mov	r0, r18
    1132:	02 c0       	rjmp	.+4      	; 0x1138 <DIO_u8SetPinValue+0x202>
    1134:	88 0f       	add	r24, r24
    1136:	99 1f       	adc	r25, r25
    1138:	0a 94       	dec	r0
    113a:	e2 f7       	brpl	.-8      	; 0x1134 <DIO_u8SetPinValue+0x1fe>
    113c:	80 95       	com	r24
    113e:	84 23       	and	r24, r20
    1140:	8c 93       	st	X, r24
    1142:	19 c0       	rjmp	.+50     	; 0x1176 <DIO_u8SetPinValue+0x240>
					case DIO_u8_HIGH:SET_BIT(DIO_u8_PORTD_REG,Copy_u8PinId);break;
    1144:	a2 e3       	ldi	r26, 0x32	; 50
    1146:	b0 e0       	ldi	r27, 0x00	; 0
    1148:	e2 e3       	ldi	r30, 0x32	; 50
    114a:	f0 e0       	ldi	r31, 0x00	; 0
    114c:	80 81       	ld	r24, Z
    114e:	48 2f       	mov	r20, r24
    1150:	8b 81       	ldd	r24, Y+3	; 0x03
    1152:	28 2f       	mov	r18, r24
    1154:	30 e0       	ldi	r19, 0x00	; 0
    1156:	81 e0       	ldi	r24, 0x01	; 1
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	02 2e       	mov	r0, r18
    115c:	02 c0       	rjmp	.+4      	; 0x1162 <DIO_u8SetPinValue+0x22c>
    115e:	88 0f       	add	r24, r24
    1160:	99 1f       	adc	r25, r25
    1162:	0a 94       	dec	r0
    1164:	e2 f7       	brpl	.-8      	; 0x115e <DIO_u8SetPinValue+0x228>
    1166:	84 2b       	or	r24, r20
    1168:	8c 93       	st	X, r24
    116a:	05 c0       	rjmp	.+10     	; 0x1176 <DIO_u8SetPinValue+0x240>
					default: Local_u8ErrorState = STD_TYPES_NOK;
    116c:	19 82       	std	Y+1, r1	; 0x01
    116e:	03 c0       	rjmp	.+6      	; 0x1176 <DIO_u8SetPinValue+0x240>
				}
			break;
			default:
				Local_u8ErrorState = STD_TYPES_NOK;
    1170:	19 82       	std	Y+1, r1	; 0x01
    1172:	01 c0       	rjmp	.+2      	; 0x1176 <DIO_u8SetPinValue+0x240>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
    1174:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
    1176:	89 81       	ldd	r24, Y+1	; 0x01
}
    1178:	2e 96       	adiw	r28, 0x0e	; 14
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	f8 94       	cli
    117e:	de bf       	out	0x3e, r29	; 62
    1180:	0f be       	out	0x3f, r0	; 63
    1182:	cd bf       	out	0x3d, r28	; 61
    1184:	cf 91       	pop	r28
    1186:	df 91       	pop	r29
    1188:	08 95       	ret

0000118a <DIO_u8GetPinValue>:

u8 DIO_u8GetPinValue(u8 Copy_u8PortId, u8 Copy_u8PinId, u8 *Copy_pu8ReturnedPinValue)
{
    118a:	df 93       	push	r29
    118c:	cf 93       	push	r28
    118e:	cd b7       	in	r28, 0x3d	; 61
    1190:	de b7       	in	r29, 0x3e	; 62
    1192:	28 97       	sbiw	r28, 0x08	; 8
    1194:	0f b6       	in	r0, 0x3f	; 63
    1196:	f8 94       	cli
    1198:	de bf       	out	0x3e, r29	; 62
    119a:	0f be       	out	0x3f, r0	; 63
    119c:	cd bf       	out	0x3d, r28	; 61
    119e:	8b 83       	std	Y+3, r24	; 0x03
    11a0:	6c 83       	std	Y+4, r22	; 0x04
    11a2:	5e 83       	std	Y+6, r21	; 0x06
    11a4:	4d 83       	std	Y+5, r20	; 0x05
	u8 Local_u8ErrorState = STD_TYPES_OK;
    11a6:	81 e0       	ldi	r24, 0x01	; 1
    11a8:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_u8PinValue;
	if((Copy_u8PortId <= DIO_u8_PORTD ) && (Copy_u8PinId <= DIO_u8_PIN7) && (Copy_pu8ReturnedPinValue != NULL))
    11aa:	8b 81       	ldd	r24, Y+3	; 0x03
    11ac:	84 30       	cpi	r24, 0x04	; 4
    11ae:	08 f0       	brcs	.+2      	; 0x11b2 <DIO_u8GetPinValue+0x28>
    11b0:	a1 c0       	rjmp	.+322    	; 0x12f4 <DIO_u8GetPinValue+0x16a>
    11b2:	8c 81       	ldd	r24, Y+4	; 0x04
    11b4:	88 30       	cpi	r24, 0x08	; 8
    11b6:	08 f0       	brcs	.+2      	; 0x11ba <DIO_u8GetPinValue+0x30>
    11b8:	9d c0       	rjmp	.+314    	; 0x12f4 <DIO_u8GetPinValue+0x16a>
    11ba:	8d 81       	ldd	r24, Y+5	; 0x05
    11bc:	9e 81       	ldd	r25, Y+6	; 0x06
    11be:	00 97       	sbiw	r24, 0x00	; 0
    11c0:	09 f4       	brne	.+2      	; 0x11c4 <DIO_u8GetPinValue+0x3a>
    11c2:	98 c0       	rjmp	.+304    	; 0x12f4 <DIO_u8GetPinValue+0x16a>
	{
		switch(Copy_u8PortId)
    11c4:	8b 81       	ldd	r24, Y+3	; 0x03
    11c6:	28 2f       	mov	r18, r24
    11c8:	30 e0       	ldi	r19, 0x00	; 0
    11ca:	38 87       	std	Y+8, r19	; 0x08
    11cc:	2f 83       	std	Y+7, r18	; 0x07
    11ce:	4f 81       	ldd	r20, Y+7	; 0x07
    11d0:	58 85       	ldd	r21, Y+8	; 0x08
    11d2:	41 30       	cpi	r20, 0x01	; 1
    11d4:	51 05       	cpc	r21, r1
    11d6:	a9 f1       	breq	.+106    	; 0x1242 <DIO_u8GetPinValue+0xb8>
    11d8:	8f 81       	ldd	r24, Y+7	; 0x07
    11da:	98 85       	ldd	r25, Y+8	; 0x08
    11dc:	82 30       	cpi	r24, 0x02	; 2
    11de:	91 05       	cpc	r25, r1
    11e0:	34 f4       	brge	.+12     	; 0x11ee <DIO_u8GetPinValue+0x64>
    11e2:	2f 81       	ldd	r18, Y+7	; 0x07
    11e4:	38 85       	ldd	r19, Y+8	; 0x08
    11e6:	21 15       	cp	r18, r1
    11e8:	31 05       	cpc	r19, r1
    11ea:	71 f0       	breq	.+28     	; 0x1208 <DIO_u8GetPinValue+0x7e>
    11ec:	81 c0       	rjmp	.+258    	; 0x12f0 <DIO_u8GetPinValue+0x166>
    11ee:	4f 81       	ldd	r20, Y+7	; 0x07
    11f0:	58 85       	ldd	r21, Y+8	; 0x08
    11f2:	42 30       	cpi	r20, 0x02	; 2
    11f4:	51 05       	cpc	r21, r1
    11f6:	09 f4       	brne	.+2      	; 0x11fa <DIO_u8GetPinValue+0x70>
    11f8:	41 c0       	rjmp	.+130    	; 0x127c <DIO_u8GetPinValue+0xf2>
    11fa:	8f 81       	ldd	r24, Y+7	; 0x07
    11fc:	98 85       	ldd	r25, Y+8	; 0x08
    11fe:	83 30       	cpi	r24, 0x03	; 3
    1200:	91 05       	cpc	r25, r1
    1202:	09 f4       	brne	.+2      	; 0x1206 <DIO_u8GetPinValue+0x7c>
    1204:	58 c0       	rjmp	.+176    	; 0x12b6 <DIO_u8GetPinValue+0x12c>
    1206:	74 c0       	rjmp	.+232    	; 0x12f0 <DIO_u8GetPinValue+0x166>
		{
			case DIO_u8_PORTA: Local_u8PinValue = GET_BIT(DIO_u8_PINA_REG,Copy_u8PinId);
    1208:	e9 e3       	ldi	r30, 0x39	; 57
    120a:	f0 e0       	ldi	r31, 0x00	; 0
    120c:	80 81       	ld	r24, Z
    120e:	28 2f       	mov	r18, r24
    1210:	30 e0       	ldi	r19, 0x00	; 0
    1212:	8c 81       	ldd	r24, Y+4	; 0x04
    1214:	88 2f       	mov	r24, r24
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	a9 01       	movw	r20, r18
    121a:	02 c0       	rjmp	.+4      	; 0x1220 <DIO_u8GetPinValue+0x96>
    121c:	55 95       	asr	r21
    121e:	47 95       	ror	r20
    1220:	8a 95       	dec	r24
    1222:	e2 f7       	brpl	.-8      	; 0x121c <DIO_u8GetPinValue+0x92>
    1224:	ca 01       	movw	r24, r20
    1226:	81 70       	andi	r24, 0x01	; 1
    1228:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
    122a:	89 81       	ldd	r24, Y+1	; 0x01
    122c:	88 23       	and	r24, r24
    122e:	21 f4       	brne	.+8      	; 0x1238 <DIO_u8GetPinValue+0xae>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    1230:	ed 81       	ldd	r30, Y+5	; 0x05
    1232:	fe 81       	ldd	r31, Y+6	; 0x06
    1234:	10 82       	st	Z, r1
    1236:	5f c0       	rjmp	.+190    	; 0x12f6 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
    1238:	ed 81       	ldd	r30, Y+5	; 0x05
    123a:	fe 81       	ldd	r31, Y+6	; 0x06
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	80 83       	st	Z, r24
    1240:	5a c0       	rjmp	.+180    	; 0x12f6 <DIO_u8GetPinValue+0x16c>
				}
			break;
			case DIO_u8_PORTB: Local_u8PinValue = GET_BIT(DIO_u8_PINB_REG,Copy_u8PinId);
    1242:	e6 e3       	ldi	r30, 0x36	; 54
    1244:	f0 e0       	ldi	r31, 0x00	; 0
    1246:	80 81       	ld	r24, Z
    1248:	28 2f       	mov	r18, r24
    124a:	30 e0       	ldi	r19, 0x00	; 0
    124c:	8c 81       	ldd	r24, Y+4	; 0x04
    124e:	88 2f       	mov	r24, r24
    1250:	90 e0       	ldi	r25, 0x00	; 0
    1252:	a9 01       	movw	r20, r18
    1254:	02 c0       	rjmp	.+4      	; 0x125a <DIO_u8GetPinValue+0xd0>
    1256:	55 95       	asr	r21
    1258:	47 95       	ror	r20
    125a:	8a 95       	dec	r24
    125c:	e2 f7       	brpl	.-8      	; 0x1256 <DIO_u8GetPinValue+0xcc>
    125e:	ca 01       	movw	r24, r20
    1260:	81 70       	andi	r24, 0x01	; 1
    1262:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
    1264:	89 81       	ldd	r24, Y+1	; 0x01
    1266:	88 23       	and	r24, r24
    1268:	21 f4       	brne	.+8      	; 0x1272 <DIO_u8GetPinValue+0xe8>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    126a:	ed 81       	ldd	r30, Y+5	; 0x05
    126c:	fe 81       	ldd	r31, Y+6	; 0x06
    126e:	10 82       	st	Z, r1
    1270:	42 c0       	rjmp	.+132    	; 0x12f6 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
    1272:	ed 81       	ldd	r30, Y+5	; 0x05
    1274:	fe 81       	ldd	r31, Y+6	; 0x06
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	80 83       	st	Z, r24
    127a:	3d c0       	rjmp	.+122    	; 0x12f6 <DIO_u8GetPinValue+0x16c>
				}
			break;
			case DIO_u8_PORTC: Local_u8PinValue = GET_BIT(DIO_u8_PINC_REG,Copy_u8PinId);
    127c:	e3 e3       	ldi	r30, 0x33	; 51
    127e:	f0 e0       	ldi	r31, 0x00	; 0
    1280:	80 81       	ld	r24, Z
    1282:	28 2f       	mov	r18, r24
    1284:	30 e0       	ldi	r19, 0x00	; 0
    1286:	8c 81       	ldd	r24, Y+4	; 0x04
    1288:	88 2f       	mov	r24, r24
    128a:	90 e0       	ldi	r25, 0x00	; 0
    128c:	a9 01       	movw	r20, r18
    128e:	02 c0       	rjmp	.+4      	; 0x1294 <DIO_u8GetPinValue+0x10a>
    1290:	55 95       	asr	r21
    1292:	47 95       	ror	r20
    1294:	8a 95       	dec	r24
    1296:	e2 f7       	brpl	.-8      	; 0x1290 <DIO_u8GetPinValue+0x106>
    1298:	ca 01       	movw	r24, r20
    129a:	81 70       	andi	r24, 0x01	; 1
    129c:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
    129e:	89 81       	ldd	r24, Y+1	; 0x01
    12a0:	88 23       	and	r24, r24
    12a2:	21 f4       	brne	.+8      	; 0x12ac <DIO_u8GetPinValue+0x122>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    12a4:	ed 81       	ldd	r30, Y+5	; 0x05
    12a6:	fe 81       	ldd	r31, Y+6	; 0x06
    12a8:	10 82       	st	Z, r1
    12aa:	25 c0       	rjmp	.+74     	; 0x12f6 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
    12ac:	ed 81       	ldd	r30, Y+5	; 0x05
    12ae:	fe 81       	ldd	r31, Y+6	; 0x06
    12b0:	81 e0       	ldi	r24, 0x01	; 1
    12b2:	80 83       	st	Z, r24
    12b4:	20 c0       	rjmp	.+64     	; 0x12f6 <DIO_u8GetPinValue+0x16c>
				}
			break;
			case DIO_u8_PORTD: Local_u8PinValue = GET_BIT(DIO_u8_PIND_REG,Copy_u8PinId);
    12b6:	e0 e3       	ldi	r30, 0x30	; 48
    12b8:	f0 e0       	ldi	r31, 0x00	; 0
    12ba:	80 81       	ld	r24, Z
    12bc:	28 2f       	mov	r18, r24
    12be:	30 e0       	ldi	r19, 0x00	; 0
    12c0:	8c 81       	ldd	r24, Y+4	; 0x04
    12c2:	88 2f       	mov	r24, r24
    12c4:	90 e0       	ldi	r25, 0x00	; 0
    12c6:	a9 01       	movw	r20, r18
    12c8:	02 c0       	rjmp	.+4      	; 0x12ce <DIO_u8GetPinValue+0x144>
    12ca:	55 95       	asr	r21
    12cc:	47 95       	ror	r20
    12ce:	8a 95       	dec	r24
    12d0:	e2 f7       	brpl	.-8      	; 0x12ca <DIO_u8GetPinValue+0x140>
    12d2:	ca 01       	movw	r24, r20
    12d4:	81 70       	andi	r24, 0x01	; 1
    12d6:	89 83       	std	Y+1, r24	; 0x01
				if(Local_u8PinValue == 0)
    12d8:	89 81       	ldd	r24, Y+1	; 0x01
    12da:	88 23       	and	r24, r24
    12dc:	21 f4       	brne	.+8      	; 0x12e6 <DIO_u8GetPinValue+0x15c>
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    12de:	ed 81       	ldd	r30, Y+5	; 0x05
    12e0:	fe 81       	ldd	r31, Y+6	; 0x06
    12e2:	10 82       	st	Z, r1
    12e4:	08 c0       	rjmp	.+16     	; 0x12f6 <DIO_u8GetPinValue+0x16c>
				}
				else
				{
					*Copy_pu8ReturnedPinValue = DIO_u8_HIGH;
    12e6:	ed 81       	ldd	r30, Y+5	; 0x05
    12e8:	fe 81       	ldd	r31, Y+6	; 0x06
    12ea:	81 e0       	ldi	r24, 0x01	; 1
    12ec:	80 83       	st	Z, r24
    12ee:	03 c0       	rjmp	.+6      	; 0x12f6 <DIO_u8GetPinValue+0x16c>
				}
			break;
			default: Local_u8ErrorState = STD_TYPES_NOK;
    12f0:	1a 82       	std	Y+2, r1	; 0x02
    12f2:	01 c0       	rjmp	.+2      	; 0x12f6 <DIO_u8GetPinValue+0x16c>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
    12f4:	1a 82       	std	Y+2, r1	; 0x02
	}
	return Local_u8ErrorState;
    12f6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    12f8:	28 96       	adiw	r28, 0x08	; 8
    12fa:	0f b6       	in	r0, 0x3f	; 63
    12fc:	f8 94       	cli
    12fe:	de bf       	out	0x3e, r29	; 62
    1300:	0f be       	out	0x3f, r0	; 63
    1302:	cd bf       	out	0x3d, r28	; 61
    1304:	cf 91       	pop	r28
    1306:	df 91       	pop	r29
    1308:	08 95       	ret

0000130a <DIO_u8SetPortDirection>:

u8 DIO_u8SetPortDirection(u8 Copy_u8PortId, u8 Copy_u8PortDirection)
{
    130a:	df 93       	push	r29
    130c:	cf 93       	push	r28
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	2d 97       	sbiw	r28, 0x0d	; 13
    1314:	0f b6       	in	r0, 0x3f	; 63
    1316:	f8 94       	cli
    1318:	de bf       	out	0x3e, r29	; 62
    131a:	0f be       	out	0x3f, r0	; 63
    131c:	cd bf       	out	0x3d, r28	; 61
    131e:	8a 83       	std	Y+2, r24	; 0x02
    1320:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortDirection == DIO_u8_INPUT) || (Copy_u8PortDirection == DIO_u8_OUTPUT))
    1326:	8b 81       	ldd	r24, Y+3	; 0x03
    1328:	88 23       	and	r24, r24
    132a:	21 f0       	breq	.+8      	; 0x1334 <DIO_u8SetPortDirection+0x2a>
    132c:	8b 81       	ldd	r24, Y+3	; 0x03
    132e:	81 30       	cpi	r24, 0x01	; 1
    1330:	09 f0       	breq	.+2      	; 0x1334 <DIO_u8SetPortDirection+0x2a>
    1332:	82 c0       	rjmp	.+260    	; 0x1438 <DIO_u8SetPortDirection+0x12e>
	{
		switch(Copy_u8PortId)
    1334:	8a 81       	ldd	r24, Y+2	; 0x02
    1336:	28 2f       	mov	r18, r24
    1338:	30 e0       	ldi	r19, 0x00	; 0
    133a:	3d 87       	std	Y+13, r19	; 0x0d
    133c:	2c 87       	std	Y+12, r18	; 0x0c
    133e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1340:	9d 85       	ldd	r25, Y+13	; 0x0d
    1342:	81 30       	cpi	r24, 0x01	; 1
    1344:	91 05       	cpc	r25, r1
    1346:	71 f1       	breq	.+92     	; 0x13a4 <DIO_u8SetPortDirection+0x9a>
    1348:	2c 85       	ldd	r18, Y+12	; 0x0c
    134a:	3d 85       	ldd	r19, Y+13	; 0x0d
    134c:	22 30       	cpi	r18, 0x02	; 2
    134e:	31 05       	cpc	r19, r1
    1350:	2c f4       	brge	.+10     	; 0x135c <DIO_u8SetPortDirection+0x52>
    1352:	8c 85       	ldd	r24, Y+12	; 0x0c
    1354:	9d 85       	ldd	r25, Y+13	; 0x0d
    1356:	00 97       	sbiw	r24, 0x00	; 0
    1358:	69 f0       	breq	.+26     	; 0x1374 <DIO_u8SetPortDirection+0x6a>
    135a:	6c c0       	rjmp	.+216    	; 0x1434 <DIO_u8SetPortDirection+0x12a>
    135c:	2c 85       	ldd	r18, Y+12	; 0x0c
    135e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1360:	22 30       	cpi	r18, 0x02	; 2
    1362:	31 05       	cpc	r19, r1
    1364:	b9 f1       	breq	.+110    	; 0x13d4 <DIO_u8SetPortDirection+0xca>
    1366:	8c 85       	ldd	r24, Y+12	; 0x0c
    1368:	9d 85       	ldd	r25, Y+13	; 0x0d
    136a:	83 30       	cpi	r24, 0x03	; 3
    136c:	91 05       	cpc	r25, r1
    136e:	09 f4       	brne	.+2      	; 0x1372 <DIO_u8SetPortDirection+0x68>
    1370:	49 c0       	rjmp	.+146    	; 0x1404 <DIO_u8SetPortDirection+0xfa>
    1372:	60 c0       	rjmp	.+192    	; 0x1434 <DIO_u8SetPortDirection+0x12a>
		{
			case DIO_u8_PORTA:
				switch(Copy_u8PortDirection)
    1374:	8b 81       	ldd	r24, Y+3	; 0x03
    1376:	28 2f       	mov	r18, r24
    1378:	30 e0       	ldi	r19, 0x00	; 0
    137a:	3b 87       	std	Y+11, r19	; 0x0b
    137c:	2a 87       	std	Y+10, r18	; 0x0a
    137e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1380:	9b 85       	ldd	r25, Y+11	; 0x0b
    1382:	00 97       	sbiw	r24, 0x00	; 0
    1384:	31 f0       	breq	.+12     	; 0x1392 <DIO_u8SetPortDirection+0x88>
    1386:	2a 85       	ldd	r18, Y+10	; 0x0a
    1388:	3b 85       	ldd	r19, Y+11	; 0x0b
    138a:	21 30       	cpi	r18, 0x01	; 1
    138c:	31 05       	cpc	r19, r1
    138e:	29 f0       	breq	.+10     	; 0x139a <DIO_u8SetPortDirection+0x90>
    1390:	54 c0       	rjmp	.+168    	; 0x143a <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRA_REG = 0x00;break;
    1392:	ea e3       	ldi	r30, 0x3A	; 58
    1394:	f0 e0       	ldi	r31, 0x00	; 0
    1396:	10 82       	st	Z, r1
    1398:	50 c0       	rjmp	.+160    	; 0x143a <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRA_REG = 0xFF;break;
    139a:	ea e3       	ldi	r30, 0x3A	; 58
    139c:	f0 e0       	ldi	r31, 0x00	; 0
    139e:	8f ef       	ldi	r24, 0xFF	; 255
    13a0:	80 83       	st	Z, r24
    13a2:	4b c0       	rjmp	.+150    	; 0x143a <DIO_u8SetPortDirection+0x130>
				}
			break;
			case DIO_u8_PORTB:
				switch(Copy_u8PortDirection)
    13a4:	8b 81       	ldd	r24, Y+3	; 0x03
    13a6:	28 2f       	mov	r18, r24
    13a8:	30 e0       	ldi	r19, 0x00	; 0
    13aa:	39 87       	std	Y+9, r19	; 0x09
    13ac:	28 87       	std	Y+8, r18	; 0x08
    13ae:	88 85       	ldd	r24, Y+8	; 0x08
    13b0:	99 85       	ldd	r25, Y+9	; 0x09
    13b2:	00 97       	sbiw	r24, 0x00	; 0
    13b4:	31 f0       	breq	.+12     	; 0x13c2 <DIO_u8SetPortDirection+0xb8>
    13b6:	28 85       	ldd	r18, Y+8	; 0x08
    13b8:	39 85       	ldd	r19, Y+9	; 0x09
    13ba:	21 30       	cpi	r18, 0x01	; 1
    13bc:	31 05       	cpc	r19, r1
    13be:	29 f0       	breq	.+10     	; 0x13ca <DIO_u8SetPortDirection+0xc0>
    13c0:	3c c0       	rjmp	.+120    	; 0x143a <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRB_REG = 0x00;break;
    13c2:	e7 e3       	ldi	r30, 0x37	; 55
    13c4:	f0 e0       	ldi	r31, 0x00	; 0
    13c6:	10 82       	st	Z, r1
    13c8:	38 c0       	rjmp	.+112    	; 0x143a <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRB_REG = 0xFF;break;
    13ca:	e7 e3       	ldi	r30, 0x37	; 55
    13cc:	f0 e0       	ldi	r31, 0x00	; 0
    13ce:	8f ef       	ldi	r24, 0xFF	; 255
    13d0:	80 83       	st	Z, r24
    13d2:	33 c0       	rjmp	.+102    	; 0x143a <DIO_u8SetPortDirection+0x130>
				}
			break;
			case DIO_u8_PORTC:
				switch(Copy_u8PortDirection)
    13d4:	8b 81       	ldd	r24, Y+3	; 0x03
    13d6:	28 2f       	mov	r18, r24
    13d8:	30 e0       	ldi	r19, 0x00	; 0
    13da:	3f 83       	std	Y+7, r19	; 0x07
    13dc:	2e 83       	std	Y+6, r18	; 0x06
    13de:	8e 81       	ldd	r24, Y+6	; 0x06
    13e0:	9f 81       	ldd	r25, Y+7	; 0x07
    13e2:	00 97       	sbiw	r24, 0x00	; 0
    13e4:	31 f0       	breq	.+12     	; 0x13f2 <DIO_u8SetPortDirection+0xe8>
    13e6:	2e 81       	ldd	r18, Y+6	; 0x06
    13e8:	3f 81       	ldd	r19, Y+7	; 0x07
    13ea:	21 30       	cpi	r18, 0x01	; 1
    13ec:	31 05       	cpc	r19, r1
    13ee:	29 f0       	breq	.+10     	; 0x13fa <DIO_u8SetPortDirection+0xf0>
    13f0:	24 c0       	rjmp	.+72     	; 0x143a <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRC_REG = 0x00;break;
    13f2:	e4 e3       	ldi	r30, 0x34	; 52
    13f4:	f0 e0       	ldi	r31, 0x00	; 0
    13f6:	10 82       	st	Z, r1
    13f8:	20 c0       	rjmp	.+64     	; 0x143a <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRC_REG = 0xFF;break;
    13fa:	e4 e3       	ldi	r30, 0x34	; 52
    13fc:	f0 e0       	ldi	r31, 0x00	; 0
    13fe:	8f ef       	ldi	r24, 0xFF	; 255
    1400:	80 83       	st	Z, r24
    1402:	1b c0       	rjmp	.+54     	; 0x143a <DIO_u8SetPortDirection+0x130>
				}
			break;
			case DIO_u8_PORTD:
				switch(Copy_u8PortDirection)
    1404:	8b 81       	ldd	r24, Y+3	; 0x03
    1406:	28 2f       	mov	r18, r24
    1408:	30 e0       	ldi	r19, 0x00	; 0
    140a:	3d 83       	std	Y+5, r19	; 0x05
    140c:	2c 83       	std	Y+4, r18	; 0x04
    140e:	8c 81       	ldd	r24, Y+4	; 0x04
    1410:	9d 81       	ldd	r25, Y+5	; 0x05
    1412:	00 97       	sbiw	r24, 0x00	; 0
    1414:	31 f0       	breq	.+12     	; 0x1422 <DIO_u8SetPortDirection+0x118>
    1416:	2c 81       	ldd	r18, Y+4	; 0x04
    1418:	3d 81       	ldd	r19, Y+5	; 0x05
    141a:	21 30       	cpi	r18, 0x01	; 1
    141c:	31 05       	cpc	r19, r1
    141e:	29 f0       	breq	.+10     	; 0x142a <DIO_u8SetPortDirection+0x120>
    1420:	0c c0       	rjmp	.+24     	; 0x143a <DIO_u8SetPortDirection+0x130>
				{
					case DIO_u8_INPUT:DIO_u8_DDRD_REG = 0x00;break;
    1422:	e1 e3       	ldi	r30, 0x31	; 49
    1424:	f0 e0       	ldi	r31, 0x00	; 0
    1426:	10 82       	st	Z, r1
    1428:	08 c0       	rjmp	.+16     	; 0x143a <DIO_u8SetPortDirection+0x130>
					case DIO_u8_OUTPUT:DIO_u8_DDRD_REG = 0xFF;break;
    142a:	e1 e3       	ldi	r30, 0x31	; 49
    142c:	f0 e0       	ldi	r31, 0x00	; 0
    142e:	8f ef       	ldi	r24, 0xFF	; 255
    1430:	80 83       	st	Z, r24
    1432:	03 c0       	rjmp	.+6      	; 0x143a <DIO_u8SetPortDirection+0x130>
				}
			break;
			default:Local_u8ErrorState = STD_TYPES_NOK;
    1434:	19 82       	std	Y+1, r1	; 0x01
    1436:	01 c0       	rjmp	.+2      	; 0x143a <DIO_u8SetPortDirection+0x130>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
    1438:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
    143a:	89 81       	ldd	r24, Y+1	; 0x01
}
    143c:	2d 96       	adiw	r28, 0x0d	; 13
    143e:	0f b6       	in	r0, 0x3f	; 63
    1440:	f8 94       	cli
    1442:	de bf       	out	0x3e, r29	; 62
    1444:	0f be       	out	0x3f, r0	; 63
    1446:	cd bf       	out	0x3d, r28	; 61
    1448:	cf 91       	pop	r28
    144a:	df 91       	pop	r29
    144c:	08 95       	ret

0000144e <DIO_u8SetPortValue>:

u8 DIO_u8SetPortValue(u8 Copy_u8PortId, u8 Copy_u8PortValue)
{
    144e:	df 93       	push	r29
    1450:	cf 93       	push	r28
    1452:	00 d0       	rcall	.+0      	; 0x1454 <DIO_u8SetPortValue+0x6>
    1454:	00 d0       	rcall	.+0      	; 0x1456 <DIO_u8SetPortValue+0x8>
    1456:	0f 92       	push	r0
    1458:	cd b7       	in	r28, 0x3d	; 61
    145a:	de b7       	in	r29, 0x3e	; 62
    145c:	8a 83       	std	Y+2, r24	; 0x02
    145e:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
    1460:	81 e0       	ldi	r24, 0x01	; 1
    1462:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortId)
    1464:	8a 81       	ldd	r24, Y+2	; 0x02
    1466:	28 2f       	mov	r18, r24
    1468:	30 e0       	ldi	r19, 0x00	; 0
    146a:	3d 83       	std	Y+5, r19	; 0x05
    146c:	2c 83       	std	Y+4, r18	; 0x04
    146e:	8c 81       	ldd	r24, Y+4	; 0x04
    1470:	9d 81       	ldd	r25, Y+5	; 0x05
    1472:	81 30       	cpi	r24, 0x01	; 1
    1474:	91 05       	cpc	r25, r1
    1476:	d1 f0       	breq	.+52     	; 0x14ac <DIO_u8SetPortValue+0x5e>
    1478:	2c 81       	ldd	r18, Y+4	; 0x04
    147a:	3d 81       	ldd	r19, Y+5	; 0x05
    147c:	22 30       	cpi	r18, 0x02	; 2
    147e:	31 05       	cpc	r19, r1
    1480:	2c f4       	brge	.+10     	; 0x148c <DIO_u8SetPortValue+0x3e>
    1482:	8c 81       	ldd	r24, Y+4	; 0x04
    1484:	9d 81       	ldd	r25, Y+5	; 0x05
    1486:	00 97       	sbiw	r24, 0x00	; 0
    1488:	61 f0       	breq	.+24     	; 0x14a2 <DIO_u8SetPortValue+0x54>
    148a:	1f c0       	rjmp	.+62     	; 0x14ca <DIO_u8SetPortValue+0x7c>
    148c:	2c 81       	ldd	r18, Y+4	; 0x04
    148e:	3d 81       	ldd	r19, Y+5	; 0x05
    1490:	22 30       	cpi	r18, 0x02	; 2
    1492:	31 05       	cpc	r19, r1
    1494:	81 f0       	breq	.+32     	; 0x14b6 <DIO_u8SetPortValue+0x68>
    1496:	8c 81       	ldd	r24, Y+4	; 0x04
    1498:	9d 81       	ldd	r25, Y+5	; 0x05
    149a:	83 30       	cpi	r24, 0x03	; 3
    149c:	91 05       	cpc	r25, r1
    149e:	81 f0       	breq	.+32     	; 0x14c0 <DIO_u8SetPortValue+0x72>
    14a0:	14 c0       	rjmp	.+40     	; 0x14ca <DIO_u8SetPortValue+0x7c>
	{
		case DIO_u8_PORTA:DIO_u8_PORTA_REG = Copy_u8PortValue; break;
    14a2:	eb e3       	ldi	r30, 0x3B	; 59
    14a4:	f0 e0       	ldi	r31, 0x00	; 0
    14a6:	8b 81       	ldd	r24, Y+3	; 0x03
    14a8:	80 83       	st	Z, r24
    14aa:	10 c0       	rjmp	.+32     	; 0x14cc <DIO_u8SetPortValue+0x7e>
		case DIO_u8_PORTB:DIO_u8_PORTB_REG = Copy_u8PortValue; break;
    14ac:	e8 e3       	ldi	r30, 0x38	; 56
    14ae:	f0 e0       	ldi	r31, 0x00	; 0
    14b0:	8b 81       	ldd	r24, Y+3	; 0x03
    14b2:	80 83       	st	Z, r24
    14b4:	0b c0       	rjmp	.+22     	; 0x14cc <DIO_u8SetPortValue+0x7e>
		case DIO_u8_PORTC:DIO_u8_PORTC_REG = Copy_u8PortValue; break;
    14b6:	e5 e3       	ldi	r30, 0x35	; 53
    14b8:	f0 e0       	ldi	r31, 0x00	; 0
    14ba:	8b 81       	ldd	r24, Y+3	; 0x03
    14bc:	80 83       	st	Z, r24
    14be:	06 c0       	rjmp	.+12     	; 0x14cc <DIO_u8SetPortValue+0x7e>
		case DIO_u8_PORTD:DIO_u8_PORTD_REG = Copy_u8PortValue; break;
    14c0:	e2 e3       	ldi	r30, 0x32	; 50
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	8b 81       	ldd	r24, Y+3	; 0x03
    14c6:	80 83       	st	Z, r24
    14c8:	01 c0       	rjmp	.+2      	; 0x14cc <DIO_u8SetPortValue+0x7e>
		default:Local_u8ErrorState = STD_TYPES_NOK;
    14ca:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
    14cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    14ce:	0f 90       	pop	r0
    14d0:	0f 90       	pop	r0
    14d2:	0f 90       	pop	r0
    14d4:	0f 90       	pop	r0
    14d6:	0f 90       	pop	r0
    14d8:	cf 91       	pop	r28
    14da:	df 91       	pop	r29
    14dc:	08 95       	ret

000014de <DIO_u8GetPortValue>:

u8 DIO_u8GetPortValue(u8 Copy_u8PortId, u8 *Copy_pu8ReturnedPortValue)
{
    14de:	df 93       	push	r29
    14e0:	cf 93       	push	r28
    14e2:	00 d0       	rcall	.+0      	; 0x14e4 <DIO_u8GetPortValue+0x6>
    14e4:	00 d0       	rcall	.+0      	; 0x14e6 <DIO_u8GetPortValue+0x8>
    14e6:	00 d0       	rcall	.+0      	; 0x14e8 <DIO_u8GetPortValue+0xa>
    14e8:	cd b7       	in	r28, 0x3d	; 61
    14ea:	de b7       	in	r29, 0x3e	; 62
    14ec:	8a 83       	std	Y+2, r24	; 0x02
    14ee:	7c 83       	std	Y+4, r23	; 0x04
    14f0:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
    14f2:	81 e0       	ldi	r24, 0x01	; 1
    14f4:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_pu8ReturnedPortValue != NULL)
    14f6:	8b 81       	ldd	r24, Y+3	; 0x03
    14f8:	9c 81       	ldd	r25, Y+4	; 0x04
    14fa:	00 97       	sbiw	r24, 0x00	; 0
    14fc:	e9 f1       	breq	.+122    	; 0x1578 <DIO_u8GetPortValue+0x9a>
	{
		switch(Copy_u8PortId)
    14fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1500:	28 2f       	mov	r18, r24
    1502:	30 e0       	ldi	r19, 0x00	; 0
    1504:	3e 83       	std	Y+6, r19	; 0x06
    1506:	2d 83       	std	Y+5, r18	; 0x05
    1508:	8d 81       	ldd	r24, Y+5	; 0x05
    150a:	9e 81       	ldd	r25, Y+6	; 0x06
    150c:	81 30       	cpi	r24, 0x01	; 1
    150e:	91 05       	cpc	r25, r1
    1510:	e1 f0       	breq	.+56     	; 0x154a <DIO_u8GetPortValue+0x6c>
    1512:	2d 81       	ldd	r18, Y+5	; 0x05
    1514:	3e 81       	ldd	r19, Y+6	; 0x06
    1516:	22 30       	cpi	r18, 0x02	; 2
    1518:	31 05       	cpc	r19, r1
    151a:	2c f4       	brge	.+10     	; 0x1526 <DIO_u8GetPortValue+0x48>
    151c:	8d 81       	ldd	r24, Y+5	; 0x05
    151e:	9e 81       	ldd	r25, Y+6	; 0x06
    1520:	00 97       	sbiw	r24, 0x00	; 0
    1522:	61 f0       	breq	.+24     	; 0x153c <DIO_u8GetPortValue+0x5e>
    1524:	27 c0       	rjmp	.+78     	; 0x1574 <DIO_u8GetPortValue+0x96>
    1526:	2d 81       	ldd	r18, Y+5	; 0x05
    1528:	3e 81       	ldd	r19, Y+6	; 0x06
    152a:	22 30       	cpi	r18, 0x02	; 2
    152c:	31 05       	cpc	r19, r1
    152e:	a1 f0       	breq	.+40     	; 0x1558 <DIO_u8GetPortValue+0x7a>
    1530:	8d 81       	ldd	r24, Y+5	; 0x05
    1532:	9e 81       	ldd	r25, Y+6	; 0x06
    1534:	83 30       	cpi	r24, 0x03	; 3
    1536:	91 05       	cpc	r25, r1
    1538:	b1 f0       	breq	.+44     	; 0x1566 <DIO_u8GetPortValue+0x88>
    153a:	1c c0       	rjmp	.+56     	; 0x1574 <DIO_u8GetPortValue+0x96>
		{
			case DIO_u8_PORTA: *Copy_pu8ReturnedPortValue = DIO_u8_PINA_REG;break;
    153c:	e9 e3       	ldi	r30, 0x39	; 57
    153e:	f0 e0       	ldi	r31, 0x00	; 0
    1540:	80 81       	ld	r24, Z
    1542:	eb 81       	ldd	r30, Y+3	; 0x03
    1544:	fc 81       	ldd	r31, Y+4	; 0x04
    1546:	80 83       	st	Z, r24
    1548:	18 c0       	rjmp	.+48     	; 0x157a <DIO_u8GetPortValue+0x9c>
			case DIO_u8_PORTB: *Copy_pu8ReturnedPortValue = DIO_u8_PINB_REG;break;
    154a:	e6 e3       	ldi	r30, 0x36	; 54
    154c:	f0 e0       	ldi	r31, 0x00	; 0
    154e:	80 81       	ld	r24, Z
    1550:	eb 81       	ldd	r30, Y+3	; 0x03
    1552:	fc 81       	ldd	r31, Y+4	; 0x04
    1554:	80 83       	st	Z, r24
    1556:	11 c0       	rjmp	.+34     	; 0x157a <DIO_u8GetPortValue+0x9c>
			case DIO_u8_PORTC: *Copy_pu8ReturnedPortValue = DIO_u8_PINC_REG;break;
    1558:	e3 e3       	ldi	r30, 0x33	; 51
    155a:	f0 e0       	ldi	r31, 0x00	; 0
    155c:	80 81       	ld	r24, Z
    155e:	eb 81       	ldd	r30, Y+3	; 0x03
    1560:	fc 81       	ldd	r31, Y+4	; 0x04
    1562:	80 83       	st	Z, r24
    1564:	0a c0       	rjmp	.+20     	; 0x157a <DIO_u8GetPortValue+0x9c>
			case DIO_u8_PORTD: *Copy_pu8ReturnedPortValue = DIO_u8_PIND_REG;break;
    1566:	e0 e3       	ldi	r30, 0x30	; 48
    1568:	f0 e0       	ldi	r31, 0x00	; 0
    156a:	80 81       	ld	r24, Z
    156c:	eb 81       	ldd	r30, Y+3	; 0x03
    156e:	fc 81       	ldd	r31, Y+4	; 0x04
    1570:	80 83       	st	Z, r24
    1572:	03 c0       	rjmp	.+6      	; 0x157a <DIO_u8GetPortValue+0x9c>
			default:Local_u8ErrorState = STD_TYPES_NOK;
    1574:	19 82       	std	Y+1, r1	; 0x01
    1576:	01 c0       	rjmp	.+2      	; 0x157a <DIO_u8GetPortValue+0x9c>
		}
	}
	else
	{
		Local_u8ErrorState = STD_TYPES_NOK;
    1578:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ErrorState;
    157a:	89 81       	ldd	r24, Y+1	; 0x01
    157c:	26 96       	adiw	r28, 0x06	; 6
    157e:	0f b6       	in	r0, 0x3f	; 63
    1580:	f8 94       	cli
    1582:	de bf       	out	0x3e, r29	; 62
    1584:	0f be       	out	0x3f, r0	; 63
    1586:	cd bf       	out	0x3d, r28	; 61
    1588:	cf 91       	pop	r28
    158a:	df 91       	pop	r29
    158c:	08 95       	ret

0000158e <LCD_voidInit>:
#include "LCD_config.h"
#include "LCD_private.h"

/************** APIs *************************/
void LCD_voidInit(void) 
{
    158e:	0f 93       	push	r16
    1590:	1f 93       	push	r17
    1592:	df 93       	push	r29
    1594:	cf 93       	push	r28
    1596:	cd b7       	in	r28, 0x3d	; 61
    1598:	de b7       	in	r29, 0x3e	; 62
    159a:	cc 54       	subi	r28, 0x4C	; 76
    159c:	d0 40       	sbci	r29, 0x00	; 0
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	de bf       	out	0x3e, r29	; 62
    15a4:	0f be       	out	0x3f, r0	; 63
    15a6:	cd bf       	out	0x3d, r28	; 61
    15a8:	fe 01       	movw	r30, r28
    15aa:	e7 5b       	subi	r30, 0xB7	; 183
    15ac:	ff 4f       	sbci	r31, 0xFF	; 255
    15ae:	80 e0       	ldi	r24, 0x00	; 0
    15b0:	90 e0       	ldi	r25, 0x00	; 0
    15b2:	ac e0       	ldi	r26, 0x0C	; 12
    15b4:	b2 e4       	ldi	r27, 0x42	; 66
    15b6:	80 83       	st	Z, r24
    15b8:	91 83       	std	Z+1, r25	; 0x01
    15ba:	a2 83       	std	Z+2, r26	; 0x02
    15bc:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    15be:	8e 01       	movw	r16, r28
    15c0:	0b 5b       	subi	r16, 0xBB	; 187
    15c2:	1f 4f       	sbci	r17, 0xFF	; 255
    15c4:	fe 01       	movw	r30, r28
    15c6:	e7 5b       	subi	r30, 0xB7	; 183
    15c8:	ff 4f       	sbci	r31, 0xFF	; 255
    15ca:	60 81       	ld	r22, Z
    15cc:	71 81       	ldd	r23, Z+1	; 0x01
    15ce:	82 81       	ldd	r24, Z+2	; 0x02
    15d0:	93 81       	ldd	r25, Z+3	; 0x03
    15d2:	20 e0       	ldi	r18, 0x00	; 0
    15d4:	30 e0       	ldi	r19, 0x00	; 0
    15d6:	4a ef       	ldi	r20, 0xFA	; 250
    15d8:	54 e4       	ldi	r21, 0x44	; 68
    15da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    15de:	dc 01       	movw	r26, r24
    15e0:	cb 01       	movw	r24, r22
    15e2:	f8 01       	movw	r30, r16
    15e4:	80 83       	st	Z, r24
    15e6:	91 83       	std	Z+1, r25	; 0x01
    15e8:	a2 83       	std	Z+2, r26	; 0x02
    15ea:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    15ec:	fe 01       	movw	r30, r28
    15ee:	eb 5b       	subi	r30, 0xBB	; 187
    15f0:	ff 4f       	sbci	r31, 0xFF	; 255
    15f2:	60 81       	ld	r22, Z
    15f4:	71 81       	ldd	r23, Z+1	; 0x01
    15f6:	82 81       	ldd	r24, Z+2	; 0x02
    15f8:	93 81       	ldd	r25, Z+3	; 0x03
    15fa:	20 e0       	ldi	r18, 0x00	; 0
    15fc:	30 e0       	ldi	r19, 0x00	; 0
    15fe:	40 e8       	ldi	r20, 0x80	; 128
    1600:	5f e3       	ldi	r21, 0x3F	; 63
    1602:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1606:	88 23       	and	r24, r24
    1608:	44 f4       	brge	.+16     	; 0x161a <LCD_voidInit+0x8c>
		__ticks = 1;
    160a:	fe 01       	movw	r30, r28
    160c:	ed 5b       	subi	r30, 0xBD	; 189
    160e:	ff 4f       	sbci	r31, 0xFF	; 255
    1610:	81 e0       	ldi	r24, 0x01	; 1
    1612:	90 e0       	ldi	r25, 0x00	; 0
    1614:	91 83       	std	Z+1, r25	; 0x01
    1616:	80 83       	st	Z, r24
    1618:	64 c0       	rjmp	.+200    	; 0x16e2 <LCD_voidInit+0x154>
	else if (__tmp > 65535)
    161a:	fe 01       	movw	r30, r28
    161c:	eb 5b       	subi	r30, 0xBB	; 187
    161e:	ff 4f       	sbci	r31, 0xFF	; 255
    1620:	60 81       	ld	r22, Z
    1622:	71 81       	ldd	r23, Z+1	; 0x01
    1624:	82 81       	ldd	r24, Z+2	; 0x02
    1626:	93 81       	ldd	r25, Z+3	; 0x03
    1628:	20 e0       	ldi	r18, 0x00	; 0
    162a:	3f ef       	ldi	r19, 0xFF	; 255
    162c:	4f e7       	ldi	r20, 0x7F	; 127
    162e:	57 e4       	ldi	r21, 0x47	; 71
    1630:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1634:	18 16       	cp	r1, r24
    1636:	0c f0       	brlt	.+2      	; 0x163a <LCD_voidInit+0xac>
    1638:	43 c0       	rjmp	.+134    	; 0x16c0 <LCD_voidInit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    163a:	fe 01       	movw	r30, r28
    163c:	e7 5b       	subi	r30, 0xB7	; 183
    163e:	ff 4f       	sbci	r31, 0xFF	; 255
    1640:	60 81       	ld	r22, Z
    1642:	71 81       	ldd	r23, Z+1	; 0x01
    1644:	82 81       	ldd	r24, Z+2	; 0x02
    1646:	93 81       	ldd	r25, Z+3	; 0x03
    1648:	20 e0       	ldi	r18, 0x00	; 0
    164a:	30 e0       	ldi	r19, 0x00	; 0
    164c:	40 e2       	ldi	r20, 0x20	; 32
    164e:	51 e4       	ldi	r21, 0x41	; 65
    1650:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1654:	dc 01       	movw	r26, r24
    1656:	cb 01       	movw	r24, r22
    1658:	8e 01       	movw	r16, r28
    165a:	0d 5b       	subi	r16, 0xBD	; 189
    165c:	1f 4f       	sbci	r17, 0xFF	; 255
    165e:	bc 01       	movw	r22, r24
    1660:	cd 01       	movw	r24, r26
    1662:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1666:	dc 01       	movw	r26, r24
    1668:	cb 01       	movw	r24, r22
    166a:	f8 01       	movw	r30, r16
    166c:	91 83       	std	Z+1, r25	; 0x01
    166e:	80 83       	st	Z, r24
    1670:	1f c0       	rjmp	.+62     	; 0x16b0 <LCD_voidInit+0x122>
    1672:	fe 01       	movw	r30, r28
    1674:	ef 5b       	subi	r30, 0xBF	; 191
    1676:	ff 4f       	sbci	r31, 0xFF	; 255
    1678:	88 ec       	ldi	r24, 0xC8	; 200
    167a:	90 e0       	ldi	r25, 0x00	; 0
    167c:	91 83       	std	Z+1, r25	; 0x01
    167e:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1680:	fe 01       	movw	r30, r28
    1682:	ef 5b       	subi	r30, 0xBF	; 191
    1684:	ff 4f       	sbci	r31, 0xFF	; 255
    1686:	80 81       	ld	r24, Z
    1688:	91 81       	ldd	r25, Z+1	; 0x01
    168a:	01 97       	sbiw	r24, 0x01	; 1
    168c:	f1 f7       	brne	.-4      	; 0x168a <LCD_voidInit+0xfc>
    168e:	fe 01       	movw	r30, r28
    1690:	ef 5b       	subi	r30, 0xBF	; 191
    1692:	ff 4f       	sbci	r31, 0xFF	; 255
    1694:	91 83       	std	Z+1, r25	; 0x01
    1696:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1698:	de 01       	movw	r26, r28
    169a:	ad 5b       	subi	r26, 0xBD	; 189
    169c:	bf 4f       	sbci	r27, 0xFF	; 255
    169e:	fe 01       	movw	r30, r28
    16a0:	ed 5b       	subi	r30, 0xBD	; 189
    16a2:	ff 4f       	sbci	r31, 0xFF	; 255
    16a4:	80 81       	ld	r24, Z
    16a6:	91 81       	ldd	r25, Z+1	; 0x01
    16a8:	01 97       	sbiw	r24, 0x01	; 1
    16aa:	11 96       	adiw	r26, 0x01	; 1
    16ac:	9c 93       	st	X, r25
    16ae:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16b0:	fe 01       	movw	r30, r28
    16b2:	ed 5b       	subi	r30, 0xBD	; 189
    16b4:	ff 4f       	sbci	r31, 0xFF	; 255
    16b6:	80 81       	ld	r24, Z
    16b8:	91 81       	ldd	r25, Z+1	; 0x01
    16ba:	00 97       	sbiw	r24, 0x00	; 0
    16bc:	d1 f6       	brne	.-76     	; 0x1672 <LCD_voidInit+0xe4>
    16be:	24 c0       	rjmp	.+72     	; 0x1708 <LCD_voidInit+0x17a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16c0:	8e 01       	movw	r16, r28
    16c2:	0d 5b       	subi	r16, 0xBD	; 189
    16c4:	1f 4f       	sbci	r17, 0xFF	; 255
    16c6:	fe 01       	movw	r30, r28
    16c8:	eb 5b       	subi	r30, 0xBB	; 187
    16ca:	ff 4f       	sbci	r31, 0xFF	; 255
    16cc:	60 81       	ld	r22, Z
    16ce:	71 81       	ldd	r23, Z+1	; 0x01
    16d0:	82 81       	ldd	r24, Z+2	; 0x02
    16d2:	93 81       	ldd	r25, Z+3	; 0x03
    16d4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16d8:	dc 01       	movw	r26, r24
    16da:	cb 01       	movw	r24, r22
    16dc:	f8 01       	movw	r30, r16
    16de:	91 83       	std	Z+1, r25	; 0x01
    16e0:	80 83       	st	Z, r24
    16e2:	fe 01       	movw	r30, r28
    16e4:	ed 5b       	subi	r30, 0xBD	; 189
    16e6:	ff 4f       	sbci	r31, 0xFF	; 255
    16e8:	80 81       	ld	r24, Z
    16ea:	91 81       	ldd	r25, Z+1	; 0x01
    16ec:	fe 01       	movw	r30, r28
    16ee:	ff 96       	adiw	r30, 0x3f	; 63
    16f0:	91 83       	std	Z+1, r25	; 0x01
    16f2:	80 83       	st	Z, r24
    16f4:	fe 01       	movw	r30, r28
    16f6:	ff 96       	adiw	r30, 0x3f	; 63
    16f8:	80 81       	ld	r24, Z
    16fa:	91 81       	ldd	r25, Z+1	; 0x01
    16fc:	01 97       	sbiw	r24, 0x01	; 1
    16fe:	f1 f7       	brne	.-4      	; 0x16fc <LCD_voidInit+0x16e>
    1700:	fe 01       	movw	r30, r28
    1702:	ff 96       	adiw	r30, 0x3f	; 63
    1704:	91 83       	std	Z+1, r25	; 0x01
    1706:	80 83       	st	Z, r24
	/* Step 2: Function Set Command
	1- DL: 1 --> 8 bit-mode
	2- N:  1 --> 2 lines
	3- F:  0 --> 5 * 7 dots */
#if LCD_u8_MODE == LCD_u8_MODE_8_BIT
	LCD_voidSendCmnd(LCD_u8_FUNCTION_SET_CMND);
    1708:	88 e3       	ldi	r24, 0x38	; 56
    170a:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
    170e:	80 e0       	ldi	r24, 0x00	; 0
    1710:	90 e0       	ldi	r25, 0x00	; 0
    1712:	a0 e2       	ldi	r26, 0x20	; 32
    1714:	b2 e4       	ldi	r27, 0x42	; 66
    1716:	8b af       	std	Y+59, r24	; 0x3b
    1718:	9c af       	std	Y+60, r25	; 0x3c
    171a:	ad af       	std	Y+61, r26	; 0x3d
    171c:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    171e:	6b ad       	ldd	r22, Y+59	; 0x3b
    1720:	7c ad       	ldd	r23, Y+60	; 0x3c
    1722:	8d ad       	ldd	r24, Y+61	; 0x3d
    1724:	9e ad       	ldd	r25, Y+62	; 0x3e
    1726:	2b ea       	ldi	r18, 0xAB	; 171
    1728:	3a ea       	ldi	r19, 0xAA	; 170
    172a:	4a e2       	ldi	r20, 0x2A	; 42
    172c:	50 e4       	ldi	r21, 0x40	; 64
    172e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1732:	dc 01       	movw	r26, r24
    1734:	cb 01       	movw	r24, r22
    1736:	8f ab       	std	Y+55, r24	; 0x37
    1738:	98 af       	std	Y+56, r25	; 0x38
    173a:	a9 af       	std	Y+57, r26	; 0x39
    173c:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    173e:	6f a9       	ldd	r22, Y+55	; 0x37
    1740:	78 ad       	ldd	r23, Y+56	; 0x38
    1742:	89 ad       	ldd	r24, Y+57	; 0x39
    1744:	9a ad       	ldd	r25, Y+58	; 0x3a
    1746:	20 e0       	ldi	r18, 0x00	; 0
    1748:	30 e0       	ldi	r19, 0x00	; 0
    174a:	40 e8       	ldi	r20, 0x80	; 128
    174c:	5f e3       	ldi	r21, 0x3F	; 63
    174e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1752:	88 23       	and	r24, r24
    1754:	1c f4       	brge	.+6      	; 0x175c <LCD_voidInit+0x1ce>
		__ticks = 1;
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	8e ab       	std	Y+54, r24	; 0x36
    175a:	91 c0       	rjmp	.+290    	; 0x187e <LCD_voidInit+0x2f0>
	else if (__tmp > 255)
    175c:	6f a9       	ldd	r22, Y+55	; 0x37
    175e:	78 ad       	ldd	r23, Y+56	; 0x38
    1760:	89 ad       	ldd	r24, Y+57	; 0x39
    1762:	9a ad       	ldd	r25, Y+58	; 0x3a
    1764:	20 e0       	ldi	r18, 0x00	; 0
    1766:	30 e0       	ldi	r19, 0x00	; 0
    1768:	4f e7       	ldi	r20, 0x7F	; 127
    176a:	53 e4       	ldi	r21, 0x43	; 67
    176c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1770:	18 16       	cp	r1, r24
    1772:	0c f0       	brlt	.+2      	; 0x1776 <LCD_voidInit+0x1e8>
    1774:	7b c0       	rjmp	.+246    	; 0x186c <LCD_voidInit+0x2de>
	{
		_delay_ms(__us / 1000.0);
    1776:	6b ad       	ldd	r22, Y+59	; 0x3b
    1778:	7c ad       	ldd	r23, Y+60	; 0x3c
    177a:	8d ad       	ldd	r24, Y+61	; 0x3d
    177c:	9e ad       	ldd	r25, Y+62	; 0x3e
    177e:	20 e0       	ldi	r18, 0x00	; 0
    1780:	30 e0       	ldi	r19, 0x00	; 0
    1782:	4a e7       	ldi	r20, 0x7A	; 122
    1784:	54 e4       	ldi	r21, 0x44	; 68
    1786:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    178a:	dc 01       	movw	r26, r24
    178c:	cb 01       	movw	r24, r22
    178e:	8a ab       	std	Y+50, r24	; 0x32
    1790:	9b ab       	std	Y+51, r25	; 0x33
    1792:	ac ab       	std	Y+52, r26	; 0x34
    1794:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1796:	6a a9       	ldd	r22, Y+50	; 0x32
    1798:	7b a9       	ldd	r23, Y+51	; 0x33
    179a:	8c a9       	ldd	r24, Y+52	; 0x34
    179c:	9d a9       	ldd	r25, Y+53	; 0x35
    179e:	20 e0       	ldi	r18, 0x00	; 0
    17a0:	30 e0       	ldi	r19, 0x00	; 0
    17a2:	4a ef       	ldi	r20, 0xFA	; 250
    17a4:	54 e4       	ldi	r21, 0x44	; 68
    17a6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17aa:	dc 01       	movw	r26, r24
    17ac:	cb 01       	movw	r24, r22
    17ae:	8e a7       	std	Y+46, r24	; 0x2e
    17b0:	9f a7       	std	Y+47, r25	; 0x2f
    17b2:	a8 ab       	std	Y+48, r26	; 0x30
    17b4:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    17b6:	6e a5       	ldd	r22, Y+46	; 0x2e
    17b8:	7f a5       	ldd	r23, Y+47	; 0x2f
    17ba:	88 a9       	ldd	r24, Y+48	; 0x30
    17bc:	99 a9       	ldd	r25, Y+49	; 0x31
    17be:	20 e0       	ldi	r18, 0x00	; 0
    17c0:	30 e0       	ldi	r19, 0x00	; 0
    17c2:	40 e8       	ldi	r20, 0x80	; 128
    17c4:	5f e3       	ldi	r21, 0x3F	; 63
    17c6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    17ca:	88 23       	and	r24, r24
    17cc:	2c f4       	brge	.+10     	; 0x17d8 <LCD_voidInit+0x24a>
		__ticks = 1;
    17ce:	81 e0       	ldi	r24, 0x01	; 1
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	9d a7       	std	Y+45, r25	; 0x2d
    17d4:	8c a7       	std	Y+44, r24	; 0x2c
    17d6:	3f c0       	rjmp	.+126    	; 0x1856 <LCD_voidInit+0x2c8>
	else if (__tmp > 65535)
    17d8:	6e a5       	ldd	r22, Y+46	; 0x2e
    17da:	7f a5       	ldd	r23, Y+47	; 0x2f
    17dc:	88 a9       	ldd	r24, Y+48	; 0x30
    17de:	99 a9       	ldd	r25, Y+49	; 0x31
    17e0:	20 e0       	ldi	r18, 0x00	; 0
    17e2:	3f ef       	ldi	r19, 0xFF	; 255
    17e4:	4f e7       	ldi	r20, 0x7F	; 127
    17e6:	57 e4       	ldi	r21, 0x47	; 71
    17e8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    17ec:	18 16       	cp	r1, r24
    17ee:	4c f5       	brge	.+82     	; 0x1842 <LCD_voidInit+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    17f0:	6a a9       	ldd	r22, Y+50	; 0x32
    17f2:	7b a9       	ldd	r23, Y+51	; 0x33
    17f4:	8c a9       	ldd	r24, Y+52	; 0x34
    17f6:	9d a9       	ldd	r25, Y+53	; 0x35
    17f8:	20 e0       	ldi	r18, 0x00	; 0
    17fa:	30 e0       	ldi	r19, 0x00	; 0
    17fc:	40 e2       	ldi	r20, 0x20	; 32
    17fe:	51 e4       	ldi	r21, 0x41	; 65
    1800:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1804:	dc 01       	movw	r26, r24
    1806:	cb 01       	movw	r24, r22
    1808:	bc 01       	movw	r22, r24
    180a:	cd 01       	movw	r24, r26
    180c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1810:	dc 01       	movw	r26, r24
    1812:	cb 01       	movw	r24, r22
    1814:	9d a7       	std	Y+45, r25	; 0x2d
    1816:	8c a7       	std	Y+44, r24	; 0x2c
    1818:	0f c0       	rjmp	.+30     	; 0x1838 <LCD_voidInit+0x2aa>
    181a:	88 ec       	ldi	r24, 0xC8	; 200
    181c:	90 e0       	ldi	r25, 0x00	; 0
    181e:	9b a7       	std	Y+43, r25	; 0x2b
    1820:	8a a7       	std	Y+42, r24	; 0x2a
    1822:	8a a5       	ldd	r24, Y+42	; 0x2a
    1824:	9b a5       	ldd	r25, Y+43	; 0x2b
    1826:	01 97       	sbiw	r24, 0x01	; 1
    1828:	f1 f7       	brne	.-4      	; 0x1826 <LCD_voidInit+0x298>
    182a:	9b a7       	std	Y+43, r25	; 0x2b
    182c:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    182e:	8c a5       	ldd	r24, Y+44	; 0x2c
    1830:	9d a5       	ldd	r25, Y+45	; 0x2d
    1832:	01 97       	sbiw	r24, 0x01	; 1
    1834:	9d a7       	std	Y+45, r25	; 0x2d
    1836:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1838:	8c a5       	ldd	r24, Y+44	; 0x2c
    183a:	9d a5       	ldd	r25, Y+45	; 0x2d
    183c:	00 97       	sbiw	r24, 0x00	; 0
    183e:	69 f7       	brne	.-38     	; 0x181a <LCD_voidInit+0x28c>
    1840:	24 c0       	rjmp	.+72     	; 0x188a <LCD_voidInit+0x2fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1842:	6e a5       	ldd	r22, Y+46	; 0x2e
    1844:	7f a5       	ldd	r23, Y+47	; 0x2f
    1846:	88 a9       	ldd	r24, Y+48	; 0x30
    1848:	99 a9       	ldd	r25, Y+49	; 0x31
    184a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    184e:	dc 01       	movw	r26, r24
    1850:	cb 01       	movw	r24, r22
    1852:	9d a7       	std	Y+45, r25	; 0x2d
    1854:	8c a7       	std	Y+44, r24	; 0x2c
    1856:	8c a5       	ldd	r24, Y+44	; 0x2c
    1858:	9d a5       	ldd	r25, Y+45	; 0x2d
    185a:	99 a7       	std	Y+41, r25	; 0x29
    185c:	88 a7       	std	Y+40, r24	; 0x28
    185e:	88 a5       	ldd	r24, Y+40	; 0x28
    1860:	99 a5       	ldd	r25, Y+41	; 0x29
    1862:	01 97       	sbiw	r24, 0x01	; 1
    1864:	f1 f7       	brne	.-4      	; 0x1862 <LCD_voidInit+0x2d4>
    1866:	99 a7       	std	Y+41, r25	; 0x29
    1868:	88 a7       	std	Y+40, r24	; 0x28
    186a:	0f c0       	rjmp	.+30     	; 0x188a <LCD_voidInit+0x2fc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    186c:	6f a9       	ldd	r22, Y+55	; 0x37
    186e:	78 ad       	ldd	r23, Y+56	; 0x38
    1870:	89 ad       	ldd	r24, Y+57	; 0x39
    1872:	9a ad       	ldd	r25, Y+58	; 0x3a
    1874:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1878:	dc 01       	movw	r26, r24
    187a:	cb 01       	movw	r24, r22
    187c:	8e ab       	std	Y+54, r24	; 0x36
    187e:	8e a9       	ldd	r24, Y+54	; 0x36
    1880:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1882:	8f a1       	ldd	r24, Y+39	; 0x27
    1884:	8a 95       	dec	r24
    1886:	f1 f7       	brne	.-4      	; 0x1884 <LCD_voidInit+0x2f6>
    1888:	8f a3       	std	Y+39, r24	; 0x27
	_delay_us(40); //Step 3: wait 39 us
	/* Step 4: DisplayControl Command
	1- D:  1 --> Display on
	2- C:  1 --> Cursor Display on
	3- B:  1 --> Blinking on */
	LCD_voidSendCmnd(LCD_u8_DISPLAY_CONTROL_CMND);
    188a:	8f e0       	ldi	r24, 0x0F	; 15
    188c:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
    1890:	80 e0       	ldi	r24, 0x00	; 0
    1892:	90 e0       	ldi	r25, 0x00	; 0
    1894:	a0 e2       	ldi	r26, 0x20	; 32
    1896:	b2 e4       	ldi	r27, 0x42	; 66
    1898:	8b a3       	std	Y+35, r24	; 0x23
    189a:	9c a3       	std	Y+36, r25	; 0x24
    189c:	ad a3       	std	Y+37, r26	; 0x25
    189e:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    18a0:	6b a1       	ldd	r22, Y+35	; 0x23
    18a2:	7c a1       	ldd	r23, Y+36	; 0x24
    18a4:	8d a1       	ldd	r24, Y+37	; 0x25
    18a6:	9e a1       	ldd	r25, Y+38	; 0x26
    18a8:	2b ea       	ldi	r18, 0xAB	; 171
    18aa:	3a ea       	ldi	r19, 0xAA	; 170
    18ac:	4a e2       	ldi	r20, 0x2A	; 42
    18ae:	50 e4       	ldi	r21, 0x40	; 64
    18b0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18b4:	dc 01       	movw	r26, r24
    18b6:	cb 01       	movw	r24, r22
    18b8:	8f 8f       	std	Y+31, r24	; 0x1f
    18ba:	98 a3       	std	Y+32, r25	; 0x20
    18bc:	a9 a3       	std	Y+33, r26	; 0x21
    18be:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    18c0:	6f 8d       	ldd	r22, Y+31	; 0x1f
    18c2:	78 a1       	ldd	r23, Y+32	; 0x20
    18c4:	89 a1       	ldd	r24, Y+33	; 0x21
    18c6:	9a a1       	ldd	r25, Y+34	; 0x22
    18c8:	20 e0       	ldi	r18, 0x00	; 0
    18ca:	30 e0       	ldi	r19, 0x00	; 0
    18cc:	40 e8       	ldi	r20, 0x80	; 128
    18ce:	5f e3       	ldi	r21, 0x3F	; 63
    18d0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    18d4:	88 23       	and	r24, r24
    18d6:	1c f4       	brge	.+6      	; 0x18de <LCD_voidInit+0x350>
		__ticks = 1;
    18d8:	81 e0       	ldi	r24, 0x01	; 1
    18da:	8e 8f       	std	Y+30, r24	; 0x1e
    18dc:	91 c0       	rjmp	.+290    	; 0x1a00 <LCD_voidInit+0x472>
	else if (__tmp > 255)
    18de:	6f 8d       	ldd	r22, Y+31	; 0x1f
    18e0:	78 a1       	ldd	r23, Y+32	; 0x20
    18e2:	89 a1       	ldd	r24, Y+33	; 0x21
    18e4:	9a a1       	ldd	r25, Y+34	; 0x22
    18e6:	20 e0       	ldi	r18, 0x00	; 0
    18e8:	30 e0       	ldi	r19, 0x00	; 0
    18ea:	4f e7       	ldi	r20, 0x7F	; 127
    18ec:	53 e4       	ldi	r21, 0x43	; 67
    18ee:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    18f2:	18 16       	cp	r1, r24
    18f4:	0c f0       	brlt	.+2      	; 0x18f8 <LCD_voidInit+0x36a>
    18f6:	7b c0       	rjmp	.+246    	; 0x19ee <LCD_voidInit+0x460>
	{
		_delay_ms(__us / 1000.0);
    18f8:	6b a1       	ldd	r22, Y+35	; 0x23
    18fa:	7c a1       	ldd	r23, Y+36	; 0x24
    18fc:	8d a1       	ldd	r24, Y+37	; 0x25
    18fe:	9e a1       	ldd	r25, Y+38	; 0x26
    1900:	20 e0       	ldi	r18, 0x00	; 0
    1902:	30 e0       	ldi	r19, 0x00	; 0
    1904:	4a e7       	ldi	r20, 0x7A	; 122
    1906:	54 e4       	ldi	r21, 0x44	; 68
    1908:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    190c:	dc 01       	movw	r26, r24
    190e:	cb 01       	movw	r24, r22
    1910:	8a 8f       	std	Y+26, r24	; 0x1a
    1912:	9b 8f       	std	Y+27, r25	; 0x1b
    1914:	ac 8f       	std	Y+28, r26	; 0x1c
    1916:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1918:	6a 8d       	ldd	r22, Y+26	; 0x1a
    191a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    191c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    191e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1920:	20 e0       	ldi	r18, 0x00	; 0
    1922:	30 e0       	ldi	r19, 0x00	; 0
    1924:	4a ef       	ldi	r20, 0xFA	; 250
    1926:	54 e4       	ldi	r21, 0x44	; 68
    1928:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    192c:	dc 01       	movw	r26, r24
    192e:	cb 01       	movw	r24, r22
    1930:	8e 8b       	std	Y+22, r24	; 0x16
    1932:	9f 8b       	std	Y+23, r25	; 0x17
    1934:	a8 8f       	std	Y+24, r26	; 0x18
    1936:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    1938:	6e 89       	ldd	r22, Y+22	; 0x16
    193a:	7f 89       	ldd	r23, Y+23	; 0x17
    193c:	88 8d       	ldd	r24, Y+24	; 0x18
    193e:	99 8d       	ldd	r25, Y+25	; 0x19
    1940:	20 e0       	ldi	r18, 0x00	; 0
    1942:	30 e0       	ldi	r19, 0x00	; 0
    1944:	40 e8       	ldi	r20, 0x80	; 128
    1946:	5f e3       	ldi	r21, 0x3F	; 63
    1948:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    194c:	88 23       	and	r24, r24
    194e:	2c f4       	brge	.+10     	; 0x195a <LCD_voidInit+0x3cc>
		__ticks = 1;
    1950:	81 e0       	ldi	r24, 0x01	; 1
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	9d 8b       	std	Y+21, r25	; 0x15
    1956:	8c 8b       	std	Y+20, r24	; 0x14
    1958:	3f c0       	rjmp	.+126    	; 0x19d8 <LCD_voidInit+0x44a>
	else if (__tmp > 65535)
    195a:	6e 89       	ldd	r22, Y+22	; 0x16
    195c:	7f 89       	ldd	r23, Y+23	; 0x17
    195e:	88 8d       	ldd	r24, Y+24	; 0x18
    1960:	99 8d       	ldd	r25, Y+25	; 0x19
    1962:	20 e0       	ldi	r18, 0x00	; 0
    1964:	3f ef       	ldi	r19, 0xFF	; 255
    1966:	4f e7       	ldi	r20, 0x7F	; 127
    1968:	57 e4       	ldi	r21, 0x47	; 71
    196a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    196e:	18 16       	cp	r1, r24
    1970:	4c f5       	brge	.+82     	; 0x19c4 <LCD_voidInit+0x436>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1972:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1974:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1976:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1978:	9d 8d       	ldd	r25, Y+29	; 0x1d
    197a:	20 e0       	ldi	r18, 0x00	; 0
    197c:	30 e0       	ldi	r19, 0x00	; 0
    197e:	40 e2       	ldi	r20, 0x20	; 32
    1980:	51 e4       	ldi	r21, 0x41	; 65
    1982:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1986:	dc 01       	movw	r26, r24
    1988:	cb 01       	movw	r24, r22
    198a:	bc 01       	movw	r22, r24
    198c:	cd 01       	movw	r24, r26
    198e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1992:	dc 01       	movw	r26, r24
    1994:	cb 01       	movw	r24, r22
    1996:	9d 8b       	std	Y+21, r25	; 0x15
    1998:	8c 8b       	std	Y+20, r24	; 0x14
    199a:	0f c0       	rjmp	.+30     	; 0x19ba <LCD_voidInit+0x42c>
    199c:	88 ec       	ldi	r24, 0xC8	; 200
    199e:	90 e0       	ldi	r25, 0x00	; 0
    19a0:	9b 8b       	std	Y+19, r25	; 0x13
    19a2:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    19a4:	8a 89       	ldd	r24, Y+18	; 0x12
    19a6:	9b 89       	ldd	r25, Y+19	; 0x13
    19a8:	01 97       	sbiw	r24, 0x01	; 1
    19aa:	f1 f7       	brne	.-4      	; 0x19a8 <LCD_voidInit+0x41a>
    19ac:	9b 8b       	std	Y+19, r25	; 0x13
    19ae:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19b0:	8c 89       	ldd	r24, Y+20	; 0x14
    19b2:	9d 89       	ldd	r25, Y+21	; 0x15
    19b4:	01 97       	sbiw	r24, 0x01	; 1
    19b6:	9d 8b       	std	Y+21, r25	; 0x15
    19b8:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19ba:	8c 89       	ldd	r24, Y+20	; 0x14
    19bc:	9d 89       	ldd	r25, Y+21	; 0x15
    19be:	00 97       	sbiw	r24, 0x00	; 0
    19c0:	69 f7       	brne	.-38     	; 0x199c <LCD_voidInit+0x40e>
    19c2:	24 c0       	rjmp	.+72     	; 0x1a0c <LCD_voidInit+0x47e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    19c4:	6e 89       	ldd	r22, Y+22	; 0x16
    19c6:	7f 89       	ldd	r23, Y+23	; 0x17
    19c8:	88 8d       	ldd	r24, Y+24	; 0x18
    19ca:	99 8d       	ldd	r25, Y+25	; 0x19
    19cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19d0:	dc 01       	movw	r26, r24
    19d2:	cb 01       	movw	r24, r22
    19d4:	9d 8b       	std	Y+21, r25	; 0x15
    19d6:	8c 8b       	std	Y+20, r24	; 0x14
    19d8:	8c 89       	ldd	r24, Y+20	; 0x14
    19da:	9d 89       	ldd	r25, Y+21	; 0x15
    19dc:	99 8b       	std	Y+17, r25	; 0x11
    19de:	88 8b       	std	Y+16, r24	; 0x10
    19e0:	88 89       	ldd	r24, Y+16	; 0x10
    19e2:	99 89       	ldd	r25, Y+17	; 0x11
    19e4:	01 97       	sbiw	r24, 0x01	; 1
    19e6:	f1 f7       	brne	.-4      	; 0x19e4 <LCD_voidInit+0x456>
    19e8:	99 8b       	std	Y+17, r25	; 0x11
    19ea:	88 8b       	std	Y+16, r24	; 0x10
    19ec:	0f c0       	rjmp	.+30     	; 0x1a0c <LCD_voidInit+0x47e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    19ee:	6f 8d       	ldd	r22, Y+31	; 0x1f
    19f0:	78 a1       	ldd	r23, Y+32	; 0x20
    19f2:	89 a1       	ldd	r24, Y+33	; 0x21
    19f4:	9a a1       	ldd	r25, Y+34	; 0x22
    19f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19fa:	dc 01       	movw	r26, r24
    19fc:	cb 01       	movw	r24, r22
    19fe:	8e 8f       	std	Y+30, r24	; 0x1e
    1a00:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a02:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1a04:	8f 85       	ldd	r24, Y+15	; 0x0f
    1a06:	8a 95       	dec	r24
    1a08:	f1 f7       	brne	.-4      	; 0x1a06 <LCD_voidInit+0x478>
    1a0a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_us(40); //Step 5: wait 39 us
	/* Step 6: Display Clear Command*/
	LCD_voidSendCmnd(LCD_u8_DISPLAY_CLEAR_CMND);
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
    1a0e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
    1a12:	80 e0       	ldi	r24, 0x00	; 0
    1a14:	90 e0       	ldi	r25, 0x00	; 0
    1a16:	a0 e0       	ldi	r26, 0x00	; 0
    1a18:	b0 e4       	ldi	r27, 0x40	; 64
    1a1a:	8b 87       	std	Y+11, r24	; 0x0b
    1a1c:	9c 87       	std	Y+12, r25	; 0x0c
    1a1e:	ad 87       	std	Y+13, r26	; 0x0d
    1a20:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1a22:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a24:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a26:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a28:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a2a:	20 e0       	ldi	r18, 0x00	; 0
    1a2c:	30 e0       	ldi	r19, 0x00	; 0
    1a2e:	4a ef       	ldi	r20, 0xFA	; 250
    1a30:	54 e4       	ldi	r21, 0x44	; 68
    1a32:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a36:	dc 01       	movw	r26, r24
    1a38:	cb 01       	movw	r24, r22
    1a3a:	8f 83       	std	Y+7, r24	; 0x07
    1a3c:	98 87       	std	Y+8, r25	; 0x08
    1a3e:	a9 87       	std	Y+9, r26	; 0x09
    1a40:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1a42:	6f 81       	ldd	r22, Y+7	; 0x07
    1a44:	78 85       	ldd	r23, Y+8	; 0x08
    1a46:	89 85       	ldd	r24, Y+9	; 0x09
    1a48:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a4a:	20 e0       	ldi	r18, 0x00	; 0
    1a4c:	30 e0       	ldi	r19, 0x00	; 0
    1a4e:	40 e8       	ldi	r20, 0x80	; 128
    1a50:	5f e3       	ldi	r21, 0x3F	; 63
    1a52:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1a56:	88 23       	and	r24, r24
    1a58:	2c f4       	brge	.+10     	; 0x1a64 <LCD_voidInit+0x4d6>
		__ticks = 1;
    1a5a:	81 e0       	ldi	r24, 0x01	; 1
    1a5c:	90 e0       	ldi	r25, 0x00	; 0
    1a5e:	9e 83       	std	Y+6, r25	; 0x06
    1a60:	8d 83       	std	Y+5, r24	; 0x05
    1a62:	3f c0       	rjmp	.+126    	; 0x1ae2 <LCD_voidInit+0x554>
	else if (__tmp > 65535)
    1a64:	6f 81       	ldd	r22, Y+7	; 0x07
    1a66:	78 85       	ldd	r23, Y+8	; 0x08
    1a68:	89 85       	ldd	r24, Y+9	; 0x09
    1a6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a6c:	20 e0       	ldi	r18, 0x00	; 0
    1a6e:	3f ef       	ldi	r19, 0xFF	; 255
    1a70:	4f e7       	ldi	r20, 0x7F	; 127
    1a72:	57 e4       	ldi	r21, 0x47	; 71
    1a74:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1a78:	18 16       	cp	r1, r24
    1a7a:	4c f5       	brge	.+82     	; 0x1ace <LCD_voidInit+0x540>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a7c:	6b 85       	ldd	r22, Y+11	; 0x0b
    1a7e:	7c 85       	ldd	r23, Y+12	; 0x0c
    1a80:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a82:	9e 85       	ldd	r25, Y+14	; 0x0e
    1a84:	20 e0       	ldi	r18, 0x00	; 0
    1a86:	30 e0       	ldi	r19, 0x00	; 0
    1a88:	40 e2       	ldi	r20, 0x20	; 32
    1a8a:	51 e4       	ldi	r21, 0x41	; 65
    1a8c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a90:	dc 01       	movw	r26, r24
    1a92:	cb 01       	movw	r24, r22
    1a94:	bc 01       	movw	r22, r24
    1a96:	cd 01       	movw	r24, r26
    1a98:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a9c:	dc 01       	movw	r26, r24
    1a9e:	cb 01       	movw	r24, r22
    1aa0:	9e 83       	std	Y+6, r25	; 0x06
    1aa2:	8d 83       	std	Y+5, r24	; 0x05
    1aa4:	0f c0       	rjmp	.+30     	; 0x1ac4 <LCD_voidInit+0x536>
    1aa6:	88 ec       	ldi	r24, 0xC8	; 200
    1aa8:	90 e0       	ldi	r25, 0x00	; 0
    1aaa:	9c 83       	std	Y+4, r25	; 0x04
    1aac:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1aae:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab2:	01 97       	sbiw	r24, 0x01	; 1
    1ab4:	f1 f7       	brne	.-4      	; 0x1ab2 <LCD_voidInit+0x524>
    1ab6:	9c 83       	std	Y+4, r25	; 0x04
    1ab8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1aba:	8d 81       	ldd	r24, Y+5	; 0x05
    1abc:	9e 81       	ldd	r25, Y+6	; 0x06
    1abe:	01 97       	sbiw	r24, 0x01	; 1
    1ac0:	9e 83       	std	Y+6, r25	; 0x06
    1ac2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ac4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ac6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ac8:	00 97       	sbiw	r24, 0x00	; 0
    1aca:	69 f7       	brne	.-38     	; 0x1aa6 <LCD_voidInit+0x518>
    1acc:	14 c0       	rjmp	.+40     	; 0x1af6 <LCD_voidInit+0x568>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ace:	6f 81       	ldd	r22, Y+7	; 0x07
    1ad0:	78 85       	ldd	r23, Y+8	; 0x08
    1ad2:	89 85       	ldd	r24, Y+9	; 0x09
    1ad4:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ad6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ada:	dc 01       	movw	r26, r24
    1adc:	cb 01       	movw	r24, r22
    1ade:	9e 83       	std	Y+6, r25	; 0x06
    1ae0:	8d 83       	std	Y+5, r24	; 0x05
    1ae2:	8d 81       	ldd	r24, Y+5	; 0x05
    1ae4:	9e 81       	ldd	r25, Y+6	; 0x06
    1ae6:	9a 83       	std	Y+2, r25	; 0x02
    1ae8:	89 83       	std	Y+1, r24	; 0x01
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
    1aec:	9a 81       	ldd	r25, Y+2	; 0x02
    1aee:	01 97       	sbiw	r24, 0x01	; 1
    1af0:	f1 f7       	brne	.-4      	; 0x1aee <LCD_voidInit+0x560>
    1af2:	9a 83       	std	Y+2, r25	; 0x02
    1af4:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2); //Step 7:wait more than 1.53 ms
	/* Step 8: Entry Mode Set Command
	1- I/D: 1 --> Increase
	2- SH: 0 --> no shift*/
	LCD_voidSendCmnd(LCD_u8_ENTRY_MODE_SET_CMND);
    1af6:	86 e0       	ldi	r24, 0x06	; 6
    1af8:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>


}
    1afc:	c4 5b       	subi	r28, 0xB4	; 180
    1afe:	df 4f       	sbci	r29, 0xFF	; 255
    1b00:	0f b6       	in	r0, 0x3f	; 63
    1b02:	f8 94       	cli
    1b04:	de bf       	out	0x3e, r29	; 62
    1b06:	0f be       	out	0x3f, r0	; 63
    1b08:	cd bf       	out	0x3d, r28	; 61
    1b0a:	cf 91       	pop	r28
    1b0c:	df 91       	pop	r29
    1b0e:	1f 91       	pop	r17
    1b10:	0f 91       	pop	r16
    1b12:	08 95       	ret

00001b14 <LCD_voidSendCmnd>:

void LCD_voidSendCmnd(u8 Copy_u8Cmnd)
{
    1b14:	df 93       	push	r29
    1b16:	cf 93       	push	r28
    1b18:	cd b7       	in	r28, 0x3d	; 61
    1b1a:	de b7       	in	r29, 0x3e	; 62
    1b1c:	e1 97       	sbiw	r28, 0x31	; 49
    1b1e:	0f b6       	in	r0, 0x3f	; 63
    1b20:	f8 94       	cli
    1b22:	de bf       	out	0x3e, r29	; 62
    1b24:	0f be       	out	0x3f, r0	; 63
    1b26:	cd bf       	out	0x3d, r28	; 61
    1b28:	89 ab       	std	Y+49, r24	; 0x31
#if LCD_u8_MODE == LCD_u8_MODE_8_BIT
	/* Step 1: RS = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RS_PIN,DIO_u8_LOW);
    1b2a:	80 e0       	ldi	r24, 0x00	; 0
    1b2c:	60 e0       	ldi	r22, 0x00	; 0
    1b2e:	40 e0       	ldi	r20, 0x00	; 0
    1b30:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
	/* Step 2: RW = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RW_PIN,DIO_u8_LOW);
    1b34:	80 e0       	ldi	r24, 0x00	; 0
    1b36:	61 e0       	ldi	r22, 0x01	; 1
    1b38:	40 e0       	ldi	r20, 0x00	; 0
    1b3a:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
	/* Step 3: Write Command  */
	DIO_u8SetPortValue(LCD_u8_DATA_PORT,Copy_u8Cmnd);
    1b3e:	82 e0       	ldi	r24, 0x02	; 2
    1b40:	69 a9       	ldd	r22, Y+49	; 0x31
    1b42:	0e 94 27 0a 	call	0x144e	; 0x144e <DIO_u8SetPortValue>
	/* Step 4: E = 1 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_HIGH);
    1b46:	80 e0       	ldi	r24, 0x00	; 0
    1b48:	62 e0       	ldi	r22, 0x02	; 2
    1b4a:	41 e0       	ldi	r20, 0x01	; 1
    1b4c:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
    1b50:	80 e0       	ldi	r24, 0x00	; 0
    1b52:	90 e0       	ldi	r25, 0x00	; 0
    1b54:	a0 e8       	ldi	r26, 0x80	; 128
    1b56:	bf e3       	ldi	r27, 0x3F	; 63
    1b58:	8d a7       	std	Y+45, r24	; 0x2d
    1b5a:	9e a7       	std	Y+46, r25	; 0x2e
    1b5c:	af a7       	std	Y+47, r26	; 0x2f
    1b5e:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1b60:	6d a5       	ldd	r22, Y+45	; 0x2d
    1b62:	7e a5       	ldd	r23, Y+46	; 0x2e
    1b64:	8f a5       	ldd	r24, Y+47	; 0x2f
    1b66:	98 a9       	ldd	r25, Y+48	; 0x30
    1b68:	2b ea       	ldi	r18, 0xAB	; 171
    1b6a:	3a ea       	ldi	r19, 0xAA	; 170
    1b6c:	4a e2       	ldi	r20, 0x2A	; 42
    1b6e:	50 e4       	ldi	r21, 0x40	; 64
    1b70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b74:	dc 01       	movw	r26, r24
    1b76:	cb 01       	movw	r24, r22
    1b78:	89 a7       	std	Y+41, r24	; 0x29
    1b7a:	9a a7       	std	Y+42, r25	; 0x2a
    1b7c:	ab a7       	std	Y+43, r26	; 0x2b
    1b7e:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    1b80:	69 a5       	ldd	r22, Y+41	; 0x29
    1b82:	7a a5       	ldd	r23, Y+42	; 0x2a
    1b84:	8b a5       	ldd	r24, Y+43	; 0x2b
    1b86:	9c a5       	ldd	r25, Y+44	; 0x2c
    1b88:	20 e0       	ldi	r18, 0x00	; 0
    1b8a:	30 e0       	ldi	r19, 0x00	; 0
    1b8c:	40 e8       	ldi	r20, 0x80	; 128
    1b8e:	5f e3       	ldi	r21, 0x3F	; 63
    1b90:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1b94:	88 23       	and	r24, r24
    1b96:	1c f4       	brge	.+6      	; 0x1b9e <LCD_voidSendCmnd+0x8a>
		__ticks = 1;
    1b98:	81 e0       	ldi	r24, 0x01	; 1
    1b9a:	88 a7       	std	Y+40, r24	; 0x28
    1b9c:	91 c0       	rjmp	.+290    	; 0x1cc0 <LCD_voidSendCmnd+0x1ac>
	else if (__tmp > 255)
    1b9e:	69 a5       	ldd	r22, Y+41	; 0x29
    1ba0:	7a a5       	ldd	r23, Y+42	; 0x2a
    1ba2:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ba4:	9c a5       	ldd	r25, Y+44	; 0x2c
    1ba6:	20 e0       	ldi	r18, 0x00	; 0
    1ba8:	30 e0       	ldi	r19, 0x00	; 0
    1baa:	4f e7       	ldi	r20, 0x7F	; 127
    1bac:	53 e4       	ldi	r21, 0x43	; 67
    1bae:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1bb2:	18 16       	cp	r1, r24
    1bb4:	0c f0       	brlt	.+2      	; 0x1bb8 <LCD_voidSendCmnd+0xa4>
    1bb6:	7b c0       	rjmp	.+246    	; 0x1cae <LCD_voidSendCmnd+0x19a>
	{
		_delay_ms(__us / 1000.0);
    1bb8:	6d a5       	ldd	r22, Y+45	; 0x2d
    1bba:	7e a5       	ldd	r23, Y+46	; 0x2e
    1bbc:	8f a5       	ldd	r24, Y+47	; 0x2f
    1bbe:	98 a9       	ldd	r25, Y+48	; 0x30
    1bc0:	20 e0       	ldi	r18, 0x00	; 0
    1bc2:	30 e0       	ldi	r19, 0x00	; 0
    1bc4:	4a e7       	ldi	r20, 0x7A	; 122
    1bc6:	54 e4       	ldi	r21, 0x44	; 68
    1bc8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1bcc:	dc 01       	movw	r26, r24
    1bce:	cb 01       	movw	r24, r22
    1bd0:	8c a3       	std	Y+36, r24	; 0x24
    1bd2:	9d a3       	std	Y+37, r25	; 0x25
    1bd4:	ae a3       	std	Y+38, r26	; 0x26
    1bd6:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1bd8:	6c a1       	ldd	r22, Y+36	; 0x24
    1bda:	7d a1       	ldd	r23, Y+37	; 0x25
    1bdc:	8e a1       	ldd	r24, Y+38	; 0x26
    1bde:	9f a1       	ldd	r25, Y+39	; 0x27
    1be0:	20 e0       	ldi	r18, 0x00	; 0
    1be2:	30 e0       	ldi	r19, 0x00	; 0
    1be4:	4a ef       	ldi	r20, 0xFA	; 250
    1be6:	54 e4       	ldi	r21, 0x44	; 68
    1be8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bec:	dc 01       	movw	r26, r24
    1bee:	cb 01       	movw	r24, r22
    1bf0:	88 a3       	std	Y+32, r24	; 0x20
    1bf2:	99 a3       	std	Y+33, r25	; 0x21
    1bf4:	aa a3       	std	Y+34, r26	; 0x22
    1bf6:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    1bf8:	68 a1       	ldd	r22, Y+32	; 0x20
    1bfa:	79 a1       	ldd	r23, Y+33	; 0x21
    1bfc:	8a a1       	ldd	r24, Y+34	; 0x22
    1bfe:	9b a1       	ldd	r25, Y+35	; 0x23
    1c00:	20 e0       	ldi	r18, 0x00	; 0
    1c02:	30 e0       	ldi	r19, 0x00	; 0
    1c04:	40 e8       	ldi	r20, 0x80	; 128
    1c06:	5f e3       	ldi	r21, 0x3F	; 63
    1c08:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1c0c:	88 23       	and	r24, r24
    1c0e:	2c f4       	brge	.+10     	; 0x1c1a <LCD_voidSendCmnd+0x106>
		__ticks = 1;
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	9f 8f       	std	Y+31, r25	; 0x1f
    1c16:	8e 8f       	std	Y+30, r24	; 0x1e
    1c18:	3f c0       	rjmp	.+126    	; 0x1c98 <LCD_voidSendCmnd+0x184>
	else if (__tmp > 65535)
    1c1a:	68 a1       	ldd	r22, Y+32	; 0x20
    1c1c:	79 a1       	ldd	r23, Y+33	; 0x21
    1c1e:	8a a1       	ldd	r24, Y+34	; 0x22
    1c20:	9b a1       	ldd	r25, Y+35	; 0x23
    1c22:	20 e0       	ldi	r18, 0x00	; 0
    1c24:	3f ef       	ldi	r19, 0xFF	; 255
    1c26:	4f e7       	ldi	r20, 0x7F	; 127
    1c28:	57 e4       	ldi	r21, 0x47	; 71
    1c2a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1c2e:	18 16       	cp	r1, r24
    1c30:	4c f5       	brge	.+82     	; 0x1c84 <LCD_voidSendCmnd+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c32:	6c a1       	ldd	r22, Y+36	; 0x24
    1c34:	7d a1       	ldd	r23, Y+37	; 0x25
    1c36:	8e a1       	ldd	r24, Y+38	; 0x26
    1c38:	9f a1       	ldd	r25, Y+39	; 0x27
    1c3a:	20 e0       	ldi	r18, 0x00	; 0
    1c3c:	30 e0       	ldi	r19, 0x00	; 0
    1c3e:	40 e2       	ldi	r20, 0x20	; 32
    1c40:	51 e4       	ldi	r21, 0x41	; 65
    1c42:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c46:	dc 01       	movw	r26, r24
    1c48:	cb 01       	movw	r24, r22
    1c4a:	bc 01       	movw	r22, r24
    1c4c:	cd 01       	movw	r24, r26
    1c4e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c52:	dc 01       	movw	r26, r24
    1c54:	cb 01       	movw	r24, r22
    1c56:	9f 8f       	std	Y+31, r25	; 0x1f
    1c58:	8e 8f       	std	Y+30, r24	; 0x1e
    1c5a:	0f c0       	rjmp	.+30     	; 0x1c7a <LCD_voidSendCmnd+0x166>
    1c5c:	88 ec       	ldi	r24, 0xC8	; 200
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	9d 8f       	std	Y+29, r25	; 0x1d
    1c62:	8c 8f       	std	Y+28, r24	; 0x1c
    1c64:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1c66:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1c68:	01 97       	sbiw	r24, 0x01	; 1
    1c6a:	f1 f7       	brne	.-4      	; 0x1c68 <LCD_voidSendCmnd+0x154>
    1c6c:	9d 8f       	std	Y+29, r25	; 0x1d
    1c6e:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c70:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c72:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1c74:	01 97       	sbiw	r24, 0x01	; 1
    1c76:	9f 8f       	std	Y+31, r25	; 0x1f
    1c78:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c7a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c7c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1c7e:	00 97       	sbiw	r24, 0x00	; 0
    1c80:	69 f7       	brne	.-38     	; 0x1c5c <LCD_voidSendCmnd+0x148>
    1c82:	24 c0       	rjmp	.+72     	; 0x1ccc <LCD_voidSendCmnd+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c84:	68 a1       	ldd	r22, Y+32	; 0x20
    1c86:	79 a1       	ldd	r23, Y+33	; 0x21
    1c88:	8a a1       	ldd	r24, Y+34	; 0x22
    1c8a:	9b a1       	ldd	r25, Y+35	; 0x23
    1c8c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c90:	dc 01       	movw	r26, r24
    1c92:	cb 01       	movw	r24, r22
    1c94:	9f 8f       	std	Y+31, r25	; 0x1f
    1c96:	8e 8f       	std	Y+30, r24	; 0x1e
    1c98:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c9a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1c9c:	9b 8f       	std	Y+27, r25	; 0x1b
    1c9e:	8a 8f       	std	Y+26, r24	; 0x1a
    1ca0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ca2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1ca4:	01 97       	sbiw	r24, 0x01	; 1
    1ca6:	f1 f7       	brne	.-4      	; 0x1ca4 <LCD_voidSendCmnd+0x190>
    1ca8:	9b 8f       	std	Y+27, r25	; 0x1b
    1caa:	8a 8f       	std	Y+26, r24	; 0x1a
    1cac:	0f c0       	rjmp	.+30     	; 0x1ccc <LCD_voidSendCmnd+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1cae:	69 a5       	ldd	r22, Y+41	; 0x29
    1cb0:	7a a5       	ldd	r23, Y+42	; 0x2a
    1cb2:	8b a5       	ldd	r24, Y+43	; 0x2b
    1cb4:	9c a5       	ldd	r25, Y+44	; 0x2c
    1cb6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cba:	dc 01       	movw	r26, r24
    1cbc:	cb 01       	movw	r24, r22
    1cbe:	88 a7       	std	Y+40, r24	; 0x28
    1cc0:	88 a5       	ldd	r24, Y+40	; 0x28
    1cc2:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1cc4:	89 8d       	ldd	r24, Y+25	; 0x19
    1cc6:	8a 95       	dec	r24
    1cc8:	f1 f7       	brne	.-4      	; 0x1cc6 <LCD_voidSendCmnd+0x1b2>
    1cca:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1); //wait tw = 230 ns
	/* Step 5: E = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
    1ccc:	80 e0       	ldi	r24, 0x00	; 0
    1cce:	62 e0       	ldi	r22, 0x02	; 2
    1cd0:	40 e0       	ldi	r20, 0x00	; 0
    1cd2:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
    1cd6:	80 e0       	ldi	r24, 0x00	; 0
    1cd8:	90 e0       	ldi	r25, 0x00	; 0
    1cda:	a0 e8       	ldi	r26, 0x80	; 128
    1cdc:	bf e3       	ldi	r27, 0x3F	; 63
    1cde:	8d 8b       	std	Y+21, r24	; 0x15
    1ce0:	9e 8b       	std	Y+22, r25	; 0x16
    1ce2:	af 8b       	std	Y+23, r26	; 0x17
    1ce4:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1ce6:	6d 89       	ldd	r22, Y+21	; 0x15
    1ce8:	7e 89       	ldd	r23, Y+22	; 0x16
    1cea:	8f 89       	ldd	r24, Y+23	; 0x17
    1cec:	98 8d       	ldd	r25, Y+24	; 0x18
    1cee:	2b ea       	ldi	r18, 0xAB	; 171
    1cf0:	3a ea       	ldi	r19, 0xAA	; 170
    1cf2:	4a e2       	ldi	r20, 0x2A	; 42
    1cf4:	50 e4       	ldi	r21, 0x40	; 64
    1cf6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cfa:	dc 01       	movw	r26, r24
    1cfc:	cb 01       	movw	r24, r22
    1cfe:	89 8b       	std	Y+17, r24	; 0x11
    1d00:	9a 8b       	std	Y+18, r25	; 0x12
    1d02:	ab 8b       	std	Y+19, r26	; 0x13
    1d04:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    1d06:	69 89       	ldd	r22, Y+17	; 0x11
    1d08:	7a 89       	ldd	r23, Y+18	; 0x12
    1d0a:	8b 89       	ldd	r24, Y+19	; 0x13
    1d0c:	9c 89       	ldd	r25, Y+20	; 0x14
    1d0e:	20 e0       	ldi	r18, 0x00	; 0
    1d10:	30 e0       	ldi	r19, 0x00	; 0
    1d12:	40 e8       	ldi	r20, 0x80	; 128
    1d14:	5f e3       	ldi	r21, 0x3F	; 63
    1d16:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1d1a:	88 23       	and	r24, r24
    1d1c:	1c f4       	brge	.+6      	; 0x1d24 <LCD_voidSendCmnd+0x210>
		__ticks = 1;
    1d1e:	81 e0       	ldi	r24, 0x01	; 1
    1d20:	88 8b       	std	Y+16, r24	; 0x10
    1d22:	91 c0       	rjmp	.+290    	; 0x1e46 <LCD_voidSendCmnd+0x332>
	else if (__tmp > 255)
    1d24:	69 89       	ldd	r22, Y+17	; 0x11
    1d26:	7a 89       	ldd	r23, Y+18	; 0x12
    1d28:	8b 89       	ldd	r24, Y+19	; 0x13
    1d2a:	9c 89       	ldd	r25, Y+20	; 0x14
    1d2c:	20 e0       	ldi	r18, 0x00	; 0
    1d2e:	30 e0       	ldi	r19, 0x00	; 0
    1d30:	4f e7       	ldi	r20, 0x7F	; 127
    1d32:	53 e4       	ldi	r21, 0x43	; 67
    1d34:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1d38:	18 16       	cp	r1, r24
    1d3a:	0c f0       	brlt	.+2      	; 0x1d3e <LCD_voidSendCmnd+0x22a>
    1d3c:	7b c0       	rjmp	.+246    	; 0x1e34 <LCD_voidSendCmnd+0x320>
	{
		_delay_ms(__us / 1000.0);
    1d3e:	6d 89       	ldd	r22, Y+21	; 0x15
    1d40:	7e 89       	ldd	r23, Y+22	; 0x16
    1d42:	8f 89       	ldd	r24, Y+23	; 0x17
    1d44:	98 8d       	ldd	r25, Y+24	; 0x18
    1d46:	20 e0       	ldi	r18, 0x00	; 0
    1d48:	30 e0       	ldi	r19, 0x00	; 0
    1d4a:	4a e7       	ldi	r20, 0x7A	; 122
    1d4c:	54 e4       	ldi	r21, 0x44	; 68
    1d4e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1d52:	dc 01       	movw	r26, r24
    1d54:	cb 01       	movw	r24, r22
    1d56:	8c 87       	std	Y+12, r24	; 0x0c
    1d58:	9d 87       	std	Y+13, r25	; 0x0d
    1d5a:	ae 87       	std	Y+14, r26	; 0x0e
    1d5c:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1d5e:	6c 85       	ldd	r22, Y+12	; 0x0c
    1d60:	7d 85       	ldd	r23, Y+13	; 0x0d
    1d62:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d64:	9f 85       	ldd	r25, Y+15	; 0x0f
    1d66:	20 e0       	ldi	r18, 0x00	; 0
    1d68:	30 e0       	ldi	r19, 0x00	; 0
    1d6a:	4a ef       	ldi	r20, 0xFA	; 250
    1d6c:	54 e4       	ldi	r21, 0x44	; 68
    1d6e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d72:	dc 01       	movw	r26, r24
    1d74:	cb 01       	movw	r24, r22
    1d76:	88 87       	std	Y+8, r24	; 0x08
    1d78:	99 87       	std	Y+9, r25	; 0x09
    1d7a:	aa 87       	std	Y+10, r26	; 0x0a
    1d7c:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1d7e:	68 85       	ldd	r22, Y+8	; 0x08
    1d80:	79 85       	ldd	r23, Y+9	; 0x09
    1d82:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d84:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d86:	20 e0       	ldi	r18, 0x00	; 0
    1d88:	30 e0       	ldi	r19, 0x00	; 0
    1d8a:	40 e8       	ldi	r20, 0x80	; 128
    1d8c:	5f e3       	ldi	r21, 0x3F	; 63
    1d8e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1d92:	88 23       	and	r24, r24
    1d94:	2c f4       	brge	.+10     	; 0x1da0 <LCD_voidSendCmnd+0x28c>
		__ticks = 1;
    1d96:	81 e0       	ldi	r24, 0x01	; 1
    1d98:	90 e0       	ldi	r25, 0x00	; 0
    1d9a:	9f 83       	std	Y+7, r25	; 0x07
    1d9c:	8e 83       	std	Y+6, r24	; 0x06
    1d9e:	3f c0       	rjmp	.+126    	; 0x1e1e <LCD_voidSendCmnd+0x30a>
	else if (__tmp > 65535)
    1da0:	68 85       	ldd	r22, Y+8	; 0x08
    1da2:	79 85       	ldd	r23, Y+9	; 0x09
    1da4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1da6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1da8:	20 e0       	ldi	r18, 0x00	; 0
    1daa:	3f ef       	ldi	r19, 0xFF	; 255
    1dac:	4f e7       	ldi	r20, 0x7F	; 127
    1dae:	57 e4       	ldi	r21, 0x47	; 71
    1db0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1db4:	18 16       	cp	r1, r24
    1db6:	4c f5       	brge	.+82     	; 0x1e0a <LCD_voidSendCmnd+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1db8:	6c 85       	ldd	r22, Y+12	; 0x0c
    1dba:	7d 85       	ldd	r23, Y+13	; 0x0d
    1dbc:	8e 85       	ldd	r24, Y+14	; 0x0e
    1dbe:	9f 85       	ldd	r25, Y+15	; 0x0f
    1dc0:	20 e0       	ldi	r18, 0x00	; 0
    1dc2:	30 e0       	ldi	r19, 0x00	; 0
    1dc4:	40 e2       	ldi	r20, 0x20	; 32
    1dc6:	51 e4       	ldi	r21, 0x41	; 65
    1dc8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dcc:	dc 01       	movw	r26, r24
    1dce:	cb 01       	movw	r24, r22
    1dd0:	bc 01       	movw	r22, r24
    1dd2:	cd 01       	movw	r24, r26
    1dd4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1dd8:	dc 01       	movw	r26, r24
    1dda:	cb 01       	movw	r24, r22
    1ddc:	9f 83       	std	Y+7, r25	; 0x07
    1dde:	8e 83       	std	Y+6, r24	; 0x06
    1de0:	0f c0       	rjmp	.+30     	; 0x1e00 <LCD_voidSendCmnd+0x2ec>
    1de2:	88 ec       	ldi	r24, 0xC8	; 200
    1de4:	90 e0       	ldi	r25, 0x00	; 0
    1de6:	9d 83       	std	Y+5, r25	; 0x05
    1de8:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1dea:	8c 81       	ldd	r24, Y+4	; 0x04
    1dec:	9d 81       	ldd	r25, Y+5	; 0x05
    1dee:	01 97       	sbiw	r24, 0x01	; 1
    1df0:	f1 f7       	brne	.-4      	; 0x1dee <LCD_voidSendCmnd+0x2da>
    1df2:	9d 83       	std	Y+5, r25	; 0x05
    1df4:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1df6:	8e 81       	ldd	r24, Y+6	; 0x06
    1df8:	9f 81       	ldd	r25, Y+7	; 0x07
    1dfa:	01 97       	sbiw	r24, 0x01	; 1
    1dfc:	9f 83       	std	Y+7, r25	; 0x07
    1dfe:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e00:	8e 81       	ldd	r24, Y+6	; 0x06
    1e02:	9f 81       	ldd	r25, Y+7	; 0x07
    1e04:	00 97       	sbiw	r24, 0x00	; 0
    1e06:	69 f7       	brne	.-38     	; 0x1de2 <LCD_voidSendCmnd+0x2ce>
    1e08:	24 c0       	rjmp	.+72     	; 0x1e52 <LCD_voidSendCmnd+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e0a:	68 85       	ldd	r22, Y+8	; 0x08
    1e0c:	79 85       	ldd	r23, Y+9	; 0x09
    1e0e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e10:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e12:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e16:	dc 01       	movw	r26, r24
    1e18:	cb 01       	movw	r24, r22
    1e1a:	9f 83       	std	Y+7, r25	; 0x07
    1e1c:	8e 83       	std	Y+6, r24	; 0x06
    1e1e:	8e 81       	ldd	r24, Y+6	; 0x06
    1e20:	9f 81       	ldd	r25, Y+7	; 0x07
    1e22:	9b 83       	std	Y+3, r25	; 0x03
    1e24:	8a 83       	std	Y+2, r24	; 0x02
    1e26:	8a 81       	ldd	r24, Y+2	; 0x02
    1e28:	9b 81       	ldd	r25, Y+3	; 0x03
    1e2a:	01 97       	sbiw	r24, 0x01	; 1
    1e2c:	f1 f7       	brne	.-4      	; 0x1e2a <LCD_voidSendCmnd+0x316>
    1e2e:	9b 83       	std	Y+3, r25	; 0x03
    1e30:	8a 83       	std	Y+2, r24	; 0x02
    1e32:	0f c0       	rjmp	.+30     	; 0x1e52 <LCD_voidSendCmnd+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1e34:	69 89       	ldd	r22, Y+17	; 0x11
    1e36:	7a 89       	ldd	r23, Y+18	; 0x12
    1e38:	8b 89       	ldd	r24, Y+19	; 0x13
    1e3a:	9c 89       	ldd	r25, Y+20	; 0x14
    1e3c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e40:	dc 01       	movw	r26, r24
    1e42:	cb 01       	movw	r24, r22
    1e44:	88 8b       	std	Y+16, r24	; 0x10
    1e46:	88 89       	ldd	r24, Y+16	; 0x10
    1e48:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1e4a:	89 81       	ldd	r24, Y+1	; 0x01
    1e4c:	8a 95       	dec	r24
    1e4e:	f1 f7       	brne	.-4      	; 0x1e4c <LCD_voidSendCmnd+0x338>
    1e50:	89 83       	std	Y+1, r24	; 0x01
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
	_delay_us(1); // wait tc = 500ns (not important because 1 us in step 4 is enough because >>> 230ns )

#endif

}
    1e52:	e1 96       	adiw	r28, 0x31	; 49
    1e54:	0f b6       	in	r0, 0x3f	; 63
    1e56:	f8 94       	cli
    1e58:	de bf       	out	0x3e, r29	; 62
    1e5a:	0f be       	out	0x3f, r0	; 63
    1e5c:	cd bf       	out	0x3d, r28	; 61
    1e5e:	cf 91       	pop	r28
    1e60:	df 91       	pop	r29
    1e62:	08 95       	ret

00001e64 <LCD_voidSendChar>:

void LCD_voidSendChar(u8 Copy_u8Char)
{
    1e64:	df 93       	push	r29
    1e66:	cf 93       	push	r28
    1e68:	cd b7       	in	r28, 0x3d	; 61
    1e6a:	de b7       	in	r29, 0x3e	; 62
    1e6c:	e1 97       	sbiw	r28, 0x31	; 49
    1e6e:	0f b6       	in	r0, 0x3f	; 63
    1e70:	f8 94       	cli
    1e72:	de bf       	out	0x3e, r29	; 62
    1e74:	0f be       	out	0x3f, r0	; 63
    1e76:	cd bf       	out	0x3d, r28	; 61
    1e78:	89 ab       	std	Y+49, r24	; 0x31
#if LCD_u8_MODE == LCD_u8_MODE_8_BIT
	/* Step 1: RS = 1 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RS_PIN,DIO_u8_HIGH);
    1e7a:	80 e0       	ldi	r24, 0x00	; 0
    1e7c:	60 e0       	ldi	r22, 0x00	; 0
    1e7e:	41 e0       	ldi	r20, 0x01	; 1
    1e80:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
	/* Step 2: RW = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RW_PIN,DIO_u8_LOW);
    1e84:	80 e0       	ldi	r24, 0x00	; 0
    1e86:	61 e0       	ldi	r22, 0x01	; 1
    1e88:	40 e0       	ldi	r20, 0x00	; 0
    1e8a:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
	/* Step 3: Write Char  */
	DIO_u8SetPortValue(LCD_u8_DATA_PORT,Copy_u8Char);
    1e8e:	82 e0       	ldi	r24, 0x02	; 2
    1e90:	69 a9       	ldd	r22, Y+49	; 0x31
    1e92:	0e 94 27 0a 	call	0x144e	; 0x144e <DIO_u8SetPortValue>
	/* Step 4: E = 1 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_HIGH);
    1e96:	80 e0       	ldi	r24, 0x00	; 0
    1e98:	62 e0       	ldi	r22, 0x02	; 2
    1e9a:	41 e0       	ldi	r20, 0x01	; 1
    1e9c:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
    1ea0:	80 e0       	ldi	r24, 0x00	; 0
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	a0 e8       	ldi	r26, 0x80	; 128
    1ea6:	bf e3       	ldi	r27, 0x3F	; 63
    1ea8:	8d a7       	std	Y+45, r24	; 0x2d
    1eaa:	9e a7       	std	Y+46, r25	; 0x2e
    1eac:	af a7       	std	Y+47, r26	; 0x2f
    1eae:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1eb0:	6d a5       	ldd	r22, Y+45	; 0x2d
    1eb2:	7e a5       	ldd	r23, Y+46	; 0x2e
    1eb4:	8f a5       	ldd	r24, Y+47	; 0x2f
    1eb6:	98 a9       	ldd	r25, Y+48	; 0x30
    1eb8:	2b ea       	ldi	r18, 0xAB	; 171
    1eba:	3a ea       	ldi	r19, 0xAA	; 170
    1ebc:	4a e2       	ldi	r20, 0x2A	; 42
    1ebe:	50 e4       	ldi	r21, 0x40	; 64
    1ec0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ec4:	dc 01       	movw	r26, r24
    1ec6:	cb 01       	movw	r24, r22
    1ec8:	89 a7       	std	Y+41, r24	; 0x29
    1eca:	9a a7       	std	Y+42, r25	; 0x2a
    1ecc:	ab a7       	std	Y+43, r26	; 0x2b
    1ece:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    1ed0:	69 a5       	ldd	r22, Y+41	; 0x29
    1ed2:	7a a5       	ldd	r23, Y+42	; 0x2a
    1ed4:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ed6:	9c a5       	ldd	r25, Y+44	; 0x2c
    1ed8:	20 e0       	ldi	r18, 0x00	; 0
    1eda:	30 e0       	ldi	r19, 0x00	; 0
    1edc:	40 e8       	ldi	r20, 0x80	; 128
    1ede:	5f e3       	ldi	r21, 0x3F	; 63
    1ee0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1ee4:	88 23       	and	r24, r24
    1ee6:	1c f4       	brge	.+6      	; 0x1eee <LCD_voidSendChar+0x8a>
		__ticks = 1;
    1ee8:	81 e0       	ldi	r24, 0x01	; 1
    1eea:	88 a7       	std	Y+40, r24	; 0x28
    1eec:	91 c0       	rjmp	.+290    	; 0x2010 <LCD_voidSendChar+0x1ac>
	else if (__tmp > 255)
    1eee:	69 a5       	ldd	r22, Y+41	; 0x29
    1ef0:	7a a5       	ldd	r23, Y+42	; 0x2a
    1ef2:	8b a5       	ldd	r24, Y+43	; 0x2b
    1ef4:	9c a5       	ldd	r25, Y+44	; 0x2c
    1ef6:	20 e0       	ldi	r18, 0x00	; 0
    1ef8:	30 e0       	ldi	r19, 0x00	; 0
    1efa:	4f e7       	ldi	r20, 0x7F	; 127
    1efc:	53 e4       	ldi	r21, 0x43	; 67
    1efe:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1f02:	18 16       	cp	r1, r24
    1f04:	0c f0       	brlt	.+2      	; 0x1f08 <LCD_voidSendChar+0xa4>
    1f06:	7b c0       	rjmp	.+246    	; 0x1ffe <LCD_voidSendChar+0x19a>
	{
		_delay_ms(__us / 1000.0);
    1f08:	6d a5       	ldd	r22, Y+45	; 0x2d
    1f0a:	7e a5       	ldd	r23, Y+46	; 0x2e
    1f0c:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f0e:	98 a9       	ldd	r25, Y+48	; 0x30
    1f10:	20 e0       	ldi	r18, 0x00	; 0
    1f12:	30 e0       	ldi	r19, 0x00	; 0
    1f14:	4a e7       	ldi	r20, 0x7A	; 122
    1f16:	54 e4       	ldi	r21, 0x44	; 68
    1f18:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1f1c:	dc 01       	movw	r26, r24
    1f1e:	cb 01       	movw	r24, r22
    1f20:	8c a3       	std	Y+36, r24	; 0x24
    1f22:	9d a3       	std	Y+37, r25	; 0x25
    1f24:	ae a3       	std	Y+38, r26	; 0x26
    1f26:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1f28:	6c a1       	ldd	r22, Y+36	; 0x24
    1f2a:	7d a1       	ldd	r23, Y+37	; 0x25
    1f2c:	8e a1       	ldd	r24, Y+38	; 0x26
    1f2e:	9f a1       	ldd	r25, Y+39	; 0x27
    1f30:	20 e0       	ldi	r18, 0x00	; 0
    1f32:	30 e0       	ldi	r19, 0x00	; 0
    1f34:	4a ef       	ldi	r20, 0xFA	; 250
    1f36:	54 e4       	ldi	r21, 0x44	; 68
    1f38:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f3c:	dc 01       	movw	r26, r24
    1f3e:	cb 01       	movw	r24, r22
    1f40:	88 a3       	std	Y+32, r24	; 0x20
    1f42:	99 a3       	std	Y+33, r25	; 0x21
    1f44:	aa a3       	std	Y+34, r26	; 0x22
    1f46:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    1f48:	68 a1       	ldd	r22, Y+32	; 0x20
    1f4a:	79 a1       	ldd	r23, Y+33	; 0x21
    1f4c:	8a a1       	ldd	r24, Y+34	; 0x22
    1f4e:	9b a1       	ldd	r25, Y+35	; 0x23
    1f50:	20 e0       	ldi	r18, 0x00	; 0
    1f52:	30 e0       	ldi	r19, 0x00	; 0
    1f54:	40 e8       	ldi	r20, 0x80	; 128
    1f56:	5f e3       	ldi	r21, 0x3F	; 63
    1f58:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1f5c:	88 23       	and	r24, r24
    1f5e:	2c f4       	brge	.+10     	; 0x1f6a <LCD_voidSendChar+0x106>
		__ticks = 1;
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	90 e0       	ldi	r25, 0x00	; 0
    1f64:	9f 8f       	std	Y+31, r25	; 0x1f
    1f66:	8e 8f       	std	Y+30, r24	; 0x1e
    1f68:	3f c0       	rjmp	.+126    	; 0x1fe8 <LCD_voidSendChar+0x184>
	else if (__tmp > 65535)
    1f6a:	68 a1       	ldd	r22, Y+32	; 0x20
    1f6c:	79 a1       	ldd	r23, Y+33	; 0x21
    1f6e:	8a a1       	ldd	r24, Y+34	; 0x22
    1f70:	9b a1       	ldd	r25, Y+35	; 0x23
    1f72:	20 e0       	ldi	r18, 0x00	; 0
    1f74:	3f ef       	ldi	r19, 0xFF	; 255
    1f76:	4f e7       	ldi	r20, 0x7F	; 127
    1f78:	57 e4       	ldi	r21, 0x47	; 71
    1f7a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1f7e:	18 16       	cp	r1, r24
    1f80:	4c f5       	brge	.+82     	; 0x1fd4 <LCD_voidSendChar+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f82:	6c a1       	ldd	r22, Y+36	; 0x24
    1f84:	7d a1       	ldd	r23, Y+37	; 0x25
    1f86:	8e a1       	ldd	r24, Y+38	; 0x26
    1f88:	9f a1       	ldd	r25, Y+39	; 0x27
    1f8a:	20 e0       	ldi	r18, 0x00	; 0
    1f8c:	30 e0       	ldi	r19, 0x00	; 0
    1f8e:	40 e2       	ldi	r20, 0x20	; 32
    1f90:	51 e4       	ldi	r21, 0x41	; 65
    1f92:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f96:	dc 01       	movw	r26, r24
    1f98:	cb 01       	movw	r24, r22
    1f9a:	bc 01       	movw	r22, r24
    1f9c:	cd 01       	movw	r24, r26
    1f9e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fa2:	dc 01       	movw	r26, r24
    1fa4:	cb 01       	movw	r24, r22
    1fa6:	9f 8f       	std	Y+31, r25	; 0x1f
    1fa8:	8e 8f       	std	Y+30, r24	; 0x1e
    1faa:	0f c0       	rjmp	.+30     	; 0x1fca <LCD_voidSendChar+0x166>
    1fac:	88 ec       	ldi	r24, 0xC8	; 200
    1fae:	90 e0       	ldi	r25, 0x00	; 0
    1fb0:	9d 8f       	std	Y+29, r25	; 0x1d
    1fb2:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1fb4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1fb6:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1fb8:	01 97       	sbiw	r24, 0x01	; 1
    1fba:	f1 f7       	brne	.-4      	; 0x1fb8 <LCD_voidSendChar+0x154>
    1fbc:	9d 8f       	std	Y+29, r25	; 0x1d
    1fbe:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1fc0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fc2:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1fc4:	01 97       	sbiw	r24, 0x01	; 1
    1fc6:	9f 8f       	std	Y+31, r25	; 0x1f
    1fc8:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1fca:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fcc:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1fce:	00 97       	sbiw	r24, 0x00	; 0
    1fd0:	69 f7       	brne	.-38     	; 0x1fac <LCD_voidSendChar+0x148>
    1fd2:	24 c0       	rjmp	.+72     	; 0x201c <LCD_voidSendChar+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1fd4:	68 a1       	ldd	r22, Y+32	; 0x20
    1fd6:	79 a1       	ldd	r23, Y+33	; 0x21
    1fd8:	8a a1       	ldd	r24, Y+34	; 0x22
    1fda:	9b a1       	ldd	r25, Y+35	; 0x23
    1fdc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fe0:	dc 01       	movw	r26, r24
    1fe2:	cb 01       	movw	r24, r22
    1fe4:	9f 8f       	std	Y+31, r25	; 0x1f
    1fe6:	8e 8f       	std	Y+30, r24	; 0x1e
    1fe8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1fea:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1fec:	9b 8f       	std	Y+27, r25	; 0x1b
    1fee:	8a 8f       	std	Y+26, r24	; 0x1a
    1ff0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ff2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1ff4:	01 97       	sbiw	r24, 0x01	; 1
    1ff6:	f1 f7       	brne	.-4      	; 0x1ff4 <LCD_voidSendChar+0x190>
    1ff8:	9b 8f       	std	Y+27, r25	; 0x1b
    1ffa:	8a 8f       	std	Y+26, r24	; 0x1a
    1ffc:	0f c0       	rjmp	.+30     	; 0x201c <LCD_voidSendChar+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1ffe:	69 a5       	ldd	r22, Y+41	; 0x29
    2000:	7a a5       	ldd	r23, Y+42	; 0x2a
    2002:	8b a5       	ldd	r24, Y+43	; 0x2b
    2004:	9c a5       	ldd	r25, Y+44	; 0x2c
    2006:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    200a:	dc 01       	movw	r26, r24
    200c:	cb 01       	movw	r24, r22
    200e:	88 a7       	std	Y+40, r24	; 0x28
    2010:	88 a5       	ldd	r24, Y+40	; 0x28
    2012:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2014:	89 8d       	ldd	r24, Y+25	; 0x19
    2016:	8a 95       	dec	r24
    2018:	f1 f7       	brne	.-4      	; 0x2016 <LCD_voidSendChar+0x1b2>
    201a:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1); //wait tw = 230 ns
	/* Step 5: E = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
    201c:	80 e0       	ldi	r24, 0x00	; 0
    201e:	62 e0       	ldi	r22, 0x02	; 2
    2020:	40 e0       	ldi	r20, 0x00	; 0
    2022:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
    2026:	80 e0       	ldi	r24, 0x00	; 0
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	a0 e8       	ldi	r26, 0x80	; 128
    202c:	bf e3       	ldi	r27, 0x3F	; 63
    202e:	8d 8b       	std	Y+21, r24	; 0x15
    2030:	9e 8b       	std	Y+22, r25	; 0x16
    2032:	af 8b       	std	Y+23, r26	; 0x17
    2034:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2036:	6d 89       	ldd	r22, Y+21	; 0x15
    2038:	7e 89       	ldd	r23, Y+22	; 0x16
    203a:	8f 89       	ldd	r24, Y+23	; 0x17
    203c:	98 8d       	ldd	r25, Y+24	; 0x18
    203e:	2b ea       	ldi	r18, 0xAB	; 171
    2040:	3a ea       	ldi	r19, 0xAA	; 170
    2042:	4a e2       	ldi	r20, 0x2A	; 42
    2044:	50 e4       	ldi	r21, 0x40	; 64
    2046:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    204a:	dc 01       	movw	r26, r24
    204c:	cb 01       	movw	r24, r22
    204e:	89 8b       	std	Y+17, r24	; 0x11
    2050:	9a 8b       	std	Y+18, r25	; 0x12
    2052:	ab 8b       	std	Y+19, r26	; 0x13
    2054:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    2056:	69 89       	ldd	r22, Y+17	; 0x11
    2058:	7a 89       	ldd	r23, Y+18	; 0x12
    205a:	8b 89       	ldd	r24, Y+19	; 0x13
    205c:	9c 89       	ldd	r25, Y+20	; 0x14
    205e:	20 e0       	ldi	r18, 0x00	; 0
    2060:	30 e0       	ldi	r19, 0x00	; 0
    2062:	40 e8       	ldi	r20, 0x80	; 128
    2064:	5f e3       	ldi	r21, 0x3F	; 63
    2066:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    206a:	88 23       	and	r24, r24
    206c:	1c f4       	brge	.+6      	; 0x2074 <LCD_voidSendChar+0x210>
		__ticks = 1;
    206e:	81 e0       	ldi	r24, 0x01	; 1
    2070:	88 8b       	std	Y+16, r24	; 0x10
    2072:	91 c0       	rjmp	.+290    	; 0x2196 <LCD_voidSendChar+0x332>
	else if (__tmp > 255)
    2074:	69 89       	ldd	r22, Y+17	; 0x11
    2076:	7a 89       	ldd	r23, Y+18	; 0x12
    2078:	8b 89       	ldd	r24, Y+19	; 0x13
    207a:	9c 89       	ldd	r25, Y+20	; 0x14
    207c:	20 e0       	ldi	r18, 0x00	; 0
    207e:	30 e0       	ldi	r19, 0x00	; 0
    2080:	4f e7       	ldi	r20, 0x7F	; 127
    2082:	53 e4       	ldi	r21, 0x43	; 67
    2084:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2088:	18 16       	cp	r1, r24
    208a:	0c f0       	brlt	.+2      	; 0x208e <LCD_voidSendChar+0x22a>
    208c:	7b c0       	rjmp	.+246    	; 0x2184 <LCD_voidSendChar+0x320>
	{
		_delay_ms(__us / 1000.0);
    208e:	6d 89       	ldd	r22, Y+21	; 0x15
    2090:	7e 89       	ldd	r23, Y+22	; 0x16
    2092:	8f 89       	ldd	r24, Y+23	; 0x17
    2094:	98 8d       	ldd	r25, Y+24	; 0x18
    2096:	20 e0       	ldi	r18, 0x00	; 0
    2098:	30 e0       	ldi	r19, 0x00	; 0
    209a:	4a e7       	ldi	r20, 0x7A	; 122
    209c:	54 e4       	ldi	r21, 0x44	; 68
    209e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    20a2:	dc 01       	movw	r26, r24
    20a4:	cb 01       	movw	r24, r22
    20a6:	8c 87       	std	Y+12, r24	; 0x0c
    20a8:	9d 87       	std	Y+13, r25	; 0x0d
    20aa:	ae 87       	std	Y+14, r26	; 0x0e
    20ac:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    20ae:	6c 85       	ldd	r22, Y+12	; 0x0c
    20b0:	7d 85       	ldd	r23, Y+13	; 0x0d
    20b2:	8e 85       	ldd	r24, Y+14	; 0x0e
    20b4:	9f 85       	ldd	r25, Y+15	; 0x0f
    20b6:	20 e0       	ldi	r18, 0x00	; 0
    20b8:	30 e0       	ldi	r19, 0x00	; 0
    20ba:	4a ef       	ldi	r20, 0xFA	; 250
    20bc:	54 e4       	ldi	r21, 0x44	; 68
    20be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20c2:	dc 01       	movw	r26, r24
    20c4:	cb 01       	movw	r24, r22
    20c6:	88 87       	std	Y+8, r24	; 0x08
    20c8:	99 87       	std	Y+9, r25	; 0x09
    20ca:	aa 87       	std	Y+10, r26	; 0x0a
    20cc:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    20ce:	68 85       	ldd	r22, Y+8	; 0x08
    20d0:	79 85       	ldd	r23, Y+9	; 0x09
    20d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    20d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    20d6:	20 e0       	ldi	r18, 0x00	; 0
    20d8:	30 e0       	ldi	r19, 0x00	; 0
    20da:	40 e8       	ldi	r20, 0x80	; 128
    20dc:	5f e3       	ldi	r21, 0x3F	; 63
    20de:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    20e2:	88 23       	and	r24, r24
    20e4:	2c f4       	brge	.+10     	; 0x20f0 <LCD_voidSendChar+0x28c>
		__ticks = 1;
    20e6:	81 e0       	ldi	r24, 0x01	; 1
    20e8:	90 e0       	ldi	r25, 0x00	; 0
    20ea:	9f 83       	std	Y+7, r25	; 0x07
    20ec:	8e 83       	std	Y+6, r24	; 0x06
    20ee:	3f c0       	rjmp	.+126    	; 0x216e <LCD_voidSendChar+0x30a>
	else if (__tmp > 65535)
    20f0:	68 85       	ldd	r22, Y+8	; 0x08
    20f2:	79 85       	ldd	r23, Y+9	; 0x09
    20f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    20f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    20f8:	20 e0       	ldi	r18, 0x00	; 0
    20fa:	3f ef       	ldi	r19, 0xFF	; 255
    20fc:	4f e7       	ldi	r20, 0x7F	; 127
    20fe:	57 e4       	ldi	r21, 0x47	; 71
    2100:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2104:	18 16       	cp	r1, r24
    2106:	4c f5       	brge	.+82     	; 0x215a <LCD_voidSendChar+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2108:	6c 85       	ldd	r22, Y+12	; 0x0c
    210a:	7d 85       	ldd	r23, Y+13	; 0x0d
    210c:	8e 85       	ldd	r24, Y+14	; 0x0e
    210e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2110:	20 e0       	ldi	r18, 0x00	; 0
    2112:	30 e0       	ldi	r19, 0x00	; 0
    2114:	40 e2       	ldi	r20, 0x20	; 32
    2116:	51 e4       	ldi	r21, 0x41	; 65
    2118:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    211c:	dc 01       	movw	r26, r24
    211e:	cb 01       	movw	r24, r22
    2120:	bc 01       	movw	r22, r24
    2122:	cd 01       	movw	r24, r26
    2124:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2128:	dc 01       	movw	r26, r24
    212a:	cb 01       	movw	r24, r22
    212c:	9f 83       	std	Y+7, r25	; 0x07
    212e:	8e 83       	std	Y+6, r24	; 0x06
    2130:	0f c0       	rjmp	.+30     	; 0x2150 <LCD_voidSendChar+0x2ec>
    2132:	88 ec       	ldi	r24, 0xC8	; 200
    2134:	90 e0       	ldi	r25, 0x00	; 0
    2136:	9d 83       	std	Y+5, r25	; 0x05
    2138:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    213a:	8c 81       	ldd	r24, Y+4	; 0x04
    213c:	9d 81       	ldd	r25, Y+5	; 0x05
    213e:	01 97       	sbiw	r24, 0x01	; 1
    2140:	f1 f7       	brne	.-4      	; 0x213e <LCD_voidSendChar+0x2da>
    2142:	9d 83       	std	Y+5, r25	; 0x05
    2144:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2146:	8e 81       	ldd	r24, Y+6	; 0x06
    2148:	9f 81       	ldd	r25, Y+7	; 0x07
    214a:	01 97       	sbiw	r24, 0x01	; 1
    214c:	9f 83       	std	Y+7, r25	; 0x07
    214e:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2150:	8e 81       	ldd	r24, Y+6	; 0x06
    2152:	9f 81       	ldd	r25, Y+7	; 0x07
    2154:	00 97       	sbiw	r24, 0x00	; 0
    2156:	69 f7       	brne	.-38     	; 0x2132 <LCD_voidSendChar+0x2ce>
    2158:	24 c0       	rjmp	.+72     	; 0x21a2 <LCD_voidSendChar+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    215a:	68 85       	ldd	r22, Y+8	; 0x08
    215c:	79 85       	ldd	r23, Y+9	; 0x09
    215e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2160:	9b 85       	ldd	r25, Y+11	; 0x0b
    2162:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2166:	dc 01       	movw	r26, r24
    2168:	cb 01       	movw	r24, r22
    216a:	9f 83       	std	Y+7, r25	; 0x07
    216c:	8e 83       	std	Y+6, r24	; 0x06
    216e:	8e 81       	ldd	r24, Y+6	; 0x06
    2170:	9f 81       	ldd	r25, Y+7	; 0x07
    2172:	9b 83       	std	Y+3, r25	; 0x03
    2174:	8a 83       	std	Y+2, r24	; 0x02
    2176:	8a 81       	ldd	r24, Y+2	; 0x02
    2178:	9b 81       	ldd	r25, Y+3	; 0x03
    217a:	01 97       	sbiw	r24, 0x01	; 1
    217c:	f1 f7       	brne	.-4      	; 0x217a <LCD_voidSendChar+0x316>
    217e:	9b 83       	std	Y+3, r25	; 0x03
    2180:	8a 83       	std	Y+2, r24	; 0x02
    2182:	0f c0       	rjmp	.+30     	; 0x21a2 <LCD_voidSendChar+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2184:	69 89       	ldd	r22, Y+17	; 0x11
    2186:	7a 89       	ldd	r23, Y+18	; 0x12
    2188:	8b 89       	ldd	r24, Y+19	; 0x13
    218a:	9c 89       	ldd	r25, Y+20	; 0x14
    218c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2190:	dc 01       	movw	r26, r24
    2192:	cb 01       	movw	r24, r22
    2194:	88 8b       	std	Y+16, r24	; 0x10
    2196:	88 89       	ldd	r24, Y+16	; 0x10
    2198:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    219a:	89 81       	ldd	r24, Y+1	; 0x01
    219c:	8a 95       	dec	r24
    219e:	f1 f7       	brne	.-4      	; 0x219c <LCD_voidSendChar+0x338>
    21a0:	89 83       	std	Y+1, r24	; 0x01
	/* Step 8: E = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
	_delay_us(1); // wait tc = 500ns (not important because 1 us in step 4 is enough because >>> 230ns )

#endif
}
    21a2:	e1 96       	adiw	r28, 0x31	; 49
    21a4:	0f b6       	in	r0, 0x3f	; 63
    21a6:	f8 94       	cli
    21a8:	de bf       	out	0x3e, r29	; 62
    21aa:	0f be       	out	0x3f, r0	; 63
    21ac:	cd bf       	out	0x3d, r28	; 61
    21ae:	cf 91       	pop	r28
    21b0:	df 91       	pop	r29
    21b2:	08 95       	ret

000021b4 <LCD_voidWriteString>:

void LCD_voidWriteString(u8* Copy_pu8String)
{
    21b4:	df 93       	push	r29
    21b6:	cf 93       	push	r28
    21b8:	00 d0       	rcall	.+0      	; 0x21ba <LCD_voidWriteString+0x6>
    21ba:	cd b7       	in	r28, 0x3d	; 61
    21bc:	de b7       	in	r29, 0x3e	; 62
    21be:	9a 83       	std	Y+2, r25	; 0x02
    21c0:	89 83       	std	Y+1, r24	; 0x01
    21c2:	0a c0       	rjmp	.+20     	; 0x21d8 <LCD_voidWriteString+0x24>
	// Iterate through the string until the null terminator ('\0') is encountered
	while(*Copy_pu8String != '\0')
	{
		// Send each character of the string to the LCD
		LCD_voidSendChar(*Copy_pu8String);
    21c4:	e9 81       	ldd	r30, Y+1	; 0x01
    21c6:	fa 81       	ldd	r31, Y+2	; 0x02
    21c8:	80 81       	ld	r24, Z
    21ca:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
		// Move to the next character in the string
		Copy_pu8String++;
    21ce:	89 81       	ldd	r24, Y+1	; 0x01
    21d0:	9a 81       	ldd	r25, Y+2	; 0x02
    21d2:	01 96       	adiw	r24, 0x01	; 1
    21d4:	9a 83       	std	Y+2, r25	; 0x02
    21d6:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_voidWriteString(u8* Copy_pu8String)
{
	// Iterate through the string until the null terminator ('\0') is encountered
	while(*Copy_pu8String != '\0')
    21d8:	e9 81       	ldd	r30, Y+1	; 0x01
    21da:	fa 81       	ldd	r31, Y+2	; 0x02
    21dc:	80 81       	ld	r24, Z
    21de:	88 23       	and	r24, r24
    21e0:	89 f7       	brne	.-30     	; 0x21c4 <LCD_voidWriteString+0x10>
		// Send each character of the string to the LCD
		LCD_voidSendChar(*Copy_pu8String);
		// Move to the next character in the string
		Copy_pu8String++;
	}
}
    21e2:	0f 90       	pop	r0
    21e4:	0f 90       	pop	r0
    21e6:	cf 91       	pop	r28
    21e8:	df 91       	pop	r29
    21ea:	08 95       	ret

000021ec <LCD_voidWriteNumber>:

void LCD_voidWriteNumber(u32 Copy_u32Number)
{
    21ec:	0f 93       	push	r16
    21ee:	1f 93       	push	r17
    21f0:	df 93       	push	r29
    21f2:	cf 93       	push	r28
    21f4:	cd b7       	in	r28, 0x3d	; 61
    21f6:	de b7       	in	r29, 0x3e	; 62
    21f8:	65 97       	sbiw	r28, 0x15	; 21
    21fa:	0f b6       	in	r0, 0x3f	; 63
    21fc:	f8 94       	cli
    21fe:	de bf       	out	0x3e, r29	; 62
    2200:	0f be       	out	0x3f, r0	; 63
    2202:	cd bf       	out	0x3d, r28	; 61
    2204:	6a 8b       	std	Y+18, r22	; 0x12
    2206:	7b 8b       	std	Y+19, r23	; 0x13
    2208:	8c 8b       	std	Y+20, r24	; 0x14
    220a:	9d 8b       	std	Y+21, r25	; 0x15
	// Temporary array to store digits of the number
	u8 digits[15];
	// Index to keep track of the current digit position
	s8 index = -1; // Start from -1 to accommodate numbers with zero
    220c:	8f ef       	ldi	r24, 0xFF	; 255
    220e:	8a 83       	std	Y+2, r24	; 0x02
	s8 i;
	// Special case for handling zero separately
	if (Copy_u32Number == 0)
    2210:	8a 89       	ldd	r24, Y+18	; 0x12
    2212:	9b 89       	ldd	r25, Y+19	; 0x13
    2214:	ac 89       	ldd	r26, Y+20	; 0x14
    2216:	bd 89       	ldd	r27, Y+21	; 0x15
    2218:	00 97       	sbiw	r24, 0x00	; 0
    221a:	a1 05       	cpc	r26, r1
    221c:	b1 05       	cpc	r27, r1
    221e:	99 f5       	brne	.+102    	; 0x2286 <LCD_voidWriteNumber+0x9a>
    {
        LCD_voidSendChar('0');
    2220:	80 e3       	ldi	r24, 0x30	; 48
    2222:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    2226:	4e c0       	rjmp	.+156    	; 0x22c4 <LCD_voidWriteNumber+0xd8>
        return;
    }
    // Extract each digit of the number and store in the temporary array
    while(Copy_u32Number > 0)
    {
    	index++;
    2228:	8a 81       	ldd	r24, Y+2	; 0x02
    222a:	8f 5f       	subi	r24, 0xFF	; 255
    222c:	8a 83       	std	Y+2, r24	; 0x02
    	digits[index] = Copy_u32Number % 10; // Extract the last digit
    222e:	8a 81       	ldd	r24, Y+2	; 0x02
    2230:	08 2f       	mov	r16, r24
    2232:	11 27       	eor	r17, r17
    2234:	07 fd       	sbrc	r16, 7
    2236:	10 95       	com	r17
    2238:	8a 89       	ldd	r24, Y+18	; 0x12
    223a:	9b 89       	ldd	r25, Y+19	; 0x13
    223c:	ac 89       	ldd	r26, Y+20	; 0x14
    223e:	bd 89       	ldd	r27, Y+21	; 0x15
    2240:	2a e0       	ldi	r18, 0x0A	; 10
    2242:	30 e0       	ldi	r19, 0x00	; 0
    2244:	40 e0       	ldi	r20, 0x00	; 0
    2246:	50 e0       	ldi	r21, 0x00	; 0
    2248:	bc 01       	movw	r22, r24
    224a:	cd 01       	movw	r24, r26
    224c:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    2250:	dc 01       	movw	r26, r24
    2252:	cb 01       	movw	r24, r22
    2254:	28 2f       	mov	r18, r24
    2256:	ce 01       	movw	r24, r28
    2258:	03 96       	adiw	r24, 0x03	; 3
    225a:	fc 01       	movw	r30, r24
    225c:	e0 0f       	add	r30, r16
    225e:	f1 1f       	adc	r31, r17
    2260:	20 83       	st	Z, r18
    	Copy_u32Number /= 10; // Move to the next digit
    2262:	8a 89       	ldd	r24, Y+18	; 0x12
    2264:	9b 89       	ldd	r25, Y+19	; 0x13
    2266:	ac 89       	ldd	r26, Y+20	; 0x14
    2268:	bd 89       	ldd	r27, Y+21	; 0x15
    226a:	2a e0       	ldi	r18, 0x0A	; 10
    226c:	30 e0       	ldi	r19, 0x00	; 0
    226e:	40 e0       	ldi	r20, 0x00	; 0
    2270:	50 e0       	ldi	r21, 0x00	; 0
    2272:	bc 01       	movw	r22, r24
    2274:	cd 01       	movw	r24, r26
    2276:	0e 94 c2 34 	call	0x6984	; 0x6984 <__udivmodsi4>
    227a:	da 01       	movw	r26, r20
    227c:	c9 01       	movw	r24, r18
    227e:	8a 8b       	std	Y+18, r24	; 0x12
    2280:	9b 8b       	std	Y+19, r25	; 0x13
    2282:	ac 8b       	std	Y+20, r26	; 0x14
    2284:	bd 8b       	std	Y+21, r27	; 0x15
    {
        LCD_voidSendChar('0');
        return;
    }
    // Extract each digit of the number and store in the temporary array
    while(Copy_u32Number > 0)
    2286:	8a 89       	ldd	r24, Y+18	; 0x12
    2288:	9b 89       	ldd	r25, Y+19	; 0x13
    228a:	ac 89       	ldd	r26, Y+20	; 0x14
    228c:	bd 89       	ldd	r27, Y+21	; 0x15
    228e:	00 97       	sbiw	r24, 0x00	; 0
    2290:	a1 05       	cpc	r26, r1
    2292:	b1 05       	cpc	r27, r1
    2294:	49 f6       	brne	.-110    	; 0x2228 <LCD_voidWriteNumber+0x3c>
    	digits[index] = Copy_u32Number % 10; // Extract the last digit
    	Copy_u32Number /= 10; // Move to the next digit
    }

    // Write the digits to the LCD in reverse order
    for (i = index; i >= 0; i--)
    2296:	8a 81       	ldd	r24, Y+2	; 0x02
    2298:	89 83       	std	Y+1, r24	; 0x01
    229a:	11 c0       	rjmp	.+34     	; 0x22be <LCD_voidWriteNumber+0xd2>
    {
    	// Convert digit to character and send to LCD
    	LCD_voidSendChar(digits[i] +'0');
    229c:	89 81       	ldd	r24, Y+1	; 0x01
    229e:	28 2f       	mov	r18, r24
    22a0:	33 27       	eor	r19, r19
    22a2:	27 fd       	sbrc	r18, 7
    22a4:	30 95       	com	r19
    22a6:	ce 01       	movw	r24, r28
    22a8:	03 96       	adiw	r24, 0x03	; 3
    22aa:	fc 01       	movw	r30, r24
    22ac:	e2 0f       	add	r30, r18
    22ae:	f3 1f       	adc	r31, r19
    22b0:	80 81       	ld	r24, Z
    22b2:	80 5d       	subi	r24, 0xD0	; 208
    22b4:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    	digits[index] = Copy_u32Number % 10; // Extract the last digit
    	Copy_u32Number /= 10; // Move to the next digit
    }

    // Write the digits to the LCD in reverse order
    for (i = index; i >= 0; i--)
    22b8:	89 81       	ldd	r24, Y+1	; 0x01
    22ba:	81 50       	subi	r24, 0x01	; 1
    22bc:	89 83       	std	Y+1, r24	; 0x01
    22be:	89 81       	ldd	r24, Y+1	; 0x01
    22c0:	88 23       	and	r24, r24
    22c2:	64 f7       	brge	.-40     	; 0x229c <LCD_voidWriteNumber+0xb0>
    {
    	// Convert digit to character and send to LCD
    	LCD_voidSendChar(digits[i] +'0');
    }

}
    22c4:	65 96       	adiw	r28, 0x15	; 21
    22c6:	0f b6       	in	r0, 0x3f	; 63
    22c8:	f8 94       	cli
    22ca:	de bf       	out	0x3e, r29	; 62
    22cc:	0f be       	out	0x3f, r0	; 63
    22ce:	cd bf       	out	0x3d, r28	; 61
    22d0:	cf 91       	pop	r28
    22d2:	df 91       	pop	r29
    22d4:	1f 91       	pop	r17
    22d6:	0f 91       	pop	r16
    22d8:	08 95       	ret

000022da <LCD_u8GoToXY>:
u8 LCD_u8GoToXY(u8 Copy_u8LineNum, u8 Copy_u8Location)
{
    22da:	df 93       	push	r29
    22dc:	cf 93       	push	r28
    22de:	00 d0       	rcall	.+0      	; 0x22e0 <LCD_u8GoToXY+0x6>
    22e0:	00 d0       	rcall	.+0      	; 0x22e2 <LCD_u8GoToXY+0x8>
    22e2:	0f 92       	push	r0
    22e4:	cd b7       	in	r28, 0x3d	; 61
    22e6:	de b7       	in	r29, 0x3e	; 62
    22e8:	8a 83       	std	Y+2, r24	; 0x02
    22ea:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState = STD_TYPES_OK;
    22ec:	81 e0       	ldi	r24, 0x01	; 1
    22ee:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8Location <= 39)
    22f0:	8b 81       	ldd	r24, Y+3	; 0x03
    22f2:	88 32       	cpi	r24, 0x28	; 40
    22f4:	d8 f4       	brcc	.+54     	; 0x232c <LCD_u8GoToXY+0x52>
	{
		switch(Copy_u8LineNum)
    22f6:	8a 81       	ldd	r24, Y+2	; 0x02
    22f8:	28 2f       	mov	r18, r24
    22fa:	30 e0       	ldi	r19, 0x00	; 0
    22fc:	3d 83       	std	Y+5, r19	; 0x05
    22fe:	2c 83       	std	Y+4, r18	; 0x04
    2300:	8c 81       	ldd	r24, Y+4	; 0x04
    2302:	9d 81       	ldd	r25, Y+5	; 0x05
    2304:	81 30       	cpi	r24, 0x01	; 1
    2306:	91 05       	cpc	r25, r1
    2308:	31 f0       	breq	.+12     	; 0x2316 <LCD_u8GoToXY+0x3c>
    230a:	2c 81       	ldd	r18, Y+4	; 0x04
    230c:	3d 81       	ldd	r19, Y+5	; 0x05
    230e:	22 30       	cpi	r18, 0x02	; 2
    2310:	31 05       	cpc	r19, r1
    2312:	31 f0       	breq	.+12     	; 0x2320 <LCD_u8GoToXY+0x46>
    2314:	0a c0       	rjmp	.+20     	; 0x232a <LCD_u8GoToXY+0x50>
		{
			case LCD_u8_LINE1:LCD_voidSendCmnd(LCD_u8_FIRSTLINE_ADDRESS + Copy_u8Location);break;
    2316:	8b 81       	ldd	r24, Y+3	; 0x03
    2318:	80 58       	subi	r24, 0x80	; 128
    231a:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
    231e:	06 c0       	rjmp	.+12     	; 0x232c <LCD_u8GoToXY+0x52>
			case LCD_u8_LINE2:LCD_voidSendCmnd(LCD_u8_SECONDLINE_ADDRESS + Copy_u8Location);break;
    2320:	8b 81       	ldd	r24, Y+3	; 0x03
    2322:	80 54       	subi	r24, 0x40	; 64
    2324:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
    2328:	01 c0       	rjmp	.+2      	; 0x232c <LCD_u8GoToXY+0x52>
			default:Local_u8ErrorState = STD_TYPES_NOK;
    232a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	return Local_u8ErrorState;
    232c:	89 81       	ldd	r24, Y+1	; 0x01
}
    232e:	0f 90       	pop	r0
    2330:	0f 90       	pop	r0
    2332:	0f 90       	pop	r0
    2334:	0f 90       	pop	r0
    2336:	0f 90       	pop	r0
    2338:	cf 91       	pop	r28
    233a:	df 91       	pop	r29
    233c:	08 95       	ret

0000233e <LCD_voidClearScreen>:
void LCD_voidClearScreen(void)
{
    233e:	df 93       	push	r29
    2340:	cf 93       	push	r28
    2342:	cd b7       	in	r28, 0x3d	; 61
    2344:	de b7       	in	r29, 0x3e	; 62
    2346:	2e 97       	sbiw	r28, 0x0e	; 14
    2348:	0f b6       	in	r0, 0x3f	; 63
    234a:	f8 94       	cli
    234c:	de bf       	out	0x3e, r29	; 62
    234e:	0f be       	out	0x3f, r0	; 63
    2350:	cd bf       	out	0x3d, r28	; 61
	LCD_voidSendCmnd(LCD_u8_DISPLAY_CLEAR_CMND);
    2352:	81 e0       	ldi	r24, 0x01	; 1
    2354:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
    2358:	80 e0       	ldi	r24, 0x00	; 0
    235a:	90 e0       	ldi	r25, 0x00	; 0
    235c:	a0 ea       	ldi	r26, 0xA0	; 160
    235e:	b1 e4       	ldi	r27, 0x41	; 65
    2360:	8b 87       	std	Y+11, r24	; 0x0b
    2362:	9c 87       	std	Y+12, r25	; 0x0c
    2364:	ad 87       	std	Y+13, r26	; 0x0d
    2366:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2368:	6b 85       	ldd	r22, Y+11	; 0x0b
    236a:	7c 85       	ldd	r23, Y+12	; 0x0c
    236c:	8d 85       	ldd	r24, Y+13	; 0x0d
    236e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2370:	20 e0       	ldi	r18, 0x00	; 0
    2372:	30 e0       	ldi	r19, 0x00	; 0
    2374:	4a ef       	ldi	r20, 0xFA	; 250
    2376:	54 e4       	ldi	r21, 0x44	; 68
    2378:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    237c:	dc 01       	movw	r26, r24
    237e:	cb 01       	movw	r24, r22
    2380:	8f 83       	std	Y+7, r24	; 0x07
    2382:	98 87       	std	Y+8, r25	; 0x08
    2384:	a9 87       	std	Y+9, r26	; 0x09
    2386:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2388:	6f 81       	ldd	r22, Y+7	; 0x07
    238a:	78 85       	ldd	r23, Y+8	; 0x08
    238c:	89 85       	ldd	r24, Y+9	; 0x09
    238e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2390:	20 e0       	ldi	r18, 0x00	; 0
    2392:	30 e0       	ldi	r19, 0x00	; 0
    2394:	40 e8       	ldi	r20, 0x80	; 128
    2396:	5f e3       	ldi	r21, 0x3F	; 63
    2398:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    239c:	88 23       	and	r24, r24
    239e:	2c f4       	brge	.+10     	; 0x23aa <LCD_voidClearScreen+0x6c>
		__ticks = 1;
    23a0:	81 e0       	ldi	r24, 0x01	; 1
    23a2:	90 e0       	ldi	r25, 0x00	; 0
    23a4:	9e 83       	std	Y+6, r25	; 0x06
    23a6:	8d 83       	std	Y+5, r24	; 0x05
    23a8:	3f c0       	rjmp	.+126    	; 0x2428 <LCD_voidClearScreen+0xea>
	else if (__tmp > 65535)
    23aa:	6f 81       	ldd	r22, Y+7	; 0x07
    23ac:	78 85       	ldd	r23, Y+8	; 0x08
    23ae:	89 85       	ldd	r24, Y+9	; 0x09
    23b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    23b2:	20 e0       	ldi	r18, 0x00	; 0
    23b4:	3f ef       	ldi	r19, 0xFF	; 255
    23b6:	4f e7       	ldi	r20, 0x7F	; 127
    23b8:	57 e4       	ldi	r21, 0x47	; 71
    23ba:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    23be:	18 16       	cp	r1, r24
    23c0:	4c f5       	brge	.+82     	; 0x2414 <LCD_voidClearScreen+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    23c2:	6b 85       	ldd	r22, Y+11	; 0x0b
    23c4:	7c 85       	ldd	r23, Y+12	; 0x0c
    23c6:	8d 85       	ldd	r24, Y+13	; 0x0d
    23c8:	9e 85       	ldd	r25, Y+14	; 0x0e
    23ca:	20 e0       	ldi	r18, 0x00	; 0
    23cc:	30 e0       	ldi	r19, 0x00	; 0
    23ce:	40 e2       	ldi	r20, 0x20	; 32
    23d0:	51 e4       	ldi	r21, 0x41	; 65
    23d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23d6:	dc 01       	movw	r26, r24
    23d8:	cb 01       	movw	r24, r22
    23da:	bc 01       	movw	r22, r24
    23dc:	cd 01       	movw	r24, r26
    23de:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23e2:	dc 01       	movw	r26, r24
    23e4:	cb 01       	movw	r24, r22
    23e6:	9e 83       	std	Y+6, r25	; 0x06
    23e8:	8d 83       	std	Y+5, r24	; 0x05
    23ea:	0f c0       	rjmp	.+30     	; 0x240a <LCD_voidClearScreen+0xcc>
    23ec:	88 ec       	ldi	r24, 0xC8	; 200
    23ee:	90 e0       	ldi	r25, 0x00	; 0
    23f0:	9c 83       	std	Y+4, r25	; 0x04
    23f2:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    23f4:	8b 81       	ldd	r24, Y+3	; 0x03
    23f6:	9c 81       	ldd	r25, Y+4	; 0x04
    23f8:	01 97       	sbiw	r24, 0x01	; 1
    23fa:	f1 f7       	brne	.-4      	; 0x23f8 <LCD_voidClearScreen+0xba>
    23fc:	9c 83       	std	Y+4, r25	; 0x04
    23fe:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2400:	8d 81       	ldd	r24, Y+5	; 0x05
    2402:	9e 81       	ldd	r25, Y+6	; 0x06
    2404:	01 97       	sbiw	r24, 0x01	; 1
    2406:	9e 83       	std	Y+6, r25	; 0x06
    2408:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    240a:	8d 81       	ldd	r24, Y+5	; 0x05
    240c:	9e 81       	ldd	r25, Y+6	; 0x06
    240e:	00 97       	sbiw	r24, 0x00	; 0
    2410:	69 f7       	brne	.-38     	; 0x23ec <LCD_voidClearScreen+0xae>
    2412:	14 c0       	rjmp	.+40     	; 0x243c <LCD_voidClearScreen+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2414:	6f 81       	ldd	r22, Y+7	; 0x07
    2416:	78 85       	ldd	r23, Y+8	; 0x08
    2418:	89 85       	ldd	r24, Y+9	; 0x09
    241a:	9a 85       	ldd	r25, Y+10	; 0x0a
    241c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2420:	dc 01       	movw	r26, r24
    2422:	cb 01       	movw	r24, r22
    2424:	9e 83       	std	Y+6, r25	; 0x06
    2426:	8d 83       	std	Y+5, r24	; 0x05
    2428:	8d 81       	ldd	r24, Y+5	; 0x05
    242a:	9e 81       	ldd	r25, Y+6	; 0x06
    242c:	9a 83       	std	Y+2, r25	; 0x02
    242e:	89 83       	std	Y+1, r24	; 0x01
    2430:	89 81       	ldd	r24, Y+1	; 0x01
    2432:	9a 81       	ldd	r25, Y+2	; 0x02
    2434:	01 97       	sbiw	r24, 0x01	; 1
    2436:	f1 f7       	brne	.-4      	; 0x2434 <LCD_voidClearScreen+0xf6>
    2438:	9a 83       	std	Y+2, r25	; 0x02
    243a:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(20);
}
    243c:	2e 96       	adiw	r28, 0x0e	; 14
    243e:	0f b6       	in	r0, 0x3f	; 63
    2440:	f8 94       	cli
    2442:	de bf       	out	0x3e, r29	; 62
    2444:	0f be       	out	0x3f, r0	; 63
    2446:	cd bf       	out	0x3d, r28	; 61
    2448:	cf 91       	pop	r28
    244a:	df 91       	pop	r29
    244c:	08 95       	ret

0000244e <LCD_voidWriteSpecialChar>:

u8 LCD_voidWriteSpecialChar(u8 Copy_u8CharNum, u8* Copy_pu8Char,u8 Copy_u8LineNum, u8 Copy_u8Location)
{
    244e:	df 93       	push	r29
    2450:	cf 93       	push	r28
    2452:	cd b7       	in	r28, 0x3d	; 61
    2454:	de b7       	in	r29, 0x3e	; 62
    2456:	2a 97       	sbiw	r28, 0x0a	; 10
    2458:	0f b6       	in	r0, 0x3f	; 63
    245a:	f8 94       	cli
    245c:	de bf       	out	0x3e, r29	; 62
    245e:	0f be       	out	0x3f, r0	; 63
    2460:	cd bf       	out	0x3d, r28	; 61
    2462:	8c 83       	std	Y+4, r24	; 0x04
    2464:	7e 83       	std	Y+6, r23	; 0x06
    2466:	6d 83       	std	Y+5, r22	; 0x05
    2468:	4f 83       	std	Y+7, r20	; 0x07
    246a:	28 87       	std	Y+8, r18	; 0x08
	u8 Local_u8ErrorState = STD_TYPES_OK;
    246c:	81 e0       	ldi	r24, 0x01	; 1
    246e:	8b 83       	std	Y+3, r24	; 0x03
	const u8 size = 8;
    2470:	88 e0       	ldi	r24, 0x08	; 8
    2472:	8a 83       	std	Y+2, r24	; 0x02
	u8 i;
	switch(Copy_u8CharNum)
    2474:	8c 81       	ldd	r24, Y+4	; 0x04
    2476:	28 2f       	mov	r18, r24
    2478:	30 e0       	ldi	r19, 0x00	; 0
    247a:	3a 87       	std	Y+10, r19	; 0x0a
    247c:	29 87       	std	Y+9, r18	; 0x09
    247e:	89 85       	ldd	r24, Y+9	; 0x09
    2480:	9a 85       	ldd	r25, Y+10	; 0x0a
    2482:	83 30       	cpi	r24, 0x03	; 3
    2484:	91 05       	cpc	r25, r1
    2486:	09 f4       	brne	.+2      	; 0x248a <LCD_voidWriteSpecialChar+0x3c>
    2488:	8c c0       	rjmp	.+280    	; 0x25a2 <LCD_voidWriteSpecialChar+0x154>
    248a:	29 85       	ldd	r18, Y+9	; 0x09
    248c:	3a 85       	ldd	r19, Y+10	; 0x0a
    248e:	24 30       	cpi	r18, 0x04	; 4
    2490:	31 05       	cpc	r19, r1
    2492:	8c f4       	brge	.+34     	; 0x24b6 <LCD_voidWriteSpecialChar+0x68>
    2494:	89 85       	ldd	r24, Y+9	; 0x09
    2496:	9a 85       	ldd	r25, Y+10	; 0x0a
    2498:	81 30       	cpi	r24, 0x01	; 1
    249a:	91 05       	cpc	r25, r1
    249c:	09 f4       	brne	.+2      	; 0x24a0 <LCD_voidWriteSpecialChar+0x52>
    249e:	43 c0       	rjmp	.+134    	; 0x2526 <LCD_voidWriteSpecialChar+0xd8>
    24a0:	29 85       	ldd	r18, Y+9	; 0x09
    24a2:	3a 85       	ldd	r19, Y+10	; 0x0a
    24a4:	22 30       	cpi	r18, 0x02	; 2
    24a6:	31 05       	cpc	r19, r1
    24a8:	0c f0       	brlt	.+2      	; 0x24ac <LCD_voidWriteSpecialChar+0x5e>
    24aa:	5c c0       	rjmp	.+184    	; 0x2564 <LCD_voidWriteSpecialChar+0x116>
    24ac:	89 85       	ldd	r24, Y+9	; 0x09
    24ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    24b0:	00 97       	sbiw	r24, 0x00	; 0
    24b2:	d1 f0       	breq	.+52     	; 0x24e8 <LCD_voidWriteSpecialChar+0x9a>
    24b4:	11 c1       	rjmp	.+546    	; 0x26d8 <LCD_voidWriteSpecialChar+0x28a>
    24b6:	29 85       	ldd	r18, Y+9	; 0x09
    24b8:	3a 85       	ldd	r19, Y+10	; 0x0a
    24ba:	25 30       	cpi	r18, 0x05	; 5
    24bc:	31 05       	cpc	r19, r1
    24be:	09 f4       	brne	.+2      	; 0x24c2 <LCD_voidWriteSpecialChar+0x74>
    24c0:	ae c0       	rjmp	.+348    	; 0x261e <LCD_voidWriteSpecialChar+0x1d0>
    24c2:	89 85       	ldd	r24, Y+9	; 0x09
    24c4:	9a 85       	ldd	r25, Y+10	; 0x0a
    24c6:	85 30       	cpi	r24, 0x05	; 5
    24c8:	91 05       	cpc	r25, r1
    24ca:	0c f4       	brge	.+2      	; 0x24ce <LCD_voidWriteSpecialChar+0x80>
    24cc:	89 c0       	rjmp	.+274    	; 0x25e0 <LCD_voidWriteSpecialChar+0x192>
    24ce:	29 85       	ldd	r18, Y+9	; 0x09
    24d0:	3a 85       	ldd	r19, Y+10	; 0x0a
    24d2:	26 30       	cpi	r18, 0x06	; 6
    24d4:	31 05       	cpc	r19, r1
    24d6:	09 f4       	brne	.+2      	; 0x24da <LCD_voidWriteSpecialChar+0x8c>
    24d8:	c1 c0       	rjmp	.+386    	; 0x265c <LCD_voidWriteSpecialChar+0x20e>
    24da:	89 85       	ldd	r24, Y+9	; 0x09
    24dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    24de:	87 30       	cpi	r24, 0x07	; 7
    24e0:	91 05       	cpc	r25, r1
    24e2:	09 f4       	brne	.+2      	; 0x24e6 <LCD_voidWriteSpecialChar+0x98>
    24e4:	da c0       	rjmp	.+436    	; 0x269a <LCD_voidWriteSpecialChar+0x24c>
    24e6:	f8 c0       	rjmp	.+496    	; 0x26d8 <LCD_voidWriteSpecialChar+0x28a>
	{
	case LCD_u8_CHAR0:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_0_COMMAND);
    24e8:	80 e4       	ldi	r24, 0x40	; 64
    24ea:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    24ee:	19 82       	std	Y+1, r1	; 0x01
    24f0:	0e c0       	rjmp	.+28     	; 0x250e <LCD_voidWriteSpecialChar+0xc0>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    24f2:	89 81       	ldd	r24, Y+1	; 0x01
    24f4:	28 2f       	mov	r18, r24
    24f6:	30 e0       	ldi	r19, 0x00	; 0
    24f8:	8d 81       	ldd	r24, Y+5	; 0x05
    24fa:	9e 81       	ldd	r25, Y+6	; 0x06
    24fc:	fc 01       	movw	r30, r24
    24fe:	e2 0f       	add	r30, r18
    2500:	f3 1f       	adc	r31, r19
    2502:	80 81       	ld	r24, Z
    2504:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
	u8 i;
	switch(Copy_u8CharNum)
	{
	case LCD_u8_CHAR0:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_0_COMMAND);
		for(i = 0;i < size; i++)
    2508:	89 81       	ldd	r24, Y+1	; 0x01
    250a:	8f 5f       	subi	r24, 0xFF	; 255
    250c:	89 83       	std	Y+1, r24	; 0x01
    250e:	99 81       	ldd	r25, Y+1	; 0x01
    2510:	8a 81       	ldd	r24, Y+2	; 0x02
    2512:	98 17       	cp	r25, r24
    2514:	70 f3       	brcs	.-36     	; 0x24f2 <LCD_voidWriteSpecialChar+0xa4>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    2516:	8f 81       	ldd	r24, Y+7	; 0x07
    2518:	68 85       	ldd	r22, Y+8	; 0x08
    251a:	0e 94 6d 11 	call	0x22da	; 0x22da <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    251e:	8c 81       	ldd	r24, Y+4	; 0x04
    2520:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    2524:	da c0       	rjmp	.+436    	; 0x26da <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR1:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_1_COMMAND);
    2526:	88 e4       	ldi	r24, 0x48	; 72
    2528:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    252c:	19 82       	std	Y+1, r1	; 0x01
    252e:	0e c0       	rjmp	.+28     	; 0x254c <LCD_voidWriteSpecialChar+0xfe>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    2530:	89 81       	ldd	r24, Y+1	; 0x01
    2532:	28 2f       	mov	r18, r24
    2534:	30 e0       	ldi	r19, 0x00	; 0
    2536:	8d 81       	ldd	r24, Y+5	; 0x05
    2538:	9e 81       	ldd	r25, Y+6	; 0x06
    253a:	fc 01       	movw	r30, r24
    253c:	e2 0f       	add	r30, r18
    253e:	f3 1f       	adc	r31, r19
    2540:	80 81       	ld	r24, Z
    2542:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR1:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_1_COMMAND);
		for(i = 0;i < size; i++)
    2546:	89 81       	ldd	r24, Y+1	; 0x01
    2548:	8f 5f       	subi	r24, 0xFF	; 255
    254a:	89 83       	std	Y+1, r24	; 0x01
    254c:	99 81       	ldd	r25, Y+1	; 0x01
    254e:	8a 81       	ldd	r24, Y+2	; 0x02
    2550:	98 17       	cp	r25, r24
    2552:	70 f3       	brcs	.-36     	; 0x2530 <LCD_voidWriteSpecialChar+0xe2>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    2554:	8f 81       	ldd	r24, Y+7	; 0x07
    2556:	68 85       	ldd	r22, Y+8	; 0x08
    2558:	0e 94 6d 11 	call	0x22da	; 0x22da <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    255c:	8c 81       	ldd	r24, Y+4	; 0x04
    255e:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    2562:	bb c0       	rjmp	.+374    	; 0x26da <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR2:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_2_COMMAND);
    2564:	80 e5       	ldi	r24, 0x50	; 80
    2566:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    256a:	19 82       	std	Y+1, r1	; 0x01
    256c:	0e c0       	rjmp	.+28     	; 0x258a <LCD_voidWriteSpecialChar+0x13c>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    256e:	89 81       	ldd	r24, Y+1	; 0x01
    2570:	28 2f       	mov	r18, r24
    2572:	30 e0       	ldi	r19, 0x00	; 0
    2574:	8d 81       	ldd	r24, Y+5	; 0x05
    2576:	9e 81       	ldd	r25, Y+6	; 0x06
    2578:	fc 01       	movw	r30, r24
    257a:	e2 0f       	add	r30, r18
    257c:	f3 1f       	adc	r31, r19
    257e:	80 81       	ld	r24, Z
    2580:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR2:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_2_COMMAND);
		for(i = 0;i < size; i++)
    2584:	89 81       	ldd	r24, Y+1	; 0x01
    2586:	8f 5f       	subi	r24, 0xFF	; 255
    2588:	89 83       	std	Y+1, r24	; 0x01
    258a:	99 81       	ldd	r25, Y+1	; 0x01
    258c:	8a 81       	ldd	r24, Y+2	; 0x02
    258e:	98 17       	cp	r25, r24
    2590:	70 f3       	brcs	.-36     	; 0x256e <LCD_voidWriteSpecialChar+0x120>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    2592:	8f 81       	ldd	r24, Y+7	; 0x07
    2594:	68 85       	ldd	r22, Y+8	; 0x08
    2596:	0e 94 6d 11 	call	0x22da	; 0x22da <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    259a:	8c 81       	ldd	r24, Y+4	; 0x04
    259c:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    25a0:	9c c0       	rjmp	.+312    	; 0x26da <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR3:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_3_COMMAND);
    25a2:	88 e5       	ldi	r24, 0x58	; 88
    25a4:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    25a8:	19 82       	std	Y+1, r1	; 0x01
    25aa:	0e c0       	rjmp	.+28     	; 0x25c8 <LCD_voidWriteSpecialChar+0x17a>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    25ac:	89 81       	ldd	r24, Y+1	; 0x01
    25ae:	28 2f       	mov	r18, r24
    25b0:	30 e0       	ldi	r19, 0x00	; 0
    25b2:	8d 81       	ldd	r24, Y+5	; 0x05
    25b4:	9e 81       	ldd	r25, Y+6	; 0x06
    25b6:	fc 01       	movw	r30, r24
    25b8:	e2 0f       	add	r30, r18
    25ba:	f3 1f       	adc	r31, r19
    25bc:	80 81       	ld	r24, Z
    25be:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR3:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_3_COMMAND);
		for(i = 0;i < size; i++)
    25c2:	89 81       	ldd	r24, Y+1	; 0x01
    25c4:	8f 5f       	subi	r24, 0xFF	; 255
    25c6:	89 83       	std	Y+1, r24	; 0x01
    25c8:	99 81       	ldd	r25, Y+1	; 0x01
    25ca:	8a 81       	ldd	r24, Y+2	; 0x02
    25cc:	98 17       	cp	r25, r24
    25ce:	70 f3       	brcs	.-36     	; 0x25ac <LCD_voidWriteSpecialChar+0x15e>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    25d0:	8f 81       	ldd	r24, Y+7	; 0x07
    25d2:	68 85       	ldd	r22, Y+8	; 0x08
    25d4:	0e 94 6d 11 	call	0x22da	; 0x22da <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    25d8:	8c 81       	ldd	r24, Y+4	; 0x04
    25da:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    25de:	7d c0       	rjmp	.+250    	; 0x26da <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR4:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_4_COMMAND);
    25e0:	80 e6       	ldi	r24, 0x60	; 96
    25e2:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    25e6:	19 82       	std	Y+1, r1	; 0x01
    25e8:	0e c0       	rjmp	.+28     	; 0x2606 <LCD_voidWriteSpecialChar+0x1b8>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    25ea:	89 81       	ldd	r24, Y+1	; 0x01
    25ec:	28 2f       	mov	r18, r24
    25ee:	30 e0       	ldi	r19, 0x00	; 0
    25f0:	8d 81       	ldd	r24, Y+5	; 0x05
    25f2:	9e 81       	ldd	r25, Y+6	; 0x06
    25f4:	fc 01       	movw	r30, r24
    25f6:	e2 0f       	add	r30, r18
    25f8:	f3 1f       	adc	r31, r19
    25fa:	80 81       	ld	r24, Z
    25fc:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR4:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_4_COMMAND);
		for(i = 0;i < size; i++)
    2600:	89 81       	ldd	r24, Y+1	; 0x01
    2602:	8f 5f       	subi	r24, 0xFF	; 255
    2604:	89 83       	std	Y+1, r24	; 0x01
    2606:	99 81       	ldd	r25, Y+1	; 0x01
    2608:	8a 81       	ldd	r24, Y+2	; 0x02
    260a:	98 17       	cp	r25, r24
    260c:	70 f3       	brcs	.-36     	; 0x25ea <LCD_voidWriteSpecialChar+0x19c>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    260e:	8f 81       	ldd	r24, Y+7	; 0x07
    2610:	68 85       	ldd	r22, Y+8	; 0x08
    2612:	0e 94 6d 11 	call	0x22da	; 0x22da <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    2616:	8c 81       	ldd	r24, Y+4	; 0x04
    2618:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    261c:	5e c0       	rjmp	.+188    	; 0x26da <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR5:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_5_COMMAND);
    261e:	88 e6       	ldi	r24, 0x68	; 104
    2620:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    2624:	19 82       	std	Y+1, r1	; 0x01
    2626:	0e c0       	rjmp	.+28     	; 0x2644 <LCD_voidWriteSpecialChar+0x1f6>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    2628:	89 81       	ldd	r24, Y+1	; 0x01
    262a:	28 2f       	mov	r18, r24
    262c:	30 e0       	ldi	r19, 0x00	; 0
    262e:	8d 81       	ldd	r24, Y+5	; 0x05
    2630:	9e 81       	ldd	r25, Y+6	; 0x06
    2632:	fc 01       	movw	r30, r24
    2634:	e2 0f       	add	r30, r18
    2636:	f3 1f       	adc	r31, r19
    2638:	80 81       	ld	r24, Z
    263a:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR5:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_5_COMMAND);
		for(i = 0;i < size; i++)
    263e:	89 81       	ldd	r24, Y+1	; 0x01
    2640:	8f 5f       	subi	r24, 0xFF	; 255
    2642:	89 83       	std	Y+1, r24	; 0x01
    2644:	99 81       	ldd	r25, Y+1	; 0x01
    2646:	8a 81       	ldd	r24, Y+2	; 0x02
    2648:	98 17       	cp	r25, r24
    264a:	70 f3       	brcs	.-36     	; 0x2628 <LCD_voidWriteSpecialChar+0x1da>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    264c:	8f 81       	ldd	r24, Y+7	; 0x07
    264e:	68 85       	ldd	r22, Y+8	; 0x08
    2650:	0e 94 6d 11 	call	0x22da	; 0x22da <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    2654:	8c 81       	ldd	r24, Y+4	; 0x04
    2656:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    265a:	3f c0       	rjmp	.+126    	; 0x26da <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR6:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_6_COMMAND);
    265c:	80 e7       	ldi	r24, 0x70	; 112
    265e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    2662:	19 82       	std	Y+1, r1	; 0x01
    2664:	0e c0       	rjmp	.+28     	; 0x2682 <LCD_voidWriteSpecialChar+0x234>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    2666:	89 81       	ldd	r24, Y+1	; 0x01
    2668:	28 2f       	mov	r18, r24
    266a:	30 e0       	ldi	r19, 0x00	; 0
    266c:	8d 81       	ldd	r24, Y+5	; 0x05
    266e:	9e 81       	ldd	r25, Y+6	; 0x06
    2670:	fc 01       	movw	r30, r24
    2672:	e2 0f       	add	r30, r18
    2674:	f3 1f       	adc	r31, r19
    2676:	80 81       	ld	r24, Z
    2678:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR6:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_6_COMMAND);
		for(i = 0;i < size; i++)
    267c:	89 81       	ldd	r24, Y+1	; 0x01
    267e:	8f 5f       	subi	r24, 0xFF	; 255
    2680:	89 83       	std	Y+1, r24	; 0x01
    2682:	99 81       	ldd	r25, Y+1	; 0x01
    2684:	8a 81       	ldd	r24, Y+2	; 0x02
    2686:	98 17       	cp	r25, r24
    2688:	70 f3       	brcs	.-36     	; 0x2666 <LCD_voidWriteSpecialChar+0x218>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    268a:	8f 81       	ldd	r24, Y+7	; 0x07
    268c:	68 85       	ldd	r22, Y+8	; 0x08
    268e:	0e 94 6d 11 	call	0x22da	; 0x22da <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    2692:	8c 81       	ldd	r24, Y+4	; 0x04
    2694:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    2698:	20 c0       	rjmp	.+64     	; 0x26da <LCD_voidWriteSpecialChar+0x28c>
		break;
	case LCD_u8_CHAR7:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_7_COMMAND);
    269a:	88 e7       	ldi	r24, 0x78	; 120
    269c:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <LCD_voidSendCmnd>
		for(i = 0;i < size; i++)
    26a0:	19 82       	std	Y+1, r1	; 0x01
    26a2:	0e c0       	rjmp	.+28     	; 0x26c0 <LCD_voidWriteSpecialChar+0x272>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
    26a4:	89 81       	ldd	r24, Y+1	; 0x01
    26a6:	28 2f       	mov	r18, r24
    26a8:	30 e0       	ldi	r19, 0x00	; 0
    26aa:	8d 81       	ldd	r24, Y+5	; 0x05
    26ac:	9e 81       	ldd	r25, Y+6	; 0x06
    26ae:	fc 01       	movw	r30, r24
    26b0:	e2 0f       	add	r30, r18
    26b2:	f3 1f       	adc	r31, r19
    26b4:	80 81       	ld	r24, Z
    26b6:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
		LCD_voidSendChar(Copy_u8CharNum);
		break;
	case LCD_u8_CHAR7:
		LCD_voidSendCmnd(LCD_u8_CUSTOM_CHAR_7_COMMAND);
		for(i = 0;i < size; i++)
    26ba:	89 81       	ldd	r24, Y+1	; 0x01
    26bc:	8f 5f       	subi	r24, 0xFF	; 255
    26be:	89 83       	std	Y+1, r24	; 0x01
    26c0:	99 81       	ldd	r25, Y+1	; 0x01
    26c2:	8a 81       	ldd	r24, Y+2	; 0x02
    26c4:	98 17       	cp	r25, r24
    26c6:	70 f3       	brcs	.-36     	; 0x26a4 <LCD_voidWriteSpecialChar+0x256>
		{
			LCD_voidSendChar(Copy_pu8Char[i]);
		}
		LCD_u8GoToXY(Copy_u8LineNum,Copy_u8Location);
    26c8:	8f 81       	ldd	r24, Y+7	; 0x07
    26ca:	68 85       	ldd	r22, Y+8	; 0x08
    26cc:	0e 94 6d 11 	call	0x22da	; 0x22da <LCD_u8GoToXY>
		LCD_voidSendChar(Copy_u8CharNum);
    26d0:	8c 81       	ldd	r24, Y+4	; 0x04
    26d2:	0e 94 32 0f 	call	0x1e64	; 0x1e64 <LCD_voidSendChar>
    26d6:	01 c0       	rjmp	.+2      	; 0x26da <LCD_voidWriteSpecialChar+0x28c>
		break;
	default:Local_u8ErrorState = STD_TYPES_NOK;
    26d8:	1b 82       	std	Y+3, r1	; 0x03
	}
	return Local_u8ErrorState;
    26da:	8b 81       	ldd	r24, Y+3	; 0x03
}
    26dc:	2a 96       	adiw	r28, 0x0a	; 10
    26de:	0f b6       	in	r0, 0x3f	; 63
    26e0:	f8 94       	cli
    26e2:	de bf       	out	0x3e, r29	; 62
    26e4:	0f be       	out	0x3f, r0	; 63
    26e6:	cd bf       	out	0x3d, r28	; 61
    26e8:	cf 91       	pop	r28
    26ea:	df 91       	pop	r29
    26ec:	08 95       	ret

000026ee <LCD_voidSendHalfCmnd>:

void LCD_voidSendHalfCmnd(u8 Copy_u8HalfCmnd)
{
    26ee:	df 93       	push	r29
    26f0:	cf 93       	push	r28
    26f2:	cd b7       	in	r28, 0x3d	; 61
    26f4:	de b7       	in	r29, 0x3e	; 62
    26f6:	e1 97       	sbiw	r28, 0x31	; 49
    26f8:	0f b6       	in	r0, 0x3f	; 63
    26fa:	f8 94       	cli
    26fc:	de bf       	out	0x3e, r29	; 62
    26fe:	0f be       	out	0x3f, r0	; 63
    2700:	cd bf       	out	0x3d, r28	; 61
    2702:	89 ab       	std	Y+49, r24	; 0x31
	/* Step 1: RS = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RS_PIN,DIO_u8_LOW);
    2704:	80 e0       	ldi	r24, 0x00	; 0
    2706:	60 e0       	ldi	r22, 0x00	; 0
    2708:	40 e0       	ldi	r20, 0x00	; 0
    270a:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
	/* Step 2: RW = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_RW_PIN,DIO_u8_LOW);
    270e:	80 e0       	ldi	r24, 0x00	; 0
    2710:	61 e0       	ldi	r22, 0x01	; 1
    2712:	40 e0       	ldi	r20, 0x00	; 0
    2714:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
	/* Step 3: Write Command  */
	DIO_u8SetPortValue(LCD_u8_DATA_PORT,Copy_u8HalfCmnd<<4);
    2718:	89 a9       	ldd	r24, Y+49	; 0x31
    271a:	98 2f       	mov	r25, r24
    271c:	92 95       	swap	r25
    271e:	90 7f       	andi	r25, 0xF0	; 240
    2720:	82 e0       	ldi	r24, 0x02	; 2
    2722:	69 2f       	mov	r22, r25
    2724:	0e 94 27 0a 	call	0x144e	; 0x144e <DIO_u8SetPortValue>
	/* Step 4: E = 1 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_HIGH);
    2728:	80 e0       	ldi	r24, 0x00	; 0
    272a:	62 e0       	ldi	r22, 0x02	; 2
    272c:	41 e0       	ldi	r20, 0x01	; 1
    272e:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
    2732:	80 e0       	ldi	r24, 0x00	; 0
    2734:	90 e0       	ldi	r25, 0x00	; 0
    2736:	a0 e8       	ldi	r26, 0x80	; 128
    2738:	bf e3       	ldi	r27, 0x3F	; 63
    273a:	8d a7       	std	Y+45, r24	; 0x2d
    273c:	9e a7       	std	Y+46, r25	; 0x2e
    273e:	af a7       	std	Y+47, r26	; 0x2f
    2740:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2742:	6d a5       	ldd	r22, Y+45	; 0x2d
    2744:	7e a5       	ldd	r23, Y+46	; 0x2e
    2746:	8f a5       	ldd	r24, Y+47	; 0x2f
    2748:	98 a9       	ldd	r25, Y+48	; 0x30
    274a:	2b ea       	ldi	r18, 0xAB	; 171
    274c:	3a ea       	ldi	r19, 0xAA	; 170
    274e:	4a e2       	ldi	r20, 0x2A	; 42
    2750:	50 e4       	ldi	r21, 0x40	; 64
    2752:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2756:	dc 01       	movw	r26, r24
    2758:	cb 01       	movw	r24, r22
    275a:	89 a7       	std	Y+41, r24	; 0x29
    275c:	9a a7       	std	Y+42, r25	; 0x2a
    275e:	ab a7       	std	Y+43, r26	; 0x2b
    2760:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    2762:	69 a5       	ldd	r22, Y+41	; 0x29
    2764:	7a a5       	ldd	r23, Y+42	; 0x2a
    2766:	8b a5       	ldd	r24, Y+43	; 0x2b
    2768:	9c a5       	ldd	r25, Y+44	; 0x2c
    276a:	20 e0       	ldi	r18, 0x00	; 0
    276c:	30 e0       	ldi	r19, 0x00	; 0
    276e:	40 e8       	ldi	r20, 0x80	; 128
    2770:	5f e3       	ldi	r21, 0x3F	; 63
    2772:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2776:	88 23       	and	r24, r24
    2778:	1c f4       	brge	.+6      	; 0x2780 <LCD_voidSendHalfCmnd+0x92>
		__ticks = 1;
    277a:	81 e0       	ldi	r24, 0x01	; 1
    277c:	88 a7       	std	Y+40, r24	; 0x28
    277e:	91 c0       	rjmp	.+290    	; 0x28a2 <LCD_voidSendHalfCmnd+0x1b4>
	else if (__tmp > 255)
    2780:	69 a5       	ldd	r22, Y+41	; 0x29
    2782:	7a a5       	ldd	r23, Y+42	; 0x2a
    2784:	8b a5       	ldd	r24, Y+43	; 0x2b
    2786:	9c a5       	ldd	r25, Y+44	; 0x2c
    2788:	20 e0       	ldi	r18, 0x00	; 0
    278a:	30 e0       	ldi	r19, 0x00	; 0
    278c:	4f e7       	ldi	r20, 0x7F	; 127
    278e:	53 e4       	ldi	r21, 0x43	; 67
    2790:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2794:	18 16       	cp	r1, r24
    2796:	0c f0       	brlt	.+2      	; 0x279a <LCD_voidSendHalfCmnd+0xac>
    2798:	7b c0       	rjmp	.+246    	; 0x2890 <LCD_voidSendHalfCmnd+0x1a2>
	{
		_delay_ms(__us / 1000.0);
    279a:	6d a5       	ldd	r22, Y+45	; 0x2d
    279c:	7e a5       	ldd	r23, Y+46	; 0x2e
    279e:	8f a5       	ldd	r24, Y+47	; 0x2f
    27a0:	98 a9       	ldd	r25, Y+48	; 0x30
    27a2:	20 e0       	ldi	r18, 0x00	; 0
    27a4:	30 e0       	ldi	r19, 0x00	; 0
    27a6:	4a e7       	ldi	r20, 0x7A	; 122
    27a8:	54 e4       	ldi	r21, 0x44	; 68
    27aa:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    27ae:	dc 01       	movw	r26, r24
    27b0:	cb 01       	movw	r24, r22
    27b2:	8c a3       	std	Y+36, r24	; 0x24
    27b4:	9d a3       	std	Y+37, r25	; 0x25
    27b6:	ae a3       	std	Y+38, r26	; 0x26
    27b8:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27ba:	6c a1       	ldd	r22, Y+36	; 0x24
    27bc:	7d a1       	ldd	r23, Y+37	; 0x25
    27be:	8e a1       	ldd	r24, Y+38	; 0x26
    27c0:	9f a1       	ldd	r25, Y+39	; 0x27
    27c2:	20 e0       	ldi	r18, 0x00	; 0
    27c4:	30 e0       	ldi	r19, 0x00	; 0
    27c6:	4a ef       	ldi	r20, 0xFA	; 250
    27c8:	54 e4       	ldi	r21, 0x44	; 68
    27ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27ce:	dc 01       	movw	r26, r24
    27d0:	cb 01       	movw	r24, r22
    27d2:	88 a3       	std	Y+32, r24	; 0x20
    27d4:	99 a3       	std	Y+33, r25	; 0x21
    27d6:	aa a3       	std	Y+34, r26	; 0x22
    27d8:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    27da:	68 a1       	ldd	r22, Y+32	; 0x20
    27dc:	79 a1       	ldd	r23, Y+33	; 0x21
    27de:	8a a1       	ldd	r24, Y+34	; 0x22
    27e0:	9b a1       	ldd	r25, Y+35	; 0x23
    27e2:	20 e0       	ldi	r18, 0x00	; 0
    27e4:	30 e0       	ldi	r19, 0x00	; 0
    27e6:	40 e8       	ldi	r20, 0x80	; 128
    27e8:	5f e3       	ldi	r21, 0x3F	; 63
    27ea:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    27ee:	88 23       	and	r24, r24
    27f0:	2c f4       	brge	.+10     	; 0x27fc <LCD_voidSendHalfCmnd+0x10e>
		__ticks = 1;
    27f2:	81 e0       	ldi	r24, 0x01	; 1
    27f4:	90 e0       	ldi	r25, 0x00	; 0
    27f6:	9f 8f       	std	Y+31, r25	; 0x1f
    27f8:	8e 8f       	std	Y+30, r24	; 0x1e
    27fa:	3f c0       	rjmp	.+126    	; 0x287a <LCD_voidSendHalfCmnd+0x18c>
	else if (__tmp > 65535)
    27fc:	68 a1       	ldd	r22, Y+32	; 0x20
    27fe:	79 a1       	ldd	r23, Y+33	; 0x21
    2800:	8a a1       	ldd	r24, Y+34	; 0x22
    2802:	9b a1       	ldd	r25, Y+35	; 0x23
    2804:	20 e0       	ldi	r18, 0x00	; 0
    2806:	3f ef       	ldi	r19, 0xFF	; 255
    2808:	4f e7       	ldi	r20, 0x7F	; 127
    280a:	57 e4       	ldi	r21, 0x47	; 71
    280c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2810:	18 16       	cp	r1, r24
    2812:	4c f5       	brge	.+82     	; 0x2866 <LCD_voidSendHalfCmnd+0x178>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2814:	6c a1       	ldd	r22, Y+36	; 0x24
    2816:	7d a1       	ldd	r23, Y+37	; 0x25
    2818:	8e a1       	ldd	r24, Y+38	; 0x26
    281a:	9f a1       	ldd	r25, Y+39	; 0x27
    281c:	20 e0       	ldi	r18, 0x00	; 0
    281e:	30 e0       	ldi	r19, 0x00	; 0
    2820:	40 e2       	ldi	r20, 0x20	; 32
    2822:	51 e4       	ldi	r21, 0x41	; 65
    2824:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2828:	dc 01       	movw	r26, r24
    282a:	cb 01       	movw	r24, r22
    282c:	bc 01       	movw	r22, r24
    282e:	cd 01       	movw	r24, r26
    2830:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2834:	dc 01       	movw	r26, r24
    2836:	cb 01       	movw	r24, r22
    2838:	9f 8f       	std	Y+31, r25	; 0x1f
    283a:	8e 8f       	std	Y+30, r24	; 0x1e
    283c:	0f c0       	rjmp	.+30     	; 0x285c <LCD_voidSendHalfCmnd+0x16e>
    283e:	88 ec       	ldi	r24, 0xC8	; 200
    2840:	90 e0       	ldi	r25, 0x00	; 0
    2842:	9d 8f       	std	Y+29, r25	; 0x1d
    2844:	8c 8f       	std	Y+28, r24	; 0x1c
    2846:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2848:	9d 8d       	ldd	r25, Y+29	; 0x1d
    284a:	01 97       	sbiw	r24, 0x01	; 1
    284c:	f1 f7       	brne	.-4      	; 0x284a <LCD_voidSendHalfCmnd+0x15c>
    284e:	9d 8f       	std	Y+29, r25	; 0x1d
    2850:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2852:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2854:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2856:	01 97       	sbiw	r24, 0x01	; 1
    2858:	9f 8f       	std	Y+31, r25	; 0x1f
    285a:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    285c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    285e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2860:	00 97       	sbiw	r24, 0x00	; 0
    2862:	69 f7       	brne	.-38     	; 0x283e <LCD_voidSendHalfCmnd+0x150>
    2864:	24 c0       	rjmp	.+72     	; 0x28ae <LCD_voidSendHalfCmnd+0x1c0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2866:	68 a1       	ldd	r22, Y+32	; 0x20
    2868:	79 a1       	ldd	r23, Y+33	; 0x21
    286a:	8a a1       	ldd	r24, Y+34	; 0x22
    286c:	9b a1       	ldd	r25, Y+35	; 0x23
    286e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2872:	dc 01       	movw	r26, r24
    2874:	cb 01       	movw	r24, r22
    2876:	9f 8f       	std	Y+31, r25	; 0x1f
    2878:	8e 8f       	std	Y+30, r24	; 0x1e
    287a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    287c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    287e:	9b 8f       	std	Y+27, r25	; 0x1b
    2880:	8a 8f       	std	Y+26, r24	; 0x1a
    2882:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2884:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2886:	01 97       	sbiw	r24, 0x01	; 1
    2888:	f1 f7       	brne	.-4      	; 0x2886 <LCD_voidSendHalfCmnd+0x198>
    288a:	9b 8f       	std	Y+27, r25	; 0x1b
    288c:	8a 8f       	std	Y+26, r24	; 0x1a
    288e:	0f c0       	rjmp	.+30     	; 0x28ae <LCD_voidSendHalfCmnd+0x1c0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2890:	69 a5       	ldd	r22, Y+41	; 0x29
    2892:	7a a5       	ldd	r23, Y+42	; 0x2a
    2894:	8b a5       	ldd	r24, Y+43	; 0x2b
    2896:	9c a5       	ldd	r25, Y+44	; 0x2c
    2898:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    289c:	dc 01       	movw	r26, r24
    289e:	cb 01       	movw	r24, r22
    28a0:	88 a7       	std	Y+40, r24	; 0x28
    28a2:	88 a5       	ldd	r24, Y+40	; 0x28
    28a4:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    28a6:	89 8d       	ldd	r24, Y+25	; 0x19
    28a8:	8a 95       	dec	r24
    28aa:	f1 f7       	brne	.-4      	; 0x28a8 <LCD_voidSendHalfCmnd+0x1ba>
    28ac:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1); //wait tw = 230 ns
	/* Step 5: E = 0 */
	DIO_u8SetPinValue(LCD_u8_CTRL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
    28ae:	80 e0       	ldi	r24, 0x00	; 0
    28b0:	62 e0       	ldi	r22, 0x02	; 2
    28b2:	40 e0       	ldi	r20, 0x00	; 0
    28b4:	0e 94 9b 07 	call	0xf36	; 0xf36 <DIO_u8SetPinValue>
    28b8:	80 e0       	ldi	r24, 0x00	; 0
    28ba:	90 e0       	ldi	r25, 0x00	; 0
    28bc:	a0 e8       	ldi	r26, 0x80	; 128
    28be:	bf e3       	ldi	r27, 0x3F	; 63
    28c0:	8d 8b       	std	Y+21, r24	; 0x15
    28c2:	9e 8b       	std	Y+22, r25	; 0x16
    28c4:	af 8b       	std	Y+23, r26	; 0x17
    28c6:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    28c8:	6d 89       	ldd	r22, Y+21	; 0x15
    28ca:	7e 89       	ldd	r23, Y+22	; 0x16
    28cc:	8f 89       	ldd	r24, Y+23	; 0x17
    28ce:	98 8d       	ldd	r25, Y+24	; 0x18
    28d0:	2b ea       	ldi	r18, 0xAB	; 171
    28d2:	3a ea       	ldi	r19, 0xAA	; 170
    28d4:	4a e2       	ldi	r20, 0x2A	; 42
    28d6:	50 e4       	ldi	r21, 0x40	; 64
    28d8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    28dc:	dc 01       	movw	r26, r24
    28de:	cb 01       	movw	r24, r22
    28e0:	89 8b       	std	Y+17, r24	; 0x11
    28e2:	9a 8b       	std	Y+18, r25	; 0x12
    28e4:	ab 8b       	std	Y+19, r26	; 0x13
    28e6:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    28e8:	69 89       	ldd	r22, Y+17	; 0x11
    28ea:	7a 89       	ldd	r23, Y+18	; 0x12
    28ec:	8b 89       	ldd	r24, Y+19	; 0x13
    28ee:	9c 89       	ldd	r25, Y+20	; 0x14
    28f0:	20 e0       	ldi	r18, 0x00	; 0
    28f2:	30 e0       	ldi	r19, 0x00	; 0
    28f4:	40 e8       	ldi	r20, 0x80	; 128
    28f6:	5f e3       	ldi	r21, 0x3F	; 63
    28f8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    28fc:	88 23       	and	r24, r24
    28fe:	1c f4       	brge	.+6      	; 0x2906 <LCD_voidSendHalfCmnd+0x218>
		__ticks = 1;
    2900:	81 e0       	ldi	r24, 0x01	; 1
    2902:	88 8b       	std	Y+16, r24	; 0x10
    2904:	91 c0       	rjmp	.+290    	; 0x2a28 <LCD_voidSendHalfCmnd+0x33a>
	else if (__tmp > 255)
    2906:	69 89       	ldd	r22, Y+17	; 0x11
    2908:	7a 89       	ldd	r23, Y+18	; 0x12
    290a:	8b 89       	ldd	r24, Y+19	; 0x13
    290c:	9c 89       	ldd	r25, Y+20	; 0x14
    290e:	20 e0       	ldi	r18, 0x00	; 0
    2910:	30 e0       	ldi	r19, 0x00	; 0
    2912:	4f e7       	ldi	r20, 0x7F	; 127
    2914:	53 e4       	ldi	r21, 0x43	; 67
    2916:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    291a:	18 16       	cp	r1, r24
    291c:	0c f0       	brlt	.+2      	; 0x2920 <LCD_voidSendHalfCmnd+0x232>
    291e:	7b c0       	rjmp	.+246    	; 0x2a16 <LCD_voidSendHalfCmnd+0x328>
	{
		_delay_ms(__us / 1000.0);
    2920:	6d 89       	ldd	r22, Y+21	; 0x15
    2922:	7e 89       	ldd	r23, Y+22	; 0x16
    2924:	8f 89       	ldd	r24, Y+23	; 0x17
    2926:	98 8d       	ldd	r25, Y+24	; 0x18
    2928:	20 e0       	ldi	r18, 0x00	; 0
    292a:	30 e0       	ldi	r19, 0x00	; 0
    292c:	4a e7       	ldi	r20, 0x7A	; 122
    292e:	54 e4       	ldi	r21, 0x44	; 68
    2930:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2934:	dc 01       	movw	r26, r24
    2936:	cb 01       	movw	r24, r22
    2938:	8c 87       	std	Y+12, r24	; 0x0c
    293a:	9d 87       	std	Y+13, r25	; 0x0d
    293c:	ae 87       	std	Y+14, r26	; 0x0e
    293e:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2940:	6c 85       	ldd	r22, Y+12	; 0x0c
    2942:	7d 85       	ldd	r23, Y+13	; 0x0d
    2944:	8e 85       	ldd	r24, Y+14	; 0x0e
    2946:	9f 85       	ldd	r25, Y+15	; 0x0f
    2948:	20 e0       	ldi	r18, 0x00	; 0
    294a:	30 e0       	ldi	r19, 0x00	; 0
    294c:	4a ef       	ldi	r20, 0xFA	; 250
    294e:	54 e4       	ldi	r21, 0x44	; 68
    2950:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2954:	dc 01       	movw	r26, r24
    2956:	cb 01       	movw	r24, r22
    2958:	88 87       	std	Y+8, r24	; 0x08
    295a:	99 87       	std	Y+9, r25	; 0x09
    295c:	aa 87       	std	Y+10, r26	; 0x0a
    295e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    2960:	68 85       	ldd	r22, Y+8	; 0x08
    2962:	79 85       	ldd	r23, Y+9	; 0x09
    2964:	8a 85       	ldd	r24, Y+10	; 0x0a
    2966:	9b 85       	ldd	r25, Y+11	; 0x0b
    2968:	20 e0       	ldi	r18, 0x00	; 0
    296a:	30 e0       	ldi	r19, 0x00	; 0
    296c:	40 e8       	ldi	r20, 0x80	; 128
    296e:	5f e3       	ldi	r21, 0x3F	; 63
    2970:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2974:	88 23       	and	r24, r24
    2976:	2c f4       	brge	.+10     	; 0x2982 <LCD_voidSendHalfCmnd+0x294>
		__ticks = 1;
    2978:	81 e0       	ldi	r24, 0x01	; 1
    297a:	90 e0       	ldi	r25, 0x00	; 0
    297c:	9f 83       	std	Y+7, r25	; 0x07
    297e:	8e 83       	std	Y+6, r24	; 0x06
    2980:	3f c0       	rjmp	.+126    	; 0x2a00 <LCD_voidSendHalfCmnd+0x312>
	else if (__tmp > 65535)
    2982:	68 85       	ldd	r22, Y+8	; 0x08
    2984:	79 85       	ldd	r23, Y+9	; 0x09
    2986:	8a 85       	ldd	r24, Y+10	; 0x0a
    2988:	9b 85       	ldd	r25, Y+11	; 0x0b
    298a:	20 e0       	ldi	r18, 0x00	; 0
    298c:	3f ef       	ldi	r19, 0xFF	; 255
    298e:	4f e7       	ldi	r20, 0x7F	; 127
    2990:	57 e4       	ldi	r21, 0x47	; 71
    2992:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2996:	18 16       	cp	r1, r24
    2998:	4c f5       	brge	.+82     	; 0x29ec <LCD_voidSendHalfCmnd+0x2fe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    299a:	6c 85       	ldd	r22, Y+12	; 0x0c
    299c:	7d 85       	ldd	r23, Y+13	; 0x0d
    299e:	8e 85       	ldd	r24, Y+14	; 0x0e
    29a0:	9f 85       	ldd	r25, Y+15	; 0x0f
    29a2:	20 e0       	ldi	r18, 0x00	; 0
    29a4:	30 e0       	ldi	r19, 0x00	; 0
    29a6:	40 e2       	ldi	r20, 0x20	; 32
    29a8:	51 e4       	ldi	r21, 0x41	; 65
    29aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29ae:	dc 01       	movw	r26, r24
    29b0:	cb 01       	movw	r24, r22
    29b2:	bc 01       	movw	r22, r24
    29b4:	cd 01       	movw	r24, r26
    29b6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29ba:	dc 01       	movw	r26, r24
    29bc:	cb 01       	movw	r24, r22
    29be:	9f 83       	std	Y+7, r25	; 0x07
    29c0:	8e 83       	std	Y+6, r24	; 0x06
    29c2:	0f c0       	rjmp	.+30     	; 0x29e2 <LCD_voidSendHalfCmnd+0x2f4>
    29c4:	88 ec       	ldi	r24, 0xC8	; 200
    29c6:	90 e0       	ldi	r25, 0x00	; 0
    29c8:	9d 83       	std	Y+5, r25	; 0x05
    29ca:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    29cc:	8c 81       	ldd	r24, Y+4	; 0x04
    29ce:	9d 81       	ldd	r25, Y+5	; 0x05
    29d0:	01 97       	sbiw	r24, 0x01	; 1
    29d2:	f1 f7       	brne	.-4      	; 0x29d0 <LCD_voidSendHalfCmnd+0x2e2>
    29d4:	9d 83       	std	Y+5, r25	; 0x05
    29d6:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    29d8:	8e 81       	ldd	r24, Y+6	; 0x06
    29da:	9f 81       	ldd	r25, Y+7	; 0x07
    29dc:	01 97       	sbiw	r24, 0x01	; 1
    29de:	9f 83       	std	Y+7, r25	; 0x07
    29e0:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    29e2:	8e 81       	ldd	r24, Y+6	; 0x06
    29e4:	9f 81       	ldd	r25, Y+7	; 0x07
    29e6:	00 97       	sbiw	r24, 0x00	; 0
    29e8:	69 f7       	brne	.-38     	; 0x29c4 <LCD_voidSendHalfCmnd+0x2d6>
    29ea:	24 c0       	rjmp	.+72     	; 0x2a34 <LCD_voidSendHalfCmnd+0x346>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    29ec:	68 85       	ldd	r22, Y+8	; 0x08
    29ee:	79 85       	ldd	r23, Y+9	; 0x09
    29f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    29f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    29f4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29f8:	dc 01       	movw	r26, r24
    29fa:	cb 01       	movw	r24, r22
    29fc:	9f 83       	std	Y+7, r25	; 0x07
    29fe:	8e 83       	std	Y+6, r24	; 0x06
    2a00:	8e 81       	ldd	r24, Y+6	; 0x06
    2a02:	9f 81       	ldd	r25, Y+7	; 0x07
    2a04:	9b 83       	std	Y+3, r25	; 0x03
    2a06:	8a 83       	std	Y+2, r24	; 0x02
    2a08:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a0c:	01 97       	sbiw	r24, 0x01	; 1
    2a0e:	f1 f7       	brne	.-4      	; 0x2a0c <LCD_voidSendHalfCmnd+0x31e>
    2a10:	9b 83       	std	Y+3, r25	; 0x03
    2a12:	8a 83       	std	Y+2, r24	; 0x02
    2a14:	0f c0       	rjmp	.+30     	; 0x2a34 <LCD_voidSendHalfCmnd+0x346>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2a16:	69 89       	ldd	r22, Y+17	; 0x11
    2a18:	7a 89       	ldd	r23, Y+18	; 0x12
    2a1a:	8b 89       	ldd	r24, Y+19	; 0x13
    2a1c:	9c 89       	ldd	r25, Y+20	; 0x14
    2a1e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a22:	dc 01       	movw	r26, r24
    2a24:	cb 01       	movw	r24, r22
    2a26:	88 8b       	std	Y+16, r24	; 0x10
    2a28:	88 89       	ldd	r24, Y+16	; 0x10
    2a2a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2a2c:	89 81       	ldd	r24, Y+1	; 0x01
    2a2e:	8a 95       	dec	r24
    2a30:	f1 f7       	brne	.-4      	; 0x2a2e <LCD_voidSendHalfCmnd+0x340>
    2a32:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1); // wait tc = 500ns (not important because 1 us in step 4 is enough because >>> 230ns )
    2a34:	e1 96       	adiw	r28, 0x31	; 49
    2a36:	0f b6       	in	r0, 0x3f	; 63
    2a38:	f8 94       	cli
    2a3a:	de bf       	out	0x3e, r29	; 62
    2a3c:	0f be       	out	0x3f, r0	; 63
    2a3e:	cd bf       	out	0x3d, r28	; 61
    2a40:	cf 91       	pop	r28
    2a42:	df 91       	pop	r29
    2a44:	08 95       	ret

00002a46 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
    2a46:	df 93       	push	r29
    2a48:	cf 93       	push	r28
    2a4a:	00 d0       	rcall	.+0      	; 0x2a4c <xEventGroupCreate+0x6>
    2a4c:	cd b7       	in	r28, 0x3d	; 61
    2a4e:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    2a50:	8b e0       	ldi	r24, 0x0B	; 11
    2a52:	90 e0       	ldi	r25, 0x00	; 0
    2a54:	0e 94 68 18 	call	0x30d0	; 0x30d0 <pvPortMalloc>
    2a58:	9a 83       	std	Y+2, r25	; 0x02
    2a5a:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
    2a5c:	89 81       	ldd	r24, Y+1	; 0x01
    2a5e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a60:	00 97       	sbiw	r24, 0x00	; 0
    2a62:	49 f0       	breq	.+18     	; 0x2a76 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
    2a64:	e9 81       	ldd	r30, Y+1	; 0x01
    2a66:	fa 81       	ldd	r31, Y+2	; 0x02
    2a68:	11 82       	std	Z+1, r1	; 0x01
    2a6a:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    2a6c:	89 81       	ldd	r24, Y+1	; 0x01
    2a6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a70:	02 96       	adiw	r24, 0x02	; 2
    2a72:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
    2a76:	89 81       	ldd	r24, Y+1	; 0x01
    2a78:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    2a7a:	0f 90       	pop	r0
    2a7c:	0f 90       	pop	r0
    2a7e:	cf 91       	pop	r28
    2a80:	df 91       	pop	r29
    2a82:	08 95       	ret

00002a84 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
    2a84:	df 93       	push	r29
    2a86:	cf 93       	push	r28
    2a88:	cd b7       	in	r28, 0x3d	; 61
    2a8a:	de b7       	in	r29, 0x3e	; 62
    2a8c:	60 97       	sbiw	r28, 0x10	; 16
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	f8 94       	cli
    2a92:	de bf       	out	0x3e, r29	; 62
    2a94:	0f be       	out	0x3f, r0	; 63
    2a96:	cd bf       	out	0x3d, r28	; 61
    2a98:	9a 87       	std	Y+10, r25	; 0x0a
    2a9a:	89 87       	std	Y+9, r24	; 0x09
    2a9c:	7c 87       	std	Y+12, r23	; 0x0c
    2a9e:	6b 87       	std	Y+11, r22	; 0x0b
    2aa0:	5e 87       	std	Y+14, r21	; 0x0e
    2aa2:	4d 87       	std	Y+13, r20	; 0x0d
    2aa4:	38 8b       	std	Y+16, r19	; 0x10
    2aa6:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
    2aa8:	89 85       	ldd	r24, Y+9	; 0x09
    2aaa:	9a 85       	ldd	r25, Y+10	; 0x0a
    2aac:	9c 83       	std	Y+4, r25	; 0x04
    2aae:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2ab0:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2ab2:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
    2ab6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aba:	80 81       	ld	r24, Z
    2abc:	91 81       	ldd	r25, Z+1	; 0x01
    2abe:	98 87       	std	Y+8, r25	; 0x08
    2ac0:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    2ac2:	89 85       	ldd	r24, Y+9	; 0x09
    2ac4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ac6:	2b 85       	ldd	r18, Y+11	; 0x0b
    2ac8:	3c 85       	ldd	r19, Y+12	; 0x0c
    2aca:	b9 01       	movw	r22, r18
    2acc:	0e 94 19 17 	call	0x2e32	; 0x2e32 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2ad0:	2f 81       	ldd	r18, Y+7	; 0x07
    2ad2:	38 85       	ldd	r19, Y+8	; 0x08
    2ad4:	8b 85       	ldd	r24, Y+11	; 0x0b
    2ad6:	9c 85       	ldd	r25, Y+12	; 0x0c
    2ad8:	28 2b       	or	r18, r24
    2ada:	39 2b       	or	r19, r25
    2adc:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ade:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ae0:	28 23       	and	r18, r24
    2ae2:	39 23       	and	r19, r25
    2ae4:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ae6:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ae8:	28 17       	cp	r18, r24
    2aea:	39 07       	cpc	r19, r25
    2aec:	c9 f4       	brne	.+50     	; 0x2b20 <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    2aee:	2f 81       	ldd	r18, Y+7	; 0x07
    2af0:	38 85       	ldd	r19, Y+8	; 0x08
    2af2:	8b 85       	ldd	r24, Y+11	; 0x0b
    2af4:	9c 85       	ldd	r25, Y+12	; 0x0c
    2af6:	82 2b       	or	r24, r18
    2af8:	93 2b       	or	r25, r19
    2afa:	9e 83       	std	Y+6, r25	; 0x06
    2afc:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2afe:	eb 81       	ldd	r30, Y+3	; 0x03
    2b00:	fc 81       	ldd	r31, Y+4	; 0x04
    2b02:	20 81       	ld	r18, Z
    2b04:	31 81       	ldd	r19, Z+1	; 0x01
    2b06:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b08:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b0a:	80 95       	com	r24
    2b0c:	90 95       	com	r25
    2b0e:	82 23       	and	r24, r18
    2b10:	93 23       	and	r25, r19
    2b12:	eb 81       	ldd	r30, Y+3	; 0x03
    2b14:	fc 81       	ldd	r31, Y+4	; 0x04
    2b16:	91 83       	std	Z+1, r25	; 0x01
    2b18:	80 83       	st	Z, r24

			xTicksToWait = 0;
    2b1a:	18 8a       	std	Y+16, r1	; 0x10
    2b1c:	1f 86       	std	Y+15, r1	; 0x0f
    2b1e:	1e c0       	rjmp	.+60     	; 0x2b5c <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
    2b20:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b22:	98 89       	ldd	r25, Y+16	; 0x10
    2b24:	00 97       	sbiw	r24, 0x00	; 0
    2b26:	91 f0       	breq	.+36     	; 0x2b4c <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    2b28:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b2c:	bc 01       	movw	r22, r24
    2b2e:	6e 5f       	subi	r22, 0xFE	; 254
    2b30:	7f 4f       	sbci	r23, 0xFF	; 255
    2b32:	8d 85       	ldd	r24, Y+13	; 0x0d
    2b34:	9e 85       	ldd	r25, Y+14	; 0x0e
    2b36:	9c 01       	movw	r18, r24
    2b38:	35 60       	ori	r19, 0x05	; 5
    2b3a:	4f 85       	ldd	r20, Y+15	; 0x0f
    2b3c:	58 89       	ldd	r21, Y+16	; 0x10
    2b3e:	cb 01       	movw	r24, r22
    2b40:	b9 01       	movw	r22, r18
    2b42:	0e 94 bb 2d 	call	0x5b76	; 0x5b76 <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
    2b46:	1e 82       	std	Y+6, r1	; 0x06
    2b48:	1d 82       	std	Y+5, r1	; 0x05
    2b4a:	08 c0       	rjmp	.+16     	; 0x2b5c <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2b4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b50:	80 81       	ld	r24, Z
    2b52:	91 81       	ldd	r25, Z+1	; 0x01
    2b54:	9e 83       	std	Y+6, r25	; 0x06
    2b56:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
    2b58:	81 e0       	ldi	r24, 0x01	; 1
    2b5a:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2b5c:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    2b60:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
    2b62:	8f 85       	ldd	r24, Y+15	; 0x0f
    2b64:	98 89       	ldd	r25, Y+16	; 0x10
    2b66:	00 97       	sbiw	r24, 0x00	; 0
    2b68:	09 f4       	brne	.+2      	; 0x2b6c <xEventGroupSync+0xe8>
    2b6a:	3a c0       	rjmp	.+116    	; 0x2be0 <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
    2b6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b6e:	88 23       	and	r24, r24
    2b70:	11 f4       	brne	.+4      	; 0x2b76 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
    2b72:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2b76:	0e 94 1c 30 	call	0x6038	; 0x6038 <uxTaskResetEventItemValue>
    2b7a:	9e 83       	std	Y+6, r25	; 0x06
    2b7c:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2b7e:	8d 81       	ldd	r24, Y+5	; 0x05
    2b80:	9e 81       	ldd	r25, Y+6	; 0x06
    2b82:	80 70       	andi	r24, 0x00	; 0
    2b84:	92 70       	andi	r25, 0x02	; 2
    2b86:	00 97       	sbiw	r24, 0x00	; 0
    2b88:	31 f5       	brne	.+76     	; 0x2bd6 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
    2b8a:	0f b6       	in	r0, 0x3f	; 63
    2b8c:	f8 94       	cli
    2b8e:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
    2b90:	eb 81       	ldd	r30, Y+3	; 0x03
    2b92:	fc 81       	ldd	r31, Y+4	; 0x04
    2b94:	80 81       	ld	r24, Z
    2b96:	91 81       	ldd	r25, Z+1	; 0x01
    2b98:	9e 83       	std	Y+6, r25	; 0x06
    2b9a:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    2b9c:	2d 81       	ldd	r18, Y+5	; 0x05
    2b9e:	3e 81       	ldd	r19, Y+6	; 0x06
    2ba0:	8d 85       	ldd	r24, Y+13	; 0x0d
    2ba2:	9e 85       	ldd	r25, Y+14	; 0x0e
    2ba4:	28 23       	and	r18, r24
    2ba6:	39 23       	and	r19, r25
    2ba8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2baa:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bac:	28 17       	cp	r18, r24
    2bae:	39 07       	cpc	r19, r25
    2bb0:	71 f4       	brne	.+28     	; 0x2bce <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2bb2:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb4:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb6:	20 81       	ld	r18, Z
    2bb8:	31 81       	ldd	r19, Z+1	; 0x01
    2bba:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bbc:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bbe:	80 95       	com	r24
    2bc0:	90 95       	com	r25
    2bc2:	82 23       	and	r24, r18
    2bc4:	93 23       	and	r25, r19
    2bc6:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc8:	fc 81       	ldd	r31, Y+4	; 0x04
    2bca:	91 83       	std	Z+1, r25	; 0x01
    2bcc:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2bce:	0f 90       	pop	r0
    2bd0:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
    2bd2:	81 e0       	ldi	r24, 0x01	; 1
    2bd4:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2bd6:	8d 81       	ldd	r24, Y+5	; 0x05
    2bd8:	9e 81       	ldd	r25, Y+6	; 0x06
    2bda:	90 70       	andi	r25, 0x00	; 0
    2bdc:	9e 83       	std	Y+6, r25	; 0x06
    2bde:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    2be0:	8d 81       	ldd	r24, Y+5	; 0x05
    2be2:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2be4:	60 96       	adiw	r28, 0x10	; 16
    2be6:	0f b6       	in	r0, 0x3f	; 63
    2be8:	f8 94       	cli
    2bea:	de bf       	out	0x3e, r29	; 62
    2bec:	0f be       	out	0x3f, r0	; 63
    2bee:	cd bf       	out	0x3d, r28	; 61
    2bf0:	cf 91       	pop	r28
    2bf2:	df 91       	pop	r29
    2bf4:	08 95       	ret

00002bf6 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
    2bf6:	0f 93       	push	r16
    2bf8:	1f 93       	push	r17
    2bfa:	df 93       	push	r29
    2bfc:	cf 93       	push	r28
    2bfe:	cd b7       	in	r28, 0x3d	; 61
    2c00:	de b7       	in	r29, 0x3e	; 62
    2c02:	63 97       	sbiw	r28, 0x13	; 19
    2c04:	0f b6       	in	r0, 0x3f	; 63
    2c06:	f8 94       	cli
    2c08:	de bf       	out	0x3e, r29	; 62
    2c0a:	0f be       	out	0x3f, r0	; 63
    2c0c:	cd bf       	out	0x3d, r28	; 61
    2c0e:	9d 87       	std	Y+13, r25	; 0x0d
    2c10:	8c 87       	std	Y+12, r24	; 0x0c
    2c12:	7f 87       	std	Y+15, r23	; 0x0f
    2c14:	6e 87       	std	Y+14, r22	; 0x0e
    2c16:	48 8b       	std	Y+16, r20	; 0x10
    2c18:	29 8b       	std	Y+17, r18	; 0x11
    2c1a:	1b 8b       	std	Y+19, r17	; 0x13
    2c1c:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
    2c1e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2c20:	9d 85       	ldd	r25, Y+13	; 0x0d
    2c22:	9b 87       	std	Y+11, r25	; 0x0b
    2c24:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
    2c26:	1f 82       	std	Y+7, r1	; 0x07
    2c28:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
    2c2a:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
    2c2c:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    2c30:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c32:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c34:	80 81       	ld	r24, Z
    2c36:	91 81       	ldd	r25, Z+1	; 0x01
    2c38:	9a 83       	std	Y+2, r25	; 0x02
    2c3a:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    2c3c:	89 81       	ldd	r24, Y+1	; 0x01
    2c3e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c40:	2e 85       	ldd	r18, Y+14	; 0x0e
    2c42:	3f 85       	ldd	r19, Y+15	; 0x0f
    2c44:	b9 01       	movw	r22, r18
    2c46:	49 89       	ldd	r20, Y+17	; 0x11
    2c48:	0e 94 36 18 	call	0x306c	; 0x306c <prvTestWaitCondition>
    2c4c:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
    2c4e:	8d 81       	ldd	r24, Y+5	; 0x05
    2c50:	88 23       	and	r24, r24
    2c52:	c1 f0       	breq	.+48     	; 0x2c84 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
    2c54:	89 81       	ldd	r24, Y+1	; 0x01
    2c56:	9a 81       	ldd	r25, Y+2	; 0x02
    2c58:	99 87       	std	Y+9, r25	; 0x09
    2c5a:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
    2c5c:	1b 8a       	std	Y+19, r1	; 0x13
    2c5e:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
    2c60:	88 89       	ldd	r24, Y+16	; 0x10
    2c62:	88 23       	and	r24, r24
    2c64:	e9 f1       	breq	.+122    	; 0x2ce0 <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2c66:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c68:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c6a:	20 81       	ld	r18, Z
    2c6c:	31 81       	ldd	r19, Z+1	; 0x01
    2c6e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2c70:	9f 85       	ldd	r25, Y+15	; 0x0f
    2c72:	80 95       	com	r24
    2c74:	90 95       	com	r25
    2c76:	82 23       	and	r24, r18
    2c78:	93 23       	and	r25, r19
    2c7a:	ea 85       	ldd	r30, Y+10	; 0x0a
    2c7c:	fb 85       	ldd	r31, Y+11	; 0x0b
    2c7e:	91 83       	std	Z+1, r25	; 0x01
    2c80:	80 83       	st	Z, r24
    2c82:	2e c0       	rjmp	.+92     	; 0x2ce0 <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
    2c84:	8a 89       	ldd	r24, Y+18	; 0x12
    2c86:	9b 89       	ldd	r25, Y+19	; 0x13
    2c88:	00 97       	sbiw	r24, 0x00	; 0
    2c8a:	39 f4       	brne	.+14     	; 0x2c9a <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
    2c8c:	89 81       	ldd	r24, Y+1	; 0x01
    2c8e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c90:	99 87       	std	Y+9, r25	; 0x09
    2c92:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
    2c94:	81 e0       	ldi	r24, 0x01	; 1
    2c96:	8b 83       	std	Y+3, r24	; 0x03
    2c98:	23 c0       	rjmp	.+70     	; 0x2ce0 <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
    2c9a:	88 89       	ldd	r24, Y+16	; 0x10
    2c9c:	88 23       	and	r24, r24
    2c9e:	29 f0       	breq	.+10     	; 0x2caa <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    2ca0:	8e 81       	ldd	r24, Y+6	; 0x06
    2ca2:	9f 81       	ldd	r25, Y+7	; 0x07
    2ca4:	91 60       	ori	r25, 0x01	; 1
    2ca6:	9f 83       	std	Y+7, r25	; 0x07
    2ca8:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
    2caa:	89 89       	ldd	r24, Y+17	; 0x11
    2cac:	88 23       	and	r24, r24
    2cae:	29 f0       	breq	.+10     	; 0x2cba <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
    2cb0:	8e 81       	ldd	r24, Y+6	; 0x06
    2cb2:	9f 81       	ldd	r25, Y+7	; 0x07
    2cb4:	94 60       	ori	r25, 0x04	; 4
    2cb6:	9f 83       	std	Y+7, r25	; 0x07
    2cb8:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    2cba:	8a 85       	ldd	r24, Y+10	; 0x0a
    2cbc:	9b 85       	ldd	r25, Y+11	; 0x0b
    2cbe:	bc 01       	movw	r22, r24
    2cc0:	6e 5f       	subi	r22, 0xFE	; 254
    2cc2:	7f 4f       	sbci	r23, 0xFF	; 255
    2cc4:	2e 85       	ldd	r18, Y+14	; 0x0e
    2cc6:	3f 85       	ldd	r19, Y+15	; 0x0f
    2cc8:	8e 81       	ldd	r24, Y+6	; 0x06
    2cca:	9f 81       	ldd	r25, Y+7	; 0x07
    2ccc:	28 2b       	or	r18, r24
    2cce:	39 2b       	or	r19, r25
    2cd0:	4a 89       	ldd	r20, Y+18	; 0x12
    2cd2:	5b 89       	ldd	r21, Y+19	; 0x13
    2cd4:	cb 01       	movw	r24, r22
    2cd6:	b9 01       	movw	r22, r18
    2cd8:	0e 94 bb 2d 	call	0x5b76	; 0x5b76 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
    2cdc:	19 86       	std	Y+9, r1	; 0x09
    2cde:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
    2ce0:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    2ce4:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
    2ce6:	8a 89       	ldd	r24, Y+18	; 0x12
    2ce8:	9b 89       	ldd	r25, Y+19	; 0x13
    2cea:	00 97       	sbiw	r24, 0x00	; 0
    2cec:	09 f4       	brne	.+2      	; 0x2cf0 <xEventGroupWaitBits+0xfa>
    2cee:	3c c0       	rjmp	.+120    	; 0x2d68 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
    2cf0:	8c 81       	ldd	r24, Y+4	; 0x04
    2cf2:	88 23       	and	r24, r24
    2cf4:	11 f4       	brne	.+4      	; 0x2cfa <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    2cf6:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    2cfa:	0e 94 1c 30 	call	0x6038	; 0x6038 <uxTaskResetEventItemValue>
    2cfe:	99 87       	std	Y+9, r25	; 0x09
    2d00:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    2d02:	88 85       	ldd	r24, Y+8	; 0x08
    2d04:	99 85       	ldd	r25, Y+9	; 0x09
    2d06:	80 70       	andi	r24, 0x00	; 0
    2d08:	92 70       	andi	r25, 0x02	; 2
    2d0a:	00 97       	sbiw	r24, 0x00	; 0
    2d0c:	41 f5       	brne	.+80     	; 0x2d5e <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    2d0e:	0f b6       	in	r0, 0x3f	; 63
    2d10:	f8 94       	cli
    2d12:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    2d14:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d16:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d18:	80 81       	ld	r24, Z
    2d1a:	91 81       	ldd	r25, Z+1	; 0x01
    2d1c:	99 87       	std	Y+9, r25	; 0x09
    2d1e:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    2d20:	88 85       	ldd	r24, Y+8	; 0x08
    2d22:	99 85       	ldd	r25, Y+9	; 0x09
    2d24:	2e 85       	ldd	r18, Y+14	; 0x0e
    2d26:	3f 85       	ldd	r19, Y+15	; 0x0f
    2d28:	b9 01       	movw	r22, r18
    2d2a:	49 89       	ldd	r20, Y+17	; 0x11
    2d2c:	0e 94 36 18 	call	0x306c	; 0x306c <prvTestWaitCondition>
    2d30:	88 23       	and	r24, r24
    2d32:	89 f0       	breq	.+34     	; 0x2d56 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    2d34:	88 89       	ldd	r24, Y+16	; 0x10
    2d36:	88 23       	and	r24, r24
    2d38:	71 f0       	breq	.+28     	; 0x2d56 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    2d3a:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d3c:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d3e:	20 81       	ld	r18, Z
    2d40:	31 81       	ldd	r19, Z+1	; 0x01
    2d42:	8e 85       	ldd	r24, Y+14	; 0x0e
    2d44:	9f 85       	ldd	r25, Y+15	; 0x0f
    2d46:	80 95       	com	r24
    2d48:	90 95       	com	r25
    2d4a:	82 23       	and	r24, r18
    2d4c:	93 23       	and	r25, r19
    2d4e:	ea 85       	ldd	r30, Y+10	; 0x0a
    2d50:	fb 85       	ldd	r31, Y+11	; 0x0b
    2d52:	91 83       	std	Z+1, r25	; 0x01
    2d54:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    2d56:	81 e0       	ldi	r24, 0x01	; 1
    2d58:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    2d5a:	0f 90       	pop	r0
    2d5c:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    2d5e:	88 85       	ldd	r24, Y+8	; 0x08
    2d60:	99 85       	ldd	r25, Y+9	; 0x09
    2d62:	90 70       	andi	r25, 0x00	; 0
    2d64:	99 87       	std	Y+9, r25	; 0x09
    2d66:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    2d68:	88 85       	ldd	r24, Y+8	; 0x08
    2d6a:	99 85       	ldd	r25, Y+9	; 0x09
}
    2d6c:	63 96       	adiw	r28, 0x13	; 19
    2d6e:	0f b6       	in	r0, 0x3f	; 63
    2d70:	f8 94       	cli
    2d72:	de bf       	out	0x3e, r29	; 62
    2d74:	0f be       	out	0x3f, r0	; 63
    2d76:	cd bf       	out	0x3d, r28	; 61
    2d78:	cf 91       	pop	r28
    2d7a:	df 91       	pop	r29
    2d7c:	1f 91       	pop	r17
    2d7e:	0f 91       	pop	r16
    2d80:	08 95       	ret

00002d82 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    2d82:	df 93       	push	r29
    2d84:	cf 93       	push	r28
    2d86:	cd b7       	in	r28, 0x3d	; 61
    2d88:	de b7       	in	r29, 0x3e	; 62
    2d8a:	28 97       	sbiw	r28, 0x08	; 8
    2d8c:	0f b6       	in	r0, 0x3f	; 63
    2d8e:	f8 94       	cli
    2d90:	de bf       	out	0x3e, r29	; 62
    2d92:	0f be       	out	0x3f, r0	; 63
    2d94:	cd bf       	out	0x3d, r28	; 61
    2d96:	9e 83       	std	Y+6, r25	; 0x06
    2d98:	8d 83       	std	Y+5, r24	; 0x05
    2d9a:	78 87       	std	Y+8, r23	; 0x08
    2d9c:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    2d9e:	8d 81       	ldd	r24, Y+5	; 0x05
    2da0:	9e 81       	ldd	r25, Y+6	; 0x06
    2da2:	9c 83       	std	Y+4, r25	; 0x04
    2da4:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    2da6:	0f b6       	in	r0, 0x3f	; 63
    2da8:	f8 94       	cli
    2daa:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    2dac:	eb 81       	ldd	r30, Y+3	; 0x03
    2dae:	fc 81       	ldd	r31, Y+4	; 0x04
    2db0:	80 81       	ld	r24, Z
    2db2:	91 81       	ldd	r25, Z+1	; 0x01
    2db4:	9a 83       	std	Y+2, r25	; 0x02
    2db6:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2db8:	eb 81       	ldd	r30, Y+3	; 0x03
    2dba:	fc 81       	ldd	r31, Y+4	; 0x04
    2dbc:	20 81       	ld	r18, Z
    2dbe:	31 81       	ldd	r19, Z+1	; 0x01
    2dc0:	8f 81       	ldd	r24, Y+7	; 0x07
    2dc2:	98 85       	ldd	r25, Y+8	; 0x08
    2dc4:	80 95       	com	r24
    2dc6:	90 95       	com	r25
    2dc8:	82 23       	and	r24, r18
    2dca:	93 23       	and	r25, r19
    2dcc:	eb 81       	ldd	r30, Y+3	; 0x03
    2dce:	fc 81       	ldd	r31, Y+4	; 0x04
    2dd0:	91 83       	std	Z+1, r25	; 0x01
    2dd2:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    2dd4:	0f 90       	pop	r0
    2dd6:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2dd8:	89 81       	ldd	r24, Y+1	; 0x01
    2dda:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2ddc:	28 96       	adiw	r28, 0x08	; 8
    2dde:	0f b6       	in	r0, 0x3f	; 63
    2de0:	f8 94       	cli
    2de2:	de bf       	out	0x3e, r29	; 62
    2de4:	0f be       	out	0x3f, r0	; 63
    2de6:	cd bf       	out	0x3d, r28	; 61
    2de8:	cf 91       	pop	r28
    2dea:	df 91       	pop	r29
    2dec:	08 95       	ret

00002dee <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    2dee:	df 93       	push	r29
    2df0:	cf 93       	push	r28
    2df2:	cd b7       	in	r28, 0x3d	; 61
    2df4:	de b7       	in	r29, 0x3e	; 62
    2df6:	27 97       	sbiw	r28, 0x07	; 7
    2df8:	0f b6       	in	r0, 0x3f	; 63
    2dfa:	f8 94       	cli
    2dfc:	de bf       	out	0x3e, r29	; 62
    2dfe:	0f be       	out	0x3f, r0	; 63
    2e00:	cd bf       	out	0x3d, r28	; 61
    2e02:	9f 83       	std	Y+7, r25	; 0x07
    2e04:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    2e06:	8e 81       	ldd	r24, Y+6	; 0x06
    2e08:	9f 81       	ldd	r25, Y+7	; 0x07
    2e0a:	9c 83       	std	Y+4, r25	; 0x04
    2e0c:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2e0e:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    2e10:	eb 81       	ldd	r30, Y+3	; 0x03
    2e12:	fc 81       	ldd	r31, Y+4	; 0x04
    2e14:	80 81       	ld	r24, Z
    2e16:	91 81       	ldd	r25, Z+1	; 0x01
    2e18:	9a 83       	std	Y+2, r25	; 0x02
    2e1a:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    2e20:	27 96       	adiw	r28, 0x07	; 7
    2e22:	0f b6       	in	r0, 0x3f	; 63
    2e24:	f8 94       	cli
    2e26:	de bf       	out	0x3e, r29	; 62
    2e28:	0f be       	out	0x3f, r0	; 63
    2e2a:	cd bf       	out	0x3d, r28	; 61
    2e2c:	cf 91       	pop	r28
    2e2e:	df 91       	pop	r29
    2e30:	08 95       	ret

00002e32 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    2e32:	df 93       	push	r29
    2e34:	cf 93       	push	r28
    2e36:	cd b7       	in	r28, 0x3d	; 61
    2e38:	de b7       	in	r29, 0x3e	; 62
    2e3a:	65 97       	sbiw	r28, 0x15	; 21
    2e3c:	0f b6       	in	r0, 0x3f	; 63
    2e3e:	f8 94       	cli
    2e40:	de bf       	out	0x3e, r29	; 62
    2e42:	0f be       	out	0x3f, r0	; 63
    2e44:	cd bf       	out	0x3d, r28	; 61
    2e46:	9b 8b       	std	Y+19, r25	; 0x13
    2e48:	8a 8b       	std	Y+18, r24	; 0x12
    2e4a:	7d 8b       	std	Y+21, r23	; 0x15
    2e4c:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    2e4e:	19 86       	std	Y+9, r1	; 0x09
    2e50:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    2e52:	8a 89       	ldd	r24, Y+18	; 0x12
    2e54:	9b 89       	ldd	r25, Y+19	; 0x13
    2e56:	9b 83       	std	Y+3, r25	; 0x03
    2e58:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    2e5a:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    2e5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e5e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e60:	02 96       	adiw	r24, 0x02	; 2
    2e62:	9b 87       	std	Y+11, r25	; 0x0b
    2e64:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2e66:	8a 85       	ldd	r24, Y+10	; 0x0a
    2e68:	9b 85       	ldd	r25, Y+11	; 0x0b
    2e6a:	03 96       	adiw	r24, 0x03	; 3
    2e6c:	9d 87       	std	Y+13, r25	; 0x0d
    2e6e:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    2e70:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    2e74:	ea 85       	ldd	r30, Y+10	; 0x0a
    2e76:	fb 85       	ldd	r31, Y+11	; 0x0b
    2e78:	85 81       	ldd	r24, Z+5	; 0x05
    2e7a:	96 81       	ldd	r25, Z+6	; 0x06
    2e7c:	99 8b       	std	Y+17, r25	; 0x11
    2e7e:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    2e80:	ea 81       	ldd	r30, Y+2	; 0x02
    2e82:	fb 81       	ldd	r31, Y+3	; 0x03
    2e84:	20 81       	ld	r18, Z
    2e86:	31 81       	ldd	r19, Z+1	; 0x01
    2e88:	8c 89       	ldd	r24, Y+20	; 0x14
    2e8a:	9d 89       	ldd	r25, Y+21	; 0x15
    2e8c:	82 2b       	or	r24, r18
    2e8e:	93 2b       	or	r25, r19
    2e90:	ea 81       	ldd	r30, Y+2	; 0x02
    2e92:	fb 81       	ldd	r31, Y+3	; 0x03
    2e94:	91 83       	std	Z+1, r25	; 0x01
    2e96:	80 83       	st	Z, r24
    2e98:	59 c0       	rjmp	.+178    	; 0x2f4c <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    2e9a:	e8 89       	ldd	r30, Y+16	; 0x10
    2e9c:	f9 89       	ldd	r31, Y+17	; 0x11
    2e9e:	82 81       	ldd	r24, Z+2	; 0x02
    2ea0:	93 81       	ldd	r25, Z+3	; 0x03
    2ea2:	9f 87       	std	Y+15, r25	; 0x0f
    2ea4:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    2ea6:	e8 89       	ldd	r30, Y+16	; 0x10
    2ea8:	f9 89       	ldd	r31, Y+17	; 0x11
    2eaa:	80 81       	ld	r24, Z
    2eac:	91 81       	ldd	r25, Z+1	; 0x01
    2eae:	9f 83       	std	Y+7, r25	; 0x07
    2eb0:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    2eb2:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    2eb4:	8e 81       	ldd	r24, Y+6	; 0x06
    2eb6:	9f 81       	ldd	r25, Y+7	; 0x07
    2eb8:	80 70       	andi	r24, 0x00	; 0
    2eba:	9d 83       	std	Y+5, r25	; 0x05
    2ebc:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    2ebe:	8e 81       	ldd	r24, Y+6	; 0x06
    2ec0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ec2:	90 70       	andi	r25, 0x00	; 0
    2ec4:	9f 83       	std	Y+7, r25	; 0x07
    2ec6:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    2ec8:	8c 81       	ldd	r24, Y+4	; 0x04
    2eca:	9d 81       	ldd	r25, Y+5	; 0x05
    2ecc:	80 70       	andi	r24, 0x00	; 0
    2ece:	94 70       	andi	r25, 0x04	; 4
    2ed0:	00 97       	sbiw	r24, 0x00	; 0
    2ed2:	69 f4       	brne	.+26     	; 0x2eee <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    2ed4:	ea 81       	ldd	r30, Y+2	; 0x02
    2ed6:	fb 81       	ldd	r31, Y+3	; 0x03
    2ed8:	20 81       	ld	r18, Z
    2eda:	31 81       	ldd	r19, Z+1	; 0x01
    2edc:	8e 81       	ldd	r24, Y+6	; 0x06
    2ede:	9f 81       	ldd	r25, Y+7	; 0x07
    2ee0:	82 23       	and	r24, r18
    2ee2:	93 23       	and	r25, r19
    2ee4:	00 97       	sbiw	r24, 0x00	; 0
    2ee6:	91 f0       	breq	.+36     	; 0x2f0c <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    2ee8:	81 e0       	ldi	r24, 0x01	; 1
    2eea:	89 83       	std	Y+1, r24	; 0x01
    2eec:	0f c0       	rjmp	.+30     	; 0x2f0c <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    2eee:	ea 81       	ldd	r30, Y+2	; 0x02
    2ef0:	fb 81       	ldd	r31, Y+3	; 0x03
    2ef2:	20 81       	ld	r18, Z
    2ef4:	31 81       	ldd	r19, Z+1	; 0x01
    2ef6:	8e 81       	ldd	r24, Y+6	; 0x06
    2ef8:	9f 81       	ldd	r25, Y+7	; 0x07
    2efa:	28 23       	and	r18, r24
    2efc:	39 23       	and	r19, r25
    2efe:	8e 81       	ldd	r24, Y+6	; 0x06
    2f00:	9f 81       	ldd	r25, Y+7	; 0x07
    2f02:	28 17       	cp	r18, r24
    2f04:	39 07       	cpc	r19, r25
    2f06:	11 f4       	brne	.+4      	; 0x2f0c <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    2f08:	81 e0       	ldi	r24, 0x01	; 1
    2f0a:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    2f0c:	89 81       	ldd	r24, Y+1	; 0x01
    2f0e:	88 23       	and	r24, r24
    2f10:	c9 f0       	breq	.+50     	; 0x2f44 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    2f12:	8c 81       	ldd	r24, Y+4	; 0x04
    2f14:	9d 81       	ldd	r25, Y+5	; 0x05
    2f16:	80 70       	andi	r24, 0x00	; 0
    2f18:	91 70       	andi	r25, 0x01	; 1
    2f1a:	00 97       	sbiw	r24, 0x00	; 0
    2f1c:	41 f0       	breq	.+16     	; 0x2f2e <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    2f1e:	88 85       	ldd	r24, Y+8	; 0x08
    2f20:	99 85       	ldd	r25, Y+9	; 0x09
    2f22:	2e 81       	ldd	r18, Y+6	; 0x06
    2f24:	3f 81       	ldd	r19, Y+7	; 0x07
    2f26:	82 2b       	or	r24, r18
    2f28:	93 2b       	or	r25, r19
    2f2a:	99 87       	std	Y+9, r25	; 0x09
    2f2c:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    2f2e:	ea 81       	ldd	r30, Y+2	; 0x02
    2f30:	fb 81       	ldd	r31, Y+3	; 0x03
    2f32:	80 81       	ld	r24, Z
    2f34:	91 81       	ldd	r25, Z+1	; 0x01
    2f36:	9c 01       	movw	r18, r24
    2f38:	32 60       	ori	r19, 0x02	; 2
    2f3a:	88 89       	ldd	r24, Y+16	; 0x10
    2f3c:	99 89       	ldd	r25, Y+17	; 0x11
    2f3e:	b9 01       	movw	r22, r18
    2f40:	0e 94 56 2e 	call	0x5cac	; 0x5cac <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    2f44:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f46:	9f 85       	ldd	r25, Y+15	; 0x0f
    2f48:	99 8b       	std	Y+17, r25	; 0x11
    2f4a:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    2f4c:	28 89       	ldd	r18, Y+16	; 0x10
    2f4e:	39 89       	ldd	r19, Y+17	; 0x11
    2f50:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f52:	9d 85       	ldd	r25, Y+13	; 0x0d
    2f54:	28 17       	cp	r18, r24
    2f56:	39 07       	cpc	r19, r25
    2f58:	09 f0       	breq	.+2      	; 0x2f5c <xEventGroupSetBits+0x12a>
    2f5a:	9f cf       	rjmp	.-194    	; 0x2e9a <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    2f5c:	ea 81       	ldd	r30, Y+2	; 0x02
    2f5e:	fb 81       	ldd	r31, Y+3	; 0x03
    2f60:	20 81       	ld	r18, Z
    2f62:	31 81       	ldd	r19, Z+1	; 0x01
    2f64:	88 85       	ldd	r24, Y+8	; 0x08
    2f66:	99 85       	ldd	r25, Y+9	; 0x09
    2f68:	80 95       	com	r24
    2f6a:	90 95       	com	r25
    2f6c:	82 23       	and	r24, r18
    2f6e:	93 23       	and	r25, r19
    2f70:	ea 81       	ldd	r30, Y+2	; 0x02
    2f72:	fb 81       	ldd	r31, Y+3	; 0x03
    2f74:	91 83       	std	Z+1, r25	; 0x01
    2f76:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    2f78:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    2f7c:	ea 81       	ldd	r30, Y+2	; 0x02
    2f7e:	fb 81       	ldd	r31, Y+3	; 0x03
    2f80:	80 81       	ld	r24, Z
    2f82:	91 81       	ldd	r25, Z+1	; 0x01
}
    2f84:	65 96       	adiw	r28, 0x15	; 21
    2f86:	0f b6       	in	r0, 0x3f	; 63
    2f88:	f8 94       	cli
    2f8a:	de bf       	out	0x3e, r29	; 62
    2f8c:	0f be       	out	0x3f, r0	; 63
    2f8e:	cd bf       	out	0x3d, r28	; 61
    2f90:	cf 91       	pop	r28
    2f92:	df 91       	pop	r29
    2f94:	08 95       	ret

00002f96 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    2f96:	df 93       	push	r29
    2f98:	cf 93       	push	r28
    2f9a:	00 d0       	rcall	.+0      	; 0x2f9c <vEventGroupDelete+0x6>
    2f9c:	00 d0       	rcall	.+0      	; 0x2f9e <vEventGroupDelete+0x8>
    2f9e:	00 d0       	rcall	.+0      	; 0x2fa0 <vEventGroupDelete+0xa>
    2fa0:	cd b7       	in	r28, 0x3d	; 61
    2fa2:	de b7       	in	r29, 0x3e	; 62
    2fa4:	9e 83       	std	Y+6, r25	; 0x06
    2fa6:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    2fa8:	8d 81       	ldd	r24, Y+5	; 0x05
    2faa:	9e 81       	ldd	r25, Y+6	; 0x06
    2fac:	9c 83       	std	Y+4, r25	; 0x04
    2fae:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    2fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb4:	02 96       	adiw	r24, 0x02	; 2
    2fb6:	9a 83       	std	Y+2, r25	; 0x02
    2fb8:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    2fba:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
    2fbe:	08 c0       	rjmp	.+16     	; 0x2fd0 <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    2fc0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fc2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fc4:	85 81       	ldd	r24, Z+5	; 0x05
    2fc6:	96 81       	ldd	r25, Z+6	; 0x06
    2fc8:	60 e0       	ldi	r22, 0x00	; 0
    2fca:	72 e0       	ldi	r23, 0x02	; 2
    2fcc:	0e 94 56 2e 	call	0x5cac	; 0x5cac <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    2fd0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fd2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd4:	80 81       	ld	r24, Z
    2fd6:	88 23       	and	r24, r24
    2fd8:	99 f7       	brne	.-26     	; 0x2fc0 <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    2fda:	8b 81       	ldd	r24, Y+3	; 0x03
    2fdc:	9c 81       	ldd	r25, Y+4	; 0x04
    2fde:	0e 94 be 18 	call	0x317c	; 0x317c <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    2fe2:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
}
    2fe6:	26 96       	adiw	r28, 0x06	; 6
    2fe8:	0f b6       	in	r0, 0x3f	; 63
    2fea:	f8 94       	cli
    2fec:	de bf       	out	0x3e, r29	; 62
    2fee:	0f be       	out	0x3f, r0	; 63
    2ff0:	cd bf       	out	0x3d, r28	; 61
    2ff2:	cf 91       	pop	r28
    2ff4:	df 91       	pop	r29
    2ff6:	08 95       	ret

00002ff8 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    2ff8:	df 93       	push	r29
    2ffa:	cf 93       	push	r28
    2ffc:	00 d0       	rcall	.+0      	; 0x2ffe <vEventGroupSetBitsCallback+0x6>
    2ffe:	00 d0       	rcall	.+0      	; 0x3000 <vEventGroupSetBitsCallback+0x8>
    3000:	00 d0       	rcall	.+0      	; 0x3002 <vEventGroupSetBitsCallback+0xa>
    3002:	cd b7       	in	r28, 0x3d	; 61
    3004:	de b7       	in	r29, 0x3e	; 62
    3006:	9a 83       	std	Y+2, r25	; 0x02
    3008:	89 83       	std	Y+1, r24	; 0x01
    300a:	4b 83       	std	Y+3, r20	; 0x03
    300c:	5c 83       	std	Y+4, r21	; 0x04
    300e:	6d 83       	std	Y+5, r22	; 0x05
    3010:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    3012:	89 81       	ldd	r24, Y+1	; 0x01
    3014:	9a 81       	ldd	r25, Y+2	; 0x02
    3016:	2b 81       	ldd	r18, Y+3	; 0x03
    3018:	3c 81       	ldd	r19, Y+4	; 0x04
    301a:	b9 01       	movw	r22, r18
    301c:	0e 94 19 17 	call	0x2e32	; 0x2e32 <xEventGroupSetBits>
}
    3020:	26 96       	adiw	r28, 0x06	; 6
    3022:	0f b6       	in	r0, 0x3f	; 63
    3024:	f8 94       	cli
    3026:	de bf       	out	0x3e, r29	; 62
    3028:	0f be       	out	0x3f, r0	; 63
    302a:	cd bf       	out	0x3d, r28	; 61
    302c:	cf 91       	pop	r28
    302e:	df 91       	pop	r29
    3030:	08 95       	ret

00003032 <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    3032:	df 93       	push	r29
    3034:	cf 93       	push	r28
    3036:	00 d0       	rcall	.+0      	; 0x3038 <vEventGroupClearBitsCallback+0x6>
    3038:	00 d0       	rcall	.+0      	; 0x303a <vEventGroupClearBitsCallback+0x8>
    303a:	00 d0       	rcall	.+0      	; 0x303c <vEventGroupClearBitsCallback+0xa>
    303c:	cd b7       	in	r28, 0x3d	; 61
    303e:	de b7       	in	r29, 0x3e	; 62
    3040:	9a 83       	std	Y+2, r25	; 0x02
    3042:	89 83       	std	Y+1, r24	; 0x01
    3044:	4b 83       	std	Y+3, r20	; 0x03
    3046:	5c 83       	std	Y+4, r21	; 0x04
    3048:	6d 83       	std	Y+5, r22	; 0x05
    304a:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    304c:	89 81       	ldd	r24, Y+1	; 0x01
    304e:	9a 81       	ldd	r25, Y+2	; 0x02
    3050:	2b 81       	ldd	r18, Y+3	; 0x03
    3052:	3c 81       	ldd	r19, Y+4	; 0x04
    3054:	b9 01       	movw	r22, r18
    3056:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <xEventGroupClearBits>
}
    305a:	26 96       	adiw	r28, 0x06	; 6
    305c:	0f b6       	in	r0, 0x3f	; 63
    305e:	f8 94       	cli
    3060:	de bf       	out	0x3e, r29	; 62
    3062:	0f be       	out	0x3f, r0	; 63
    3064:	cd bf       	out	0x3d, r28	; 61
    3066:	cf 91       	pop	r28
    3068:	df 91       	pop	r29
    306a:	08 95       	ret

0000306c <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    306c:	df 93       	push	r29
    306e:	cf 93       	push	r28
    3070:	00 d0       	rcall	.+0      	; 0x3072 <prvTestWaitCondition+0x6>
    3072:	00 d0       	rcall	.+0      	; 0x3074 <prvTestWaitCondition+0x8>
    3074:	00 d0       	rcall	.+0      	; 0x3076 <prvTestWaitCondition+0xa>
    3076:	cd b7       	in	r28, 0x3d	; 61
    3078:	de b7       	in	r29, 0x3e	; 62
    307a:	9b 83       	std	Y+3, r25	; 0x03
    307c:	8a 83       	std	Y+2, r24	; 0x02
    307e:	7d 83       	std	Y+5, r23	; 0x05
    3080:	6c 83       	std	Y+4, r22	; 0x04
    3082:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    3084:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    3086:	8e 81       	ldd	r24, Y+6	; 0x06
    3088:	88 23       	and	r24, r24
    308a:	59 f4       	brne	.+22     	; 0x30a2 <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    308c:	8a 81       	ldd	r24, Y+2	; 0x02
    308e:	9b 81       	ldd	r25, Y+3	; 0x03
    3090:	2c 81       	ldd	r18, Y+4	; 0x04
    3092:	3d 81       	ldd	r19, Y+5	; 0x05
    3094:	82 23       	and	r24, r18
    3096:	93 23       	and	r25, r19
    3098:	00 97       	sbiw	r24, 0x00	; 0
    309a:	81 f0       	breq	.+32     	; 0x30bc <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    309c:	81 e0       	ldi	r24, 0x01	; 1
    309e:	89 83       	std	Y+1, r24	; 0x01
    30a0:	0d c0       	rjmp	.+26     	; 0x30bc <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    30a2:	2a 81       	ldd	r18, Y+2	; 0x02
    30a4:	3b 81       	ldd	r19, Y+3	; 0x03
    30a6:	8c 81       	ldd	r24, Y+4	; 0x04
    30a8:	9d 81       	ldd	r25, Y+5	; 0x05
    30aa:	28 23       	and	r18, r24
    30ac:	39 23       	and	r19, r25
    30ae:	8c 81       	ldd	r24, Y+4	; 0x04
    30b0:	9d 81       	ldd	r25, Y+5	; 0x05
    30b2:	28 17       	cp	r18, r24
    30b4:	39 07       	cpc	r19, r25
    30b6:	11 f4       	brne	.+4      	; 0x30bc <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    30b8:	81 e0       	ldi	r24, 0x01	; 1
    30ba:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    30bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    30be:	26 96       	adiw	r28, 0x06	; 6
    30c0:	0f b6       	in	r0, 0x3f	; 63
    30c2:	f8 94       	cli
    30c4:	de bf       	out	0x3e, r29	; 62
    30c6:	0f be       	out	0x3f, r0	; 63
    30c8:	cd bf       	out	0x3d, r28	; 61
    30ca:	cf 91       	pop	r28
    30cc:	df 91       	pop	r29
    30ce:	08 95       	ret

000030d0 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    30d0:	df 93       	push	r29
    30d2:	cf 93       	push	r28
    30d4:	00 d0       	rcall	.+0      	; 0x30d6 <pvPortMalloc+0x6>
    30d6:	00 d0       	rcall	.+0      	; 0x30d8 <pvPortMalloc+0x8>
    30d8:	cd b7       	in	r28, 0x3d	; 61
    30da:	de b7       	in	r29, 0x3e	; 62
    30dc:	9c 83       	std	Y+4, r25	; 0x04
    30de:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    30e0:	1a 82       	std	Y+2, r1	; 0x02
    30e2:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    30e4:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    30e8:	80 91 92 00 	lds	r24, 0x0092
    30ec:	90 91 93 00 	lds	r25, 0x0093
    30f0:	00 97       	sbiw	r24, 0x00	; 0
    30f2:	31 f4       	brne	.+12     	; 0x3100 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    30f4:	85 e9       	ldi	r24, 0x95	; 149
    30f6:	90 e0       	ldi	r25, 0x00	; 0
    30f8:	90 93 93 00 	sts	0x0093, r25
    30fc:	80 93 92 00 	sts	0x0092, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    3100:	80 91 90 00 	lds	r24, 0x0090
    3104:	90 91 91 00 	lds	r25, 0x0091
    3108:	2b 81       	ldd	r18, Y+3	; 0x03
    310a:	3c 81       	ldd	r19, Y+4	; 0x04
    310c:	82 0f       	add	r24, r18
    310e:	93 1f       	adc	r25, r19
    3110:	23 e0       	ldi	r18, 0x03	; 3
    3112:	87 3e       	cpi	r24, 0xE7	; 231
    3114:	92 07       	cpc	r25, r18
    3116:	38 f5       	brcc	.+78     	; 0x3166 <pvPortMalloc+0x96>
    3118:	20 91 90 00 	lds	r18, 0x0090
    311c:	30 91 91 00 	lds	r19, 0x0091
    3120:	8b 81       	ldd	r24, Y+3	; 0x03
    3122:	9c 81       	ldd	r25, Y+4	; 0x04
    3124:	28 0f       	add	r18, r24
    3126:	39 1f       	adc	r19, r25
    3128:	80 91 90 00 	lds	r24, 0x0090
    312c:	90 91 91 00 	lds	r25, 0x0091
    3130:	82 17       	cp	r24, r18
    3132:	93 07       	cpc	r25, r19
    3134:	c0 f4       	brcc	.+48     	; 0x3166 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    3136:	20 91 92 00 	lds	r18, 0x0092
    313a:	30 91 93 00 	lds	r19, 0x0093
    313e:	80 91 90 00 	lds	r24, 0x0090
    3142:	90 91 91 00 	lds	r25, 0x0091
    3146:	82 0f       	add	r24, r18
    3148:	93 1f       	adc	r25, r19
    314a:	9a 83       	std	Y+2, r25	; 0x02
    314c:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    314e:	20 91 90 00 	lds	r18, 0x0090
    3152:	30 91 91 00 	lds	r19, 0x0091
    3156:	8b 81       	ldd	r24, Y+3	; 0x03
    3158:	9c 81       	ldd	r25, Y+4	; 0x04
    315a:	82 0f       	add	r24, r18
    315c:	93 1f       	adc	r25, r19
    315e:	90 93 91 00 	sts	0x0091, r25
    3162:	80 93 90 00 	sts	0x0090, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    3166:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    316a:	89 81       	ldd	r24, Y+1	; 0x01
    316c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    316e:	0f 90       	pop	r0
    3170:	0f 90       	pop	r0
    3172:	0f 90       	pop	r0
    3174:	0f 90       	pop	r0
    3176:	cf 91       	pop	r28
    3178:	df 91       	pop	r29
    317a:	08 95       	ret

0000317c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    317c:	df 93       	push	r29
    317e:	cf 93       	push	r28
    3180:	00 d0       	rcall	.+0      	; 0x3182 <vPortFree+0x6>
    3182:	cd b7       	in	r28, 0x3d	; 61
    3184:	de b7       	in	r29, 0x3e	; 62
    3186:	9a 83       	std	Y+2, r25	; 0x02
    3188:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    318a:	0f 90       	pop	r0
    318c:	0f 90       	pop	r0
    318e:	cf 91       	pop	r28
    3190:	df 91       	pop	r29
    3192:	08 95       	ret

00003194 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    3194:	df 93       	push	r29
    3196:	cf 93       	push	r28
    3198:	cd b7       	in	r28, 0x3d	; 61
    319a:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    319c:	10 92 91 00 	sts	0x0091, r1
    31a0:	10 92 90 00 	sts	0x0090, r1
}
    31a4:	cf 91       	pop	r28
    31a6:	df 91       	pop	r29
    31a8:	08 95       	ret

000031aa <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    31aa:	df 93       	push	r29
    31ac:	cf 93       	push	r28
    31ae:	cd b7       	in	r28, 0x3d	; 61
    31b0:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    31b2:	20 91 90 00 	lds	r18, 0x0090
    31b6:	30 91 91 00 	lds	r19, 0x0091
    31ba:	87 ee       	ldi	r24, 0xE7	; 231
    31bc:	93 e0       	ldi	r25, 0x03	; 3
    31be:	82 1b       	sub	r24, r18
    31c0:	93 0b       	sbc	r25, r19
}
    31c2:	cf 91       	pop	r28
    31c4:	df 91       	pop	r29
    31c6:	08 95       	ret

000031c8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    31c8:	df 93       	push	r29
    31ca:	cf 93       	push	r28
    31cc:	00 d0       	rcall	.+0      	; 0x31ce <vListInitialise+0x6>
    31ce:	cd b7       	in	r28, 0x3d	; 61
    31d0:	de b7       	in	r29, 0x3e	; 62
    31d2:	9a 83       	std	Y+2, r25	; 0x02
    31d4:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    31d6:	89 81       	ldd	r24, Y+1	; 0x01
    31d8:	9a 81       	ldd	r25, Y+2	; 0x02
    31da:	03 96       	adiw	r24, 0x03	; 3
    31dc:	e9 81       	ldd	r30, Y+1	; 0x01
    31de:	fa 81       	ldd	r31, Y+2	; 0x02
    31e0:	92 83       	std	Z+2, r25	; 0x02
    31e2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    31e4:	e9 81       	ldd	r30, Y+1	; 0x01
    31e6:	fa 81       	ldd	r31, Y+2	; 0x02
    31e8:	8f ef       	ldi	r24, 0xFF	; 255
    31ea:	9f ef       	ldi	r25, 0xFF	; 255
    31ec:	94 83       	std	Z+4, r25	; 0x04
    31ee:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    31f0:	89 81       	ldd	r24, Y+1	; 0x01
    31f2:	9a 81       	ldd	r25, Y+2	; 0x02
    31f4:	03 96       	adiw	r24, 0x03	; 3
    31f6:	e9 81       	ldd	r30, Y+1	; 0x01
    31f8:	fa 81       	ldd	r31, Y+2	; 0x02
    31fa:	96 83       	std	Z+6, r25	; 0x06
    31fc:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    31fe:	89 81       	ldd	r24, Y+1	; 0x01
    3200:	9a 81       	ldd	r25, Y+2	; 0x02
    3202:	03 96       	adiw	r24, 0x03	; 3
    3204:	e9 81       	ldd	r30, Y+1	; 0x01
    3206:	fa 81       	ldd	r31, Y+2	; 0x02
    3208:	90 87       	std	Z+8, r25	; 0x08
    320a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    320c:	e9 81       	ldd	r30, Y+1	; 0x01
    320e:	fa 81       	ldd	r31, Y+2	; 0x02
    3210:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    3212:	0f 90       	pop	r0
    3214:	0f 90       	pop	r0
    3216:	cf 91       	pop	r28
    3218:	df 91       	pop	r29
    321a:	08 95       	ret

0000321c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    321c:	df 93       	push	r29
    321e:	cf 93       	push	r28
    3220:	00 d0       	rcall	.+0      	; 0x3222 <vListInitialiseItem+0x6>
    3222:	cd b7       	in	r28, 0x3d	; 61
    3224:	de b7       	in	r29, 0x3e	; 62
    3226:	9a 83       	std	Y+2, r25	; 0x02
    3228:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    322a:	e9 81       	ldd	r30, Y+1	; 0x01
    322c:	fa 81       	ldd	r31, Y+2	; 0x02
    322e:	11 86       	std	Z+9, r1	; 0x09
    3230:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    3232:	0f 90       	pop	r0
    3234:	0f 90       	pop	r0
    3236:	cf 91       	pop	r28
    3238:	df 91       	pop	r29
    323a:	08 95       	ret

0000323c <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    323c:	df 93       	push	r29
    323e:	cf 93       	push	r28
    3240:	00 d0       	rcall	.+0      	; 0x3242 <vListInsertEnd+0x6>
    3242:	00 d0       	rcall	.+0      	; 0x3244 <vListInsertEnd+0x8>
    3244:	00 d0       	rcall	.+0      	; 0x3246 <vListInsertEnd+0xa>
    3246:	cd b7       	in	r28, 0x3d	; 61
    3248:	de b7       	in	r29, 0x3e	; 62
    324a:	9c 83       	std	Y+4, r25	; 0x04
    324c:	8b 83       	std	Y+3, r24	; 0x03
    324e:	7e 83       	std	Y+6, r23	; 0x06
    3250:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    3252:	eb 81       	ldd	r30, Y+3	; 0x03
    3254:	fc 81       	ldd	r31, Y+4	; 0x04
    3256:	81 81       	ldd	r24, Z+1	; 0x01
    3258:	92 81       	ldd	r25, Z+2	; 0x02
    325a:	9a 83       	std	Y+2, r25	; 0x02
    325c:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    325e:	ed 81       	ldd	r30, Y+5	; 0x05
    3260:	fe 81       	ldd	r31, Y+6	; 0x06
    3262:	89 81       	ldd	r24, Y+1	; 0x01
    3264:	9a 81       	ldd	r25, Y+2	; 0x02
    3266:	93 83       	std	Z+3, r25	; 0x03
    3268:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    326a:	e9 81       	ldd	r30, Y+1	; 0x01
    326c:	fa 81       	ldd	r31, Y+2	; 0x02
    326e:	84 81       	ldd	r24, Z+4	; 0x04
    3270:	95 81       	ldd	r25, Z+5	; 0x05
    3272:	ed 81       	ldd	r30, Y+5	; 0x05
    3274:	fe 81       	ldd	r31, Y+6	; 0x06
    3276:	95 83       	std	Z+5, r25	; 0x05
    3278:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    327a:	e9 81       	ldd	r30, Y+1	; 0x01
    327c:	fa 81       	ldd	r31, Y+2	; 0x02
    327e:	04 80       	ldd	r0, Z+4	; 0x04
    3280:	f5 81       	ldd	r31, Z+5	; 0x05
    3282:	e0 2d       	mov	r30, r0
    3284:	8d 81       	ldd	r24, Y+5	; 0x05
    3286:	9e 81       	ldd	r25, Y+6	; 0x06
    3288:	93 83       	std	Z+3, r25	; 0x03
    328a:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    328c:	e9 81       	ldd	r30, Y+1	; 0x01
    328e:	fa 81       	ldd	r31, Y+2	; 0x02
    3290:	8d 81       	ldd	r24, Y+5	; 0x05
    3292:	9e 81       	ldd	r25, Y+6	; 0x06
    3294:	95 83       	std	Z+5, r25	; 0x05
    3296:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    3298:	ed 81       	ldd	r30, Y+5	; 0x05
    329a:	fe 81       	ldd	r31, Y+6	; 0x06
    329c:	8b 81       	ldd	r24, Y+3	; 0x03
    329e:	9c 81       	ldd	r25, Y+4	; 0x04
    32a0:	91 87       	std	Z+9, r25	; 0x09
    32a2:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    32a4:	eb 81       	ldd	r30, Y+3	; 0x03
    32a6:	fc 81       	ldd	r31, Y+4	; 0x04
    32a8:	80 81       	ld	r24, Z
    32aa:	8f 5f       	subi	r24, 0xFF	; 255
    32ac:	eb 81       	ldd	r30, Y+3	; 0x03
    32ae:	fc 81       	ldd	r31, Y+4	; 0x04
    32b0:	80 83       	st	Z, r24
}
    32b2:	26 96       	adiw	r28, 0x06	; 6
    32b4:	0f b6       	in	r0, 0x3f	; 63
    32b6:	f8 94       	cli
    32b8:	de bf       	out	0x3e, r29	; 62
    32ba:	0f be       	out	0x3f, r0	; 63
    32bc:	cd bf       	out	0x3d, r28	; 61
    32be:	cf 91       	pop	r28
    32c0:	df 91       	pop	r29
    32c2:	08 95       	ret

000032c4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    32c4:	df 93       	push	r29
    32c6:	cf 93       	push	r28
    32c8:	cd b7       	in	r28, 0x3d	; 61
    32ca:	de b7       	in	r29, 0x3e	; 62
    32cc:	28 97       	sbiw	r28, 0x08	; 8
    32ce:	0f b6       	in	r0, 0x3f	; 63
    32d0:	f8 94       	cli
    32d2:	de bf       	out	0x3e, r29	; 62
    32d4:	0f be       	out	0x3f, r0	; 63
    32d6:	cd bf       	out	0x3d, r28	; 61
    32d8:	9e 83       	std	Y+6, r25	; 0x06
    32da:	8d 83       	std	Y+5, r24	; 0x05
    32dc:	78 87       	std	Y+8, r23	; 0x08
    32de:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    32e0:	ef 81       	ldd	r30, Y+7	; 0x07
    32e2:	f8 85       	ldd	r31, Y+8	; 0x08
    32e4:	80 81       	ld	r24, Z
    32e6:	91 81       	ldd	r25, Z+1	; 0x01
    32e8:	9a 83       	std	Y+2, r25	; 0x02
    32ea:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    32ec:	89 81       	ldd	r24, Y+1	; 0x01
    32ee:	9a 81       	ldd	r25, Y+2	; 0x02
    32f0:	2f ef       	ldi	r18, 0xFF	; 255
    32f2:	8f 3f       	cpi	r24, 0xFF	; 255
    32f4:	92 07       	cpc	r25, r18
    32f6:	39 f4       	brne	.+14     	; 0x3306 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    32f8:	ed 81       	ldd	r30, Y+5	; 0x05
    32fa:	fe 81       	ldd	r31, Y+6	; 0x06
    32fc:	87 81       	ldd	r24, Z+7	; 0x07
    32fe:	90 85       	ldd	r25, Z+8	; 0x08
    3300:	9c 83       	std	Y+4, r25	; 0x04
    3302:	8b 83       	std	Y+3, r24	; 0x03
    3304:	18 c0       	rjmp	.+48     	; 0x3336 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3306:	8d 81       	ldd	r24, Y+5	; 0x05
    3308:	9e 81       	ldd	r25, Y+6	; 0x06
    330a:	03 96       	adiw	r24, 0x03	; 3
    330c:	9c 83       	std	Y+4, r25	; 0x04
    330e:	8b 83       	std	Y+3, r24	; 0x03
    3310:	06 c0       	rjmp	.+12     	; 0x331e <vListInsert+0x5a>
    3312:	eb 81       	ldd	r30, Y+3	; 0x03
    3314:	fc 81       	ldd	r31, Y+4	; 0x04
    3316:	82 81       	ldd	r24, Z+2	; 0x02
    3318:	93 81       	ldd	r25, Z+3	; 0x03
    331a:	9c 83       	std	Y+4, r25	; 0x04
    331c:	8b 83       	std	Y+3, r24	; 0x03
    331e:	eb 81       	ldd	r30, Y+3	; 0x03
    3320:	fc 81       	ldd	r31, Y+4	; 0x04
    3322:	02 80       	ldd	r0, Z+2	; 0x02
    3324:	f3 81       	ldd	r31, Z+3	; 0x03
    3326:	e0 2d       	mov	r30, r0
    3328:	20 81       	ld	r18, Z
    332a:	31 81       	ldd	r19, Z+1	; 0x01
    332c:	89 81       	ldd	r24, Y+1	; 0x01
    332e:	9a 81       	ldd	r25, Y+2	; 0x02
    3330:	82 17       	cp	r24, r18
    3332:	93 07       	cpc	r25, r19
    3334:	70 f7       	brcc	.-36     	; 0x3312 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    3336:	eb 81       	ldd	r30, Y+3	; 0x03
    3338:	fc 81       	ldd	r31, Y+4	; 0x04
    333a:	82 81       	ldd	r24, Z+2	; 0x02
    333c:	93 81       	ldd	r25, Z+3	; 0x03
    333e:	ef 81       	ldd	r30, Y+7	; 0x07
    3340:	f8 85       	ldd	r31, Y+8	; 0x08
    3342:	93 83       	std	Z+3, r25	; 0x03
    3344:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3346:	ef 81       	ldd	r30, Y+7	; 0x07
    3348:	f8 85       	ldd	r31, Y+8	; 0x08
    334a:	02 80       	ldd	r0, Z+2	; 0x02
    334c:	f3 81       	ldd	r31, Z+3	; 0x03
    334e:	e0 2d       	mov	r30, r0
    3350:	8f 81       	ldd	r24, Y+7	; 0x07
    3352:	98 85       	ldd	r25, Y+8	; 0x08
    3354:	95 83       	std	Z+5, r25	; 0x05
    3356:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    3358:	ef 81       	ldd	r30, Y+7	; 0x07
    335a:	f8 85       	ldd	r31, Y+8	; 0x08
    335c:	8b 81       	ldd	r24, Y+3	; 0x03
    335e:	9c 81       	ldd	r25, Y+4	; 0x04
    3360:	95 83       	std	Z+5, r25	; 0x05
    3362:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    3364:	eb 81       	ldd	r30, Y+3	; 0x03
    3366:	fc 81       	ldd	r31, Y+4	; 0x04
    3368:	8f 81       	ldd	r24, Y+7	; 0x07
    336a:	98 85       	ldd	r25, Y+8	; 0x08
    336c:	93 83       	std	Z+3, r25	; 0x03
    336e:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    3370:	ef 81       	ldd	r30, Y+7	; 0x07
    3372:	f8 85       	ldd	r31, Y+8	; 0x08
    3374:	8d 81       	ldd	r24, Y+5	; 0x05
    3376:	9e 81       	ldd	r25, Y+6	; 0x06
    3378:	91 87       	std	Z+9, r25	; 0x09
    337a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    337c:	ed 81       	ldd	r30, Y+5	; 0x05
    337e:	fe 81       	ldd	r31, Y+6	; 0x06
    3380:	80 81       	ld	r24, Z
    3382:	8f 5f       	subi	r24, 0xFF	; 255
    3384:	ed 81       	ldd	r30, Y+5	; 0x05
    3386:	fe 81       	ldd	r31, Y+6	; 0x06
    3388:	80 83       	st	Z, r24
}
    338a:	28 96       	adiw	r28, 0x08	; 8
    338c:	0f b6       	in	r0, 0x3f	; 63
    338e:	f8 94       	cli
    3390:	de bf       	out	0x3e, r29	; 62
    3392:	0f be       	out	0x3f, r0	; 63
    3394:	cd bf       	out	0x3d, r28	; 61
    3396:	cf 91       	pop	r28
    3398:	df 91       	pop	r29
    339a:	08 95       	ret

0000339c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    339c:	df 93       	push	r29
    339e:	cf 93       	push	r28
    33a0:	00 d0       	rcall	.+0      	; 0x33a2 <uxListRemove+0x6>
    33a2:	00 d0       	rcall	.+0      	; 0x33a4 <uxListRemove+0x8>
    33a4:	cd b7       	in	r28, 0x3d	; 61
    33a6:	de b7       	in	r29, 0x3e	; 62
    33a8:	9c 83       	std	Y+4, r25	; 0x04
    33aa:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    33ac:	eb 81       	ldd	r30, Y+3	; 0x03
    33ae:	fc 81       	ldd	r31, Y+4	; 0x04
    33b0:	80 85       	ldd	r24, Z+8	; 0x08
    33b2:	91 85       	ldd	r25, Z+9	; 0x09
    33b4:	9a 83       	std	Y+2, r25	; 0x02
    33b6:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    33b8:	eb 81       	ldd	r30, Y+3	; 0x03
    33ba:	fc 81       	ldd	r31, Y+4	; 0x04
    33bc:	a2 81       	ldd	r26, Z+2	; 0x02
    33be:	b3 81       	ldd	r27, Z+3	; 0x03
    33c0:	eb 81       	ldd	r30, Y+3	; 0x03
    33c2:	fc 81       	ldd	r31, Y+4	; 0x04
    33c4:	84 81       	ldd	r24, Z+4	; 0x04
    33c6:	95 81       	ldd	r25, Z+5	; 0x05
    33c8:	15 96       	adiw	r26, 0x05	; 5
    33ca:	9c 93       	st	X, r25
    33cc:	8e 93       	st	-X, r24
    33ce:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    33d0:	eb 81       	ldd	r30, Y+3	; 0x03
    33d2:	fc 81       	ldd	r31, Y+4	; 0x04
    33d4:	a4 81       	ldd	r26, Z+4	; 0x04
    33d6:	b5 81       	ldd	r27, Z+5	; 0x05
    33d8:	eb 81       	ldd	r30, Y+3	; 0x03
    33da:	fc 81       	ldd	r31, Y+4	; 0x04
    33dc:	82 81       	ldd	r24, Z+2	; 0x02
    33de:	93 81       	ldd	r25, Z+3	; 0x03
    33e0:	13 96       	adiw	r26, 0x03	; 3
    33e2:	9c 93       	st	X, r25
    33e4:	8e 93       	st	-X, r24
    33e6:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    33e8:	e9 81       	ldd	r30, Y+1	; 0x01
    33ea:	fa 81       	ldd	r31, Y+2	; 0x02
    33ec:	21 81       	ldd	r18, Z+1	; 0x01
    33ee:	32 81       	ldd	r19, Z+2	; 0x02
    33f0:	8b 81       	ldd	r24, Y+3	; 0x03
    33f2:	9c 81       	ldd	r25, Y+4	; 0x04
    33f4:	28 17       	cp	r18, r24
    33f6:	39 07       	cpc	r19, r25
    33f8:	41 f4       	brne	.+16     	; 0x340a <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    33fa:	eb 81       	ldd	r30, Y+3	; 0x03
    33fc:	fc 81       	ldd	r31, Y+4	; 0x04
    33fe:	84 81       	ldd	r24, Z+4	; 0x04
    3400:	95 81       	ldd	r25, Z+5	; 0x05
    3402:	e9 81       	ldd	r30, Y+1	; 0x01
    3404:	fa 81       	ldd	r31, Y+2	; 0x02
    3406:	92 83       	std	Z+2, r25	; 0x02
    3408:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    340a:	eb 81       	ldd	r30, Y+3	; 0x03
    340c:	fc 81       	ldd	r31, Y+4	; 0x04
    340e:	11 86       	std	Z+9, r1	; 0x09
    3410:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    3412:	e9 81       	ldd	r30, Y+1	; 0x01
    3414:	fa 81       	ldd	r31, Y+2	; 0x02
    3416:	80 81       	ld	r24, Z
    3418:	81 50       	subi	r24, 0x01	; 1
    341a:	e9 81       	ldd	r30, Y+1	; 0x01
    341c:	fa 81       	ldd	r31, Y+2	; 0x02
    341e:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    3420:	e9 81       	ldd	r30, Y+1	; 0x01
    3422:	fa 81       	ldd	r31, Y+2	; 0x02
    3424:	80 81       	ld	r24, Z
}
    3426:	0f 90       	pop	r0
    3428:	0f 90       	pop	r0
    342a:	0f 90       	pop	r0
    342c:	0f 90       	pop	r0
    342e:	cf 91       	pop	r28
    3430:	df 91       	pop	r29
    3432:	08 95       	ret

00003434 <main>:

/* Create Semaphore */
xSemaphoreHandle LCD_Semaphore;

int main(void)
{
    3434:	ef 92       	push	r14
    3436:	ff 92       	push	r15
    3438:	0f 93       	push	r16
    343a:	df 93       	push	r29
    343c:	cf 93       	push	r28
    343e:	cd b7       	in	r28, 0x3d	; 61
    3440:	de b7       	in	r29, 0x3e	; 62
	DIO_voidInit();
    3442:	0e 94 4f 06 	call	0xc9e	; 0xc9e <DIO_voidInit>
	LCD_voidInit();
    3446:	0e 94 c7 0a 	call	0x158e	; 0x158e <LCD_voidInit>
	/* Create Tasks */
	//	xTaskCreate(&App_voidLCD1,NULL,512,NULL,2,NULL);
	//	xTaskCreate(&App_voidLCD2,NULL,512,NULL,4,NULL);
	/* Create Tasks */
	if (xTaskCreate(&App_voidLCD1, "LCD1", 200, NULL, 3, NULL) != pdPASS) {
    344a:	80 e7       	ldi	r24, 0x70	; 112
    344c:	9a e1       	ldi	r25, 0x1A	; 26
    344e:	20 e6       	ldi	r18, 0x60	; 96
    3450:	30 e0       	ldi	r19, 0x00	; 0
    3452:	b9 01       	movw	r22, r18
    3454:	48 ec       	ldi	r20, 0xC8	; 200
    3456:	50 e0       	ldi	r21, 0x00	; 0
    3458:	20 e0       	ldi	r18, 0x00	; 0
    345a:	30 e0       	ldi	r19, 0x00	; 0
    345c:	03 e0       	ldi	r16, 0x03	; 3
    345e:	ee 24       	eor	r14, r14
    3460:	ff 24       	eor	r15, r15
    3462:	0e 94 a0 25 	call	0x4b40	; 0x4b40 <xTaskCreate>
    3466:	81 30       	cpi	r24, 0x01	; 1
    3468:	39 f0       	breq	.+14     	; 0x3478 <main+0x44>
		// Handle task creation failure
		LCD_voidWriteNumber(1);
    346a:	61 e0       	ldi	r22, 0x01	; 1
    346c:	70 e0       	ldi	r23, 0x00	; 0
    346e:	80 e0       	ldi	r24, 0x00	; 0
    3470:	90 e0       	ldi	r25, 0x00	; 0
    3472:	0e 94 f6 10 	call	0x21ec	; 0x21ec <LCD_voidWriteNumber>
    3476:	ff cf       	rjmp	.-2      	; 0x3476 <main+0x42>
		while(1);
	}
	if (xTaskCreate(&App_voidLCD2, "LCD2", 200, NULL, 3, NULL) != pdPASS) {
    3478:	8e e0       	ldi	r24, 0x0E	; 14
    347a:	9b e1       	ldi	r25, 0x1B	; 27
    347c:	25 e6       	ldi	r18, 0x65	; 101
    347e:	30 e0       	ldi	r19, 0x00	; 0
    3480:	b9 01       	movw	r22, r18
    3482:	48 ec       	ldi	r20, 0xC8	; 200
    3484:	50 e0       	ldi	r21, 0x00	; 0
    3486:	20 e0       	ldi	r18, 0x00	; 0
    3488:	30 e0       	ldi	r19, 0x00	; 0
    348a:	03 e0       	ldi	r16, 0x03	; 3
    348c:	ee 24       	eor	r14, r14
    348e:	ff 24       	eor	r15, r15
    3490:	0e 94 a0 25 	call	0x4b40	; 0x4b40 <xTaskCreate>
    3494:	81 30       	cpi	r24, 0x01	; 1
    3496:	39 f0       	breq	.+14     	; 0x34a6 <main+0x72>
		// Handle task creation failure
		LCD_voidWriteNumber(2);
    3498:	62 e0       	ldi	r22, 0x02	; 2
    349a:	70 e0       	ldi	r23, 0x00	; 0
    349c:	80 e0       	ldi	r24, 0x00	; 0
    349e:	90 e0       	ldi	r25, 0x00	; 0
    34a0:	0e 94 f6 10 	call	0x21ec	; 0x21ec <LCD_voidWriteNumber>
    34a4:	ff cf       	rjmp	.-2      	; 0x34a4 <main+0x70>
		while(1);
	}
	/* Create Semaphore */
	vSemaphoreCreateBinary(LCD_Semaphore);
    34a6:	81 e0       	ldi	r24, 0x01	; 1
    34a8:	60 e0       	ldi	r22, 0x00	; 0
    34aa:	43 e0       	ldi	r20, 0x03	; 3
    34ac:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <xQueueGenericCreate>
    34b0:	90 93 ed 04 	sts	0x04ED, r25
    34b4:	80 93 ec 04 	sts	0x04EC, r24
    34b8:	80 91 ec 04 	lds	r24, 0x04EC
    34bc:	90 91 ed 04 	lds	r25, 0x04ED
    34c0:	00 97       	sbiw	r24, 0x00	; 0
    34c2:	59 f0       	breq	.+22     	; 0x34da <main+0xa6>
    34c4:	80 91 ec 04 	lds	r24, 0x04EC
    34c8:	90 91 ed 04 	lds	r25, 0x04ED
    34cc:	60 e0       	ldi	r22, 0x00	; 0
    34ce:	70 e0       	ldi	r23, 0x00	; 0
    34d0:	40 e0       	ldi	r20, 0x00	; 0
    34d2:	50 e0       	ldi	r21, 0x00	; 0
    34d4:	20 e0       	ldi	r18, 0x00	; 0
    34d6:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <xQueueGenericSend>

	//	LCD_Semaphore = xSemaphoreCreateCounting(1,1);

	/* Start Scheduler */
	vTaskStartScheduler();
    34da:	0e 94 dd 2a 	call	0x55ba	; 0x55ba <vTaskStartScheduler>
    34de:	ff cf       	rjmp	.-2      	; 0x34de <main+0xaa>

000034e0 <App_voidLCD1>:

	return 0;
}

void App_voidLCD1(void * Copy_pv)
{
    34e0:	df 93       	push	r29
    34e2:	cf 93       	push	r28
    34e4:	cd b7       	in	r28, 0x3d	; 61
    34e6:	de b7       	in	r29, 0x3e	; 62
    34e8:	60 97       	sbiw	r28, 0x10	; 16
    34ea:	0f b6       	in	r0, 0x3f	; 63
    34ec:	f8 94       	cli
    34ee:	de bf       	out	0x3e, r29	; 62
    34f0:	0f be       	out	0x3f, r0	; 63
    34f2:	cd bf       	out	0x3d, r28	; 61
    34f4:	98 8b       	std	Y+16, r25	; 0x10
    34f6:	8f 87       	std	Y+15, r24	; 0x0f
	while(1)
	{
		/* Take Semaphore */
		if(xSemaphoreTake(LCD_Semaphore,portMAX_DELAY) == pdTRUE)
    34f8:	80 91 ec 04 	lds	r24, 0x04EC
    34fc:	90 91 ed 04 	lds	r25, 0x04ED
    3500:	6f ef       	ldi	r22, 0xFF	; 255
    3502:	7f ef       	ldi	r23, 0xFF	; 255
    3504:	0e 94 90 21 	call	0x4320	; 0x4320 <xQueueSemaphoreTake>
    3508:	81 30       	cpi	r24, 0x01	; 1
    350a:	b1 f7       	brne	.-20     	; 0x34f8 <App_voidLCD1+0x18>
		{
			LCD_voidWriteString((u8*)"I am TASK 1");
    350c:	8a e6       	ldi	r24, 0x6A	; 106
    350e:	90 e0       	ldi	r25, 0x00	; 0
    3510:	0e 94 da 10 	call	0x21b4	; 0x21b4 <LCD_voidWriteString>
    3514:	80 e0       	ldi	r24, 0x00	; 0
    3516:	90 e0       	ldi	r25, 0x00	; 0
    3518:	a8 e4       	ldi	r26, 0x48	; 72
    351a:	b4 e4       	ldi	r27, 0x44	; 68
    351c:	8b 87       	std	Y+11, r24	; 0x0b
    351e:	9c 87       	std	Y+12, r25	; 0x0c
    3520:	ad 87       	std	Y+13, r26	; 0x0d
    3522:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3524:	6b 85       	ldd	r22, Y+11	; 0x0b
    3526:	7c 85       	ldd	r23, Y+12	; 0x0c
    3528:	8d 85       	ldd	r24, Y+13	; 0x0d
    352a:	9e 85       	ldd	r25, Y+14	; 0x0e
    352c:	20 e0       	ldi	r18, 0x00	; 0
    352e:	30 e0       	ldi	r19, 0x00	; 0
    3530:	4a ef       	ldi	r20, 0xFA	; 250
    3532:	54 e4       	ldi	r21, 0x44	; 68
    3534:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3538:	dc 01       	movw	r26, r24
    353a:	cb 01       	movw	r24, r22
    353c:	8f 83       	std	Y+7, r24	; 0x07
    353e:	98 87       	std	Y+8, r25	; 0x08
    3540:	a9 87       	std	Y+9, r26	; 0x09
    3542:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3544:	6f 81       	ldd	r22, Y+7	; 0x07
    3546:	78 85       	ldd	r23, Y+8	; 0x08
    3548:	89 85       	ldd	r24, Y+9	; 0x09
    354a:	9a 85       	ldd	r25, Y+10	; 0x0a
    354c:	20 e0       	ldi	r18, 0x00	; 0
    354e:	30 e0       	ldi	r19, 0x00	; 0
    3550:	40 e8       	ldi	r20, 0x80	; 128
    3552:	5f e3       	ldi	r21, 0x3F	; 63
    3554:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3558:	88 23       	and	r24, r24
    355a:	2c f4       	brge	.+10     	; 0x3566 <App_voidLCD1+0x86>
		__ticks = 1;
    355c:	81 e0       	ldi	r24, 0x01	; 1
    355e:	90 e0       	ldi	r25, 0x00	; 0
    3560:	9e 83       	std	Y+6, r25	; 0x06
    3562:	8d 83       	std	Y+5, r24	; 0x05
    3564:	3f c0       	rjmp	.+126    	; 0x35e4 <App_voidLCD1+0x104>
	else if (__tmp > 65535)
    3566:	6f 81       	ldd	r22, Y+7	; 0x07
    3568:	78 85       	ldd	r23, Y+8	; 0x08
    356a:	89 85       	ldd	r24, Y+9	; 0x09
    356c:	9a 85       	ldd	r25, Y+10	; 0x0a
    356e:	20 e0       	ldi	r18, 0x00	; 0
    3570:	3f ef       	ldi	r19, 0xFF	; 255
    3572:	4f e7       	ldi	r20, 0x7F	; 127
    3574:	57 e4       	ldi	r21, 0x47	; 71
    3576:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    357a:	18 16       	cp	r1, r24
    357c:	4c f5       	brge	.+82     	; 0x35d0 <App_voidLCD1+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    357e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3580:	7c 85       	ldd	r23, Y+12	; 0x0c
    3582:	8d 85       	ldd	r24, Y+13	; 0x0d
    3584:	9e 85       	ldd	r25, Y+14	; 0x0e
    3586:	20 e0       	ldi	r18, 0x00	; 0
    3588:	30 e0       	ldi	r19, 0x00	; 0
    358a:	40 e2       	ldi	r20, 0x20	; 32
    358c:	51 e4       	ldi	r21, 0x41	; 65
    358e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3592:	dc 01       	movw	r26, r24
    3594:	cb 01       	movw	r24, r22
    3596:	bc 01       	movw	r22, r24
    3598:	cd 01       	movw	r24, r26
    359a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    359e:	dc 01       	movw	r26, r24
    35a0:	cb 01       	movw	r24, r22
    35a2:	9e 83       	std	Y+6, r25	; 0x06
    35a4:	8d 83       	std	Y+5, r24	; 0x05
    35a6:	0f c0       	rjmp	.+30     	; 0x35c6 <App_voidLCD1+0xe6>
    35a8:	88 ec       	ldi	r24, 0xC8	; 200
    35aa:	90 e0       	ldi	r25, 0x00	; 0
    35ac:	9c 83       	std	Y+4, r25	; 0x04
    35ae:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    35b0:	8b 81       	ldd	r24, Y+3	; 0x03
    35b2:	9c 81       	ldd	r25, Y+4	; 0x04
    35b4:	01 97       	sbiw	r24, 0x01	; 1
    35b6:	f1 f7       	brne	.-4      	; 0x35b4 <App_voidLCD1+0xd4>
    35b8:	9c 83       	std	Y+4, r25	; 0x04
    35ba:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35bc:	8d 81       	ldd	r24, Y+5	; 0x05
    35be:	9e 81       	ldd	r25, Y+6	; 0x06
    35c0:	01 97       	sbiw	r24, 0x01	; 1
    35c2:	9e 83       	std	Y+6, r25	; 0x06
    35c4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35c6:	8d 81       	ldd	r24, Y+5	; 0x05
    35c8:	9e 81       	ldd	r25, Y+6	; 0x06
    35ca:	00 97       	sbiw	r24, 0x00	; 0
    35cc:	69 f7       	brne	.-38     	; 0x35a8 <App_voidLCD1+0xc8>
    35ce:	14 c0       	rjmp	.+40     	; 0x35f8 <App_voidLCD1+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35d0:	6f 81       	ldd	r22, Y+7	; 0x07
    35d2:	78 85       	ldd	r23, Y+8	; 0x08
    35d4:	89 85       	ldd	r24, Y+9	; 0x09
    35d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    35d8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    35dc:	dc 01       	movw	r26, r24
    35de:	cb 01       	movw	r24, r22
    35e0:	9e 83       	std	Y+6, r25	; 0x06
    35e2:	8d 83       	std	Y+5, r24	; 0x05
    35e4:	8d 81       	ldd	r24, Y+5	; 0x05
    35e6:	9e 81       	ldd	r25, Y+6	; 0x06
    35e8:	9a 83       	std	Y+2, r25	; 0x02
    35ea:	89 83       	std	Y+1, r24	; 0x01
    35ec:	89 81       	ldd	r24, Y+1	; 0x01
    35ee:	9a 81       	ldd	r25, Y+2	; 0x02
    35f0:	01 97       	sbiw	r24, 0x01	; 1
    35f2:	f1 f7       	brne	.-4      	; 0x35f0 <App_voidLCD1+0x110>
    35f4:	9a 83       	std	Y+2, r25	; 0x02
    35f6:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(800);
			LCD_voidClearScreen();
    35f8:	0e 94 9f 11 	call	0x233e	; 0x233e <LCD_voidClearScreen>
			xSemaphoreGive(LCD_Semaphore);
    35fc:	80 91 ec 04 	lds	r24, 0x04EC
    3600:	90 91 ed 04 	lds	r25, 0x04ED
    3604:	60 e0       	ldi	r22, 0x00	; 0
    3606:	70 e0       	ldi	r23, 0x00	; 0
    3608:	40 e0       	ldi	r20, 0x00	; 0
    360a:	50 e0       	ldi	r21, 0x00	; 0
    360c:	20 e0       	ldi	r18, 0x00	; 0
    360e:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <xQueueGenericSend>

			vTaskDelay(1000);
    3612:	88 ee       	ldi	r24, 0xE8	; 232
    3614:	93 e0       	ldi	r25, 0x03	; 3
    3616:	0e 94 30 28 	call	0x5060	; 0x5060 <vTaskDelay>
    361a:	6e cf       	rjmp	.-292    	; 0x34f8 <App_voidLCD1+0x18>

0000361c <App_voidLCD2>:
		}

	}
}
void App_voidLCD2(void * Copy_pv)
{
    361c:	df 93       	push	r29
    361e:	cf 93       	push	r28
    3620:	cd b7       	in	r28, 0x3d	; 61
    3622:	de b7       	in	r29, 0x3e	; 62
    3624:	60 97       	sbiw	r28, 0x10	; 16
    3626:	0f b6       	in	r0, 0x3f	; 63
    3628:	f8 94       	cli
    362a:	de bf       	out	0x3e, r29	; 62
    362c:	0f be       	out	0x3f, r0	; 63
    362e:	cd bf       	out	0x3d, r28	; 61
    3630:	98 8b       	std	Y+16, r25	; 0x10
    3632:	8f 87       	std	Y+15, r24	; 0x0f
	while(1)
	{
		/* Take Semaphore */
		if(xSemaphoreTake(LCD_Semaphore,portMAX_DELAY) == pdTRUE)
    3634:	80 91 ec 04 	lds	r24, 0x04EC
    3638:	90 91 ed 04 	lds	r25, 0x04ED
    363c:	6f ef       	ldi	r22, 0xFF	; 255
    363e:	7f ef       	ldi	r23, 0xFF	; 255
    3640:	0e 94 90 21 	call	0x4320	; 0x4320 <xQueueSemaphoreTake>
    3644:	81 30       	cpi	r24, 0x01	; 1
    3646:	b1 f7       	brne	.-20     	; 0x3634 <App_voidLCD2+0x18>
		{
			LCD_voidWriteString((u8*)"I am TASK 2");
    3648:	86 e7       	ldi	r24, 0x76	; 118
    364a:	90 e0       	ldi	r25, 0x00	; 0
    364c:	0e 94 da 10 	call	0x21b4	; 0x21b4 <LCD_voidWriteString>
    3650:	80 e0       	ldi	r24, 0x00	; 0
    3652:	90 e0       	ldi	r25, 0x00	; 0
    3654:	a8 e4       	ldi	r26, 0x48	; 72
    3656:	b4 e4       	ldi	r27, 0x44	; 68
    3658:	8b 87       	std	Y+11, r24	; 0x0b
    365a:	9c 87       	std	Y+12, r25	; 0x0c
    365c:	ad 87       	std	Y+13, r26	; 0x0d
    365e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3660:	6b 85       	ldd	r22, Y+11	; 0x0b
    3662:	7c 85       	ldd	r23, Y+12	; 0x0c
    3664:	8d 85       	ldd	r24, Y+13	; 0x0d
    3666:	9e 85       	ldd	r25, Y+14	; 0x0e
    3668:	20 e0       	ldi	r18, 0x00	; 0
    366a:	30 e0       	ldi	r19, 0x00	; 0
    366c:	4a ef       	ldi	r20, 0xFA	; 250
    366e:	54 e4       	ldi	r21, 0x44	; 68
    3670:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3674:	dc 01       	movw	r26, r24
    3676:	cb 01       	movw	r24, r22
    3678:	8f 83       	std	Y+7, r24	; 0x07
    367a:	98 87       	std	Y+8, r25	; 0x08
    367c:	a9 87       	std	Y+9, r26	; 0x09
    367e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3680:	6f 81       	ldd	r22, Y+7	; 0x07
    3682:	78 85       	ldd	r23, Y+8	; 0x08
    3684:	89 85       	ldd	r24, Y+9	; 0x09
    3686:	9a 85       	ldd	r25, Y+10	; 0x0a
    3688:	20 e0       	ldi	r18, 0x00	; 0
    368a:	30 e0       	ldi	r19, 0x00	; 0
    368c:	40 e8       	ldi	r20, 0x80	; 128
    368e:	5f e3       	ldi	r21, 0x3F	; 63
    3690:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3694:	88 23       	and	r24, r24
    3696:	2c f4       	brge	.+10     	; 0x36a2 <App_voidLCD2+0x86>
		__ticks = 1;
    3698:	81 e0       	ldi	r24, 0x01	; 1
    369a:	90 e0       	ldi	r25, 0x00	; 0
    369c:	9e 83       	std	Y+6, r25	; 0x06
    369e:	8d 83       	std	Y+5, r24	; 0x05
    36a0:	3f c0       	rjmp	.+126    	; 0x3720 <App_voidLCD2+0x104>
	else if (__tmp > 65535)
    36a2:	6f 81       	ldd	r22, Y+7	; 0x07
    36a4:	78 85       	ldd	r23, Y+8	; 0x08
    36a6:	89 85       	ldd	r24, Y+9	; 0x09
    36a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    36aa:	20 e0       	ldi	r18, 0x00	; 0
    36ac:	3f ef       	ldi	r19, 0xFF	; 255
    36ae:	4f e7       	ldi	r20, 0x7F	; 127
    36b0:	57 e4       	ldi	r21, 0x47	; 71
    36b2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    36b6:	18 16       	cp	r1, r24
    36b8:	4c f5       	brge	.+82     	; 0x370c <App_voidLCD2+0xf0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    36ba:	6b 85       	ldd	r22, Y+11	; 0x0b
    36bc:	7c 85       	ldd	r23, Y+12	; 0x0c
    36be:	8d 85       	ldd	r24, Y+13	; 0x0d
    36c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    36c2:	20 e0       	ldi	r18, 0x00	; 0
    36c4:	30 e0       	ldi	r19, 0x00	; 0
    36c6:	40 e2       	ldi	r20, 0x20	; 32
    36c8:	51 e4       	ldi	r21, 0x41	; 65
    36ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    36ce:	dc 01       	movw	r26, r24
    36d0:	cb 01       	movw	r24, r22
    36d2:	bc 01       	movw	r22, r24
    36d4:	cd 01       	movw	r24, r26
    36d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36da:	dc 01       	movw	r26, r24
    36dc:	cb 01       	movw	r24, r22
    36de:	9e 83       	std	Y+6, r25	; 0x06
    36e0:	8d 83       	std	Y+5, r24	; 0x05
    36e2:	0f c0       	rjmp	.+30     	; 0x3702 <App_voidLCD2+0xe6>
    36e4:	88 ec       	ldi	r24, 0xC8	; 200
    36e6:	90 e0       	ldi	r25, 0x00	; 0
    36e8:	9c 83       	std	Y+4, r25	; 0x04
    36ea:	8b 83       	std	Y+3, r24	; 0x03
    36ec:	8b 81       	ldd	r24, Y+3	; 0x03
    36ee:	9c 81       	ldd	r25, Y+4	; 0x04
    36f0:	01 97       	sbiw	r24, 0x01	; 1
    36f2:	f1 f7       	brne	.-4      	; 0x36f0 <App_voidLCD2+0xd4>
    36f4:	9c 83       	std	Y+4, r25	; 0x04
    36f6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    36f8:	8d 81       	ldd	r24, Y+5	; 0x05
    36fa:	9e 81       	ldd	r25, Y+6	; 0x06
    36fc:	01 97       	sbiw	r24, 0x01	; 1
    36fe:	9e 83       	std	Y+6, r25	; 0x06
    3700:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3702:	8d 81       	ldd	r24, Y+5	; 0x05
    3704:	9e 81       	ldd	r25, Y+6	; 0x06
    3706:	00 97       	sbiw	r24, 0x00	; 0
    3708:	69 f7       	brne	.-38     	; 0x36e4 <App_voidLCD2+0xc8>
    370a:	14 c0       	rjmp	.+40     	; 0x3734 <App_voidLCD2+0x118>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    370c:	6f 81       	ldd	r22, Y+7	; 0x07
    370e:	78 85       	ldd	r23, Y+8	; 0x08
    3710:	89 85       	ldd	r24, Y+9	; 0x09
    3712:	9a 85       	ldd	r25, Y+10	; 0x0a
    3714:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3718:	dc 01       	movw	r26, r24
    371a:	cb 01       	movw	r24, r22
    371c:	9e 83       	std	Y+6, r25	; 0x06
    371e:	8d 83       	std	Y+5, r24	; 0x05
    3720:	8d 81       	ldd	r24, Y+5	; 0x05
    3722:	9e 81       	ldd	r25, Y+6	; 0x06
    3724:	9a 83       	std	Y+2, r25	; 0x02
    3726:	89 83       	std	Y+1, r24	; 0x01
    3728:	89 81       	ldd	r24, Y+1	; 0x01
    372a:	9a 81       	ldd	r25, Y+2	; 0x02
    372c:	01 97       	sbiw	r24, 0x01	; 1
    372e:	f1 f7       	brne	.-4      	; 0x372c <App_voidLCD2+0x110>
    3730:	9a 83       	std	Y+2, r25	; 0x02
    3732:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(800);
			LCD_voidClearScreen();
    3734:	0e 94 9f 11 	call	0x233e	; 0x233e <LCD_voidClearScreen>
			xSemaphoreGive(LCD_Semaphore);
    3738:	80 91 ec 04 	lds	r24, 0x04EC
    373c:	90 91 ed 04 	lds	r25, 0x04ED
    3740:	60 e0       	ldi	r22, 0x00	; 0
    3742:	70 e0       	ldi	r23, 0x00	; 0
    3744:	40 e0       	ldi	r20, 0x00	; 0
    3746:	50 e0       	ldi	r21, 0x00	; 0
    3748:	20 e0       	ldi	r18, 0x00	; 0
    374a:	0e 94 8c 1f 	call	0x3f18	; 0x3f18 <xQueueGenericSend>
			vTaskDelay(1000);
    374e:	88 ee       	ldi	r24, 0xE8	; 232
    3750:	93 e0       	ldi	r25, 0x03	; 3
    3752:	0e 94 30 28 	call	0x5060	; 0x5060 <vTaskDelay>
    3756:	6e cf       	rjmp	.-292    	; 0x3634 <App_voidLCD2+0x18>

00003758 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    3758:	df 93       	push	r29
    375a:	cf 93       	push	r28
    375c:	cd b7       	in	r28, 0x3d	; 61
    375e:	de b7       	in	r29, 0x3e	; 62
    3760:	28 97       	sbiw	r28, 0x08	; 8
    3762:	0f b6       	in	r0, 0x3f	; 63
    3764:	f8 94       	cli
    3766:	de bf       	out	0x3e, r29	; 62
    3768:	0f be       	out	0x3f, r0	; 63
    376a:	cd bf       	out	0x3d, r28	; 61
    376c:	9c 83       	std	Y+4, r25	; 0x04
    376e:	8b 83       	std	Y+3, r24	; 0x03
    3770:	7e 83       	std	Y+6, r23	; 0x06
    3772:	6d 83       	std	Y+5, r22	; 0x05
    3774:	58 87       	std	Y+8, r21	; 0x08
    3776:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3778:	eb 81       	ldd	r30, Y+3	; 0x03
    377a:	fc 81       	ldd	r31, Y+4	; 0x04
    377c:	81 e1       	ldi	r24, 0x11	; 17
    377e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3780:	8b 81       	ldd	r24, Y+3	; 0x03
    3782:	9c 81       	ldd	r25, Y+4	; 0x04
    3784:	01 97       	sbiw	r24, 0x01	; 1
    3786:	9c 83       	std	Y+4, r25	; 0x04
    3788:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    378a:	eb 81       	ldd	r30, Y+3	; 0x03
    378c:	fc 81       	ldd	r31, Y+4	; 0x04
    378e:	82 e2       	ldi	r24, 0x22	; 34
    3790:	80 83       	st	Z, r24
	pxTopOfStack--;
    3792:	8b 81       	ldd	r24, Y+3	; 0x03
    3794:	9c 81       	ldd	r25, Y+4	; 0x04
    3796:	01 97       	sbiw	r24, 0x01	; 1
    3798:	9c 83       	std	Y+4, r25	; 0x04
    379a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    379c:	eb 81       	ldd	r30, Y+3	; 0x03
    379e:	fc 81       	ldd	r31, Y+4	; 0x04
    37a0:	83 e3       	ldi	r24, 0x33	; 51
    37a2:	80 83       	st	Z, r24
	pxTopOfStack--;
    37a4:	8b 81       	ldd	r24, Y+3	; 0x03
    37a6:	9c 81       	ldd	r25, Y+4	; 0x04
    37a8:	01 97       	sbiw	r24, 0x01	; 1
    37aa:	9c 83       	std	Y+4, r25	; 0x04
    37ac:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    37ae:	8d 81       	ldd	r24, Y+5	; 0x05
    37b0:	9e 81       	ldd	r25, Y+6	; 0x06
    37b2:	9a 83       	std	Y+2, r25	; 0x02
    37b4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    37b6:	89 81       	ldd	r24, Y+1	; 0x01
    37b8:	eb 81       	ldd	r30, Y+3	; 0x03
    37ba:	fc 81       	ldd	r31, Y+4	; 0x04
    37bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    37be:	8b 81       	ldd	r24, Y+3	; 0x03
    37c0:	9c 81       	ldd	r25, Y+4	; 0x04
    37c2:	01 97       	sbiw	r24, 0x01	; 1
    37c4:	9c 83       	std	Y+4, r25	; 0x04
    37c6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    37c8:	89 81       	ldd	r24, Y+1	; 0x01
    37ca:	9a 81       	ldd	r25, Y+2	; 0x02
    37cc:	89 2f       	mov	r24, r25
    37ce:	99 27       	eor	r25, r25
    37d0:	9a 83       	std	Y+2, r25	; 0x02
    37d2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    37d4:	89 81       	ldd	r24, Y+1	; 0x01
    37d6:	eb 81       	ldd	r30, Y+3	; 0x03
    37d8:	fc 81       	ldd	r31, Y+4	; 0x04
    37da:	80 83       	st	Z, r24
	pxTopOfStack--;
    37dc:	8b 81       	ldd	r24, Y+3	; 0x03
    37de:	9c 81       	ldd	r25, Y+4	; 0x04
    37e0:	01 97       	sbiw	r24, 0x01	; 1
    37e2:	9c 83       	std	Y+4, r25	; 0x04
    37e4:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    37e6:	eb 81       	ldd	r30, Y+3	; 0x03
    37e8:	fc 81       	ldd	r31, Y+4	; 0x04
    37ea:	10 82       	st	Z, r1
	pxTopOfStack--;
    37ec:	8b 81       	ldd	r24, Y+3	; 0x03
    37ee:	9c 81       	ldd	r25, Y+4	; 0x04
    37f0:	01 97       	sbiw	r24, 0x01	; 1
    37f2:	9c 83       	std	Y+4, r25	; 0x04
    37f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    37f6:	eb 81       	ldd	r30, Y+3	; 0x03
    37f8:	fc 81       	ldd	r31, Y+4	; 0x04
    37fa:	80 e8       	ldi	r24, 0x80	; 128
    37fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    37fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3800:	9c 81       	ldd	r25, Y+4	; 0x04
    3802:	01 97       	sbiw	r24, 0x01	; 1
    3804:	9c 83       	std	Y+4, r25	; 0x04
    3806:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3808:	eb 81       	ldd	r30, Y+3	; 0x03
    380a:	fc 81       	ldd	r31, Y+4	; 0x04
    380c:	10 82       	st	Z, r1
	pxTopOfStack--;
    380e:	8b 81       	ldd	r24, Y+3	; 0x03
    3810:	9c 81       	ldd	r25, Y+4	; 0x04
    3812:	01 97       	sbiw	r24, 0x01	; 1
    3814:	9c 83       	std	Y+4, r25	; 0x04
    3816:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3818:	eb 81       	ldd	r30, Y+3	; 0x03
    381a:	fc 81       	ldd	r31, Y+4	; 0x04
    381c:	82 e0       	ldi	r24, 0x02	; 2
    381e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3820:	8b 81       	ldd	r24, Y+3	; 0x03
    3822:	9c 81       	ldd	r25, Y+4	; 0x04
    3824:	01 97       	sbiw	r24, 0x01	; 1
    3826:	9c 83       	std	Y+4, r25	; 0x04
    3828:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    382a:	eb 81       	ldd	r30, Y+3	; 0x03
    382c:	fc 81       	ldd	r31, Y+4	; 0x04
    382e:	83 e0       	ldi	r24, 0x03	; 3
    3830:	80 83       	st	Z, r24
	pxTopOfStack--;
    3832:	8b 81       	ldd	r24, Y+3	; 0x03
    3834:	9c 81       	ldd	r25, Y+4	; 0x04
    3836:	01 97       	sbiw	r24, 0x01	; 1
    3838:	9c 83       	std	Y+4, r25	; 0x04
    383a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    383c:	eb 81       	ldd	r30, Y+3	; 0x03
    383e:	fc 81       	ldd	r31, Y+4	; 0x04
    3840:	84 e0       	ldi	r24, 0x04	; 4
    3842:	80 83       	st	Z, r24
	pxTopOfStack--;
    3844:	8b 81       	ldd	r24, Y+3	; 0x03
    3846:	9c 81       	ldd	r25, Y+4	; 0x04
    3848:	01 97       	sbiw	r24, 0x01	; 1
    384a:	9c 83       	std	Y+4, r25	; 0x04
    384c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    384e:	eb 81       	ldd	r30, Y+3	; 0x03
    3850:	fc 81       	ldd	r31, Y+4	; 0x04
    3852:	85 e0       	ldi	r24, 0x05	; 5
    3854:	80 83       	st	Z, r24
	pxTopOfStack--;
    3856:	8b 81       	ldd	r24, Y+3	; 0x03
    3858:	9c 81       	ldd	r25, Y+4	; 0x04
    385a:	01 97       	sbiw	r24, 0x01	; 1
    385c:	9c 83       	std	Y+4, r25	; 0x04
    385e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    3860:	eb 81       	ldd	r30, Y+3	; 0x03
    3862:	fc 81       	ldd	r31, Y+4	; 0x04
    3864:	86 e0       	ldi	r24, 0x06	; 6
    3866:	80 83       	st	Z, r24
	pxTopOfStack--;
    3868:	8b 81       	ldd	r24, Y+3	; 0x03
    386a:	9c 81       	ldd	r25, Y+4	; 0x04
    386c:	01 97       	sbiw	r24, 0x01	; 1
    386e:	9c 83       	std	Y+4, r25	; 0x04
    3870:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    3872:	eb 81       	ldd	r30, Y+3	; 0x03
    3874:	fc 81       	ldd	r31, Y+4	; 0x04
    3876:	87 e0       	ldi	r24, 0x07	; 7
    3878:	80 83       	st	Z, r24
	pxTopOfStack--;
    387a:	8b 81       	ldd	r24, Y+3	; 0x03
    387c:	9c 81       	ldd	r25, Y+4	; 0x04
    387e:	01 97       	sbiw	r24, 0x01	; 1
    3880:	9c 83       	std	Y+4, r25	; 0x04
    3882:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    3884:	eb 81       	ldd	r30, Y+3	; 0x03
    3886:	fc 81       	ldd	r31, Y+4	; 0x04
    3888:	88 e0       	ldi	r24, 0x08	; 8
    388a:	80 83       	st	Z, r24
	pxTopOfStack--;
    388c:	8b 81       	ldd	r24, Y+3	; 0x03
    388e:	9c 81       	ldd	r25, Y+4	; 0x04
    3890:	01 97       	sbiw	r24, 0x01	; 1
    3892:	9c 83       	std	Y+4, r25	; 0x04
    3894:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3896:	eb 81       	ldd	r30, Y+3	; 0x03
    3898:	fc 81       	ldd	r31, Y+4	; 0x04
    389a:	89 e0       	ldi	r24, 0x09	; 9
    389c:	80 83       	st	Z, r24
	pxTopOfStack--;
    389e:	8b 81       	ldd	r24, Y+3	; 0x03
    38a0:	9c 81       	ldd	r25, Y+4	; 0x04
    38a2:	01 97       	sbiw	r24, 0x01	; 1
    38a4:	9c 83       	std	Y+4, r25	; 0x04
    38a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    38a8:	eb 81       	ldd	r30, Y+3	; 0x03
    38aa:	fc 81       	ldd	r31, Y+4	; 0x04
    38ac:	80 e1       	ldi	r24, 0x10	; 16
    38ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    38b0:	8b 81       	ldd	r24, Y+3	; 0x03
    38b2:	9c 81       	ldd	r25, Y+4	; 0x04
    38b4:	01 97       	sbiw	r24, 0x01	; 1
    38b6:	9c 83       	std	Y+4, r25	; 0x04
    38b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    38ba:	eb 81       	ldd	r30, Y+3	; 0x03
    38bc:	fc 81       	ldd	r31, Y+4	; 0x04
    38be:	81 e1       	ldi	r24, 0x11	; 17
    38c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    38c2:	8b 81       	ldd	r24, Y+3	; 0x03
    38c4:	9c 81       	ldd	r25, Y+4	; 0x04
    38c6:	01 97       	sbiw	r24, 0x01	; 1
    38c8:	9c 83       	std	Y+4, r25	; 0x04
    38ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    38cc:	eb 81       	ldd	r30, Y+3	; 0x03
    38ce:	fc 81       	ldd	r31, Y+4	; 0x04
    38d0:	82 e1       	ldi	r24, 0x12	; 18
    38d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    38d4:	8b 81       	ldd	r24, Y+3	; 0x03
    38d6:	9c 81       	ldd	r25, Y+4	; 0x04
    38d8:	01 97       	sbiw	r24, 0x01	; 1
    38da:	9c 83       	std	Y+4, r25	; 0x04
    38dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    38de:	eb 81       	ldd	r30, Y+3	; 0x03
    38e0:	fc 81       	ldd	r31, Y+4	; 0x04
    38e2:	83 e1       	ldi	r24, 0x13	; 19
    38e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    38e6:	8b 81       	ldd	r24, Y+3	; 0x03
    38e8:	9c 81       	ldd	r25, Y+4	; 0x04
    38ea:	01 97       	sbiw	r24, 0x01	; 1
    38ec:	9c 83       	std	Y+4, r25	; 0x04
    38ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    38f0:	eb 81       	ldd	r30, Y+3	; 0x03
    38f2:	fc 81       	ldd	r31, Y+4	; 0x04
    38f4:	84 e1       	ldi	r24, 0x14	; 20
    38f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    38f8:	8b 81       	ldd	r24, Y+3	; 0x03
    38fa:	9c 81       	ldd	r25, Y+4	; 0x04
    38fc:	01 97       	sbiw	r24, 0x01	; 1
    38fe:	9c 83       	std	Y+4, r25	; 0x04
    3900:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3902:	eb 81       	ldd	r30, Y+3	; 0x03
    3904:	fc 81       	ldd	r31, Y+4	; 0x04
    3906:	85 e1       	ldi	r24, 0x15	; 21
    3908:	80 83       	st	Z, r24
	pxTopOfStack--;
    390a:	8b 81       	ldd	r24, Y+3	; 0x03
    390c:	9c 81       	ldd	r25, Y+4	; 0x04
    390e:	01 97       	sbiw	r24, 0x01	; 1
    3910:	9c 83       	std	Y+4, r25	; 0x04
    3912:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    3914:	eb 81       	ldd	r30, Y+3	; 0x03
    3916:	fc 81       	ldd	r31, Y+4	; 0x04
    3918:	86 e1       	ldi	r24, 0x16	; 22
    391a:	80 83       	st	Z, r24
	pxTopOfStack--;
    391c:	8b 81       	ldd	r24, Y+3	; 0x03
    391e:	9c 81       	ldd	r25, Y+4	; 0x04
    3920:	01 97       	sbiw	r24, 0x01	; 1
    3922:	9c 83       	std	Y+4, r25	; 0x04
    3924:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    3926:	eb 81       	ldd	r30, Y+3	; 0x03
    3928:	fc 81       	ldd	r31, Y+4	; 0x04
    392a:	87 e1       	ldi	r24, 0x17	; 23
    392c:	80 83       	st	Z, r24
	pxTopOfStack--;
    392e:	8b 81       	ldd	r24, Y+3	; 0x03
    3930:	9c 81       	ldd	r25, Y+4	; 0x04
    3932:	01 97       	sbiw	r24, 0x01	; 1
    3934:	9c 83       	std	Y+4, r25	; 0x04
    3936:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    3938:	eb 81       	ldd	r30, Y+3	; 0x03
    393a:	fc 81       	ldd	r31, Y+4	; 0x04
    393c:	88 e1       	ldi	r24, 0x18	; 24
    393e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3940:	8b 81       	ldd	r24, Y+3	; 0x03
    3942:	9c 81       	ldd	r25, Y+4	; 0x04
    3944:	01 97       	sbiw	r24, 0x01	; 1
    3946:	9c 83       	std	Y+4, r25	; 0x04
    3948:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    394a:	eb 81       	ldd	r30, Y+3	; 0x03
    394c:	fc 81       	ldd	r31, Y+4	; 0x04
    394e:	89 e1       	ldi	r24, 0x19	; 25
    3950:	80 83       	st	Z, r24
	pxTopOfStack--;
    3952:	8b 81       	ldd	r24, Y+3	; 0x03
    3954:	9c 81       	ldd	r25, Y+4	; 0x04
    3956:	01 97       	sbiw	r24, 0x01	; 1
    3958:	9c 83       	std	Y+4, r25	; 0x04
    395a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    395c:	eb 81       	ldd	r30, Y+3	; 0x03
    395e:	fc 81       	ldd	r31, Y+4	; 0x04
    3960:	80 e2       	ldi	r24, 0x20	; 32
    3962:	80 83       	st	Z, r24
	pxTopOfStack--;
    3964:	8b 81       	ldd	r24, Y+3	; 0x03
    3966:	9c 81       	ldd	r25, Y+4	; 0x04
    3968:	01 97       	sbiw	r24, 0x01	; 1
    396a:	9c 83       	std	Y+4, r25	; 0x04
    396c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    396e:	eb 81       	ldd	r30, Y+3	; 0x03
    3970:	fc 81       	ldd	r31, Y+4	; 0x04
    3972:	81 e2       	ldi	r24, 0x21	; 33
    3974:	80 83       	st	Z, r24
	pxTopOfStack--;
    3976:	8b 81       	ldd	r24, Y+3	; 0x03
    3978:	9c 81       	ldd	r25, Y+4	; 0x04
    397a:	01 97       	sbiw	r24, 0x01	; 1
    397c:	9c 83       	std	Y+4, r25	; 0x04
    397e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3980:	eb 81       	ldd	r30, Y+3	; 0x03
    3982:	fc 81       	ldd	r31, Y+4	; 0x04
    3984:	82 e2       	ldi	r24, 0x22	; 34
    3986:	80 83       	st	Z, r24
	pxTopOfStack--;
    3988:	8b 81       	ldd	r24, Y+3	; 0x03
    398a:	9c 81       	ldd	r25, Y+4	; 0x04
    398c:	01 97       	sbiw	r24, 0x01	; 1
    398e:	9c 83       	std	Y+4, r25	; 0x04
    3990:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3992:	eb 81       	ldd	r30, Y+3	; 0x03
    3994:	fc 81       	ldd	r31, Y+4	; 0x04
    3996:	83 e2       	ldi	r24, 0x23	; 35
    3998:	80 83       	st	Z, r24
	pxTopOfStack--;
    399a:	8b 81       	ldd	r24, Y+3	; 0x03
    399c:	9c 81       	ldd	r25, Y+4	; 0x04
    399e:	01 97       	sbiw	r24, 0x01	; 1
    39a0:	9c 83       	std	Y+4, r25	; 0x04
    39a2:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    39a4:	8f 81       	ldd	r24, Y+7	; 0x07
    39a6:	98 85       	ldd	r25, Y+8	; 0x08
    39a8:	9a 83       	std	Y+2, r25	; 0x02
    39aa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    39ac:	89 81       	ldd	r24, Y+1	; 0x01
    39ae:	eb 81       	ldd	r30, Y+3	; 0x03
    39b0:	fc 81       	ldd	r31, Y+4	; 0x04
    39b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    39b4:	8b 81       	ldd	r24, Y+3	; 0x03
    39b6:	9c 81       	ldd	r25, Y+4	; 0x04
    39b8:	01 97       	sbiw	r24, 0x01	; 1
    39ba:	9c 83       	std	Y+4, r25	; 0x04
    39bc:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    39be:	89 81       	ldd	r24, Y+1	; 0x01
    39c0:	9a 81       	ldd	r25, Y+2	; 0x02
    39c2:	89 2f       	mov	r24, r25
    39c4:	99 27       	eor	r25, r25
    39c6:	9a 83       	std	Y+2, r25	; 0x02
    39c8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    39ca:	89 81       	ldd	r24, Y+1	; 0x01
    39cc:	eb 81       	ldd	r30, Y+3	; 0x03
    39ce:	fc 81       	ldd	r31, Y+4	; 0x04
    39d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    39d2:	8b 81       	ldd	r24, Y+3	; 0x03
    39d4:	9c 81       	ldd	r25, Y+4	; 0x04
    39d6:	01 97       	sbiw	r24, 0x01	; 1
    39d8:	9c 83       	std	Y+4, r25	; 0x04
    39da:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    39dc:	eb 81       	ldd	r30, Y+3	; 0x03
    39de:	fc 81       	ldd	r31, Y+4	; 0x04
    39e0:	86 e2       	ldi	r24, 0x26	; 38
    39e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    39e4:	8b 81       	ldd	r24, Y+3	; 0x03
    39e6:	9c 81       	ldd	r25, Y+4	; 0x04
    39e8:	01 97       	sbiw	r24, 0x01	; 1
    39ea:	9c 83       	std	Y+4, r25	; 0x04
    39ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    39ee:	eb 81       	ldd	r30, Y+3	; 0x03
    39f0:	fc 81       	ldd	r31, Y+4	; 0x04
    39f2:	87 e2       	ldi	r24, 0x27	; 39
    39f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    39f6:	8b 81       	ldd	r24, Y+3	; 0x03
    39f8:	9c 81       	ldd	r25, Y+4	; 0x04
    39fa:	01 97       	sbiw	r24, 0x01	; 1
    39fc:	9c 83       	std	Y+4, r25	; 0x04
    39fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3a00:	eb 81       	ldd	r30, Y+3	; 0x03
    3a02:	fc 81       	ldd	r31, Y+4	; 0x04
    3a04:	88 e2       	ldi	r24, 0x28	; 40
    3a06:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a08:	8b 81       	ldd	r24, Y+3	; 0x03
    3a0a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a0c:	01 97       	sbiw	r24, 0x01	; 1
    3a0e:	9c 83       	std	Y+4, r25	; 0x04
    3a10:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    3a12:	eb 81       	ldd	r30, Y+3	; 0x03
    3a14:	fc 81       	ldd	r31, Y+4	; 0x04
    3a16:	89 e2       	ldi	r24, 0x29	; 41
    3a18:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a1a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a1c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a1e:	01 97       	sbiw	r24, 0x01	; 1
    3a20:	9c 83       	std	Y+4, r25	; 0x04
    3a22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    3a24:	eb 81       	ldd	r30, Y+3	; 0x03
    3a26:	fc 81       	ldd	r31, Y+4	; 0x04
    3a28:	80 e3       	ldi	r24, 0x30	; 48
    3a2a:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a2e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a30:	01 97       	sbiw	r24, 0x01	; 1
    3a32:	9c 83       	std	Y+4, r25	; 0x04
    3a34:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3a36:	eb 81       	ldd	r30, Y+3	; 0x03
    3a38:	fc 81       	ldd	r31, Y+4	; 0x04
    3a3a:	81 e3       	ldi	r24, 0x31	; 49
    3a3c:	80 83       	st	Z, r24
	pxTopOfStack--;
    3a3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a40:	9c 81       	ldd	r25, Y+4	; 0x04
    3a42:	01 97       	sbiw	r24, 0x01	; 1
    3a44:	9c 83       	std	Y+4, r25	; 0x04
    3a46:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3a48:	8b 81       	ldd	r24, Y+3	; 0x03
    3a4a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3a4c:	28 96       	adiw	r28, 0x08	; 8
    3a4e:	0f b6       	in	r0, 0x3f	; 63
    3a50:	f8 94       	cli
    3a52:	de bf       	out	0x3e, r29	; 62
    3a54:	0f be       	out	0x3f, r0	; 63
    3a56:	cd bf       	out	0x3d, r28	; 61
    3a58:	cf 91       	pop	r28
    3a5a:	df 91       	pop	r29
    3a5c:	08 95       	ret

00003a5e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    3a5e:	df 93       	push	r29
    3a60:	cf 93       	push	r28
    3a62:	cd b7       	in	r28, 0x3d	; 61
    3a64:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    3a66:	0e 94 21 1e 	call	0x3c42	; 0x3c42 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3a6a:	a0 91 7c 04 	lds	r26, 0x047C
    3a6e:	b0 91 7d 04 	lds	r27, 0x047D
    3a72:	cd 91       	ld	r28, X+
    3a74:	cd bf       	out	0x3d, r28	; 61
    3a76:	dd 91       	ld	r29, X+
    3a78:	de bf       	out	0x3e, r29	; 62
    3a7a:	ff 91       	pop	r31
    3a7c:	ef 91       	pop	r30
    3a7e:	df 91       	pop	r29
    3a80:	cf 91       	pop	r28
    3a82:	bf 91       	pop	r27
    3a84:	af 91       	pop	r26
    3a86:	9f 91       	pop	r25
    3a88:	8f 91       	pop	r24
    3a8a:	7f 91       	pop	r23
    3a8c:	6f 91       	pop	r22
    3a8e:	5f 91       	pop	r21
    3a90:	4f 91       	pop	r20
    3a92:	3f 91       	pop	r19
    3a94:	2f 91       	pop	r18
    3a96:	1f 91       	pop	r17
    3a98:	0f 91       	pop	r16
    3a9a:	ff 90       	pop	r15
    3a9c:	ef 90       	pop	r14
    3a9e:	df 90       	pop	r13
    3aa0:	cf 90       	pop	r12
    3aa2:	bf 90       	pop	r11
    3aa4:	af 90       	pop	r10
    3aa6:	9f 90       	pop	r9
    3aa8:	8f 90       	pop	r8
    3aaa:	7f 90       	pop	r7
    3aac:	6f 90       	pop	r6
    3aae:	5f 90       	pop	r5
    3ab0:	4f 90       	pop	r4
    3ab2:	3f 90       	pop	r3
    3ab4:	2f 90       	pop	r2
    3ab6:	1f 90       	pop	r1
    3ab8:	0f 90       	pop	r0
    3aba:	0f be       	out	0x3f, r0	; 63
    3abc:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3abe:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3ac0:	81 e0       	ldi	r24, 0x01	; 1
}
    3ac2:	cf 91       	pop	r28
    3ac4:	df 91       	pop	r29
    3ac6:	08 95       	ret

00003ac8 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3ac8:	df 93       	push	r29
    3aca:	cf 93       	push	r28
    3acc:	cd b7       	in	r28, 0x3d	; 61
    3ace:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3ad0:	cf 91       	pop	r28
    3ad2:	df 91       	pop	r29
    3ad4:	08 95       	ret

00003ad6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3ad6:	0f 92       	push	r0
    3ad8:	0f b6       	in	r0, 0x3f	; 63
    3ada:	f8 94       	cli
    3adc:	0f 92       	push	r0
    3ade:	1f 92       	push	r1
    3ae0:	11 24       	eor	r1, r1
    3ae2:	2f 92       	push	r2
    3ae4:	3f 92       	push	r3
    3ae6:	4f 92       	push	r4
    3ae8:	5f 92       	push	r5
    3aea:	6f 92       	push	r6
    3aec:	7f 92       	push	r7
    3aee:	8f 92       	push	r8
    3af0:	9f 92       	push	r9
    3af2:	af 92       	push	r10
    3af4:	bf 92       	push	r11
    3af6:	cf 92       	push	r12
    3af8:	df 92       	push	r13
    3afa:	ef 92       	push	r14
    3afc:	ff 92       	push	r15
    3afe:	0f 93       	push	r16
    3b00:	1f 93       	push	r17
    3b02:	2f 93       	push	r18
    3b04:	3f 93       	push	r19
    3b06:	4f 93       	push	r20
    3b08:	5f 93       	push	r21
    3b0a:	6f 93       	push	r22
    3b0c:	7f 93       	push	r23
    3b0e:	8f 93       	push	r24
    3b10:	9f 93       	push	r25
    3b12:	af 93       	push	r26
    3b14:	bf 93       	push	r27
    3b16:	cf 93       	push	r28
    3b18:	df 93       	push	r29
    3b1a:	ef 93       	push	r30
    3b1c:	ff 93       	push	r31
    3b1e:	a0 91 7c 04 	lds	r26, 0x047C
    3b22:	b0 91 7d 04 	lds	r27, 0x047D
    3b26:	0d b6       	in	r0, 0x3d	; 61
    3b28:	0d 92       	st	X+, r0
    3b2a:	0e b6       	in	r0, 0x3e	; 62
    3b2c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3b2e:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3b32:	a0 91 7c 04 	lds	r26, 0x047C
    3b36:	b0 91 7d 04 	lds	r27, 0x047D
    3b3a:	cd 91       	ld	r28, X+
    3b3c:	cd bf       	out	0x3d, r28	; 61
    3b3e:	dd 91       	ld	r29, X+
    3b40:	de bf       	out	0x3e, r29	; 62
    3b42:	ff 91       	pop	r31
    3b44:	ef 91       	pop	r30
    3b46:	df 91       	pop	r29
    3b48:	cf 91       	pop	r28
    3b4a:	bf 91       	pop	r27
    3b4c:	af 91       	pop	r26
    3b4e:	9f 91       	pop	r25
    3b50:	8f 91       	pop	r24
    3b52:	7f 91       	pop	r23
    3b54:	6f 91       	pop	r22
    3b56:	5f 91       	pop	r21
    3b58:	4f 91       	pop	r20
    3b5a:	3f 91       	pop	r19
    3b5c:	2f 91       	pop	r18
    3b5e:	1f 91       	pop	r17
    3b60:	0f 91       	pop	r16
    3b62:	ff 90       	pop	r15
    3b64:	ef 90       	pop	r14
    3b66:	df 90       	pop	r13
    3b68:	cf 90       	pop	r12
    3b6a:	bf 90       	pop	r11
    3b6c:	af 90       	pop	r10
    3b6e:	9f 90       	pop	r9
    3b70:	8f 90       	pop	r8
    3b72:	7f 90       	pop	r7
    3b74:	6f 90       	pop	r6
    3b76:	5f 90       	pop	r5
    3b78:	4f 90       	pop	r4
    3b7a:	3f 90       	pop	r3
    3b7c:	2f 90       	pop	r2
    3b7e:	1f 90       	pop	r1
    3b80:	0f 90       	pop	r0
    3b82:	0f be       	out	0x3f, r0	; 63
    3b84:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3b86:	08 95       	ret

00003b88 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3b88:	0f 92       	push	r0
    3b8a:	0f b6       	in	r0, 0x3f	; 63
    3b8c:	f8 94       	cli
    3b8e:	0f 92       	push	r0
    3b90:	1f 92       	push	r1
    3b92:	11 24       	eor	r1, r1
    3b94:	2f 92       	push	r2
    3b96:	3f 92       	push	r3
    3b98:	4f 92       	push	r4
    3b9a:	5f 92       	push	r5
    3b9c:	6f 92       	push	r6
    3b9e:	7f 92       	push	r7
    3ba0:	8f 92       	push	r8
    3ba2:	9f 92       	push	r9
    3ba4:	af 92       	push	r10
    3ba6:	bf 92       	push	r11
    3ba8:	cf 92       	push	r12
    3baa:	df 92       	push	r13
    3bac:	ef 92       	push	r14
    3bae:	ff 92       	push	r15
    3bb0:	0f 93       	push	r16
    3bb2:	1f 93       	push	r17
    3bb4:	2f 93       	push	r18
    3bb6:	3f 93       	push	r19
    3bb8:	4f 93       	push	r20
    3bba:	5f 93       	push	r21
    3bbc:	6f 93       	push	r22
    3bbe:	7f 93       	push	r23
    3bc0:	8f 93       	push	r24
    3bc2:	9f 93       	push	r25
    3bc4:	af 93       	push	r26
    3bc6:	bf 93       	push	r27
    3bc8:	cf 93       	push	r28
    3bca:	df 93       	push	r29
    3bcc:	ef 93       	push	r30
    3bce:	ff 93       	push	r31
    3bd0:	a0 91 7c 04 	lds	r26, 0x047C
    3bd4:	b0 91 7d 04 	lds	r27, 0x047D
    3bd8:	0d b6       	in	r0, 0x3d	; 61
    3bda:	0d 92       	st	X+, r0
    3bdc:	0e b6       	in	r0, 0x3e	; 62
    3bde:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    3be0:	0e 94 43 2c 	call	0x5886	; 0x5886 <xTaskIncrementTick>
    3be4:	88 23       	and	r24, r24
    3be6:	11 f0       	breq	.+4      	; 0x3bec <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    3be8:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    3bec:	a0 91 7c 04 	lds	r26, 0x047C
    3bf0:	b0 91 7d 04 	lds	r27, 0x047D
    3bf4:	cd 91       	ld	r28, X+
    3bf6:	cd bf       	out	0x3d, r28	; 61
    3bf8:	dd 91       	ld	r29, X+
    3bfa:	de bf       	out	0x3e, r29	; 62
    3bfc:	ff 91       	pop	r31
    3bfe:	ef 91       	pop	r30
    3c00:	df 91       	pop	r29
    3c02:	cf 91       	pop	r28
    3c04:	bf 91       	pop	r27
    3c06:	af 91       	pop	r26
    3c08:	9f 91       	pop	r25
    3c0a:	8f 91       	pop	r24
    3c0c:	7f 91       	pop	r23
    3c0e:	6f 91       	pop	r22
    3c10:	5f 91       	pop	r21
    3c12:	4f 91       	pop	r20
    3c14:	3f 91       	pop	r19
    3c16:	2f 91       	pop	r18
    3c18:	1f 91       	pop	r17
    3c1a:	0f 91       	pop	r16
    3c1c:	ff 90       	pop	r15
    3c1e:	ef 90       	pop	r14
    3c20:	df 90       	pop	r13
    3c22:	cf 90       	pop	r12
    3c24:	bf 90       	pop	r11
    3c26:	af 90       	pop	r10
    3c28:	9f 90       	pop	r9
    3c2a:	8f 90       	pop	r8
    3c2c:	7f 90       	pop	r7
    3c2e:	6f 90       	pop	r6
    3c30:	5f 90       	pop	r5
    3c32:	4f 90       	pop	r4
    3c34:	3f 90       	pop	r3
    3c36:	2f 90       	pop	r2
    3c38:	1f 90       	pop	r1
    3c3a:	0f 90       	pop	r0
    3c3c:	0f be       	out	0x3f, r0	; 63
    3c3e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3c40:	08 95       	ret

00003c42 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3c42:	df 93       	push	r29
    3c44:	cf 93       	push	r28
    3c46:	00 d0       	rcall	.+0      	; 0x3c48 <prvSetupTimerInterrupt+0x6>
    3c48:	00 d0       	rcall	.+0      	; 0x3c4a <prvSetupTimerInterrupt+0x8>
    3c4a:	00 d0       	rcall	.+0      	; 0x3c4c <prvSetupTimerInterrupt+0xa>
    3c4c:	cd b7       	in	r28, 0x3d	; 61
    3c4e:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3c50:	80 e4       	ldi	r24, 0x40	; 64
    3c52:	9f e1       	ldi	r25, 0x1F	; 31
    3c54:	a0 e0       	ldi	r26, 0x00	; 0
    3c56:	b0 e0       	ldi	r27, 0x00	; 0
    3c58:	8b 83       	std	Y+3, r24	; 0x03
    3c5a:	9c 83       	std	Y+4, r25	; 0x04
    3c5c:	ad 83       	std	Y+5, r26	; 0x05
    3c5e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3c60:	8b 81       	ldd	r24, Y+3	; 0x03
    3c62:	9c 81       	ldd	r25, Y+4	; 0x04
    3c64:	ad 81       	ldd	r26, Y+5	; 0x05
    3c66:	be 81       	ldd	r27, Y+6	; 0x06
    3c68:	68 94       	set
    3c6a:	15 f8       	bld	r1, 5
    3c6c:	b6 95       	lsr	r27
    3c6e:	a7 95       	ror	r26
    3c70:	97 95       	ror	r25
    3c72:	87 95       	ror	r24
    3c74:	16 94       	lsr	r1
    3c76:	d1 f7       	brne	.-12     	; 0x3c6c <prvSetupTimerInterrupt+0x2a>
    3c78:	8b 83       	std	Y+3, r24	; 0x03
    3c7a:	9c 83       	std	Y+4, r25	; 0x04
    3c7c:	ad 83       	std	Y+5, r26	; 0x05
    3c7e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    3c80:	8b 81       	ldd	r24, Y+3	; 0x03
    3c82:	9c 81       	ldd	r25, Y+4	; 0x04
    3c84:	ad 81       	ldd	r26, Y+5	; 0x05
    3c86:	be 81       	ldd	r27, Y+6	; 0x06
    3c88:	01 97       	sbiw	r24, 0x01	; 1
    3c8a:	a1 09       	sbc	r26, r1
    3c8c:	b1 09       	sbc	r27, r1
    3c8e:	8b 83       	std	Y+3, r24	; 0x03
    3c90:	9c 83       	std	Y+4, r25	; 0x04
    3c92:	ad 83       	std	Y+5, r26	; 0x05
    3c94:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3c96:	8b 81       	ldd	r24, Y+3	; 0x03
    3c98:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    3c9c:	9c 81       	ldd	r25, Y+4	; 0x04
    3c9e:	ad 81       	ldd	r26, Y+5	; 0x05
    3ca0:	be 81       	ldd	r27, Y+6	; 0x06
    3ca2:	89 2f       	mov	r24, r25
    3ca4:	9a 2f       	mov	r25, r26
    3ca6:	ab 2f       	mov	r26, r27
    3ca8:	bb 27       	eor	r27, r27
    3caa:	8b 83       	std	Y+3, r24	; 0x03
    3cac:	9c 83       	std	Y+4, r25	; 0x04
    3cae:	ad 83       	std	Y+5, r26	; 0x05
    3cb0:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    3cb2:	8b 81       	ldd	r24, Y+3	; 0x03
    3cb4:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3cb6:	eb e4       	ldi	r30, 0x4B	; 75
    3cb8:	f0 e0       	ldi	r31, 0x00	; 0
    3cba:	8a 81       	ldd	r24, Y+2	; 0x02
    3cbc:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3cbe:	ea e4       	ldi	r30, 0x4A	; 74
    3cc0:	f0 e0       	ldi	r31, 0x00	; 0
    3cc2:	89 81       	ldd	r24, Y+1	; 0x01
    3cc4:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3cc6:	8b e0       	ldi	r24, 0x0B	; 11
    3cc8:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3cca:	ee e4       	ldi	r30, 0x4E	; 78
    3ccc:	f0 e0       	ldi	r31, 0x00	; 0
    3cce:	89 81       	ldd	r24, Y+1	; 0x01
    3cd0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3cd2:	e9 e5       	ldi	r30, 0x59	; 89
    3cd4:	f0 e0       	ldi	r31, 0x00	; 0
    3cd6:	80 81       	ld	r24, Z
    3cd8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3cda:	89 81       	ldd	r24, Y+1	; 0x01
    3cdc:	80 61       	ori	r24, 0x10	; 16
    3cde:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3ce0:	e9 e5       	ldi	r30, 0x59	; 89
    3ce2:	f0 e0       	ldi	r31, 0x00	; 0
    3ce4:	89 81       	ldd	r24, Y+1	; 0x01
    3ce6:	80 83       	st	Z, r24
}
    3ce8:	26 96       	adiw	r28, 0x06	; 6
    3cea:	0f b6       	in	r0, 0x3f	; 63
    3cec:	f8 94       	cli
    3cee:	de bf       	out	0x3e, r29	; 62
    3cf0:	0f be       	out	0x3f, r0	; 63
    3cf2:	cd bf       	out	0x3d, r28	; 61
    3cf4:	cf 91       	pop	r28
    3cf6:	df 91       	pop	r29
    3cf8:	08 95       	ret

00003cfa <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    3cfa:	0e 94 c4 1d 	call	0x3b88	; 0x3b88 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3cfe:	18 95       	reti

00003d00 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    3d00:	df 93       	push	r29
    3d02:	cf 93       	push	r28
    3d04:	00 d0       	rcall	.+0      	; 0x3d06 <xQueueGenericReset+0x6>
    3d06:	00 d0       	rcall	.+0      	; 0x3d08 <xQueueGenericReset+0x8>
    3d08:	0f 92       	push	r0
    3d0a:	cd b7       	in	r28, 0x3d	; 61
    3d0c:	de b7       	in	r29, 0x3e	; 62
    3d0e:	9c 83       	std	Y+4, r25	; 0x04
    3d10:	8b 83       	std	Y+3, r24	; 0x03
    3d12:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    3d14:	8b 81       	ldd	r24, Y+3	; 0x03
    3d16:	9c 81       	ldd	r25, Y+4	; 0x04
    3d18:	9a 83       	std	Y+2, r25	; 0x02
    3d1a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3d1c:	0f b6       	in	r0, 0x3f	; 63
    3d1e:	f8 94       	cli
    3d20:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3d22:	e9 81       	ldd	r30, Y+1	; 0x01
    3d24:	fa 81       	ldd	r31, Y+2	; 0x02
    3d26:	40 81       	ld	r20, Z
    3d28:	51 81       	ldd	r21, Z+1	; 0x01
    3d2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d2e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3d30:	28 2f       	mov	r18, r24
    3d32:	30 e0       	ldi	r19, 0x00	; 0
    3d34:	e9 81       	ldd	r30, Y+1	; 0x01
    3d36:	fa 81       	ldd	r31, Y+2	; 0x02
    3d38:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d3a:	88 2f       	mov	r24, r24
    3d3c:	90 e0       	ldi	r25, 0x00	; 0
    3d3e:	bc 01       	movw	r22, r24
    3d40:	26 9f       	mul	r18, r22
    3d42:	c0 01       	movw	r24, r0
    3d44:	27 9f       	mul	r18, r23
    3d46:	90 0d       	add	r25, r0
    3d48:	36 9f       	mul	r19, r22
    3d4a:	90 0d       	add	r25, r0
    3d4c:	11 24       	eor	r1, r1
    3d4e:	84 0f       	add	r24, r20
    3d50:	95 1f       	adc	r25, r21
    3d52:	e9 81       	ldd	r30, Y+1	; 0x01
    3d54:	fa 81       	ldd	r31, Y+2	; 0x02
    3d56:	95 83       	std	Z+5, r25	; 0x05
    3d58:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    3d5a:	e9 81       	ldd	r30, Y+1	; 0x01
    3d5c:	fa 81       	ldd	r31, Y+2	; 0x02
    3d5e:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    3d60:	e9 81       	ldd	r30, Y+1	; 0x01
    3d62:	fa 81       	ldd	r31, Y+2	; 0x02
    3d64:	80 81       	ld	r24, Z
    3d66:	91 81       	ldd	r25, Z+1	; 0x01
    3d68:	e9 81       	ldd	r30, Y+1	; 0x01
    3d6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d6c:	93 83       	std	Z+3, r25	; 0x03
    3d6e:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3d70:	e9 81       	ldd	r30, Y+1	; 0x01
    3d72:	fa 81       	ldd	r31, Y+2	; 0x02
    3d74:	40 81       	ld	r20, Z
    3d76:	51 81       	ldd	r21, Z+1	; 0x01
    3d78:	e9 81       	ldd	r30, Y+1	; 0x01
    3d7a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d7c:	83 8d       	ldd	r24, Z+27	; 0x1b
    3d7e:	88 2f       	mov	r24, r24
    3d80:	90 e0       	ldi	r25, 0x00	; 0
    3d82:	9c 01       	movw	r18, r24
    3d84:	21 50       	subi	r18, 0x01	; 1
    3d86:	30 40       	sbci	r19, 0x00	; 0
    3d88:	e9 81       	ldd	r30, Y+1	; 0x01
    3d8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3d8c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3d8e:	88 2f       	mov	r24, r24
    3d90:	90 e0       	ldi	r25, 0x00	; 0
    3d92:	bc 01       	movw	r22, r24
    3d94:	26 9f       	mul	r18, r22
    3d96:	c0 01       	movw	r24, r0
    3d98:	27 9f       	mul	r18, r23
    3d9a:	90 0d       	add	r25, r0
    3d9c:	36 9f       	mul	r19, r22
    3d9e:	90 0d       	add	r25, r0
    3da0:	11 24       	eor	r1, r1
    3da2:	84 0f       	add	r24, r20
    3da4:	95 1f       	adc	r25, r21
    3da6:	e9 81       	ldd	r30, Y+1	; 0x01
    3da8:	fa 81       	ldd	r31, Y+2	; 0x02
    3daa:	97 83       	std	Z+7, r25	; 0x07
    3dac:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    3dae:	e9 81       	ldd	r30, Y+1	; 0x01
    3db0:	fa 81       	ldd	r31, Y+2	; 0x02
    3db2:	8f ef       	ldi	r24, 0xFF	; 255
    3db4:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    3db6:	e9 81       	ldd	r30, Y+1	; 0x01
    3db8:	fa 81       	ldd	r31, Y+2	; 0x02
    3dba:	8f ef       	ldi	r24, 0xFF	; 255
    3dbc:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    3dbe:	8d 81       	ldd	r24, Y+5	; 0x05
    3dc0:	88 23       	and	r24, r24
    3dc2:	79 f4       	brne	.+30     	; 0x3de2 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3dc4:	e9 81       	ldd	r30, Y+1	; 0x01
    3dc6:	fa 81       	ldd	r31, Y+2	; 0x02
    3dc8:	80 85       	ldd	r24, Z+8	; 0x08
    3dca:	88 23       	and	r24, r24
    3dcc:	a1 f0       	breq	.+40     	; 0x3df6 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3dce:	89 81       	ldd	r24, Y+1	; 0x01
    3dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    3dd2:	08 96       	adiw	r24, 0x08	; 8
    3dd4:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    3dd8:	88 23       	and	r24, r24
    3dda:	69 f0       	breq	.+26     	; 0x3df6 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    3ddc:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
    3de0:	0a c0       	rjmp	.+20     	; 0x3df6 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    3de2:	89 81       	ldd	r24, Y+1	; 0x01
    3de4:	9a 81       	ldd	r25, Y+2	; 0x02
    3de6:	08 96       	adiw	r24, 0x08	; 8
    3de8:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3dec:	89 81       	ldd	r24, Y+1	; 0x01
    3dee:	9a 81       	ldd	r25, Y+2	; 0x02
    3df0:	41 96       	adiw	r24, 0x11	; 17
    3df2:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    3df6:	0f 90       	pop	r0
    3df8:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3dfa:	81 e0       	ldi	r24, 0x01	; 1
}
    3dfc:	0f 90       	pop	r0
    3dfe:	0f 90       	pop	r0
    3e00:	0f 90       	pop	r0
    3e02:	0f 90       	pop	r0
    3e04:	0f 90       	pop	r0
    3e06:	cf 91       	pop	r28
    3e08:	df 91       	pop	r29
    3e0a:	08 95       	ret

00003e0c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    3e0c:	0f 93       	push	r16
    3e0e:	1f 93       	push	r17
    3e10:	df 93       	push	r29
    3e12:	cf 93       	push	r28
    3e14:	cd b7       	in	r28, 0x3d	; 61
    3e16:	de b7       	in	r29, 0x3e	; 62
    3e18:	29 97       	sbiw	r28, 0x09	; 9
    3e1a:	0f b6       	in	r0, 0x3f	; 63
    3e1c:	f8 94       	cli
    3e1e:	de bf       	out	0x3e, r29	; 62
    3e20:	0f be       	out	0x3f, r0	; 63
    3e22:	cd bf       	out	0x3d, r28	; 61
    3e24:	8f 83       	std	Y+7, r24	; 0x07
    3e26:	68 87       	std	Y+8, r22	; 0x08
    3e28:	49 87       	std	Y+9, r20	; 0x09
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e2a:	8f 81       	ldd	r24, Y+7	; 0x07
    3e2c:	28 2f       	mov	r18, r24
    3e2e:	30 e0       	ldi	r19, 0x00	; 0
    3e30:	88 85       	ldd	r24, Y+8	; 0x08
    3e32:	88 2f       	mov	r24, r24
    3e34:	90 e0       	ldi	r25, 0x00	; 0
    3e36:	ac 01       	movw	r20, r24
    3e38:	24 9f       	mul	r18, r20
    3e3a:	c0 01       	movw	r24, r0
    3e3c:	25 9f       	mul	r18, r21
    3e3e:	90 0d       	add	r25, r0
    3e40:	34 9f       	mul	r19, r20
    3e42:	90 0d       	add	r25, r0
    3e44:	11 24       	eor	r1, r1
    3e46:	9c 83       	std	Y+4, r25	; 0x04
    3e48:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    3e4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3e4c:	9c 81       	ldd	r25, Y+4	; 0x04
    3e4e:	4f 96       	adiw	r24, 0x1f	; 31
    3e50:	0e 94 68 18 	call	0x30d0	; 0x30d0 <pvPortMalloc>
    3e54:	9e 83       	std	Y+6, r25	; 0x06
    3e56:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    3e58:	8d 81       	ldd	r24, Y+5	; 0x05
    3e5a:	9e 81       	ldd	r25, Y+6	; 0x06
    3e5c:	00 97       	sbiw	r24, 0x00	; 0
    3e5e:	a1 f0       	breq	.+40     	; 0x3e88 <xQueueGenericCreate+0x7c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    3e60:	8d 81       	ldd	r24, Y+5	; 0x05
    3e62:	9e 81       	ldd	r25, Y+6	; 0x06
    3e64:	9a 83       	std	Y+2, r25	; 0x02
    3e66:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    3e68:	89 81       	ldd	r24, Y+1	; 0x01
    3e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e6c:	4f 96       	adiw	r24, 0x1f	; 31
    3e6e:	9a 83       	std	Y+2, r25	; 0x02
    3e70:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    3e72:	29 81       	ldd	r18, Y+1	; 0x01
    3e74:	3a 81       	ldd	r19, Y+2	; 0x02
    3e76:	ed 81       	ldd	r30, Y+5	; 0x05
    3e78:	fe 81       	ldd	r31, Y+6	; 0x06
    3e7a:	8f 81       	ldd	r24, Y+7	; 0x07
    3e7c:	68 85       	ldd	r22, Y+8	; 0x08
    3e7e:	a9 01       	movw	r20, r18
    3e80:	29 85       	ldd	r18, Y+9	; 0x09
    3e82:	8f 01       	movw	r16, r30
    3e84:	0e 94 51 1f 	call	0x3ea2	; 0x3ea2 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    3e88:	8d 81       	ldd	r24, Y+5	; 0x05
    3e8a:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    3e8c:	29 96       	adiw	r28, 0x09	; 9
    3e8e:	0f b6       	in	r0, 0x3f	; 63
    3e90:	f8 94       	cli
    3e92:	de bf       	out	0x3e, r29	; 62
    3e94:	0f be       	out	0x3f, r0	; 63
    3e96:	cd bf       	out	0x3d, r28	; 61
    3e98:	cf 91       	pop	r28
    3e9a:	df 91       	pop	r29
    3e9c:	1f 91       	pop	r17
    3e9e:	0f 91       	pop	r16
    3ea0:	08 95       	ret

00003ea2 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    3ea2:	0f 93       	push	r16
    3ea4:	1f 93       	push	r17
    3ea6:	df 93       	push	r29
    3ea8:	cf 93       	push	r28
    3eaa:	cd b7       	in	r28, 0x3d	; 61
    3eac:	de b7       	in	r29, 0x3e	; 62
    3eae:	27 97       	sbiw	r28, 0x07	; 7
    3eb0:	0f b6       	in	r0, 0x3f	; 63
    3eb2:	f8 94       	cli
    3eb4:	de bf       	out	0x3e, r29	; 62
    3eb6:	0f be       	out	0x3f, r0	; 63
    3eb8:	cd bf       	out	0x3d, r28	; 61
    3eba:	89 83       	std	Y+1, r24	; 0x01
    3ebc:	6a 83       	std	Y+2, r22	; 0x02
    3ebe:	5c 83       	std	Y+4, r21	; 0x04
    3ec0:	4b 83       	std	Y+3, r20	; 0x03
    3ec2:	2d 83       	std	Y+5, r18	; 0x05
    3ec4:	1f 83       	std	Y+7, r17	; 0x07
    3ec6:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    3ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    3eca:	88 23       	and	r24, r24
    3ecc:	39 f4       	brne	.+14     	; 0x3edc <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    3ece:	8e 81       	ldd	r24, Y+6	; 0x06
    3ed0:	9f 81       	ldd	r25, Y+7	; 0x07
    3ed2:	ee 81       	ldd	r30, Y+6	; 0x06
    3ed4:	ff 81       	ldd	r31, Y+7	; 0x07
    3ed6:	91 83       	std	Z+1, r25	; 0x01
    3ed8:	80 83       	st	Z, r24
    3eda:	06 c0       	rjmp	.+12     	; 0x3ee8 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    3edc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ede:	9c 81       	ldd	r25, Y+4	; 0x04
    3ee0:	ee 81       	ldd	r30, Y+6	; 0x06
    3ee2:	ff 81       	ldd	r31, Y+7	; 0x07
    3ee4:	91 83       	std	Z+1, r25	; 0x01
    3ee6:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    3ee8:	ee 81       	ldd	r30, Y+6	; 0x06
    3eea:	ff 81       	ldd	r31, Y+7	; 0x07
    3eec:	89 81       	ldd	r24, Y+1	; 0x01
    3eee:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    3ef0:	ee 81       	ldd	r30, Y+6	; 0x06
    3ef2:	ff 81       	ldd	r31, Y+7	; 0x07
    3ef4:	8a 81       	ldd	r24, Y+2	; 0x02
    3ef6:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    3ef8:	8e 81       	ldd	r24, Y+6	; 0x06
    3efa:	9f 81       	ldd	r25, Y+7	; 0x07
    3efc:	61 e0       	ldi	r22, 0x01	; 1
    3efe:	0e 94 80 1e 	call	0x3d00	; 0x3d00 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    3f02:	27 96       	adiw	r28, 0x07	; 7
    3f04:	0f b6       	in	r0, 0x3f	; 63
    3f06:	f8 94       	cli
    3f08:	de bf       	out	0x3e, r29	; 62
    3f0a:	0f be       	out	0x3f, r0	; 63
    3f0c:	cd bf       	out	0x3d, r28	; 61
    3f0e:	cf 91       	pop	r28
    3f10:	df 91       	pop	r29
    3f12:	1f 91       	pop	r17
    3f14:	0f 91       	pop	r16
    3f16:	08 95       	ret

00003f18 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    3f18:	df 93       	push	r29
    3f1a:	cf 93       	push	r28
    3f1c:	cd b7       	in	r28, 0x3d	; 61
    3f1e:	de b7       	in	r29, 0x3e	; 62
    3f20:	2f 97       	sbiw	r28, 0x0f	; 15
    3f22:	0f b6       	in	r0, 0x3f	; 63
    3f24:	f8 94       	cli
    3f26:	de bf       	out	0x3e, r29	; 62
    3f28:	0f be       	out	0x3f, r0	; 63
    3f2a:	cd bf       	out	0x3d, r28	; 61
    3f2c:	99 87       	std	Y+9, r25	; 0x09
    3f2e:	88 87       	std	Y+8, r24	; 0x08
    3f30:	7b 87       	std	Y+11, r23	; 0x0b
    3f32:	6a 87       	std	Y+10, r22	; 0x0a
    3f34:	5d 87       	std	Y+13, r21	; 0x0d
    3f36:	4c 87       	std	Y+12, r20	; 0x0c
    3f38:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    3f3a:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    3f3c:	88 85       	ldd	r24, Y+8	; 0x08
    3f3e:	99 85       	ldd	r25, Y+9	; 0x09
    3f40:	9a 83       	std	Y+2, r25	; 0x02
    3f42:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3f44:	0f b6       	in	r0, 0x3f	; 63
    3f46:	f8 94       	cli
    3f48:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3f4a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f4c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f4e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3f50:	e9 81       	ldd	r30, Y+1	; 0x01
    3f52:	fa 81       	ldd	r31, Y+2	; 0x02
    3f54:	83 8d       	ldd	r24, Z+27	; 0x1b
    3f56:	98 17       	cp	r25, r24
    3f58:	18 f0       	brcs	.+6      	; 0x3f60 <xQueueGenericSend+0x48>
    3f5a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3f5c:	82 30       	cpi	r24, 0x02	; 2
    3f5e:	11 f5       	brne	.+68     	; 0x3fa4 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3f60:	89 81       	ldd	r24, Y+1	; 0x01
    3f62:	9a 81       	ldd	r25, Y+2	; 0x02
    3f64:	2a 85       	ldd	r18, Y+10	; 0x0a
    3f66:	3b 85       	ldd	r19, Y+11	; 0x0b
    3f68:	b9 01       	movw	r22, r18
    3f6a:	4e 85       	ldd	r20, Y+14	; 0x0e
    3f6c:	0e 94 e2 23 	call	0x47c4	; 0x47c4 <prvCopyDataToQueue>
    3f70:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3f72:	e9 81       	ldd	r30, Y+1	; 0x01
    3f74:	fa 81       	ldd	r31, Y+2	; 0x02
    3f76:	81 89       	ldd	r24, Z+17	; 0x11
    3f78:	88 23       	and	r24, r24
    3f7a:	51 f0       	breq	.+20     	; 0x3f90 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3f7c:	89 81       	ldd	r24, Y+1	; 0x01
    3f7e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f80:	41 96       	adiw	r24, 0x11	; 17
    3f82:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    3f86:	88 23       	and	r24, r24
    3f88:	41 f0       	breq	.+16     	; 0x3f9a <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    3f8a:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
    3f8e:	05 c0       	rjmp	.+10     	; 0x3f9a <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    3f90:	8b 81       	ldd	r24, Y+3	; 0x03
    3f92:	88 23       	and	r24, r24
    3f94:	11 f0       	breq	.+4      	; 0x3f9a <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    3f96:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    3f9a:	0f 90       	pop	r0
    3f9c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3f9e:	81 e0       	ldi	r24, 0x01	; 1
    3fa0:	8f 87       	std	Y+15, r24	; 0x0f
    3fa2:	5c c0       	rjmp	.+184    	; 0x405c <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3fa4:	8c 85       	ldd	r24, Y+12	; 0x0c
    3fa6:	9d 85       	ldd	r25, Y+13	; 0x0d
    3fa8:	00 97       	sbiw	r24, 0x00	; 0
    3faa:	21 f4       	brne	.+8      	; 0x3fb4 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3fac:	0f 90       	pop	r0
    3fae:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3fb0:	1f 86       	std	Y+15, r1	; 0x0f
    3fb2:	54 c0       	rjmp	.+168    	; 0x405c <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    3fb4:	8c 81       	ldd	r24, Y+4	; 0x04
    3fb6:	88 23       	and	r24, r24
    3fb8:	31 f4       	brne	.+12     	; 0x3fc6 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    3fba:	ce 01       	movw	r24, r28
    3fbc:	05 96       	adiw	r24, 0x05	; 5
    3fbe:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3fc2:	81 e0       	ldi	r24, 0x01	; 1
    3fc4:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3fc6:	0f 90       	pop	r0
    3fc8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3fca:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3fce:	0f b6       	in	r0, 0x3f	; 63
    3fd0:	f8 94       	cli
    3fd2:	0f 92       	push	r0
    3fd4:	e9 81       	ldd	r30, Y+1	; 0x01
    3fd6:	fa 81       	ldd	r31, Y+2	; 0x02
    3fd8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fda:	8f 3f       	cpi	r24, 0xFF	; 255
    3fdc:	19 f4       	brne	.+6      	; 0x3fe4 <xQueueGenericSend+0xcc>
    3fde:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fe2:	15 8e       	std	Z+29, r1	; 0x1d
    3fe4:	e9 81       	ldd	r30, Y+1	; 0x01
    3fe6:	fa 81       	ldd	r31, Y+2	; 0x02
    3fe8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fea:	8f 3f       	cpi	r24, 0xFF	; 255
    3fec:	19 f4       	brne	.+6      	; 0x3ff4 <xQueueGenericSend+0xdc>
    3fee:	e9 81       	ldd	r30, Y+1	; 0x01
    3ff0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ff2:	16 8e       	std	Z+30, r1	; 0x1e
    3ff4:	0f 90       	pop	r0
    3ff6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3ff8:	ce 01       	movw	r24, r28
    3ffa:	05 96       	adiw	r24, 0x05	; 5
    3ffc:	9e 01       	movw	r18, r28
    3ffe:	24 5f       	subi	r18, 0xF4	; 244
    4000:	3f 4f       	sbci	r19, 0xFF	; 255
    4002:	b9 01       	movw	r22, r18
    4004:	0e 94 ea 2e 	call	0x5dd4	; 0x5dd4 <xTaskCheckForTimeOut>
    4008:	88 23       	and	r24, r24
    400a:	09 f5       	brne	.+66     	; 0x404e <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    400c:	89 81       	ldd	r24, Y+1	; 0x01
    400e:	9a 81       	ldd	r25, Y+2	; 0x02
    4010:	0e 94 5e 25 	call	0x4abc	; 0x4abc <prvIsQueueFull>
    4014:	88 23       	and	r24, r24
    4016:	a1 f0       	breq	.+40     	; 0x4040 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    4018:	89 81       	ldd	r24, Y+1	; 0x01
    401a:	9a 81       	ldd	r25, Y+2	; 0x02
    401c:	08 96       	adiw	r24, 0x08	; 8
    401e:	2c 85       	ldd	r18, Y+12	; 0x0c
    4020:	3d 85       	ldd	r19, Y+13	; 0x0d
    4022:	b9 01       	movw	r22, r18
    4024:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    4028:	89 81       	ldd	r24, Y+1	; 0x01
    402a:	9a 81       	ldd	r25, Y+2	; 0x02
    402c:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    4030:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    4034:	88 23       	and	r24, r24
    4036:	09 f0       	breq	.+2      	; 0x403a <xQueueGenericSend+0x122>
    4038:	85 cf       	rjmp	.-246    	; 0x3f44 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    403a:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
    403e:	82 cf       	rjmp	.-252    	; 0x3f44 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4040:	89 81       	ldd	r24, Y+1	; 0x01
    4042:	9a 81       	ldd	r25, Y+2	; 0x02
    4044:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4048:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    404c:	7b cf       	rjmp	.-266    	; 0x3f44 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    404e:	89 81       	ldd	r24, Y+1	; 0x01
    4050:	9a 81       	ldd	r25, Y+2	; 0x02
    4052:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    4056:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    405a:	1f 86       	std	Y+15, r1	; 0x0f
    405c:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    405e:	2f 96       	adiw	r28, 0x0f	; 15
    4060:	0f b6       	in	r0, 0x3f	; 63
    4062:	f8 94       	cli
    4064:	de bf       	out	0x3e, r29	; 62
    4066:	0f be       	out	0x3f, r0	; 63
    4068:	cd bf       	out	0x3d, r28	; 61
    406a:	cf 91       	pop	r28
    406c:	df 91       	pop	r29
    406e:	08 95       	ret

00004070 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    4070:	df 93       	push	r29
    4072:	cf 93       	push	r28
    4074:	cd b7       	in	r28, 0x3d	; 61
    4076:	de b7       	in	r29, 0x3e	; 62
    4078:	2d 97       	sbiw	r28, 0x0d	; 13
    407a:	0f b6       	in	r0, 0x3f	; 63
    407c:	f8 94       	cli
    407e:	de bf       	out	0x3e, r29	; 62
    4080:	0f be       	out	0x3f, r0	; 63
    4082:	cd bf       	out	0x3d, r28	; 61
    4084:	98 87       	std	Y+8, r25	; 0x08
    4086:	8f 83       	std	Y+7, r24	; 0x07
    4088:	7a 87       	std	Y+10, r23	; 0x0a
    408a:	69 87       	std	Y+9, r22	; 0x09
    408c:	5c 87       	std	Y+12, r21	; 0x0c
    408e:	4b 87       	std	Y+11, r20	; 0x0b
    4090:	2d 87       	std	Y+13, r18	; 0x0d
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    4092:	8f 81       	ldd	r24, Y+7	; 0x07
    4094:	98 85       	ldd	r25, Y+8	; 0x08
    4096:	9c 83       	std	Y+4, r25	; 0x04
    4098:	8b 83       	std	Y+3, r24	; 0x03
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    409a:	1d 82       	std	Y+5, r1	; 0x05
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    409c:	eb 81       	ldd	r30, Y+3	; 0x03
    409e:	fc 81       	ldd	r31, Y+4	; 0x04
    40a0:	92 8d       	ldd	r25, Z+26	; 0x1a
    40a2:	eb 81       	ldd	r30, Y+3	; 0x03
    40a4:	fc 81       	ldd	r31, Y+4	; 0x04
    40a6:	83 8d       	ldd	r24, Z+27	; 0x1b
    40a8:	98 17       	cp	r25, r24
    40aa:	18 f0       	brcs	.+6      	; 0x40b2 <xQueueGenericSendFromISR+0x42>
    40ac:	8d 85       	ldd	r24, Y+13	; 0x0d
    40ae:	82 30       	cpi	r24, 0x02	; 2
    40b0:	81 f5       	brne	.+96     	; 0x4112 <xQueueGenericSendFromISR+0xa2>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    40b2:	eb 81       	ldd	r30, Y+3	; 0x03
    40b4:	fc 81       	ldd	r31, Y+4	; 0x04
    40b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    40b8:	8a 83       	std	Y+2, r24	; 0x02
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    40ba:	eb 81       	ldd	r30, Y+3	; 0x03
    40bc:	fc 81       	ldd	r31, Y+4	; 0x04
    40be:	82 8d       	ldd	r24, Z+26	; 0x1a
    40c0:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    40c2:	8b 81       	ldd	r24, Y+3	; 0x03
    40c4:	9c 81       	ldd	r25, Y+4	; 0x04
    40c6:	29 85       	ldd	r18, Y+9	; 0x09
    40c8:	3a 85       	ldd	r19, Y+10	; 0x0a
    40ca:	b9 01       	movw	r22, r18
    40cc:	4d 85       	ldd	r20, Y+13	; 0x0d
    40ce:	0e 94 e2 23 	call	0x47c4	; 0x47c4 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    40d2:	8a 81       	ldd	r24, Y+2	; 0x02
    40d4:	8f 3f       	cpi	r24, 0xFF	; 255
    40d6:	a9 f4       	brne	.+42     	; 0x4102 <xQueueGenericSendFromISR+0x92>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    40d8:	eb 81       	ldd	r30, Y+3	; 0x03
    40da:	fc 81       	ldd	r31, Y+4	; 0x04
    40dc:	81 89       	ldd	r24, Z+17	; 0x11
    40de:	88 23       	and	r24, r24
    40e0:	a9 f0       	breq	.+42     	; 0x410c <xQueueGenericSendFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    40e2:	8b 81       	ldd	r24, Y+3	; 0x03
    40e4:	9c 81       	ldd	r25, Y+4	; 0x04
    40e6:	41 96       	adiw	r24, 0x11	; 17
    40e8:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    40ec:	88 23       	and	r24, r24
    40ee:	71 f0       	breq	.+28     	; 0x410c <xQueueGenericSendFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    40f0:	8b 85       	ldd	r24, Y+11	; 0x0b
    40f2:	9c 85       	ldd	r25, Y+12	; 0x0c
    40f4:	00 97       	sbiw	r24, 0x00	; 0
    40f6:	51 f0       	breq	.+20     	; 0x410c <xQueueGenericSendFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    40f8:	eb 85       	ldd	r30, Y+11	; 0x0b
    40fa:	fc 85       	ldd	r31, Y+12	; 0x0c
    40fc:	81 e0       	ldi	r24, 0x01	; 1
    40fe:	80 83       	st	Z, r24
    4100:	05 c0       	rjmp	.+10     	; 0x410c <xQueueGenericSendFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    4102:	8a 81       	ldd	r24, Y+2	; 0x02
    4104:	8f 5f       	subi	r24, 0xFF	; 255
    4106:	eb 81       	ldd	r30, Y+3	; 0x03
    4108:	fc 81       	ldd	r31, Y+4	; 0x04
    410a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    410c:	81 e0       	ldi	r24, 0x01	; 1
    410e:	8e 83       	std	Y+6, r24	; 0x06
    4110:	01 c0       	rjmp	.+2      	; 0x4114 <xQueueGenericSendFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    4112:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4114:	8e 81       	ldd	r24, Y+6	; 0x06
}
    4116:	2d 96       	adiw	r28, 0x0d	; 13
    4118:	0f b6       	in	r0, 0x3f	; 63
    411a:	f8 94       	cli
    411c:	de bf       	out	0x3e, r29	; 62
    411e:	0f be       	out	0x3f, r0	; 63
    4120:	cd bf       	out	0x3d, r28	; 61
    4122:	cf 91       	pop	r28
    4124:	df 91       	pop	r29
    4126:	08 95       	ret

00004128 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    4128:	df 93       	push	r29
    412a:	cf 93       	push	r28
    412c:	cd b7       	in	r28, 0x3d	; 61
    412e:	de b7       	in	r29, 0x3e	; 62
    4130:	2a 97       	sbiw	r28, 0x0a	; 10
    4132:	0f b6       	in	r0, 0x3f	; 63
    4134:	f8 94       	cli
    4136:	de bf       	out	0x3e, r29	; 62
    4138:	0f be       	out	0x3f, r0	; 63
    413a:	cd bf       	out	0x3d, r28	; 61
    413c:	98 87       	std	Y+8, r25	; 0x08
    413e:	8f 83       	std	Y+7, r24	; 0x07
    4140:	7a 87       	std	Y+10, r23	; 0x0a
    4142:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    4144:	8f 81       	ldd	r24, Y+7	; 0x07
    4146:	98 85       	ldd	r25, Y+8	; 0x08
    4148:	9c 83       	std	Y+4, r25	; 0x04
    414a:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    414c:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    414e:	eb 81       	ldd	r30, Y+3	; 0x03
    4150:	fc 81       	ldd	r31, Y+4	; 0x04
    4152:	82 8d       	ldd	r24, Z+26	; 0x1a
    4154:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    4156:	eb 81       	ldd	r30, Y+3	; 0x03
    4158:	fc 81       	ldd	r31, Y+4	; 0x04
    415a:	93 8d       	ldd	r25, Z+27	; 0x1b
    415c:	8a 81       	ldd	r24, Y+2	; 0x02
    415e:	89 17       	cp	r24, r25
    4160:	48 f5       	brcc	.+82     	; 0x41b4 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    4162:	eb 81       	ldd	r30, Y+3	; 0x03
    4164:	fc 81       	ldd	r31, Y+4	; 0x04
    4166:	86 8d       	ldd	r24, Z+30	; 0x1e
    4168:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    416a:	8a 81       	ldd	r24, Y+2	; 0x02
    416c:	8f 5f       	subi	r24, 0xFF	; 255
    416e:	eb 81       	ldd	r30, Y+3	; 0x03
    4170:	fc 81       	ldd	r31, Y+4	; 0x04
    4172:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    4174:	89 81       	ldd	r24, Y+1	; 0x01
    4176:	8f 3f       	cpi	r24, 0xFF	; 255
    4178:	a9 f4       	brne	.+42     	; 0x41a4 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    417a:	eb 81       	ldd	r30, Y+3	; 0x03
    417c:	fc 81       	ldd	r31, Y+4	; 0x04
    417e:	81 89       	ldd	r24, Z+17	; 0x11
    4180:	88 23       	and	r24, r24
    4182:	a9 f0       	breq	.+42     	; 0x41ae <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4184:	8b 81       	ldd	r24, Y+3	; 0x03
    4186:	9c 81       	ldd	r25, Y+4	; 0x04
    4188:	41 96       	adiw	r24, 0x11	; 17
    418a:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    418e:	88 23       	and	r24, r24
    4190:	71 f0       	breq	.+28     	; 0x41ae <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    4192:	89 85       	ldd	r24, Y+9	; 0x09
    4194:	9a 85       	ldd	r25, Y+10	; 0x0a
    4196:	00 97       	sbiw	r24, 0x00	; 0
    4198:	51 f0       	breq	.+20     	; 0x41ae <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    419a:	e9 85       	ldd	r30, Y+9	; 0x09
    419c:	fa 85       	ldd	r31, Y+10	; 0x0a
    419e:	81 e0       	ldi	r24, 0x01	; 1
    41a0:	80 83       	st	Z, r24
    41a2:	05 c0       	rjmp	.+10     	; 0x41ae <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    41a4:	89 81       	ldd	r24, Y+1	; 0x01
    41a6:	8f 5f       	subi	r24, 0xFF	; 255
    41a8:	eb 81       	ldd	r30, Y+3	; 0x03
    41aa:	fc 81       	ldd	r31, Y+4	; 0x04
    41ac:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    41ae:	81 e0       	ldi	r24, 0x01	; 1
    41b0:	8e 83       	std	Y+6, r24	; 0x06
    41b2:	01 c0       	rjmp	.+2      	; 0x41b6 <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    41b4:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    41b6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    41b8:	2a 96       	adiw	r28, 0x0a	; 10
    41ba:	0f b6       	in	r0, 0x3f	; 63
    41bc:	f8 94       	cli
    41be:	de bf       	out	0x3e, r29	; 62
    41c0:	0f be       	out	0x3f, r0	; 63
    41c2:	cd bf       	out	0x3d, r28	; 61
    41c4:	cf 91       	pop	r28
    41c6:	df 91       	pop	r29
    41c8:	08 95       	ret

000041ca <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    41ca:	df 93       	push	r29
    41cc:	cf 93       	push	r28
    41ce:	cd b7       	in	r28, 0x3d	; 61
    41d0:	de b7       	in	r29, 0x3e	; 62
    41d2:	2e 97       	sbiw	r28, 0x0e	; 14
    41d4:	0f b6       	in	r0, 0x3f	; 63
    41d6:	f8 94       	cli
    41d8:	de bf       	out	0x3e, r29	; 62
    41da:	0f be       	out	0x3f, r0	; 63
    41dc:	cd bf       	out	0x3d, r28	; 61
    41de:	99 87       	std	Y+9, r25	; 0x09
    41e0:	88 87       	std	Y+8, r24	; 0x08
    41e2:	7b 87       	std	Y+11, r23	; 0x0b
    41e4:	6a 87       	std	Y+10, r22	; 0x0a
    41e6:	5d 87       	std	Y+13, r21	; 0x0d
    41e8:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    41ea:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    41ec:	88 85       	ldd	r24, Y+8	; 0x08
    41ee:	99 85       	ldd	r25, Y+9	; 0x09
    41f0:	9b 83       	std	Y+3, r25	; 0x03
    41f2:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    41f4:	0f b6       	in	r0, 0x3f	; 63
    41f6:	f8 94       	cli
    41f8:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    41fa:	ea 81       	ldd	r30, Y+2	; 0x02
    41fc:	fb 81       	ldd	r31, Y+3	; 0x03
    41fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    4200:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    4202:	89 81       	ldd	r24, Y+1	; 0x01
    4204:	88 23       	and	r24, r24
    4206:	f9 f0       	breq	.+62     	; 0x4246 <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    4208:	8a 81       	ldd	r24, Y+2	; 0x02
    420a:	9b 81       	ldd	r25, Y+3	; 0x03
    420c:	2a 85       	ldd	r18, Y+10	; 0x0a
    420e:	3b 85       	ldd	r19, Y+11	; 0x0b
    4210:	b9 01       	movw	r22, r18
    4212:	0e 94 88 24 	call	0x4910	; 0x4910 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    4216:	89 81       	ldd	r24, Y+1	; 0x01
    4218:	81 50       	subi	r24, 0x01	; 1
    421a:	ea 81       	ldd	r30, Y+2	; 0x02
    421c:	fb 81       	ldd	r31, Y+3	; 0x03
    421e:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4220:	ea 81       	ldd	r30, Y+2	; 0x02
    4222:	fb 81       	ldd	r31, Y+3	; 0x03
    4224:	80 85       	ldd	r24, Z+8	; 0x08
    4226:	88 23       	and	r24, r24
    4228:	49 f0       	breq	.+18     	; 0x423c <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    422a:	8a 81       	ldd	r24, Y+2	; 0x02
    422c:	9b 81       	ldd	r25, Y+3	; 0x03
    422e:	08 96       	adiw	r24, 0x08	; 8
    4230:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    4234:	88 23       	and	r24, r24
    4236:	11 f0       	breq	.+4      	; 0x423c <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    4238:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    423c:	0f 90       	pop	r0
    423e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    4240:	81 e0       	ldi	r24, 0x01	; 1
    4242:	8e 87       	std	Y+14, r24	; 0x0e
    4244:	63 c0       	rjmp	.+198    	; 0x430c <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    4246:	8c 85       	ldd	r24, Y+12	; 0x0c
    4248:	9d 85       	ldd	r25, Y+13	; 0x0d
    424a:	00 97       	sbiw	r24, 0x00	; 0
    424c:	21 f4       	brne	.+8      	; 0x4256 <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    424e:	0f 90       	pop	r0
    4250:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    4252:	1e 86       	std	Y+14, r1	; 0x0e
    4254:	5b c0       	rjmp	.+182    	; 0x430c <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    4256:	8c 81       	ldd	r24, Y+4	; 0x04
    4258:	88 23       	and	r24, r24
    425a:	31 f4       	brne	.+12     	; 0x4268 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    425c:	ce 01       	movw	r24, r28
    425e:	05 96       	adiw	r24, 0x05	; 5
    4260:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4264:	81 e0       	ldi	r24, 0x01	; 1
    4266:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4268:	0f 90       	pop	r0
    426a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    426c:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4270:	0f b6       	in	r0, 0x3f	; 63
    4272:	f8 94       	cli
    4274:	0f 92       	push	r0
    4276:	ea 81       	ldd	r30, Y+2	; 0x02
    4278:	fb 81       	ldd	r31, Y+3	; 0x03
    427a:	85 8d       	ldd	r24, Z+29	; 0x1d
    427c:	8f 3f       	cpi	r24, 0xFF	; 255
    427e:	19 f4       	brne	.+6      	; 0x4286 <xQueueReceive+0xbc>
    4280:	ea 81       	ldd	r30, Y+2	; 0x02
    4282:	fb 81       	ldd	r31, Y+3	; 0x03
    4284:	15 8e       	std	Z+29, r1	; 0x1d
    4286:	ea 81       	ldd	r30, Y+2	; 0x02
    4288:	fb 81       	ldd	r31, Y+3	; 0x03
    428a:	86 8d       	ldd	r24, Z+30	; 0x1e
    428c:	8f 3f       	cpi	r24, 0xFF	; 255
    428e:	19 f4       	brne	.+6      	; 0x4296 <xQueueReceive+0xcc>
    4290:	ea 81       	ldd	r30, Y+2	; 0x02
    4292:	fb 81       	ldd	r31, Y+3	; 0x03
    4294:	16 8e       	std	Z+30, r1	; 0x1e
    4296:	0f 90       	pop	r0
    4298:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    429a:	ce 01       	movw	r24, r28
    429c:	05 96       	adiw	r24, 0x05	; 5
    429e:	9e 01       	movw	r18, r28
    42a0:	24 5f       	subi	r18, 0xF4	; 244
    42a2:	3f 4f       	sbci	r19, 0xFF	; 255
    42a4:	b9 01       	movw	r22, r18
    42a6:	0e 94 ea 2e 	call	0x5dd4	; 0x5dd4 <xTaskCheckForTimeOut>
    42aa:	88 23       	and	r24, r24
    42ac:	09 f5       	brne	.+66     	; 0x42f0 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    42ae:	8a 81       	ldd	r24, Y+2	; 0x02
    42b0:	9b 81       	ldd	r25, Y+3	; 0x03
    42b2:	0e 94 22 25 	call	0x4a44	; 0x4a44 <prvIsQueueEmpty>
    42b6:	88 23       	and	r24, r24
    42b8:	a1 f0       	breq	.+40     	; 0x42e2 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    42ba:	8a 81       	ldd	r24, Y+2	; 0x02
    42bc:	9b 81       	ldd	r25, Y+3	; 0x03
    42be:	41 96       	adiw	r24, 0x11	; 17
    42c0:	2c 85       	ldd	r18, Y+12	; 0x0c
    42c2:	3d 85       	ldd	r19, Y+13	; 0x0d
    42c4:	b9 01       	movw	r22, r18
    42c6:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    42ca:	8a 81       	ldd	r24, Y+2	; 0x02
    42cc:	9b 81       	ldd	r25, Y+3	; 0x03
    42ce:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    42d2:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    42d6:	88 23       	and	r24, r24
    42d8:	09 f0       	breq	.+2      	; 0x42dc <xQueueReceive+0x112>
    42da:	8c cf       	rjmp	.-232    	; 0x41f4 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    42dc:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
    42e0:	89 cf       	rjmp	.-238    	; 0x41f4 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    42e2:	8a 81       	ldd	r24, Y+2	; 0x02
    42e4:	9b 81       	ldd	r25, Y+3	; 0x03
    42e6:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    42ea:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    42ee:	82 cf       	rjmp	.-252    	; 0x41f4 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    42f0:	8a 81       	ldd	r24, Y+2	; 0x02
    42f2:	9b 81       	ldd	r25, Y+3	; 0x03
    42f4:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    42f8:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    42fc:	8a 81       	ldd	r24, Y+2	; 0x02
    42fe:	9b 81       	ldd	r25, Y+3	; 0x03
    4300:	0e 94 22 25 	call	0x4a44	; 0x4a44 <prvIsQueueEmpty>
    4304:	88 23       	and	r24, r24
    4306:	09 f4       	brne	.+2      	; 0x430a <xQueueReceive+0x140>
    4308:	75 cf       	rjmp	.-278    	; 0x41f4 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    430a:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    430c:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    430e:	2e 96       	adiw	r28, 0x0e	; 14
    4310:	0f b6       	in	r0, 0x3f	; 63
    4312:	f8 94       	cli
    4314:	de bf       	out	0x3e, r29	; 62
    4316:	0f be       	out	0x3f, r0	; 63
    4318:	cd bf       	out	0x3d, r28	; 61
    431a:	cf 91       	pop	r28
    431c:	df 91       	pop	r29
    431e:	08 95       	ret

00004320 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    4320:	df 93       	push	r29
    4322:	cf 93       	push	r28
    4324:	cd b7       	in	r28, 0x3d	; 61
    4326:	de b7       	in	r29, 0x3e	; 62
    4328:	2c 97       	sbiw	r28, 0x0c	; 12
    432a:	0f b6       	in	r0, 0x3f	; 63
    432c:	f8 94       	cli
    432e:	de bf       	out	0x3e, r29	; 62
    4330:	0f be       	out	0x3f, r0	; 63
    4332:	cd bf       	out	0x3d, r28	; 61
    4334:	99 87       	std	Y+9, r25	; 0x09
    4336:	88 87       	std	Y+8, r24	; 0x08
    4338:	7b 87       	std	Y+11, r23	; 0x0b
    433a:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    433c:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    433e:	88 85       	ldd	r24, Y+8	; 0x08
    4340:	99 85       	ldd	r25, Y+9	; 0x09
    4342:	9b 83       	std	Y+3, r25	; 0x03
    4344:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    4346:	0f b6       	in	r0, 0x3f	; 63
    4348:	f8 94       	cli
    434a:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    434c:	ea 81       	ldd	r30, Y+2	; 0x02
    434e:	fb 81       	ldd	r31, Y+3	; 0x03
    4350:	82 8d       	ldd	r24, Z+26	; 0x1a
    4352:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    4354:	89 81       	ldd	r24, Y+1	; 0x01
    4356:	88 23       	and	r24, r24
    4358:	c1 f0       	breq	.+48     	; 0x438a <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    435a:	89 81       	ldd	r24, Y+1	; 0x01
    435c:	81 50       	subi	r24, 0x01	; 1
    435e:	ea 81       	ldd	r30, Y+2	; 0x02
    4360:	fb 81       	ldd	r31, Y+3	; 0x03
    4362:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4364:	ea 81       	ldd	r30, Y+2	; 0x02
    4366:	fb 81       	ldd	r31, Y+3	; 0x03
    4368:	80 85       	ldd	r24, Z+8	; 0x08
    436a:	88 23       	and	r24, r24
    436c:	49 f0       	breq	.+18     	; 0x4380 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    436e:	8a 81       	ldd	r24, Y+2	; 0x02
    4370:	9b 81       	ldd	r25, Y+3	; 0x03
    4372:	08 96       	adiw	r24, 0x08	; 8
    4374:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    4378:	88 23       	and	r24, r24
    437a:	11 f0       	breq	.+4      	; 0x4380 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    437c:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    4380:	0f 90       	pop	r0
    4382:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    4384:	81 e0       	ldi	r24, 0x01	; 1
    4386:	8c 87       	std	Y+12, r24	; 0x0c
    4388:	63 c0       	rjmp	.+198    	; 0x4450 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    438a:	8a 85       	ldd	r24, Y+10	; 0x0a
    438c:	9b 85       	ldd	r25, Y+11	; 0x0b
    438e:	00 97       	sbiw	r24, 0x00	; 0
    4390:	21 f4       	brne	.+8      	; 0x439a <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    4392:	0f 90       	pop	r0
    4394:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    4396:	1c 86       	std	Y+12, r1	; 0x0c
    4398:	5b c0       	rjmp	.+182    	; 0x4450 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    439a:	8c 81       	ldd	r24, Y+4	; 0x04
    439c:	88 23       	and	r24, r24
    439e:	31 f4       	brne	.+12     	; 0x43ac <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    43a0:	ce 01       	movw	r24, r28
    43a2:	05 96       	adiw	r24, 0x05	; 5
    43a4:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    43a8:	81 e0       	ldi	r24, 0x01	; 1
    43aa:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    43ac:	0f 90       	pop	r0
    43ae:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    43b0:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    43b4:	0f b6       	in	r0, 0x3f	; 63
    43b6:	f8 94       	cli
    43b8:	0f 92       	push	r0
    43ba:	ea 81       	ldd	r30, Y+2	; 0x02
    43bc:	fb 81       	ldd	r31, Y+3	; 0x03
    43be:	85 8d       	ldd	r24, Z+29	; 0x1d
    43c0:	8f 3f       	cpi	r24, 0xFF	; 255
    43c2:	19 f4       	brne	.+6      	; 0x43ca <xQueueSemaphoreTake+0xaa>
    43c4:	ea 81       	ldd	r30, Y+2	; 0x02
    43c6:	fb 81       	ldd	r31, Y+3	; 0x03
    43c8:	15 8e       	std	Z+29, r1	; 0x1d
    43ca:	ea 81       	ldd	r30, Y+2	; 0x02
    43cc:	fb 81       	ldd	r31, Y+3	; 0x03
    43ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    43d0:	8f 3f       	cpi	r24, 0xFF	; 255
    43d2:	19 f4       	brne	.+6      	; 0x43da <xQueueSemaphoreTake+0xba>
    43d4:	ea 81       	ldd	r30, Y+2	; 0x02
    43d6:	fb 81       	ldd	r31, Y+3	; 0x03
    43d8:	16 8e       	std	Z+30, r1	; 0x1e
    43da:	0f 90       	pop	r0
    43dc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    43de:	ce 01       	movw	r24, r28
    43e0:	05 96       	adiw	r24, 0x05	; 5
    43e2:	9e 01       	movw	r18, r28
    43e4:	26 5f       	subi	r18, 0xF6	; 246
    43e6:	3f 4f       	sbci	r19, 0xFF	; 255
    43e8:	b9 01       	movw	r22, r18
    43ea:	0e 94 ea 2e 	call	0x5dd4	; 0x5dd4 <xTaskCheckForTimeOut>
    43ee:	88 23       	and	r24, r24
    43f0:	09 f5       	brne	.+66     	; 0x4434 <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    43f2:	8a 81       	ldd	r24, Y+2	; 0x02
    43f4:	9b 81       	ldd	r25, Y+3	; 0x03
    43f6:	0e 94 22 25 	call	0x4a44	; 0x4a44 <prvIsQueueEmpty>
    43fa:	88 23       	and	r24, r24
    43fc:	a1 f0       	breq	.+40     	; 0x4426 <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    43fe:	8a 81       	ldd	r24, Y+2	; 0x02
    4400:	9b 81       	ldd	r25, Y+3	; 0x03
    4402:	41 96       	adiw	r24, 0x11	; 17
    4404:	2a 85       	ldd	r18, Y+10	; 0x0a
    4406:	3b 85       	ldd	r19, Y+11	; 0x0b
    4408:	b9 01       	movw	r22, r18
    440a:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    440e:	8a 81       	ldd	r24, Y+2	; 0x02
    4410:	9b 81       	ldd	r25, Y+3	; 0x03
    4412:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    4416:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    441a:	88 23       	and	r24, r24
    441c:	09 f0       	breq	.+2      	; 0x4420 <xQueueSemaphoreTake+0x100>
    441e:	93 cf       	rjmp	.-218    	; 0x4346 <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    4420:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
    4424:	90 cf       	rjmp	.-224    	; 0x4346 <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    4426:	8a 81       	ldd	r24, Y+2	; 0x02
    4428:	9b 81       	ldd	r25, Y+3	; 0x03
    442a:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    442e:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    4432:	89 cf       	rjmp	.-238    	; 0x4346 <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    4434:	8a 81       	ldd	r24, Y+2	; 0x02
    4436:	9b 81       	ldd	r25, Y+3	; 0x03
    4438:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    443c:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4440:	8a 81       	ldd	r24, Y+2	; 0x02
    4442:	9b 81       	ldd	r25, Y+3	; 0x03
    4444:	0e 94 22 25 	call	0x4a44	; 0x4a44 <prvIsQueueEmpty>
    4448:	88 23       	and	r24, r24
    444a:	09 f4       	brne	.+2      	; 0x444e <xQueueSemaphoreTake+0x12e>
    444c:	7c cf       	rjmp	.-264    	; 0x4346 <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    444e:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    4450:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    4452:	2c 96       	adiw	r28, 0x0c	; 12
    4454:	0f b6       	in	r0, 0x3f	; 63
    4456:	f8 94       	cli
    4458:	de bf       	out	0x3e, r29	; 62
    445a:	0f be       	out	0x3f, r0	; 63
    445c:	cd bf       	out	0x3d, r28	; 61
    445e:	cf 91       	pop	r28
    4460:	df 91       	pop	r29
    4462:	08 95       	ret

00004464 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    4464:	df 93       	push	r29
    4466:	cf 93       	push	r28
    4468:	cd b7       	in	r28, 0x3d	; 61
    446a:	de b7       	in	r29, 0x3e	; 62
    446c:	60 97       	sbiw	r28, 0x10	; 16
    446e:	0f b6       	in	r0, 0x3f	; 63
    4470:	f8 94       	cli
    4472:	de bf       	out	0x3e, r29	; 62
    4474:	0f be       	out	0x3f, r0	; 63
    4476:	cd bf       	out	0x3d, r28	; 61
    4478:	9b 87       	std	Y+11, r25	; 0x0b
    447a:	8a 87       	std	Y+10, r24	; 0x0a
    447c:	7d 87       	std	Y+13, r23	; 0x0d
    447e:	6c 87       	std	Y+12, r22	; 0x0c
    4480:	5f 87       	std	Y+15, r21	; 0x0f
    4482:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    4484:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    4486:	8a 85       	ldd	r24, Y+10	; 0x0a
    4488:	9b 85       	ldd	r25, Y+11	; 0x0b
    448a:	9b 83       	std	Y+3, r25	; 0x03
    448c:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    448e:	0f b6       	in	r0, 0x3f	; 63
    4490:	f8 94       	cli
    4492:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    4494:	ea 81       	ldd	r30, Y+2	; 0x02
    4496:	fb 81       	ldd	r31, Y+3	; 0x03
    4498:	82 8d       	ldd	r24, Z+26	; 0x1a
    449a:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    449c:	89 81       	ldd	r24, Y+1	; 0x01
    449e:	88 23       	and	r24, r24
    44a0:	31 f1       	breq	.+76     	; 0x44ee <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    44a2:	ea 81       	ldd	r30, Y+2	; 0x02
    44a4:	fb 81       	ldd	r31, Y+3	; 0x03
    44a6:	86 81       	ldd	r24, Z+6	; 0x06
    44a8:	97 81       	ldd	r25, Z+7	; 0x07
    44aa:	9d 83       	std	Y+5, r25	; 0x05
    44ac:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    44ae:	8a 81       	ldd	r24, Y+2	; 0x02
    44b0:	9b 81       	ldd	r25, Y+3	; 0x03
    44b2:	2c 85       	ldd	r18, Y+12	; 0x0c
    44b4:	3d 85       	ldd	r19, Y+13	; 0x0d
    44b6:	b9 01       	movw	r22, r18
    44b8:	0e 94 88 24 	call	0x4910	; 0x4910 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    44bc:	ea 81       	ldd	r30, Y+2	; 0x02
    44be:	fb 81       	ldd	r31, Y+3	; 0x03
    44c0:	8c 81       	ldd	r24, Y+4	; 0x04
    44c2:	9d 81       	ldd	r25, Y+5	; 0x05
    44c4:	97 83       	std	Z+7, r25	; 0x07
    44c6:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    44c8:	ea 81       	ldd	r30, Y+2	; 0x02
    44ca:	fb 81       	ldd	r31, Y+3	; 0x03
    44cc:	81 89       	ldd	r24, Z+17	; 0x11
    44ce:	88 23       	and	r24, r24
    44d0:	49 f0       	breq	.+18     	; 0x44e4 <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    44d2:	8a 81       	ldd	r24, Y+2	; 0x02
    44d4:	9b 81       	ldd	r25, Y+3	; 0x03
    44d6:	41 96       	adiw	r24, 0x11	; 17
    44d8:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    44dc:	88 23       	and	r24, r24
    44de:	11 f0       	breq	.+4      	; 0x44e4 <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    44e0:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    44e4:	0f 90       	pop	r0
    44e6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    44e8:	81 e0       	ldi	r24, 0x01	; 1
    44ea:	88 8b       	std	Y+16, r24	; 0x10
    44ec:	63 c0       	rjmp	.+198    	; 0x45b4 <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    44ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    44f0:	9f 85       	ldd	r25, Y+15	; 0x0f
    44f2:	00 97       	sbiw	r24, 0x00	; 0
    44f4:	21 f4       	brne	.+8      	; 0x44fe <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    44f6:	0f 90       	pop	r0
    44f8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    44fa:	18 8a       	std	Y+16, r1	; 0x10
    44fc:	5b c0       	rjmp	.+182    	; 0x45b4 <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    44fe:	8e 81       	ldd	r24, Y+6	; 0x06
    4500:	88 23       	and	r24, r24
    4502:	31 f4       	brne	.+12     	; 0x4510 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    4504:	ce 01       	movw	r24, r28
    4506:	07 96       	adiw	r24, 0x07	; 7
    4508:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    450c:	81 e0       	ldi	r24, 0x01	; 1
    450e:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4510:	0f 90       	pop	r0
    4512:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4514:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4518:	0f b6       	in	r0, 0x3f	; 63
    451a:	f8 94       	cli
    451c:	0f 92       	push	r0
    451e:	ea 81       	ldd	r30, Y+2	; 0x02
    4520:	fb 81       	ldd	r31, Y+3	; 0x03
    4522:	85 8d       	ldd	r24, Z+29	; 0x1d
    4524:	8f 3f       	cpi	r24, 0xFF	; 255
    4526:	19 f4       	brne	.+6      	; 0x452e <xQueuePeek+0xca>
    4528:	ea 81       	ldd	r30, Y+2	; 0x02
    452a:	fb 81       	ldd	r31, Y+3	; 0x03
    452c:	15 8e       	std	Z+29, r1	; 0x1d
    452e:	ea 81       	ldd	r30, Y+2	; 0x02
    4530:	fb 81       	ldd	r31, Y+3	; 0x03
    4532:	86 8d       	ldd	r24, Z+30	; 0x1e
    4534:	8f 3f       	cpi	r24, 0xFF	; 255
    4536:	19 f4       	brne	.+6      	; 0x453e <xQueuePeek+0xda>
    4538:	ea 81       	ldd	r30, Y+2	; 0x02
    453a:	fb 81       	ldd	r31, Y+3	; 0x03
    453c:	16 8e       	std	Z+30, r1	; 0x1e
    453e:	0f 90       	pop	r0
    4540:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4542:	ce 01       	movw	r24, r28
    4544:	07 96       	adiw	r24, 0x07	; 7
    4546:	9e 01       	movw	r18, r28
    4548:	22 5f       	subi	r18, 0xF2	; 242
    454a:	3f 4f       	sbci	r19, 0xFF	; 255
    454c:	b9 01       	movw	r22, r18
    454e:	0e 94 ea 2e 	call	0x5dd4	; 0x5dd4 <xTaskCheckForTimeOut>
    4552:	88 23       	and	r24, r24
    4554:	09 f5       	brne	.+66     	; 0x4598 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4556:	8a 81       	ldd	r24, Y+2	; 0x02
    4558:	9b 81       	ldd	r25, Y+3	; 0x03
    455a:	0e 94 22 25 	call	0x4a44	; 0x4a44 <prvIsQueueEmpty>
    455e:	88 23       	and	r24, r24
    4560:	a1 f0       	breq	.+40     	; 0x458a <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4562:	8a 81       	ldd	r24, Y+2	; 0x02
    4564:	9b 81       	ldd	r25, Y+3	; 0x03
    4566:	41 96       	adiw	r24, 0x11	; 17
    4568:	2e 85       	ldd	r18, Y+14	; 0x0e
    456a:	3f 85       	ldd	r19, Y+15	; 0x0f
    456c:	b9 01       	movw	r22, r18
    456e:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    4572:	8a 81       	ldd	r24, Y+2	; 0x02
    4574:	9b 81       	ldd	r25, Y+3	; 0x03
    4576:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    457a:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    457e:	88 23       	and	r24, r24
    4580:	09 f0       	breq	.+2      	; 0x4584 <xQueuePeek+0x120>
    4582:	85 cf       	rjmp	.-246    	; 0x448e <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    4584:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
    4588:	82 cf       	rjmp	.-252    	; 0x448e <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    458a:	8a 81       	ldd	r24, Y+2	; 0x02
    458c:	9b 81       	ldd	r25, Y+3	; 0x03
    458e:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4592:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    4596:	7b cf       	rjmp	.-266    	; 0x448e <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    4598:	8a 81       	ldd	r24, Y+2	; 0x02
    459a:	9b 81       	ldd	r25, Y+3	; 0x03
    459c:	0e 94 cf 24 	call	0x499e	; 0x499e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    45a0:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    45a4:	8a 81       	ldd	r24, Y+2	; 0x02
    45a6:	9b 81       	ldd	r25, Y+3	; 0x03
    45a8:	0e 94 22 25 	call	0x4a44	; 0x4a44 <prvIsQueueEmpty>
    45ac:	88 23       	and	r24, r24
    45ae:	09 f4       	brne	.+2      	; 0x45b2 <xQueuePeek+0x14e>
    45b0:	6e cf       	rjmp	.-292    	; 0x448e <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    45b2:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    45b4:	88 89       	ldd	r24, Y+16	; 0x10
}
    45b6:	60 96       	adiw	r28, 0x10	; 16
    45b8:	0f b6       	in	r0, 0x3f	; 63
    45ba:	f8 94       	cli
    45bc:	de bf       	out	0x3e, r29	; 62
    45be:	0f be       	out	0x3f, r0	; 63
    45c0:	cd bf       	out	0x3d, r28	; 61
    45c2:	cf 91       	pop	r28
    45c4:	df 91       	pop	r29
    45c6:	08 95       	ret

000045c8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    45c8:	df 93       	push	r29
    45ca:	cf 93       	push	r28
    45cc:	cd b7       	in	r28, 0x3d	; 61
    45ce:	de b7       	in	r29, 0x3e	; 62
    45d0:	2c 97       	sbiw	r28, 0x0c	; 12
    45d2:	0f b6       	in	r0, 0x3f	; 63
    45d4:	f8 94       	cli
    45d6:	de bf       	out	0x3e, r29	; 62
    45d8:	0f be       	out	0x3f, r0	; 63
    45da:	cd bf       	out	0x3d, r28	; 61
    45dc:	98 87       	std	Y+8, r25	; 0x08
    45de:	8f 83       	std	Y+7, r24	; 0x07
    45e0:	7a 87       	std	Y+10, r23	; 0x0a
    45e2:	69 87       	std	Y+9, r22	; 0x09
    45e4:	5c 87       	std	Y+12, r21	; 0x0c
    45e6:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    45e8:	8f 81       	ldd	r24, Y+7	; 0x07
    45ea:	98 85       	ldd	r25, Y+8	; 0x08
    45ec:	9c 83       	std	Y+4, r25	; 0x04
    45ee:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    45f0:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    45f2:	eb 81       	ldd	r30, Y+3	; 0x03
    45f4:	fc 81       	ldd	r31, Y+4	; 0x04
    45f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    45f8:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    45fa:	8a 81       	ldd	r24, Y+2	; 0x02
    45fc:	88 23       	and	r24, r24
    45fe:	81 f1       	breq	.+96     	; 0x4660 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    4600:	eb 81       	ldd	r30, Y+3	; 0x03
    4602:	fc 81       	ldd	r31, Y+4	; 0x04
    4604:	85 8d       	ldd	r24, Z+29	; 0x1d
    4606:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    4608:	8b 81       	ldd	r24, Y+3	; 0x03
    460a:	9c 81       	ldd	r25, Y+4	; 0x04
    460c:	29 85       	ldd	r18, Y+9	; 0x09
    460e:	3a 85       	ldd	r19, Y+10	; 0x0a
    4610:	b9 01       	movw	r22, r18
    4612:	0e 94 88 24 	call	0x4910	; 0x4910 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    4616:	8a 81       	ldd	r24, Y+2	; 0x02
    4618:	81 50       	subi	r24, 0x01	; 1
    461a:	eb 81       	ldd	r30, Y+3	; 0x03
    461c:	fc 81       	ldd	r31, Y+4	; 0x04
    461e:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    4620:	89 81       	ldd	r24, Y+1	; 0x01
    4622:	8f 3f       	cpi	r24, 0xFF	; 255
    4624:	a9 f4       	brne	.+42     	; 0x4650 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4626:	eb 81       	ldd	r30, Y+3	; 0x03
    4628:	fc 81       	ldd	r31, Y+4	; 0x04
    462a:	80 85       	ldd	r24, Z+8	; 0x08
    462c:	88 23       	and	r24, r24
    462e:	a9 f0       	breq	.+42     	; 0x465a <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4630:	8b 81       	ldd	r24, Y+3	; 0x03
    4632:	9c 81       	ldd	r25, Y+4	; 0x04
    4634:	08 96       	adiw	r24, 0x08	; 8
    4636:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    463a:	88 23       	and	r24, r24
    463c:	71 f0       	breq	.+28     	; 0x465a <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    463e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4640:	9c 85       	ldd	r25, Y+12	; 0x0c
    4642:	00 97       	sbiw	r24, 0x00	; 0
    4644:	51 f0       	breq	.+20     	; 0x465a <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    4646:	eb 85       	ldd	r30, Y+11	; 0x0b
    4648:	fc 85       	ldd	r31, Y+12	; 0x0c
    464a:	81 e0       	ldi	r24, 0x01	; 1
    464c:	80 83       	st	Z, r24
    464e:	05 c0       	rjmp	.+10     	; 0x465a <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    4650:	89 81       	ldd	r24, Y+1	; 0x01
    4652:	8f 5f       	subi	r24, 0xFF	; 255
    4654:	eb 81       	ldd	r30, Y+3	; 0x03
    4656:	fc 81       	ldd	r31, Y+4	; 0x04
    4658:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    465a:	81 e0       	ldi	r24, 0x01	; 1
    465c:	8e 83       	std	Y+6, r24	; 0x06
    465e:	01 c0       	rjmp	.+2      	; 0x4662 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    4660:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4662:	8e 81       	ldd	r24, Y+6	; 0x06
}
    4664:	2c 96       	adiw	r28, 0x0c	; 12
    4666:	0f b6       	in	r0, 0x3f	; 63
    4668:	f8 94       	cli
    466a:	de bf       	out	0x3e, r29	; 62
    466c:	0f be       	out	0x3f, r0	; 63
    466e:	cd bf       	out	0x3d, r28	; 61
    4670:	cf 91       	pop	r28
    4672:	df 91       	pop	r29
    4674:	08 95       	ret

00004676 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    4676:	df 93       	push	r29
    4678:	cf 93       	push	r28
    467a:	cd b7       	in	r28, 0x3d	; 61
    467c:	de b7       	in	r29, 0x3e	; 62
    467e:	2a 97       	sbiw	r28, 0x0a	; 10
    4680:	0f b6       	in	r0, 0x3f	; 63
    4682:	f8 94       	cli
    4684:	de bf       	out	0x3e, r29	; 62
    4686:	0f be       	out	0x3f, r0	; 63
    4688:	cd bf       	out	0x3d, r28	; 61
    468a:	98 87       	std	Y+8, r25	; 0x08
    468c:	8f 83       	std	Y+7, r24	; 0x07
    468e:	7a 87       	std	Y+10, r23	; 0x0a
    4690:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    4692:	8f 81       	ldd	r24, Y+7	; 0x07
    4694:	98 85       	ldd	r25, Y+8	; 0x08
    4696:	9a 83       	std	Y+2, r25	; 0x02
    4698:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    469a:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    469c:	e9 81       	ldd	r30, Y+1	; 0x01
    469e:	fa 81       	ldd	r31, Y+2	; 0x02
    46a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    46a2:	88 23       	and	r24, r24
    46a4:	b1 f0       	breq	.+44     	; 0x46d2 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    46a6:	e9 81       	ldd	r30, Y+1	; 0x01
    46a8:	fa 81       	ldd	r31, Y+2	; 0x02
    46aa:	86 81       	ldd	r24, Z+6	; 0x06
    46ac:	97 81       	ldd	r25, Z+7	; 0x07
    46ae:	9c 83       	std	Y+4, r25	; 0x04
    46b0:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    46b2:	89 81       	ldd	r24, Y+1	; 0x01
    46b4:	9a 81       	ldd	r25, Y+2	; 0x02
    46b6:	29 85       	ldd	r18, Y+9	; 0x09
    46b8:	3a 85       	ldd	r19, Y+10	; 0x0a
    46ba:	b9 01       	movw	r22, r18
    46bc:	0e 94 88 24 	call	0x4910	; 0x4910 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    46c0:	e9 81       	ldd	r30, Y+1	; 0x01
    46c2:	fa 81       	ldd	r31, Y+2	; 0x02
    46c4:	8b 81       	ldd	r24, Y+3	; 0x03
    46c6:	9c 81       	ldd	r25, Y+4	; 0x04
    46c8:	97 83       	std	Z+7, r25	; 0x07
    46ca:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    46cc:	81 e0       	ldi	r24, 0x01	; 1
    46ce:	8e 83       	std	Y+6, r24	; 0x06
    46d0:	01 c0       	rjmp	.+2      	; 0x46d4 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    46d2:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    46d4:	8e 81       	ldd	r24, Y+6	; 0x06
}
    46d6:	2a 96       	adiw	r28, 0x0a	; 10
    46d8:	0f b6       	in	r0, 0x3f	; 63
    46da:	f8 94       	cli
    46dc:	de bf       	out	0x3e, r29	; 62
    46de:	0f be       	out	0x3f, r0	; 63
    46e0:	cd bf       	out	0x3d, r28	; 61
    46e2:	cf 91       	pop	r28
    46e4:	df 91       	pop	r29
    46e6:	08 95       	ret

000046e8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    46e8:	df 93       	push	r29
    46ea:	cf 93       	push	r28
    46ec:	00 d0       	rcall	.+0      	; 0x46ee <uxQueueMessagesWaiting+0x6>
    46ee:	0f 92       	push	r0
    46f0:	cd b7       	in	r28, 0x3d	; 61
    46f2:	de b7       	in	r29, 0x3e	; 62
    46f4:	9b 83       	std	Y+3, r25	; 0x03
    46f6:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    46f8:	0f b6       	in	r0, 0x3f	; 63
    46fa:	f8 94       	cli
    46fc:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    46fe:	ea 81       	ldd	r30, Y+2	; 0x02
    4700:	fb 81       	ldd	r31, Y+3	; 0x03
    4702:	82 8d       	ldd	r24, Z+26	; 0x1a
    4704:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4706:	0f 90       	pop	r0
    4708:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    470a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    470c:	0f 90       	pop	r0
    470e:	0f 90       	pop	r0
    4710:	0f 90       	pop	r0
    4712:	cf 91       	pop	r28
    4714:	df 91       	pop	r29
    4716:	08 95       	ret

00004718 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    4718:	df 93       	push	r29
    471a:	cf 93       	push	r28
    471c:	00 d0       	rcall	.+0      	; 0x471e <uxQueueSpacesAvailable+0x6>
    471e:	00 d0       	rcall	.+0      	; 0x4720 <uxQueueSpacesAvailable+0x8>
    4720:	0f 92       	push	r0
    4722:	cd b7       	in	r28, 0x3d	; 61
    4724:	de b7       	in	r29, 0x3e	; 62
    4726:	9d 83       	std	Y+5, r25	; 0x05
    4728:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    472a:	8c 81       	ldd	r24, Y+4	; 0x04
    472c:	9d 81       	ldd	r25, Y+5	; 0x05
    472e:	9a 83       	std	Y+2, r25	; 0x02
    4730:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    4732:	0f b6       	in	r0, 0x3f	; 63
    4734:	f8 94       	cli
    4736:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    4738:	e9 81       	ldd	r30, Y+1	; 0x01
    473a:	fa 81       	ldd	r31, Y+2	; 0x02
    473c:	93 8d       	ldd	r25, Z+27	; 0x1b
    473e:	e9 81       	ldd	r30, Y+1	; 0x01
    4740:	fa 81       	ldd	r31, Y+2	; 0x02
    4742:	82 8d       	ldd	r24, Z+26	; 0x1a
    4744:	29 2f       	mov	r18, r25
    4746:	28 1b       	sub	r18, r24
    4748:	82 2f       	mov	r24, r18
    474a:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    474c:	0f 90       	pop	r0
    474e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    4750:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4752:	0f 90       	pop	r0
    4754:	0f 90       	pop	r0
    4756:	0f 90       	pop	r0
    4758:	0f 90       	pop	r0
    475a:	0f 90       	pop	r0
    475c:	cf 91       	pop	r28
    475e:	df 91       	pop	r29
    4760:	08 95       	ret

00004762 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    4762:	df 93       	push	r29
    4764:	cf 93       	push	r28
    4766:	00 d0       	rcall	.+0      	; 0x4768 <uxQueueMessagesWaitingFromISR+0x6>
    4768:	00 d0       	rcall	.+0      	; 0x476a <uxQueueMessagesWaitingFromISR+0x8>
    476a:	0f 92       	push	r0
    476c:	cd b7       	in	r28, 0x3d	; 61
    476e:	de b7       	in	r29, 0x3e	; 62
    4770:	9d 83       	std	Y+5, r25	; 0x05
    4772:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    4774:	8c 81       	ldd	r24, Y+4	; 0x04
    4776:	9d 81       	ldd	r25, Y+5	; 0x05
    4778:	9a 83       	std	Y+2, r25	; 0x02
    477a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    477c:	e9 81       	ldd	r30, Y+1	; 0x01
    477e:	fa 81       	ldd	r31, Y+2	; 0x02
    4780:	82 8d       	ldd	r24, Z+26	; 0x1a
    4782:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    4784:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4786:	0f 90       	pop	r0
    4788:	0f 90       	pop	r0
    478a:	0f 90       	pop	r0
    478c:	0f 90       	pop	r0
    478e:	0f 90       	pop	r0
    4790:	cf 91       	pop	r28
    4792:	df 91       	pop	r29
    4794:	08 95       	ret

00004796 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    4796:	df 93       	push	r29
    4798:	cf 93       	push	r28
    479a:	00 d0       	rcall	.+0      	; 0x479c <vQueueDelete+0x6>
    479c:	00 d0       	rcall	.+0      	; 0x479e <vQueueDelete+0x8>
    479e:	cd b7       	in	r28, 0x3d	; 61
    47a0:	de b7       	in	r29, 0x3e	; 62
    47a2:	9c 83       	std	Y+4, r25	; 0x04
    47a4:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    47a6:	8b 81       	ldd	r24, Y+3	; 0x03
    47a8:	9c 81       	ldd	r25, Y+4	; 0x04
    47aa:	9a 83       	std	Y+2, r25	; 0x02
    47ac:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    47ae:	89 81       	ldd	r24, Y+1	; 0x01
    47b0:	9a 81       	ldd	r25, Y+2	; 0x02
    47b2:	0e 94 be 18 	call	0x317c	; 0x317c <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    47b6:	0f 90       	pop	r0
    47b8:	0f 90       	pop	r0
    47ba:	0f 90       	pop	r0
    47bc:	0f 90       	pop	r0
    47be:	cf 91       	pop	r28
    47c0:	df 91       	pop	r29
    47c2:	08 95       	ret

000047c4 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    47c4:	df 93       	push	r29
    47c6:	cf 93       	push	r28
    47c8:	cd b7       	in	r28, 0x3d	; 61
    47ca:	de b7       	in	r29, 0x3e	; 62
    47cc:	27 97       	sbiw	r28, 0x07	; 7
    47ce:	0f b6       	in	r0, 0x3f	; 63
    47d0:	f8 94       	cli
    47d2:	de bf       	out	0x3e, r29	; 62
    47d4:	0f be       	out	0x3f, r0	; 63
    47d6:	cd bf       	out	0x3d, r28	; 61
    47d8:	9c 83       	std	Y+4, r25	; 0x04
    47da:	8b 83       	std	Y+3, r24	; 0x03
    47dc:	7e 83       	std	Y+6, r23	; 0x06
    47de:	6d 83       	std	Y+5, r22	; 0x05
    47e0:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    47e2:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    47e4:	eb 81       	ldd	r30, Y+3	; 0x03
    47e6:	fc 81       	ldd	r31, Y+4	; 0x04
    47e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    47ea:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    47ec:	eb 81       	ldd	r30, Y+3	; 0x03
    47ee:	fc 81       	ldd	r31, Y+4	; 0x04
    47f0:	84 8d       	ldd	r24, Z+28	; 0x1c
    47f2:	88 23       	and	r24, r24
    47f4:	09 f4       	brne	.+2      	; 0x47f8 <prvCopyDataToQueue+0x34>
    47f6:	7d c0       	rjmp	.+250    	; 0x48f2 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    47f8:	8f 81       	ldd	r24, Y+7	; 0x07
    47fa:	88 23       	and	r24, r24
    47fc:	99 f5       	brne	.+102    	; 0x4864 <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    47fe:	eb 81       	ldd	r30, Y+3	; 0x03
    4800:	fc 81       	ldd	r31, Y+4	; 0x04
    4802:	62 81       	ldd	r22, Z+2	; 0x02
    4804:	73 81       	ldd	r23, Z+3	; 0x03
    4806:	eb 81       	ldd	r30, Y+3	; 0x03
    4808:	fc 81       	ldd	r31, Y+4	; 0x04
    480a:	84 8d       	ldd	r24, Z+28	; 0x1c
    480c:	48 2f       	mov	r20, r24
    480e:	50 e0       	ldi	r21, 0x00	; 0
    4810:	2d 81       	ldd	r18, Y+5	; 0x05
    4812:	3e 81       	ldd	r19, Y+6	; 0x06
    4814:	cb 01       	movw	r24, r22
    4816:	b9 01       	movw	r22, r18
    4818:	0e 94 1b 35 	call	0x6a36	; 0x6a36 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    481c:	eb 81       	ldd	r30, Y+3	; 0x03
    481e:	fc 81       	ldd	r31, Y+4	; 0x04
    4820:	22 81       	ldd	r18, Z+2	; 0x02
    4822:	33 81       	ldd	r19, Z+3	; 0x03
    4824:	eb 81       	ldd	r30, Y+3	; 0x03
    4826:	fc 81       	ldd	r31, Y+4	; 0x04
    4828:	84 8d       	ldd	r24, Z+28	; 0x1c
    482a:	88 2f       	mov	r24, r24
    482c:	90 e0       	ldi	r25, 0x00	; 0
    482e:	82 0f       	add	r24, r18
    4830:	93 1f       	adc	r25, r19
    4832:	eb 81       	ldd	r30, Y+3	; 0x03
    4834:	fc 81       	ldd	r31, Y+4	; 0x04
    4836:	93 83       	std	Z+3, r25	; 0x03
    4838:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    483a:	eb 81       	ldd	r30, Y+3	; 0x03
    483c:	fc 81       	ldd	r31, Y+4	; 0x04
    483e:	22 81       	ldd	r18, Z+2	; 0x02
    4840:	33 81       	ldd	r19, Z+3	; 0x03
    4842:	eb 81       	ldd	r30, Y+3	; 0x03
    4844:	fc 81       	ldd	r31, Y+4	; 0x04
    4846:	84 81       	ldd	r24, Z+4	; 0x04
    4848:	95 81       	ldd	r25, Z+5	; 0x05
    484a:	28 17       	cp	r18, r24
    484c:	39 07       	cpc	r19, r25
    484e:	08 f4       	brcc	.+2      	; 0x4852 <prvCopyDataToQueue+0x8e>
    4850:	50 c0       	rjmp	.+160    	; 0x48f2 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4852:	eb 81       	ldd	r30, Y+3	; 0x03
    4854:	fc 81       	ldd	r31, Y+4	; 0x04
    4856:	80 81       	ld	r24, Z
    4858:	91 81       	ldd	r25, Z+1	; 0x01
    485a:	eb 81       	ldd	r30, Y+3	; 0x03
    485c:	fc 81       	ldd	r31, Y+4	; 0x04
    485e:	93 83       	std	Z+3, r25	; 0x03
    4860:	82 83       	std	Z+2, r24	; 0x02
    4862:	47 c0       	rjmp	.+142    	; 0x48f2 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    4864:	eb 81       	ldd	r30, Y+3	; 0x03
    4866:	fc 81       	ldd	r31, Y+4	; 0x04
    4868:	66 81       	ldd	r22, Z+6	; 0x06
    486a:	77 81       	ldd	r23, Z+7	; 0x07
    486c:	eb 81       	ldd	r30, Y+3	; 0x03
    486e:	fc 81       	ldd	r31, Y+4	; 0x04
    4870:	84 8d       	ldd	r24, Z+28	; 0x1c
    4872:	48 2f       	mov	r20, r24
    4874:	50 e0       	ldi	r21, 0x00	; 0
    4876:	2d 81       	ldd	r18, Y+5	; 0x05
    4878:	3e 81       	ldd	r19, Y+6	; 0x06
    487a:	cb 01       	movw	r24, r22
    487c:	b9 01       	movw	r22, r18
    487e:	0e 94 1b 35 	call	0x6a36	; 0x6a36 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    4882:	eb 81       	ldd	r30, Y+3	; 0x03
    4884:	fc 81       	ldd	r31, Y+4	; 0x04
    4886:	26 81       	ldd	r18, Z+6	; 0x06
    4888:	37 81       	ldd	r19, Z+7	; 0x07
    488a:	eb 81       	ldd	r30, Y+3	; 0x03
    488c:	fc 81       	ldd	r31, Y+4	; 0x04
    488e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4890:	88 2f       	mov	r24, r24
    4892:	90 e0       	ldi	r25, 0x00	; 0
    4894:	90 95       	com	r25
    4896:	81 95       	neg	r24
    4898:	9f 4f       	sbci	r25, 0xFF	; 255
    489a:	82 0f       	add	r24, r18
    489c:	93 1f       	adc	r25, r19
    489e:	eb 81       	ldd	r30, Y+3	; 0x03
    48a0:	fc 81       	ldd	r31, Y+4	; 0x04
    48a2:	97 83       	std	Z+7, r25	; 0x07
    48a4:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    48a6:	eb 81       	ldd	r30, Y+3	; 0x03
    48a8:	fc 81       	ldd	r31, Y+4	; 0x04
    48aa:	26 81       	ldd	r18, Z+6	; 0x06
    48ac:	37 81       	ldd	r19, Z+7	; 0x07
    48ae:	eb 81       	ldd	r30, Y+3	; 0x03
    48b0:	fc 81       	ldd	r31, Y+4	; 0x04
    48b2:	80 81       	ld	r24, Z
    48b4:	91 81       	ldd	r25, Z+1	; 0x01
    48b6:	28 17       	cp	r18, r24
    48b8:	39 07       	cpc	r19, r25
    48ba:	90 f4       	brcc	.+36     	; 0x48e0 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    48bc:	eb 81       	ldd	r30, Y+3	; 0x03
    48be:	fc 81       	ldd	r31, Y+4	; 0x04
    48c0:	24 81       	ldd	r18, Z+4	; 0x04
    48c2:	35 81       	ldd	r19, Z+5	; 0x05
    48c4:	eb 81       	ldd	r30, Y+3	; 0x03
    48c6:	fc 81       	ldd	r31, Y+4	; 0x04
    48c8:	84 8d       	ldd	r24, Z+28	; 0x1c
    48ca:	88 2f       	mov	r24, r24
    48cc:	90 e0       	ldi	r25, 0x00	; 0
    48ce:	90 95       	com	r25
    48d0:	81 95       	neg	r24
    48d2:	9f 4f       	sbci	r25, 0xFF	; 255
    48d4:	82 0f       	add	r24, r18
    48d6:	93 1f       	adc	r25, r19
    48d8:	eb 81       	ldd	r30, Y+3	; 0x03
    48da:	fc 81       	ldd	r31, Y+4	; 0x04
    48dc:	97 83       	std	Z+7, r25	; 0x07
    48de:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    48e0:	8f 81       	ldd	r24, Y+7	; 0x07
    48e2:	82 30       	cpi	r24, 0x02	; 2
    48e4:	31 f4       	brne	.+12     	; 0x48f2 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    48e6:	89 81       	ldd	r24, Y+1	; 0x01
    48e8:	88 23       	and	r24, r24
    48ea:	19 f0       	breq	.+6      	; 0x48f2 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    48ec:	89 81       	ldd	r24, Y+1	; 0x01
    48ee:	81 50       	subi	r24, 0x01	; 1
    48f0:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    48f2:	89 81       	ldd	r24, Y+1	; 0x01
    48f4:	8f 5f       	subi	r24, 0xFF	; 255
    48f6:	eb 81       	ldd	r30, Y+3	; 0x03
    48f8:	fc 81       	ldd	r31, Y+4	; 0x04
    48fa:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    48fc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    48fe:	27 96       	adiw	r28, 0x07	; 7
    4900:	0f b6       	in	r0, 0x3f	; 63
    4902:	f8 94       	cli
    4904:	de bf       	out	0x3e, r29	; 62
    4906:	0f be       	out	0x3f, r0	; 63
    4908:	cd bf       	out	0x3d, r28	; 61
    490a:	cf 91       	pop	r28
    490c:	df 91       	pop	r29
    490e:	08 95       	ret

00004910 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    4910:	df 93       	push	r29
    4912:	cf 93       	push	r28
    4914:	00 d0       	rcall	.+0      	; 0x4916 <prvCopyDataFromQueue+0x6>
    4916:	00 d0       	rcall	.+0      	; 0x4918 <prvCopyDataFromQueue+0x8>
    4918:	cd b7       	in	r28, 0x3d	; 61
    491a:	de b7       	in	r29, 0x3e	; 62
    491c:	9a 83       	std	Y+2, r25	; 0x02
    491e:	89 83       	std	Y+1, r24	; 0x01
    4920:	7c 83       	std	Y+4, r23	; 0x04
    4922:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    4924:	e9 81       	ldd	r30, Y+1	; 0x01
    4926:	fa 81       	ldd	r31, Y+2	; 0x02
    4928:	84 8d       	ldd	r24, Z+28	; 0x1c
    492a:	88 23       	and	r24, r24
    492c:	89 f1       	breq	.+98     	; 0x4990 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    492e:	e9 81       	ldd	r30, Y+1	; 0x01
    4930:	fa 81       	ldd	r31, Y+2	; 0x02
    4932:	26 81       	ldd	r18, Z+6	; 0x06
    4934:	37 81       	ldd	r19, Z+7	; 0x07
    4936:	e9 81       	ldd	r30, Y+1	; 0x01
    4938:	fa 81       	ldd	r31, Y+2	; 0x02
    493a:	84 8d       	ldd	r24, Z+28	; 0x1c
    493c:	88 2f       	mov	r24, r24
    493e:	90 e0       	ldi	r25, 0x00	; 0
    4940:	82 0f       	add	r24, r18
    4942:	93 1f       	adc	r25, r19
    4944:	e9 81       	ldd	r30, Y+1	; 0x01
    4946:	fa 81       	ldd	r31, Y+2	; 0x02
    4948:	97 83       	std	Z+7, r25	; 0x07
    494a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    494c:	e9 81       	ldd	r30, Y+1	; 0x01
    494e:	fa 81       	ldd	r31, Y+2	; 0x02
    4950:	26 81       	ldd	r18, Z+6	; 0x06
    4952:	37 81       	ldd	r19, Z+7	; 0x07
    4954:	e9 81       	ldd	r30, Y+1	; 0x01
    4956:	fa 81       	ldd	r31, Y+2	; 0x02
    4958:	84 81       	ldd	r24, Z+4	; 0x04
    495a:	95 81       	ldd	r25, Z+5	; 0x05
    495c:	28 17       	cp	r18, r24
    495e:	39 07       	cpc	r19, r25
    4960:	40 f0       	brcs	.+16     	; 0x4972 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    4962:	e9 81       	ldd	r30, Y+1	; 0x01
    4964:	fa 81       	ldd	r31, Y+2	; 0x02
    4966:	80 81       	ld	r24, Z
    4968:	91 81       	ldd	r25, Z+1	; 0x01
    496a:	e9 81       	ldd	r30, Y+1	; 0x01
    496c:	fa 81       	ldd	r31, Y+2	; 0x02
    496e:	97 83       	std	Z+7, r25	; 0x07
    4970:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    4972:	e9 81       	ldd	r30, Y+1	; 0x01
    4974:	fa 81       	ldd	r31, Y+2	; 0x02
    4976:	46 81       	ldd	r20, Z+6	; 0x06
    4978:	57 81       	ldd	r21, Z+7	; 0x07
    497a:	e9 81       	ldd	r30, Y+1	; 0x01
    497c:	fa 81       	ldd	r31, Y+2	; 0x02
    497e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4980:	28 2f       	mov	r18, r24
    4982:	30 e0       	ldi	r19, 0x00	; 0
    4984:	8b 81       	ldd	r24, Y+3	; 0x03
    4986:	9c 81       	ldd	r25, Y+4	; 0x04
    4988:	ba 01       	movw	r22, r20
    498a:	a9 01       	movw	r20, r18
    498c:	0e 94 1b 35 	call	0x6a36	; 0x6a36 <memcpy>
	}
}
    4990:	0f 90       	pop	r0
    4992:	0f 90       	pop	r0
    4994:	0f 90       	pop	r0
    4996:	0f 90       	pop	r0
    4998:	cf 91       	pop	r28
    499a:	df 91       	pop	r29
    499c:	08 95       	ret

0000499e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    499e:	df 93       	push	r29
    49a0:	cf 93       	push	r28
    49a2:	00 d0       	rcall	.+0      	; 0x49a4 <prvUnlockQueue+0x6>
    49a4:	00 d0       	rcall	.+0      	; 0x49a6 <prvUnlockQueue+0x8>
    49a6:	cd b7       	in	r28, 0x3d	; 61
    49a8:	de b7       	in	r29, 0x3e	; 62
    49aa:	9c 83       	std	Y+4, r25	; 0x04
    49ac:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    49ae:	0f b6       	in	r0, 0x3f	; 63
    49b0:	f8 94       	cli
    49b2:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    49b4:	eb 81       	ldd	r30, Y+3	; 0x03
    49b6:	fc 81       	ldd	r31, Y+4	; 0x04
    49b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    49ba:	8a 83       	std	Y+2, r24	; 0x02
    49bc:	11 c0       	rjmp	.+34     	; 0x49e0 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    49be:	eb 81       	ldd	r30, Y+3	; 0x03
    49c0:	fc 81       	ldd	r31, Y+4	; 0x04
    49c2:	81 89       	ldd	r24, Z+17	; 0x11
    49c4:	88 23       	and	r24, r24
    49c6:	79 f0       	breq	.+30     	; 0x49e6 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    49c8:	8b 81       	ldd	r24, Y+3	; 0x03
    49ca:	9c 81       	ldd	r25, Y+4	; 0x04
    49cc:	41 96       	adiw	r24, 0x11	; 17
    49ce:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    49d2:	88 23       	and	r24, r24
    49d4:	11 f0       	breq	.+4      	; 0x49da <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    49d6:	0e 94 57 2f 	call	0x5eae	; 0x5eae <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    49da:	8a 81       	ldd	r24, Y+2	; 0x02
    49dc:	81 50       	subi	r24, 0x01	; 1
    49de:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    49e0:	8a 81       	ldd	r24, Y+2	; 0x02
    49e2:	18 16       	cp	r1, r24
    49e4:	64 f3       	brlt	.-40     	; 0x49be <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    49e6:	eb 81       	ldd	r30, Y+3	; 0x03
    49e8:	fc 81       	ldd	r31, Y+4	; 0x04
    49ea:	8f ef       	ldi	r24, 0xFF	; 255
    49ec:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    49ee:	0f 90       	pop	r0
    49f0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    49f2:	0f b6       	in	r0, 0x3f	; 63
    49f4:	f8 94       	cli
    49f6:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    49f8:	eb 81       	ldd	r30, Y+3	; 0x03
    49fa:	fc 81       	ldd	r31, Y+4	; 0x04
    49fc:	85 8d       	ldd	r24, Z+29	; 0x1d
    49fe:	89 83       	std	Y+1, r24	; 0x01
    4a00:	11 c0       	rjmp	.+34     	; 0x4a24 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4a02:	eb 81       	ldd	r30, Y+3	; 0x03
    4a04:	fc 81       	ldd	r31, Y+4	; 0x04
    4a06:	80 85       	ldd	r24, Z+8	; 0x08
    4a08:	88 23       	and	r24, r24
    4a0a:	79 f0       	breq	.+30     	; 0x4a2a <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4a0c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a0e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a10:	08 96       	adiw	r24, 0x08	; 8
    4a12:	0e 94 eb 2d 	call	0x5bd6	; 0x5bd6 <xTaskRemoveFromEventList>
    4a16:	88 23       	and	r24, r24
    4a18:	11 f0       	breq	.+4      	; 0x4a1e <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    4a1a:	0e 94 57 2f 	call	0x5eae	; 0x5eae <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    4a1e:	89 81       	ldd	r24, Y+1	; 0x01
    4a20:	81 50       	subi	r24, 0x01	; 1
    4a22:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    4a24:	89 81       	ldd	r24, Y+1	; 0x01
    4a26:	18 16       	cp	r1, r24
    4a28:	64 f3       	brlt	.-40     	; 0x4a02 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    4a2a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a2c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a2e:	8f ef       	ldi	r24, 0xFF	; 255
    4a30:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4a32:	0f 90       	pop	r0
    4a34:	0f be       	out	0x3f, r0	; 63
}
    4a36:	0f 90       	pop	r0
    4a38:	0f 90       	pop	r0
    4a3a:	0f 90       	pop	r0
    4a3c:	0f 90       	pop	r0
    4a3e:	cf 91       	pop	r28
    4a40:	df 91       	pop	r29
    4a42:	08 95       	ret

00004a44 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    4a44:	df 93       	push	r29
    4a46:	cf 93       	push	r28
    4a48:	00 d0       	rcall	.+0      	; 0x4a4a <prvIsQueueEmpty+0x6>
    4a4a:	0f 92       	push	r0
    4a4c:	cd b7       	in	r28, 0x3d	; 61
    4a4e:	de b7       	in	r29, 0x3e	; 62
    4a50:	9b 83       	std	Y+3, r25	; 0x03
    4a52:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4a54:	0f b6       	in	r0, 0x3f	; 63
    4a56:	f8 94       	cli
    4a58:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    4a5a:	ea 81       	ldd	r30, Y+2	; 0x02
    4a5c:	fb 81       	ldd	r31, Y+3	; 0x03
    4a5e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4a60:	88 23       	and	r24, r24
    4a62:	19 f4       	brne	.+6      	; 0x4a6a <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    4a64:	81 e0       	ldi	r24, 0x01	; 1
    4a66:	89 83       	std	Y+1, r24	; 0x01
    4a68:	01 c0       	rjmp	.+2      	; 0x4a6c <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    4a6a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4a6c:	0f 90       	pop	r0
    4a6e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4a70:	89 81       	ldd	r24, Y+1	; 0x01
}
    4a72:	0f 90       	pop	r0
    4a74:	0f 90       	pop	r0
    4a76:	0f 90       	pop	r0
    4a78:	cf 91       	pop	r28
    4a7a:	df 91       	pop	r29
    4a7c:	08 95       	ret

00004a7e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    4a7e:	df 93       	push	r29
    4a80:	cf 93       	push	r28
    4a82:	00 d0       	rcall	.+0      	; 0x4a84 <xQueueIsQueueEmptyFromISR+0x6>
    4a84:	00 d0       	rcall	.+0      	; 0x4a86 <xQueueIsQueueEmptyFromISR+0x8>
    4a86:	0f 92       	push	r0
    4a88:	cd b7       	in	r28, 0x3d	; 61
    4a8a:	de b7       	in	r29, 0x3e	; 62
    4a8c:	9d 83       	std	Y+5, r25	; 0x05
    4a8e:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    4a90:	8c 81       	ldd	r24, Y+4	; 0x04
    4a92:	9d 81       	ldd	r25, Y+5	; 0x05
    4a94:	9a 83       	std	Y+2, r25	; 0x02
    4a96:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    4a98:	e9 81       	ldd	r30, Y+1	; 0x01
    4a9a:	fa 81       	ldd	r31, Y+2	; 0x02
    4a9c:	82 8d       	ldd	r24, Z+26	; 0x1a
    4a9e:	88 23       	and	r24, r24
    4aa0:	19 f4       	brne	.+6      	; 0x4aa8 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    4aa2:	81 e0       	ldi	r24, 0x01	; 1
    4aa4:	8b 83       	std	Y+3, r24	; 0x03
    4aa6:	01 c0       	rjmp	.+2      	; 0x4aaa <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    4aa8:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    4aaa:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4aac:	0f 90       	pop	r0
    4aae:	0f 90       	pop	r0
    4ab0:	0f 90       	pop	r0
    4ab2:	0f 90       	pop	r0
    4ab4:	0f 90       	pop	r0
    4ab6:	cf 91       	pop	r28
    4ab8:	df 91       	pop	r29
    4aba:	08 95       	ret

00004abc <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    4abc:	df 93       	push	r29
    4abe:	cf 93       	push	r28
    4ac0:	00 d0       	rcall	.+0      	; 0x4ac2 <prvIsQueueFull+0x6>
    4ac2:	0f 92       	push	r0
    4ac4:	cd b7       	in	r28, 0x3d	; 61
    4ac6:	de b7       	in	r29, 0x3e	; 62
    4ac8:	9b 83       	std	Y+3, r25	; 0x03
    4aca:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4acc:	0f b6       	in	r0, 0x3f	; 63
    4ace:	f8 94       	cli
    4ad0:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4ad2:	ea 81       	ldd	r30, Y+2	; 0x02
    4ad4:	fb 81       	ldd	r31, Y+3	; 0x03
    4ad6:	92 8d       	ldd	r25, Z+26	; 0x1a
    4ad8:	ea 81       	ldd	r30, Y+2	; 0x02
    4ada:	fb 81       	ldd	r31, Y+3	; 0x03
    4adc:	83 8d       	ldd	r24, Z+27	; 0x1b
    4ade:	98 17       	cp	r25, r24
    4ae0:	19 f4       	brne	.+6      	; 0x4ae8 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    4ae2:	81 e0       	ldi	r24, 0x01	; 1
    4ae4:	89 83       	std	Y+1, r24	; 0x01
    4ae6:	01 c0       	rjmp	.+2      	; 0x4aea <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    4ae8:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4aea:	0f 90       	pop	r0
    4aec:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4aee:	89 81       	ldd	r24, Y+1	; 0x01
}
    4af0:	0f 90       	pop	r0
    4af2:	0f 90       	pop	r0
    4af4:	0f 90       	pop	r0
    4af6:	cf 91       	pop	r28
    4af8:	df 91       	pop	r29
    4afa:	08 95       	ret

00004afc <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    4afc:	df 93       	push	r29
    4afe:	cf 93       	push	r28
    4b00:	00 d0       	rcall	.+0      	; 0x4b02 <xQueueIsQueueFullFromISR+0x6>
    4b02:	00 d0       	rcall	.+0      	; 0x4b04 <xQueueIsQueueFullFromISR+0x8>
    4b04:	0f 92       	push	r0
    4b06:	cd b7       	in	r28, 0x3d	; 61
    4b08:	de b7       	in	r29, 0x3e	; 62
    4b0a:	9d 83       	std	Y+5, r25	; 0x05
    4b0c:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    4b0e:	8c 81       	ldd	r24, Y+4	; 0x04
    4b10:	9d 81       	ldd	r25, Y+5	; 0x05
    4b12:	9a 83       	std	Y+2, r25	; 0x02
    4b14:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    4b16:	e9 81       	ldd	r30, Y+1	; 0x01
    4b18:	fa 81       	ldd	r31, Y+2	; 0x02
    4b1a:	92 8d       	ldd	r25, Z+26	; 0x1a
    4b1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4b1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4b20:	83 8d       	ldd	r24, Z+27	; 0x1b
    4b22:	98 17       	cp	r25, r24
    4b24:	19 f4       	brne	.+6      	; 0x4b2c <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    4b26:	81 e0       	ldi	r24, 0x01	; 1
    4b28:	8b 83       	std	Y+3, r24	; 0x03
    4b2a:	01 c0       	rjmp	.+2      	; 0x4b2e <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    4b2c:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    4b2e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    4b30:	0f 90       	pop	r0
    4b32:	0f 90       	pop	r0
    4b34:	0f 90       	pop	r0
    4b36:	0f 90       	pop	r0
    4b38:	0f 90       	pop	r0
    4b3a:	cf 91       	pop	r28
    4b3c:	df 91       	pop	r29
    4b3e:	08 95       	ret

00004b40 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    4b40:	8f 92       	push	r8
    4b42:	9f 92       	push	r9
    4b44:	af 92       	push	r10
    4b46:	bf 92       	push	r11
    4b48:	cf 92       	push	r12
    4b4a:	df 92       	push	r13
    4b4c:	ef 92       	push	r14
    4b4e:	ff 92       	push	r15
    4b50:	0f 93       	push	r16
    4b52:	1f 93       	push	r17
    4b54:	df 93       	push	r29
    4b56:	cf 93       	push	r28
    4b58:	cd b7       	in	r28, 0x3d	; 61
    4b5a:	de b7       	in	r29, 0x3e	; 62
    4b5c:	60 97       	sbiw	r28, 0x10	; 16
    4b5e:	0f b6       	in	r0, 0x3f	; 63
    4b60:	f8 94       	cli
    4b62:	de bf       	out	0x3e, r29	; 62
    4b64:	0f be       	out	0x3f, r0	; 63
    4b66:	cd bf       	out	0x3d, r28	; 61
    4b68:	9f 83       	std	Y+7, r25	; 0x07
    4b6a:	8e 83       	std	Y+6, r24	; 0x06
    4b6c:	79 87       	std	Y+9, r23	; 0x09
    4b6e:	68 87       	std	Y+8, r22	; 0x08
    4b70:	5b 87       	std	Y+11, r21	; 0x0b
    4b72:	4a 87       	std	Y+10, r20	; 0x0a
    4b74:	3d 87       	std	Y+13, r19	; 0x0d
    4b76:	2c 87       	std	Y+12, r18	; 0x0c
    4b78:	0e 87       	std	Y+14, r16	; 0x0e
    4b7a:	f8 8a       	std	Y+16, r15	; 0x10
    4b7c:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    4b7e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b80:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b82:	0e 94 68 18 	call	0x30d0	; 0x30d0 <pvPortMalloc>
    4b86:	9a 83       	std	Y+2, r25	; 0x02
    4b88:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    4b8a:	89 81       	ldd	r24, Y+1	; 0x01
    4b8c:	9a 81       	ldd	r25, Y+2	; 0x02
    4b8e:	00 97       	sbiw	r24, 0x00	; 0
    4b90:	b1 f0       	breq	.+44     	; 0x4bbe <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    4b92:	86 e2       	ldi	r24, 0x26	; 38
    4b94:	90 e0       	ldi	r25, 0x00	; 0
    4b96:	0e 94 68 18 	call	0x30d0	; 0x30d0 <pvPortMalloc>
    4b9a:	9d 83       	std	Y+5, r25	; 0x05
    4b9c:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    4b9e:	8c 81       	ldd	r24, Y+4	; 0x04
    4ba0:	9d 81       	ldd	r25, Y+5	; 0x05
    4ba2:	00 97       	sbiw	r24, 0x00	; 0
    4ba4:	39 f0       	breq	.+14     	; 0x4bb4 <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    4ba6:	ec 81       	ldd	r30, Y+4	; 0x04
    4ba8:	fd 81       	ldd	r31, Y+5	; 0x05
    4baa:	89 81       	ldd	r24, Y+1	; 0x01
    4bac:	9a 81       	ldd	r25, Y+2	; 0x02
    4bae:	90 8f       	std	Z+24, r25	; 0x18
    4bb0:	87 8b       	std	Z+23, r24	; 0x17
    4bb2:	07 c0       	rjmp	.+14     	; 0x4bc2 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    4bb4:	89 81       	ldd	r24, Y+1	; 0x01
    4bb6:	9a 81       	ldd	r25, Y+2	; 0x02
    4bb8:	0e 94 be 18 	call	0x317c	; 0x317c <vPortFree>
    4bbc:	02 c0       	rjmp	.+4      	; 0x4bc2 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    4bbe:	1d 82       	std	Y+5, r1	; 0x05
    4bc0:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    4bc2:	8c 81       	ldd	r24, Y+4	; 0x04
    4bc4:	9d 81       	ldd	r25, Y+5	; 0x05
    4bc6:	00 97       	sbiw	r24, 0x00	; 0
    4bc8:	e9 f0       	breq	.+58     	; 0x4c04 <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    4bca:	8a 85       	ldd	r24, Y+10	; 0x0a
    4bcc:	9b 85       	ldd	r25, Y+11	; 0x0b
    4bce:	9c 01       	movw	r18, r24
    4bd0:	40 e0       	ldi	r20, 0x00	; 0
    4bd2:	50 e0       	ldi	r21, 0x00	; 0
    4bd4:	8e 81       	ldd	r24, Y+6	; 0x06
    4bd6:	9f 81       	ldd	r25, Y+7	; 0x07
    4bd8:	68 85       	ldd	r22, Y+8	; 0x08
    4bda:	79 85       	ldd	r23, Y+9	; 0x09
    4bdc:	ec 85       	ldd	r30, Y+12	; 0x0c
    4bde:	fd 85       	ldd	r31, Y+13	; 0x0d
    4be0:	af 85       	ldd	r26, Y+15	; 0x0f
    4be2:	b8 89       	ldd	r27, Y+16	; 0x10
    4be4:	ac 80       	ldd	r10, Y+4	; 0x04
    4be6:	bd 80       	ldd	r11, Y+5	; 0x05
    4be8:	8f 01       	movw	r16, r30
    4bea:	ee 84       	ldd	r14, Y+14	; 0x0e
    4bec:	6d 01       	movw	r12, r26
    4bee:	88 24       	eor	r8, r8
    4bf0:	99 24       	eor	r9, r9
    4bf2:	0e 94 18 26 	call	0x4c30	; 0x4c30 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    4bf6:	8c 81       	ldd	r24, Y+4	; 0x04
    4bf8:	9d 81       	ldd	r25, Y+5	; 0x05
    4bfa:	0e 94 d4 26 	call	0x4da8	; 0x4da8 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    4bfe:	81 e0       	ldi	r24, 0x01	; 1
    4c00:	8b 83       	std	Y+3, r24	; 0x03
    4c02:	02 c0       	rjmp	.+4      	; 0x4c08 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4c04:	8f ef       	ldi	r24, 0xFF	; 255
    4c06:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    4c08:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    4c0a:	60 96       	adiw	r28, 0x10	; 16
    4c0c:	0f b6       	in	r0, 0x3f	; 63
    4c0e:	f8 94       	cli
    4c10:	de bf       	out	0x3e, r29	; 62
    4c12:	0f be       	out	0x3f, r0	; 63
    4c14:	cd bf       	out	0x3d, r28	; 61
    4c16:	cf 91       	pop	r28
    4c18:	df 91       	pop	r29
    4c1a:	1f 91       	pop	r17
    4c1c:	0f 91       	pop	r16
    4c1e:	ff 90       	pop	r15
    4c20:	ef 90       	pop	r14
    4c22:	df 90       	pop	r13
    4c24:	cf 90       	pop	r12
    4c26:	bf 90       	pop	r11
    4c28:	af 90       	pop	r10
    4c2a:	9f 90       	pop	r9
    4c2c:	8f 90       	pop	r8
    4c2e:	08 95       	ret

00004c30 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    4c30:	8f 92       	push	r8
    4c32:	9f 92       	push	r9
    4c34:	af 92       	push	r10
    4c36:	bf 92       	push	r11
    4c38:	cf 92       	push	r12
    4c3a:	df 92       	push	r13
    4c3c:	ef 92       	push	r14
    4c3e:	0f 93       	push	r16
    4c40:	1f 93       	push	r17
    4c42:	df 93       	push	r29
    4c44:	cf 93       	push	r28
    4c46:	cd b7       	in	r28, 0x3d	; 61
    4c48:	de b7       	in	r29, 0x3e	; 62
    4c4a:	64 97       	sbiw	r28, 0x14	; 20
    4c4c:	0f b6       	in	r0, 0x3f	; 63
    4c4e:	f8 94       	cli
    4c50:	de bf       	out	0x3e, r29	; 62
    4c52:	0f be       	out	0x3f, r0	; 63
    4c54:	cd bf       	out	0x3d, r28	; 61
    4c56:	9d 83       	std	Y+5, r25	; 0x05
    4c58:	8c 83       	std	Y+4, r24	; 0x04
    4c5a:	7f 83       	std	Y+7, r23	; 0x07
    4c5c:	6e 83       	std	Y+6, r22	; 0x06
    4c5e:	28 87       	std	Y+8, r18	; 0x08
    4c60:	39 87       	std	Y+9, r19	; 0x09
    4c62:	4a 87       	std	Y+10, r20	; 0x0a
    4c64:	5b 87       	std	Y+11, r21	; 0x0b
    4c66:	1d 87       	std	Y+13, r17	; 0x0d
    4c68:	0c 87       	std	Y+12, r16	; 0x0c
    4c6a:	ee 86       	std	Y+14, r14	; 0x0e
    4c6c:	d8 8a       	std	Y+16, r13	; 0x10
    4c6e:	cf 86       	std	Y+15, r12	; 0x0f
    4c70:	ba 8a       	std	Y+18, r11	; 0x12
    4c72:	a9 8a       	std	Y+17, r10	; 0x11
    4c74:	9c 8a       	std	Y+20, r9	; 0x14
    4c76:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    4c78:	e9 89       	ldd	r30, Y+17	; 0x11
    4c7a:	fa 89       	ldd	r31, Y+18	; 0x12
    4c7c:	27 89       	ldd	r18, Z+23	; 0x17
    4c7e:	30 8d       	ldd	r19, Z+24	; 0x18
    4c80:	88 85       	ldd	r24, Y+8	; 0x08
    4c82:	99 85       	ldd	r25, Y+9	; 0x09
    4c84:	01 97       	sbiw	r24, 0x01	; 1
    4c86:	82 0f       	add	r24, r18
    4c88:	93 1f       	adc	r25, r19
    4c8a:	9b 83       	std	Y+3, r25	; 0x03
    4c8c:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    4c8e:	8e 81       	ldd	r24, Y+6	; 0x06
    4c90:	9f 81       	ldd	r25, Y+7	; 0x07
    4c92:	00 97       	sbiw	r24, 0x00	; 0
    4c94:	51 f1       	breq	.+84     	; 0x4cea <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4c96:	19 82       	std	Y+1, r1	; 0x01
    4c98:	21 c0       	rjmp	.+66     	; 0x4cdc <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    4c9a:	89 81       	ldd	r24, Y+1	; 0x01
    4c9c:	48 2f       	mov	r20, r24
    4c9e:	50 e0       	ldi	r21, 0x00	; 0
    4ca0:	89 81       	ldd	r24, Y+1	; 0x01
    4ca2:	28 2f       	mov	r18, r24
    4ca4:	30 e0       	ldi	r19, 0x00	; 0
    4ca6:	8e 81       	ldd	r24, Y+6	; 0x06
    4ca8:	9f 81       	ldd	r25, Y+7	; 0x07
    4caa:	fc 01       	movw	r30, r24
    4cac:	e2 0f       	add	r30, r18
    4cae:	f3 1f       	adc	r31, r19
    4cb0:	20 81       	ld	r18, Z
    4cb2:	89 89       	ldd	r24, Y+17	; 0x11
    4cb4:	9a 89       	ldd	r25, Y+18	; 0x12
    4cb6:	84 0f       	add	r24, r20
    4cb8:	95 1f       	adc	r25, r21
    4cba:	fc 01       	movw	r30, r24
    4cbc:	79 96       	adiw	r30, 0x19	; 25
    4cbe:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    4cc0:	89 81       	ldd	r24, Y+1	; 0x01
    4cc2:	28 2f       	mov	r18, r24
    4cc4:	30 e0       	ldi	r19, 0x00	; 0
    4cc6:	8e 81       	ldd	r24, Y+6	; 0x06
    4cc8:	9f 81       	ldd	r25, Y+7	; 0x07
    4cca:	fc 01       	movw	r30, r24
    4ccc:	e2 0f       	add	r30, r18
    4cce:	f3 1f       	adc	r31, r19
    4cd0:	80 81       	ld	r24, Z
    4cd2:	88 23       	and	r24, r24
    4cd4:	31 f0       	breq	.+12     	; 0x4ce2 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    4cd6:	89 81       	ldd	r24, Y+1	; 0x01
    4cd8:	8f 5f       	subi	r24, 0xFF	; 255
    4cda:	89 83       	std	Y+1, r24	; 0x01
    4cdc:	89 81       	ldd	r24, Y+1	; 0x01
    4cde:	88 30       	cpi	r24, 0x08	; 8
    4ce0:	e0 f2       	brcs	.-72     	; 0x4c9a <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    4ce2:	e9 89       	ldd	r30, Y+17	; 0x11
    4ce4:	fa 89       	ldd	r31, Y+18	; 0x12
    4ce6:	10 a2       	std	Z+32, r1	; 0x20
    4ce8:	03 c0       	rjmp	.+6      	; 0x4cf0 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    4cea:	e9 89       	ldd	r30, Y+17	; 0x11
    4cec:	fa 89       	ldd	r31, Y+18	; 0x12
    4cee:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    4cf0:	8e 85       	ldd	r24, Y+14	; 0x0e
    4cf2:	85 30       	cpi	r24, 0x05	; 5
    4cf4:	10 f0       	brcs	.+4      	; 0x4cfa <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    4cf6:	84 e0       	ldi	r24, 0x04	; 4
    4cf8:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    4cfa:	e9 89       	ldd	r30, Y+17	; 0x11
    4cfc:	fa 89       	ldd	r31, Y+18	; 0x12
    4cfe:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d00:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    4d02:	89 89       	ldd	r24, Y+17	; 0x11
    4d04:	9a 89       	ldd	r25, Y+18	; 0x12
    4d06:	02 96       	adiw	r24, 0x02	; 2
    4d08:	0e 94 0e 19 	call	0x321c	; 0x321c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    4d0c:	89 89       	ldd	r24, Y+17	; 0x11
    4d0e:	9a 89       	ldd	r25, Y+18	; 0x12
    4d10:	0c 96       	adiw	r24, 0x0c	; 12
    4d12:	0e 94 0e 19 	call	0x321c	; 0x321c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    4d16:	e9 89       	ldd	r30, Y+17	; 0x11
    4d18:	fa 89       	ldd	r31, Y+18	; 0x12
    4d1a:	89 89       	ldd	r24, Y+17	; 0x11
    4d1c:	9a 89       	ldd	r25, Y+18	; 0x12
    4d1e:	91 87       	std	Z+9, r25	; 0x09
    4d20:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4d22:	8e 85       	ldd	r24, Y+14	; 0x0e
    4d24:	28 2f       	mov	r18, r24
    4d26:	30 e0       	ldi	r19, 0x00	; 0
    4d28:	85 e0       	ldi	r24, 0x05	; 5
    4d2a:	90 e0       	ldi	r25, 0x00	; 0
    4d2c:	82 1b       	sub	r24, r18
    4d2e:	93 0b       	sbc	r25, r19
    4d30:	e9 89       	ldd	r30, Y+17	; 0x11
    4d32:	fa 89       	ldd	r31, Y+18	; 0x12
    4d34:	95 87       	std	Z+13, r25	; 0x0d
    4d36:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    4d38:	e9 89       	ldd	r30, Y+17	; 0x11
    4d3a:	fa 89       	ldd	r31, Y+18	; 0x12
    4d3c:	89 89       	ldd	r24, Y+17	; 0x11
    4d3e:	9a 89       	ldd	r25, Y+18	; 0x12
    4d40:	93 8b       	std	Z+19, r25	; 0x13
    4d42:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    4d44:	e9 89       	ldd	r30, Y+17	; 0x11
    4d46:	fa 89       	ldd	r31, Y+18	; 0x12
    4d48:	11 a2       	std	Z+33, r1	; 0x21
    4d4a:	12 a2       	std	Z+34, r1	; 0x22
    4d4c:	13 a2       	std	Z+35, r1	; 0x23
    4d4e:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4d50:	e9 89       	ldd	r30, Y+17	; 0x11
    4d52:	fa 89       	ldd	r31, Y+18	; 0x12
    4d54:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4d56:	8a 81       	ldd	r24, Y+2	; 0x02
    4d58:	9b 81       	ldd	r25, Y+3	; 0x03
    4d5a:	2c 81       	ldd	r18, Y+4	; 0x04
    4d5c:	3d 81       	ldd	r19, Y+5	; 0x05
    4d5e:	4c 85       	ldd	r20, Y+12	; 0x0c
    4d60:	5d 85       	ldd	r21, Y+13	; 0x0d
    4d62:	b9 01       	movw	r22, r18
    4d64:	0e 94 ac 1b 	call	0x3758	; 0x3758 <pxPortInitialiseStack>
    4d68:	e9 89       	ldd	r30, Y+17	; 0x11
    4d6a:	fa 89       	ldd	r31, Y+18	; 0x12
    4d6c:	91 83       	std	Z+1, r25	; 0x01
    4d6e:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    4d70:	8f 85       	ldd	r24, Y+15	; 0x0f
    4d72:	98 89       	ldd	r25, Y+16	; 0x10
    4d74:	00 97       	sbiw	r24, 0x00	; 0
    4d76:	31 f0       	breq	.+12     	; 0x4d84 <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4d78:	ef 85       	ldd	r30, Y+15	; 0x0f
    4d7a:	f8 89       	ldd	r31, Y+16	; 0x10
    4d7c:	89 89       	ldd	r24, Y+17	; 0x11
    4d7e:	9a 89       	ldd	r25, Y+18	; 0x12
    4d80:	91 83       	std	Z+1, r25	; 0x01
    4d82:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4d84:	64 96       	adiw	r28, 0x14	; 20
    4d86:	0f b6       	in	r0, 0x3f	; 63
    4d88:	f8 94       	cli
    4d8a:	de bf       	out	0x3e, r29	; 62
    4d8c:	0f be       	out	0x3f, r0	; 63
    4d8e:	cd bf       	out	0x3d, r28	; 61
    4d90:	cf 91       	pop	r28
    4d92:	df 91       	pop	r29
    4d94:	1f 91       	pop	r17
    4d96:	0f 91       	pop	r16
    4d98:	ef 90       	pop	r14
    4d9a:	df 90       	pop	r13
    4d9c:	cf 90       	pop	r12
    4d9e:	bf 90       	pop	r11
    4da0:	af 90       	pop	r10
    4da2:	9f 90       	pop	r9
    4da4:	8f 90       	pop	r8
    4da6:	08 95       	ret

00004da8 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    4da8:	df 93       	push	r29
    4daa:	cf 93       	push	r28
    4dac:	00 d0       	rcall	.+0      	; 0x4dae <prvAddNewTaskToReadyList+0x6>
    4dae:	cd b7       	in	r28, 0x3d	; 61
    4db0:	de b7       	in	r29, 0x3e	; 62
    4db2:	9a 83       	std	Y+2, r25	; 0x02
    4db4:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    4db6:	0f b6       	in	r0, 0x3f	; 63
    4db8:	f8 94       	cli
    4dba:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    4dbc:	80 91 7f 04 	lds	r24, 0x047F
    4dc0:	8f 5f       	subi	r24, 0xFF	; 255
    4dc2:	80 93 7f 04 	sts	0x047F, r24
		if( pxCurrentTCB == NULL )
    4dc6:	80 91 7c 04 	lds	r24, 0x047C
    4dca:	90 91 7d 04 	lds	r25, 0x047D
    4dce:	00 97       	sbiw	r24, 0x00	; 0
    4dd0:	69 f4       	brne	.+26     	; 0x4dec <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    4dd2:	89 81       	ldd	r24, Y+1	; 0x01
    4dd4:	9a 81       	ldd	r25, Y+2	; 0x02
    4dd6:	90 93 7d 04 	sts	0x047D, r25
    4dda:	80 93 7c 04 	sts	0x047C, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    4dde:	80 91 7f 04 	lds	r24, 0x047F
    4de2:	81 30       	cpi	r24, 0x01	; 1
    4de4:	b9 f4       	brne	.+46     	; 0x4e14 <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    4de6:	0e 94 6b 2f 	call	0x5ed6	; 0x5ed6 <prvInitialiseTaskLists>
    4dea:	14 c0       	rjmp	.+40     	; 0x4e14 <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    4dec:	80 91 83 04 	lds	r24, 0x0483
    4df0:	88 23       	and	r24, r24
    4df2:	81 f4       	brne	.+32     	; 0x4e14 <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    4df4:	e0 91 7c 04 	lds	r30, 0x047C
    4df8:	f0 91 7d 04 	lds	r31, 0x047D
    4dfc:	96 89       	ldd	r25, Z+22	; 0x16
    4dfe:	e9 81       	ldd	r30, Y+1	; 0x01
    4e00:	fa 81       	ldd	r31, Y+2	; 0x02
    4e02:	86 89       	ldd	r24, Z+22	; 0x16
    4e04:	89 17       	cp	r24, r25
    4e06:	30 f0       	brcs	.+12     	; 0x4e14 <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    4e08:	89 81       	ldd	r24, Y+1	; 0x01
    4e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e0c:	90 93 7d 04 	sts	0x047D, r25
    4e10:	80 93 7c 04 	sts	0x047C, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    4e14:	80 91 88 04 	lds	r24, 0x0488
    4e18:	8f 5f       	subi	r24, 0xFF	; 255
    4e1a:	80 93 88 04 	sts	0x0488, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    4e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    4e20:	fa 81       	ldd	r31, Y+2	; 0x02
    4e22:	96 89       	ldd	r25, Z+22	; 0x16
    4e24:	80 91 82 04 	lds	r24, 0x0482
    4e28:	89 17       	cp	r24, r25
    4e2a:	28 f4       	brcc	.+10     	; 0x4e36 <prvAddNewTaskToReadyList+0x8e>
    4e2c:	e9 81       	ldd	r30, Y+1	; 0x01
    4e2e:	fa 81       	ldd	r31, Y+2	; 0x02
    4e30:	86 89       	ldd	r24, Z+22	; 0x16
    4e32:	80 93 82 04 	sts	0x0482, r24
    4e36:	e9 81       	ldd	r30, Y+1	; 0x01
    4e38:	fa 81       	ldd	r31, Y+2	; 0x02
    4e3a:	86 89       	ldd	r24, Z+22	; 0x16
    4e3c:	28 2f       	mov	r18, r24
    4e3e:	30 e0       	ldi	r19, 0x00	; 0
    4e40:	c9 01       	movw	r24, r18
    4e42:	88 0f       	add	r24, r24
    4e44:	99 1f       	adc	r25, r25
    4e46:	88 0f       	add	r24, r24
    4e48:	99 1f       	adc	r25, r25
    4e4a:	88 0f       	add	r24, r24
    4e4c:	99 1f       	adc	r25, r25
    4e4e:	82 0f       	add	r24, r18
    4e50:	93 1f       	adc	r25, r19
    4e52:	ac 01       	movw	r20, r24
    4e54:	42 57       	subi	r20, 0x72	; 114
    4e56:	5b 4f       	sbci	r21, 0xFB	; 251
    4e58:	89 81       	ldd	r24, Y+1	; 0x01
    4e5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e5c:	9c 01       	movw	r18, r24
    4e5e:	2e 5f       	subi	r18, 0xFE	; 254
    4e60:	3f 4f       	sbci	r19, 0xFF	; 255
    4e62:	ca 01       	movw	r24, r20
    4e64:	b9 01       	movw	r22, r18
    4e66:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    4e6a:	0f 90       	pop	r0
    4e6c:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    4e6e:	80 91 83 04 	lds	r24, 0x0483
    4e72:	88 23       	and	r24, r24
    4e74:	61 f0       	breq	.+24     	; 0x4e8e <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4e76:	e0 91 7c 04 	lds	r30, 0x047C
    4e7a:	f0 91 7d 04 	lds	r31, 0x047D
    4e7e:	96 89       	ldd	r25, Z+22	; 0x16
    4e80:	e9 81       	ldd	r30, Y+1	; 0x01
    4e82:	fa 81       	ldd	r31, Y+2	; 0x02
    4e84:	86 89       	ldd	r24, Z+22	; 0x16
    4e86:	98 17       	cp	r25, r24
    4e88:	10 f4       	brcc	.+4      	; 0x4e8e <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    4e8a:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    4e8e:	0f 90       	pop	r0
    4e90:	0f 90       	pop	r0
    4e92:	cf 91       	pop	r28
    4e94:	df 91       	pop	r29
    4e96:	08 95       	ret

00004e98 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    4e98:	df 93       	push	r29
    4e9a:	cf 93       	push	r28
    4e9c:	00 d0       	rcall	.+0      	; 0x4e9e <vTaskDelete+0x6>
    4e9e:	00 d0       	rcall	.+0      	; 0x4ea0 <vTaskDelete+0x8>
    4ea0:	00 d0       	rcall	.+0      	; 0x4ea2 <vTaskDelete+0xa>
    4ea2:	cd b7       	in	r28, 0x3d	; 61
    4ea4:	de b7       	in	r29, 0x3e	; 62
    4ea6:	9c 83       	std	Y+4, r25	; 0x04
    4ea8:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    4eaa:	0f b6       	in	r0, 0x3f	; 63
    4eac:	f8 94       	cli
    4eae:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4eb0:	8b 81       	ldd	r24, Y+3	; 0x03
    4eb2:	9c 81       	ldd	r25, Y+4	; 0x04
    4eb4:	00 97       	sbiw	r24, 0x00	; 0
    4eb6:	39 f4       	brne	.+14     	; 0x4ec6 <vTaskDelete+0x2e>
    4eb8:	80 91 7c 04 	lds	r24, 0x047C
    4ebc:	90 91 7d 04 	lds	r25, 0x047D
    4ec0:	9e 83       	std	Y+6, r25	; 0x06
    4ec2:	8d 83       	std	Y+5, r24	; 0x05
    4ec4:	04 c0       	rjmp	.+8      	; 0x4ece <vTaskDelete+0x36>
    4ec6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ec8:	9c 81       	ldd	r25, Y+4	; 0x04
    4eca:	9e 83       	std	Y+6, r25	; 0x06
    4ecc:	8d 83       	std	Y+5, r24	; 0x05
    4ece:	8d 81       	ldd	r24, Y+5	; 0x05
    4ed0:	9e 81       	ldd	r25, Y+6	; 0x06
    4ed2:	9a 83       	std	Y+2, r25	; 0x02
    4ed4:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4ed6:	89 81       	ldd	r24, Y+1	; 0x01
    4ed8:	9a 81       	ldd	r25, Y+2	; 0x02
    4eda:	02 96       	adiw	r24, 0x02	; 2
    4edc:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    4ee0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ee2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ee4:	84 89       	ldd	r24, Z+20	; 0x14
    4ee6:	95 89       	ldd	r25, Z+21	; 0x15
    4ee8:	00 97       	sbiw	r24, 0x00	; 0
    4eea:	29 f0       	breq	.+10     	; 0x4ef6 <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4eec:	89 81       	ldd	r24, Y+1	; 0x01
    4eee:	9a 81       	ldd	r25, Y+2	; 0x02
    4ef0:	0c 96       	adiw	r24, 0x0c	; 12
    4ef2:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    4ef6:	80 91 88 04 	lds	r24, 0x0488
    4efa:	8f 5f       	subi	r24, 0xFF	; 255
    4efc:	80 93 88 04 	sts	0x0488, r24

			if( pxTCB == pxCurrentTCB )
    4f00:	20 91 7c 04 	lds	r18, 0x047C
    4f04:	30 91 7d 04 	lds	r19, 0x047D
    4f08:	89 81       	ldd	r24, Y+1	; 0x01
    4f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f0c:	82 17       	cp	r24, r18
    4f0e:	93 07       	cpc	r25, r19
    4f10:	81 f4       	brne	.+32     	; 0x4f32 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    4f12:	89 81       	ldd	r24, Y+1	; 0x01
    4f14:	9a 81       	ldd	r25, Y+2	; 0x02
    4f16:	9c 01       	movw	r18, r24
    4f18:	2e 5f       	subi	r18, 0xFE	; 254
    4f1a:	3f 4f       	sbci	r19, 0xFF	; 255
    4f1c:	8a ed       	ldi	r24, 0xDA	; 218
    4f1e:	94 e0       	ldi	r25, 0x04	; 4
    4f20:	b9 01       	movw	r22, r18
    4f22:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    4f26:	80 91 7e 04 	lds	r24, 0x047E
    4f2a:	8f 5f       	subi	r24, 0xFF	; 255
    4f2c:	80 93 7e 04 	sts	0x047E, r24
    4f30:	0b c0       	rjmp	.+22     	; 0x4f48 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    4f32:	80 91 7f 04 	lds	r24, 0x047F
    4f36:	81 50       	subi	r24, 0x01	; 1
    4f38:	80 93 7f 04 	sts	0x047F, r24
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
    4f3c:	89 81       	ldd	r24, Y+1	; 0x01
    4f3e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f40:	0e 94 db 2f 	call	0x5fb6	; 0x5fb6 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    4f44:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
    4f48:	0f 90       	pop	r0
    4f4a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    4f4c:	80 91 83 04 	lds	r24, 0x0483
    4f50:	88 23       	and	r24, r24
    4f52:	59 f0       	breq	.+22     	; 0x4f6a <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    4f54:	20 91 7c 04 	lds	r18, 0x047C
    4f58:	30 91 7d 04 	lds	r19, 0x047D
    4f5c:	89 81       	ldd	r24, Y+1	; 0x01
    4f5e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f60:	82 17       	cp	r24, r18
    4f62:	93 07       	cpc	r25, r19
    4f64:	11 f4       	brne	.+4      	; 0x4f6a <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    4f66:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    4f6a:	26 96       	adiw	r28, 0x06	; 6
    4f6c:	0f b6       	in	r0, 0x3f	; 63
    4f6e:	f8 94       	cli
    4f70:	de bf       	out	0x3e, r29	; 62
    4f72:	0f be       	out	0x3f, r0	; 63
    4f74:	cd bf       	out	0x3d, r28	; 61
    4f76:	cf 91       	pop	r28
    4f78:	df 91       	pop	r29
    4f7a:	08 95       	ret

00004f7c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    4f7c:	df 93       	push	r29
    4f7e:	cf 93       	push	r28
    4f80:	cd b7       	in	r28, 0x3d	; 61
    4f82:	de b7       	in	r29, 0x3e	; 62
    4f84:	2a 97       	sbiw	r28, 0x0a	; 10
    4f86:	0f b6       	in	r0, 0x3f	; 63
    4f88:	f8 94       	cli
    4f8a:	de bf       	out	0x3e, r29	; 62
    4f8c:	0f be       	out	0x3f, r0	; 63
    4f8e:	cd bf       	out	0x3d, r28	; 61
    4f90:	98 87       	std	Y+8, r25	; 0x08
    4f92:	8f 83       	std	Y+7, r24	; 0x07
    4f94:	7a 87       	std	Y+10, r23	; 0x0a
    4f96:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    4f98:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    4f9a:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    4f9e:	80 91 80 04 	lds	r24, 0x0480
    4fa2:	90 91 81 04 	lds	r25, 0x0481
    4fa6:	9a 83       	std	Y+2, r25	; 0x02
    4fa8:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4faa:	ef 81       	ldd	r30, Y+7	; 0x07
    4fac:	f8 85       	ldd	r31, Y+8	; 0x08
    4fae:	20 81       	ld	r18, Z
    4fb0:	31 81       	ldd	r19, Z+1	; 0x01
    4fb2:	89 85       	ldd	r24, Y+9	; 0x09
    4fb4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fb6:	82 0f       	add	r24, r18
    4fb8:	93 1f       	adc	r25, r19
    4fba:	9e 83       	std	Y+6, r25	; 0x06
    4fbc:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    4fbe:	ef 81       	ldd	r30, Y+7	; 0x07
    4fc0:	f8 85       	ldd	r31, Y+8	; 0x08
    4fc2:	20 81       	ld	r18, Z
    4fc4:	31 81       	ldd	r19, Z+1	; 0x01
    4fc6:	89 81       	ldd	r24, Y+1	; 0x01
    4fc8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fca:	82 17       	cp	r24, r18
    4fcc:	93 07       	cpc	r25, r19
    4fce:	98 f4       	brcc	.+38     	; 0x4ff6 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    4fd0:	ef 81       	ldd	r30, Y+7	; 0x07
    4fd2:	f8 85       	ldd	r31, Y+8	; 0x08
    4fd4:	20 81       	ld	r18, Z
    4fd6:	31 81       	ldd	r19, Z+1	; 0x01
    4fd8:	8d 81       	ldd	r24, Y+5	; 0x05
    4fda:	9e 81       	ldd	r25, Y+6	; 0x06
    4fdc:	82 17       	cp	r24, r18
    4fde:	93 07       	cpc	r25, r19
    4fe0:	e0 f4       	brcc	.+56     	; 0x501a <vTaskDelayUntil+0x9e>
    4fe2:	2d 81       	ldd	r18, Y+5	; 0x05
    4fe4:	3e 81       	ldd	r19, Y+6	; 0x06
    4fe6:	89 81       	ldd	r24, Y+1	; 0x01
    4fe8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fea:	82 17       	cp	r24, r18
    4fec:	93 07       	cpc	r25, r19
    4fee:	a8 f4       	brcc	.+42     	; 0x501a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4ff0:	81 e0       	ldi	r24, 0x01	; 1
    4ff2:	8b 83       	std	Y+3, r24	; 0x03
    4ff4:	12 c0       	rjmp	.+36     	; 0x501a <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    4ff6:	ef 81       	ldd	r30, Y+7	; 0x07
    4ff8:	f8 85       	ldd	r31, Y+8	; 0x08
    4ffa:	20 81       	ld	r18, Z
    4ffc:	31 81       	ldd	r19, Z+1	; 0x01
    4ffe:	8d 81       	ldd	r24, Y+5	; 0x05
    5000:	9e 81       	ldd	r25, Y+6	; 0x06
    5002:	82 17       	cp	r24, r18
    5004:	93 07       	cpc	r25, r19
    5006:	38 f0       	brcs	.+14     	; 0x5016 <vTaskDelayUntil+0x9a>
    5008:	2d 81       	ldd	r18, Y+5	; 0x05
    500a:	3e 81       	ldd	r19, Y+6	; 0x06
    500c:	89 81       	ldd	r24, Y+1	; 0x01
    500e:	9a 81       	ldd	r25, Y+2	; 0x02
    5010:	82 17       	cp	r24, r18
    5012:	93 07       	cpc	r25, r19
    5014:	10 f4       	brcc	.+4      	; 0x501a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    5016:	81 e0       	ldi	r24, 0x01	; 1
    5018:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    501a:	ef 81       	ldd	r30, Y+7	; 0x07
    501c:	f8 85       	ldd	r31, Y+8	; 0x08
    501e:	8d 81       	ldd	r24, Y+5	; 0x05
    5020:	9e 81       	ldd	r25, Y+6	; 0x06
    5022:	91 83       	std	Z+1, r25	; 0x01
    5024:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    5026:	8b 81       	ldd	r24, Y+3	; 0x03
    5028:	88 23       	and	r24, r24
    502a:	49 f0       	breq	.+18     	; 0x503e <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    502c:	8d 81       	ldd	r24, Y+5	; 0x05
    502e:	9e 81       	ldd	r25, Y+6	; 0x06
    5030:	29 81       	ldd	r18, Y+1	; 0x01
    5032:	3a 81       	ldd	r19, Y+2	; 0x02
    5034:	82 1b       	sub	r24, r18
    5036:	93 0b       	sbc	r25, r19
    5038:	60 e0       	ldi	r22, 0x00	; 0
    503a:	0e 94 46 34 	call	0x688c	; 0x688c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    503e:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    5042:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    5044:	8c 81       	ldd	r24, Y+4	; 0x04
    5046:	88 23       	and	r24, r24
    5048:	11 f4       	brne	.+4      	; 0x504e <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    504a:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    504e:	2a 96       	adiw	r28, 0x0a	; 10
    5050:	0f b6       	in	r0, 0x3f	; 63
    5052:	f8 94       	cli
    5054:	de bf       	out	0x3e, r29	; 62
    5056:	0f be       	out	0x3f, r0	; 63
    5058:	cd bf       	out	0x3d, r28	; 61
    505a:	cf 91       	pop	r28
    505c:	df 91       	pop	r29
    505e:	08 95       	ret

00005060 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    5060:	df 93       	push	r29
    5062:	cf 93       	push	r28
    5064:	00 d0       	rcall	.+0      	; 0x5066 <vTaskDelay+0x6>
    5066:	0f 92       	push	r0
    5068:	cd b7       	in	r28, 0x3d	; 61
    506a:	de b7       	in	r29, 0x3e	; 62
    506c:	9b 83       	std	Y+3, r25	; 0x03
    506e:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    5070:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    5072:	8a 81       	ldd	r24, Y+2	; 0x02
    5074:	9b 81       	ldd	r25, Y+3	; 0x03
    5076:	00 97       	sbiw	r24, 0x00	; 0
    5078:	51 f0       	breq	.+20     	; 0x508e <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    507a:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    507e:	8a 81       	ldd	r24, Y+2	; 0x02
    5080:	9b 81       	ldd	r25, Y+3	; 0x03
    5082:	60 e0       	ldi	r22, 0x00	; 0
    5084:	0e 94 46 34 	call	0x688c	; 0x688c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    5088:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    508c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    508e:	89 81       	ldd	r24, Y+1	; 0x01
    5090:	88 23       	and	r24, r24
    5092:	11 f4       	brne	.+4      	; 0x5098 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    5094:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    5098:	0f 90       	pop	r0
    509a:	0f 90       	pop	r0
    509c:	0f 90       	pop	r0
    509e:	cf 91       	pop	r28
    50a0:	df 91       	pop	r29
    50a2:	08 95       	ret

000050a4 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
    50a4:	df 93       	push	r29
    50a6:	cf 93       	push	r28
    50a8:	cd b7       	in	r28, 0x3d	; 61
    50aa:	de b7       	in	r29, 0x3e	; 62
    50ac:	27 97       	sbiw	r28, 0x07	; 7
    50ae:	0f b6       	in	r0, 0x3f	; 63
    50b0:	f8 94       	cli
    50b2:	de bf       	out	0x3e, r29	; 62
    50b4:	0f be       	out	0x3f, r0	; 63
    50b6:	cd bf       	out	0x3d, r28	; 61
    50b8:	9d 83       	std	Y+5, r25	; 0x05
    50ba:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    50bc:	0f b6       	in	r0, 0x3f	; 63
    50be:	f8 94       	cli
    50c0:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    50c2:	8c 81       	ldd	r24, Y+4	; 0x04
    50c4:	9d 81       	ldd	r25, Y+5	; 0x05
    50c6:	00 97       	sbiw	r24, 0x00	; 0
    50c8:	39 f4       	brne	.+14     	; 0x50d8 <uxTaskPriorityGet+0x34>
    50ca:	80 91 7c 04 	lds	r24, 0x047C
    50ce:	90 91 7d 04 	lds	r25, 0x047D
    50d2:	9f 83       	std	Y+7, r25	; 0x07
    50d4:	8e 83       	std	Y+6, r24	; 0x06
    50d6:	04 c0       	rjmp	.+8      	; 0x50e0 <uxTaskPriorityGet+0x3c>
    50d8:	8c 81       	ldd	r24, Y+4	; 0x04
    50da:	9d 81       	ldd	r25, Y+5	; 0x05
    50dc:	9f 83       	std	Y+7, r25	; 0x07
    50de:	8e 83       	std	Y+6, r24	; 0x06
    50e0:	8e 81       	ldd	r24, Y+6	; 0x06
    50e2:	9f 81       	ldd	r25, Y+7	; 0x07
    50e4:	9b 83       	std	Y+3, r25	; 0x03
    50e6:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    50e8:	ea 81       	ldd	r30, Y+2	; 0x02
    50ea:	fb 81       	ldd	r31, Y+3	; 0x03
    50ec:	86 89       	ldd	r24, Z+22	; 0x16
    50ee:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    50f0:	0f 90       	pop	r0
    50f2:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    50f4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    50f6:	27 96       	adiw	r28, 0x07	; 7
    50f8:	0f b6       	in	r0, 0x3f	; 63
    50fa:	f8 94       	cli
    50fc:	de bf       	out	0x3e, r29	; 62
    50fe:	0f be       	out	0x3f, r0	; 63
    5100:	cd bf       	out	0x3d, r28	; 61
    5102:	cf 91       	pop	r28
    5104:	df 91       	pop	r29
    5106:	08 95       	ret

00005108 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
    5108:	df 93       	push	r29
    510a:	cf 93       	push	r28
    510c:	cd b7       	in	r28, 0x3d	; 61
    510e:	de b7       	in	r29, 0x3e	; 62
    5110:	28 97       	sbiw	r28, 0x08	; 8
    5112:	0f b6       	in	r0, 0x3f	; 63
    5114:	f8 94       	cli
    5116:	de bf       	out	0x3e, r29	; 62
    5118:	0f be       	out	0x3f, r0	; 63
    511a:	cd bf       	out	0x3d, r28	; 61
    511c:	9e 83       	std	Y+6, r25	; 0x06
    511e:	8d 83       	std	Y+5, r24	; 0x05
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    5120:	19 82       	std	Y+1, r1	; 0x01
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    5122:	8d 81       	ldd	r24, Y+5	; 0x05
    5124:	9e 81       	ldd	r25, Y+6	; 0x06
    5126:	00 97       	sbiw	r24, 0x00	; 0
    5128:	39 f4       	brne	.+14     	; 0x5138 <uxTaskPriorityGetFromISR+0x30>
    512a:	80 91 7c 04 	lds	r24, 0x047C
    512e:	90 91 7d 04 	lds	r25, 0x047D
    5132:	98 87       	std	Y+8, r25	; 0x08
    5134:	8f 83       	std	Y+7, r24	; 0x07
    5136:	04 c0       	rjmp	.+8      	; 0x5140 <uxTaskPriorityGetFromISR+0x38>
    5138:	8d 81       	ldd	r24, Y+5	; 0x05
    513a:	9e 81       	ldd	r25, Y+6	; 0x06
    513c:	98 87       	std	Y+8, r25	; 0x08
    513e:	8f 83       	std	Y+7, r24	; 0x07
    5140:	8f 81       	ldd	r24, Y+7	; 0x07
    5142:	98 85       	ldd	r25, Y+8	; 0x08
    5144:	9c 83       	std	Y+4, r25	; 0x04
    5146:	8b 83       	std	Y+3, r24	; 0x03
			uxReturn = pxTCB->uxPriority;
    5148:	eb 81       	ldd	r30, Y+3	; 0x03
    514a:	fc 81       	ldd	r31, Y+4	; 0x04
    514c:	86 89       	ldd	r24, Z+22	; 0x16
    514e:	8a 83       	std	Y+2, r24	; 0x02
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    5150:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    5152:	28 96       	adiw	r28, 0x08	; 8
    5154:	0f b6       	in	r0, 0x3f	; 63
    5156:	f8 94       	cli
    5158:	de bf       	out	0x3e, r29	; 62
    515a:	0f be       	out	0x3f, r0	; 63
    515c:	cd bf       	out	0x3d, r28	; 61
    515e:	cf 91       	pop	r28
    5160:	df 91       	pop	r29
    5162:	08 95       	ret

00005164 <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    5164:	df 93       	push	r29
    5166:	cf 93       	push	r28
    5168:	cd b7       	in	r28, 0x3d	; 61
    516a:	de b7       	in	r29, 0x3e	; 62
    516c:	2a 97       	sbiw	r28, 0x0a	; 10
    516e:	0f b6       	in	r0, 0x3f	; 63
    5170:	f8 94       	cli
    5172:	de bf       	out	0x3e, r29	; 62
    5174:	0f be       	out	0x3f, r0	; 63
    5176:	cd bf       	out	0x3d, r28	; 61
    5178:	9f 83       	std	Y+7, r25	; 0x07
    517a:	8e 83       	std	Y+6, r24	; 0x06
    517c:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    517e:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    5180:	88 85       	ldd	r24, Y+8	; 0x08
    5182:	85 30       	cpi	r24, 0x05	; 5
    5184:	10 f0       	brcs	.+4      	; 0x518a <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    5186:	84 e0       	ldi	r24, 0x04	; 4
    5188:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    518a:	0f b6       	in	r0, 0x3f	; 63
    518c:	f8 94       	cli
    518e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    5190:	8e 81       	ldd	r24, Y+6	; 0x06
    5192:	9f 81       	ldd	r25, Y+7	; 0x07
    5194:	00 97       	sbiw	r24, 0x00	; 0
    5196:	39 f4       	brne	.+14     	; 0x51a6 <vTaskPrioritySet+0x42>
    5198:	80 91 7c 04 	lds	r24, 0x047C
    519c:	90 91 7d 04 	lds	r25, 0x047D
    51a0:	9a 87       	std	Y+10, r25	; 0x0a
    51a2:	89 87       	std	Y+9, r24	; 0x09
    51a4:	04 c0       	rjmp	.+8      	; 0x51ae <vTaskPrioritySet+0x4a>
    51a6:	8e 81       	ldd	r24, Y+6	; 0x06
    51a8:	9f 81       	ldd	r25, Y+7	; 0x07
    51aa:	9a 87       	std	Y+10, r25	; 0x0a
    51ac:	89 87       	std	Y+9, r24	; 0x09
    51ae:	89 85       	ldd	r24, Y+9	; 0x09
    51b0:	9a 85       	ldd	r25, Y+10	; 0x0a
    51b2:	9d 83       	std	Y+5, r25	; 0x05
    51b4:	8c 83       	std	Y+4, r24	; 0x04
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
    51b6:	ec 81       	ldd	r30, Y+4	; 0x04
    51b8:	fd 81       	ldd	r31, Y+5	; 0x05
    51ba:	86 89       	ldd	r24, Z+22	; 0x16
    51bc:	8b 83       	std	Y+3, r24	; 0x03
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    51be:	9b 81       	ldd	r25, Y+3	; 0x03
    51c0:	88 85       	ldd	r24, Y+8	; 0x08
    51c2:	98 17       	cp	r25, r24
    51c4:	09 f4       	brne	.+2      	; 0x51c8 <vTaskPrioritySet+0x64>
    51c6:	81 c0       	rjmp	.+258    	; 0x52ca <vTaskPrioritySet+0x166>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    51c8:	98 85       	ldd	r25, Y+8	; 0x08
    51ca:	8b 81       	ldd	r24, Y+3	; 0x03
    51cc:	89 17       	cp	r24, r25
    51ce:	a0 f4       	brcc	.+40     	; 0x51f8 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    51d0:	20 91 7c 04 	lds	r18, 0x047C
    51d4:	30 91 7d 04 	lds	r19, 0x047D
    51d8:	8c 81       	ldd	r24, Y+4	; 0x04
    51da:	9d 81       	ldd	r25, Y+5	; 0x05
    51dc:	82 17       	cp	r24, r18
    51de:	93 07       	cpc	r25, r19
    51e0:	b1 f0       	breq	.+44     	; 0x520e <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    51e2:	e0 91 7c 04 	lds	r30, 0x047C
    51e6:	f0 91 7d 04 	lds	r31, 0x047D
    51ea:	96 89       	ldd	r25, Z+22	; 0x16
    51ec:	88 85       	ldd	r24, Y+8	; 0x08
    51ee:	89 17       	cp	r24, r25
    51f0:	70 f0       	brcs	.+28     	; 0x520e <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    51f2:	81 e0       	ldi	r24, 0x01	; 1
    51f4:	89 83       	std	Y+1, r24	; 0x01
    51f6:	0b c0       	rjmp	.+22     	; 0x520e <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    51f8:	20 91 7c 04 	lds	r18, 0x047C
    51fc:	30 91 7d 04 	lds	r19, 0x047D
    5200:	8c 81       	ldd	r24, Y+4	; 0x04
    5202:	9d 81       	ldd	r25, Y+5	; 0x05
    5204:	82 17       	cp	r24, r18
    5206:	93 07       	cpc	r25, r19
    5208:	11 f4       	brne	.+4      	; 0x520e <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    520a:	81 e0       	ldi	r24, 0x01	; 1
    520c:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    520e:	ec 81       	ldd	r30, Y+4	; 0x04
    5210:	fd 81       	ldd	r31, Y+5	; 0x05
    5212:	86 89       	ldd	r24, Z+22	; 0x16
    5214:	8a 83       	std	Y+2, r24	; 0x02
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    5216:	ec 81       	ldd	r30, Y+4	; 0x04
    5218:	fd 81       	ldd	r31, Y+5	; 0x05
    521a:	88 85       	ldd	r24, Y+8	; 0x08
    521c:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    521e:	ec 81       	ldd	r30, Y+4	; 0x04
    5220:	fd 81       	ldd	r31, Y+5	; 0x05
    5222:	84 85       	ldd	r24, Z+12	; 0x0c
    5224:	95 85       	ldd	r25, Z+13	; 0x0d
    5226:	99 23       	and	r25, r25
    5228:	5c f0       	brlt	.+22     	; 0x5240 <vTaskPrioritySet+0xdc>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    522a:	88 85       	ldd	r24, Y+8	; 0x08
    522c:	28 2f       	mov	r18, r24
    522e:	30 e0       	ldi	r19, 0x00	; 0
    5230:	85 e0       	ldi	r24, 0x05	; 5
    5232:	90 e0       	ldi	r25, 0x00	; 0
    5234:	82 1b       	sub	r24, r18
    5236:	93 0b       	sbc	r25, r19
    5238:	ec 81       	ldd	r30, Y+4	; 0x04
    523a:	fd 81       	ldd	r31, Y+5	; 0x05
    523c:	95 87       	std	Z+13, r25	; 0x0d
    523e:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    5240:	ec 81       	ldd	r30, Y+4	; 0x04
    5242:	fd 81       	ldd	r31, Y+5	; 0x05
    5244:	42 85       	ldd	r20, Z+10	; 0x0a
    5246:	53 85       	ldd	r21, Z+11	; 0x0b
    5248:	8a 81       	ldd	r24, Y+2	; 0x02
    524a:	28 2f       	mov	r18, r24
    524c:	30 e0       	ldi	r19, 0x00	; 0
    524e:	c9 01       	movw	r24, r18
    5250:	88 0f       	add	r24, r24
    5252:	99 1f       	adc	r25, r25
    5254:	88 0f       	add	r24, r24
    5256:	99 1f       	adc	r25, r25
    5258:	88 0f       	add	r24, r24
    525a:	99 1f       	adc	r25, r25
    525c:	82 0f       	add	r24, r18
    525e:	93 1f       	adc	r25, r19
    5260:	82 57       	subi	r24, 0x72	; 114
    5262:	9b 4f       	sbci	r25, 0xFB	; 251
    5264:	48 17       	cp	r20, r24
    5266:	59 07       	cpc	r21, r25
    5268:	59 f5       	brne	.+86     	; 0x52c0 <vTaskPrioritySet+0x15c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    526a:	8c 81       	ldd	r24, Y+4	; 0x04
    526c:	9d 81       	ldd	r25, Y+5	; 0x05
    526e:	02 96       	adiw	r24, 0x02	; 2
    5270:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    5274:	ec 81       	ldd	r30, Y+4	; 0x04
    5276:	fd 81       	ldd	r31, Y+5	; 0x05
    5278:	96 89       	ldd	r25, Z+22	; 0x16
    527a:	80 91 82 04 	lds	r24, 0x0482
    527e:	89 17       	cp	r24, r25
    5280:	28 f4       	brcc	.+10     	; 0x528c <vTaskPrioritySet+0x128>
    5282:	ec 81       	ldd	r30, Y+4	; 0x04
    5284:	fd 81       	ldd	r31, Y+5	; 0x05
    5286:	86 89       	ldd	r24, Z+22	; 0x16
    5288:	80 93 82 04 	sts	0x0482, r24
    528c:	ec 81       	ldd	r30, Y+4	; 0x04
    528e:	fd 81       	ldd	r31, Y+5	; 0x05
    5290:	86 89       	ldd	r24, Z+22	; 0x16
    5292:	28 2f       	mov	r18, r24
    5294:	30 e0       	ldi	r19, 0x00	; 0
    5296:	c9 01       	movw	r24, r18
    5298:	88 0f       	add	r24, r24
    529a:	99 1f       	adc	r25, r25
    529c:	88 0f       	add	r24, r24
    529e:	99 1f       	adc	r25, r25
    52a0:	88 0f       	add	r24, r24
    52a2:	99 1f       	adc	r25, r25
    52a4:	82 0f       	add	r24, r18
    52a6:	93 1f       	adc	r25, r19
    52a8:	ac 01       	movw	r20, r24
    52aa:	42 57       	subi	r20, 0x72	; 114
    52ac:	5b 4f       	sbci	r21, 0xFB	; 251
    52ae:	8c 81       	ldd	r24, Y+4	; 0x04
    52b0:	9d 81       	ldd	r25, Y+5	; 0x05
    52b2:	9c 01       	movw	r18, r24
    52b4:	2e 5f       	subi	r18, 0xFE	; 254
    52b6:	3f 4f       	sbci	r19, 0xFF	; 255
    52b8:	ca 01       	movw	r24, r20
    52ba:	b9 01       	movw	r22, r18
    52bc:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    52c0:	89 81       	ldd	r24, Y+1	; 0x01
    52c2:	88 23       	and	r24, r24
    52c4:	11 f0       	breq	.+4      	; 0x52ca <vTaskPrioritySet+0x166>
				{
					taskYIELD_IF_USING_PREEMPTION();
    52c6:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    52ca:	0f 90       	pop	r0
    52cc:	0f be       	out	0x3f, r0	; 63
	}
    52ce:	2a 96       	adiw	r28, 0x0a	; 10
    52d0:	0f b6       	in	r0, 0x3f	; 63
    52d2:	f8 94       	cli
    52d4:	de bf       	out	0x3e, r29	; 62
    52d6:	0f be       	out	0x3f, r0	; 63
    52d8:	cd bf       	out	0x3d, r28	; 61
    52da:	cf 91       	pop	r28
    52dc:	df 91       	pop	r29
    52de:	08 95       	ret

000052e0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    52e0:	df 93       	push	r29
    52e2:	cf 93       	push	r28
    52e4:	00 d0       	rcall	.+0      	; 0x52e6 <vTaskSuspend+0x6>
    52e6:	00 d0       	rcall	.+0      	; 0x52e8 <vTaskSuspend+0x8>
    52e8:	00 d0       	rcall	.+0      	; 0x52ea <vTaskSuspend+0xa>
    52ea:	cd b7       	in	r28, 0x3d	; 61
    52ec:	de b7       	in	r29, 0x3e	; 62
    52ee:	9c 83       	std	Y+4, r25	; 0x04
    52f0:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    52f2:	0f b6       	in	r0, 0x3f	; 63
    52f4:	f8 94       	cli
    52f6:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    52f8:	8b 81       	ldd	r24, Y+3	; 0x03
    52fa:	9c 81       	ldd	r25, Y+4	; 0x04
    52fc:	00 97       	sbiw	r24, 0x00	; 0
    52fe:	39 f4       	brne	.+14     	; 0x530e <vTaskSuspend+0x2e>
    5300:	80 91 7c 04 	lds	r24, 0x047C
    5304:	90 91 7d 04 	lds	r25, 0x047D
    5308:	9e 83       	std	Y+6, r25	; 0x06
    530a:	8d 83       	std	Y+5, r24	; 0x05
    530c:	04 c0       	rjmp	.+8      	; 0x5316 <vTaskSuspend+0x36>
    530e:	8b 81       	ldd	r24, Y+3	; 0x03
    5310:	9c 81       	ldd	r25, Y+4	; 0x04
    5312:	9e 83       	std	Y+6, r25	; 0x06
    5314:	8d 83       	std	Y+5, r24	; 0x05
    5316:	8d 81       	ldd	r24, Y+5	; 0x05
    5318:	9e 81       	ldd	r25, Y+6	; 0x06
    531a:	9a 83       	std	Y+2, r25	; 0x02
    531c:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    531e:	89 81       	ldd	r24, Y+1	; 0x01
    5320:	9a 81       	ldd	r25, Y+2	; 0x02
    5322:	02 96       	adiw	r24, 0x02	; 2
    5324:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5328:	e9 81       	ldd	r30, Y+1	; 0x01
    532a:	fa 81       	ldd	r31, Y+2	; 0x02
    532c:	84 89       	ldd	r24, Z+20	; 0x14
    532e:	95 89       	ldd	r25, Z+21	; 0x15
    5330:	00 97       	sbiw	r24, 0x00	; 0
    5332:	29 f0       	breq	.+10     	; 0x533e <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5334:	89 81       	ldd	r24, Y+1	; 0x01
    5336:	9a 81       	ldd	r25, Y+2	; 0x02
    5338:	0c 96       	adiw	r24, 0x0c	; 12
    533a:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    533e:	89 81       	ldd	r24, Y+1	; 0x01
    5340:	9a 81       	ldd	r25, Y+2	; 0x02
    5342:	9c 01       	movw	r18, r24
    5344:	2e 5f       	subi	r18, 0xFE	; 254
    5346:	3f 4f       	sbci	r19, 0xFF	; 255
    5348:	83 ee       	ldi	r24, 0xE3	; 227
    534a:	94 e0       	ldi	r25, 0x04	; 4
    534c:	b9 01       	movw	r22, r18
    534e:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    5352:	e9 81       	ldd	r30, Y+1	; 0x01
    5354:	fa 81       	ldd	r31, Y+2	; 0x02
    5356:	85 a1       	ldd	r24, Z+37	; 0x25
    5358:	81 30       	cpi	r24, 0x01	; 1
    535a:	19 f4       	brne	.+6      	; 0x5362 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    535c:	e9 81       	ldd	r30, Y+1	; 0x01
    535e:	fa 81       	ldd	r31, Y+2	; 0x02
    5360:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    5362:	0f 90       	pop	r0
    5364:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    5366:	80 91 83 04 	lds	r24, 0x0483
    536a:	88 23       	and	r24, r24
    536c:	39 f0       	breq	.+14     	; 0x537c <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    536e:	0f b6       	in	r0, 0x3f	; 63
    5370:	f8 94       	cli
    5372:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    5374:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    5378:	0f 90       	pop	r0
    537a:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    537c:	20 91 7c 04 	lds	r18, 0x047C
    5380:	30 91 7d 04 	lds	r19, 0x047D
    5384:	89 81       	ldd	r24, Y+1	; 0x01
    5386:	9a 81       	ldd	r25, Y+2	; 0x02
    5388:	82 17       	cp	r24, r18
    538a:	93 07       	cpc	r25, r19
    538c:	a1 f4       	brne	.+40     	; 0x53b6 <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    538e:	80 91 83 04 	lds	r24, 0x0483
    5392:	88 23       	and	r24, r24
    5394:	19 f0       	breq	.+6      	; 0x539c <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    5396:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
    539a:	0d c0       	rjmp	.+26     	; 0x53b6 <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    539c:	90 91 e3 04 	lds	r25, 0x04E3
    53a0:	80 91 7f 04 	lds	r24, 0x047F
    53a4:	98 17       	cp	r25, r24
    53a6:	29 f4       	brne	.+10     	; 0x53b2 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    53a8:	10 92 7d 04 	sts	0x047D, r1
    53ac:	10 92 7c 04 	sts	0x047C, r1
    53b0:	02 c0       	rjmp	.+4      	; 0x53b6 <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    53b2:	0e 94 2c 2d 	call	0x5a58	; 0x5a58 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    53b6:	26 96       	adiw	r28, 0x06	; 6
    53b8:	0f b6       	in	r0, 0x3f	; 63
    53ba:	f8 94       	cli
    53bc:	de bf       	out	0x3e, r29	; 62
    53be:	0f be       	out	0x3f, r0	; 63
    53c0:	cd bf       	out	0x3d, r28	; 61
    53c2:	cf 91       	pop	r28
    53c4:	df 91       	pop	r29
    53c6:	08 95       	ret

000053c8 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    53c8:	df 93       	push	r29
    53ca:	cf 93       	push	r28
    53cc:	00 d0       	rcall	.+0      	; 0x53ce <prvTaskIsTaskSuspended+0x6>
    53ce:	00 d0       	rcall	.+0      	; 0x53d0 <prvTaskIsTaskSuspended+0x8>
    53d0:	0f 92       	push	r0
    53d2:	cd b7       	in	r28, 0x3d	; 61
    53d4:	de b7       	in	r29, 0x3e	; 62
    53d6:	9d 83       	std	Y+5, r25	; 0x05
    53d8:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    53da:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    53dc:	8c 81       	ldd	r24, Y+4	; 0x04
    53de:	9d 81       	ldd	r25, Y+5	; 0x05
    53e0:	9a 83       	std	Y+2, r25	; 0x02
    53e2:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    53e4:	e9 81       	ldd	r30, Y+1	; 0x01
    53e6:	fa 81       	ldd	r31, Y+2	; 0x02
    53e8:	82 85       	ldd	r24, Z+10	; 0x0a
    53ea:	93 85       	ldd	r25, Z+11	; 0x0b
    53ec:	24 e0       	ldi	r18, 0x04	; 4
    53ee:	83 3e       	cpi	r24, 0xE3	; 227
    53f0:	92 07       	cpc	r25, r18
    53f2:	81 f4       	brne	.+32     	; 0x5414 <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    53f4:	e9 81       	ldd	r30, Y+1	; 0x01
    53f6:	fa 81       	ldd	r31, Y+2	; 0x02
    53f8:	84 89       	ldd	r24, Z+20	; 0x14
    53fa:	95 89       	ldd	r25, Z+21	; 0x15
    53fc:	24 e0       	ldi	r18, 0x04	; 4
    53fe:	81 3d       	cpi	r24, 0xD1	; 209
    5400:	92 07       	cpc	r25, r18
    5402:	41 f0       	breq	.+16     	; 0x5414 <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    5404:	e9 81       	ldd	r30, Y+1	; 0x01
    5406:	fa 81       	ldd	r31, Y+2	; 0x02
    5408:	84 89       	ldd	r24, Z+20	; 0x14
    540a:	95 89       	ldd	r25, Z+21	; 0x15
    540c:	00 97       	sbiw	r24, 0x00	; 0
    540e:	11 f4       	brne	.+4      	; 0x5414 <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    5410:	81 e0       	ldi	r24, 0x01	; 1
    5412:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    5414:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    5416:	0f 90       	pop	r0
    5418:	0f 90       	pop	r0
    541a:	0f 90       	pop	r0
    541c:	0f 90       	pop	r0
    541e:	0f 90       	pop	r0
    5420:	cf 91       	pop	r28
    5422:	df 91       	pop	r29
    5424:	08 95       	ret

00005426 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    5426:	df 93       	push	r29
    5428:	cf 93       	push	r28
    542a:	00 d0       	rcall	.+0      	; 0x542c <vTaskResume+0x6>
    542c:	00 d0       	rcall	.+0      	; 0x542e <vTaskResume+0x8>
    542e:	cd b7       	in	r28, 0x3d	; 61
    5430:	de b7       	in	r29, 0x3e	; 62
    5432:	9c 83       	std	Y+4, r25	; 0x04
    5434:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    5436:	8b 81       	ldd	r24, Y+3	; 0x03
    5438:	9c 81       	ldd	r25, Y+4	; 0x04
    543a:	9a 83       	std	Y+2, r25	; 0x02
    543c:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    543e:	20 91 7c 04 	lds	r18, 0x047C
    5442:	30 91 7d 04 	lds	r19, 0x047D
    5446:	89 81       	ldd	r24, Y+1	; 0x01
    5448:	9a 81       	ldd	r25, Y+2	; 0x02
    544a:	82 17       	cp	r24, r18
    544c:	93 07       	cpc	r25, r19
    544e:	09 f4       	brne	.+2      	; 0x5452 <vTaskResume+0x2c>
    5450:	47 c0       	rjmp	.+142    	; 0x54e0 <vTaskResume+0xba>
    5452:	89 81       	ldd	r24, Y+1	; 0x01
    5454:	9a 81       	ldd	r25, Y+2	; 0x02
    5456:	00 97       	sbiw	r24, 0x00	; 0
    5458:	09 f4       	brne	.+2      	; 0x545c <vTaskResume+0x36>
    545a:	42 c0       	rjmp	.+132    	; 0x54e0 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    545c:	0f b6       	in	r0, 0x3f	; 63
    545e:	f8 94       	cli
    5460:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    5462:	89 81       	ldd	r24, Y+1	; 0x01
    5464:	9a 81       	ldd	r25, Y+2	; 0x02
    5466:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <prvTaskIsTaskSuspended>
    546a:	88 23       	and	r24, r24
    546c:	b9 f1       	breq	.+110    	; 0x54dc <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    546e:	89 81       	ldd	r24, Y+1	; 0x01
    5470:	9a 81       	ldd	r25, Y+2	; 0x02
    5472:	02 96       	adiw	r24, 0x02	; 2
    5474:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5478:	e9 81       	ldd	r30, Y+1	; 0x01
    547a:	fa 81       	ldd	r31, Y+2	; 0x02
    547c:	96 89       	ldd	r25, Z+22	; 0x16
    547e:	80 91 82 04 	lds	r24, 0x0482
    5482:	89 17       	cp	r24, r25
    5484:	28 f4       	brcc	.+10     	; 0x5490 <vTaskResume+0x6a>
    5486:	e9 81       	ldd	r30, Y+1	; 0x01
    5488:	fa 81       	ldd	r31, Y+2	; 0x02
    548a:	86 89       	ldd	r24, Z+22	; 0x16
    548c:	80 93 82 04 	sts	0x0482, r24
    5490:	e9 81       	ldd	r30, Y+1	; 0x01
    5492:	fa 81       	ldd	r31, Y+2	; 0x02
    5494:	86 89       	ldd	r24, Z+22	; 0x16
    5496:	28 2f       	mov	r18, r24
    5498:	30 e0       	ldi	r19, 0x00	; 0
    549a:	c9 01       	movw	r24, r18
    549c:	88 0f       	add	r24, r24
    549e:	99 1f       	adc	r25, r25
    54a0:	88 0f       	add	r24, r24
    54a2:	99 1f       	adc	r25, r25
    54a4:	88 0f       	add	r24, r24
    54a6:	99 1f       	adc	r25, r25
    54a8:	82 0f       	add	r24, r18
    54aa:	93 1f       	adc	r25, r19
    54ac:	ac 01       	movw	r20, r24
    54ae:	42 57       	subi	r20, 0x72	; 114
    54b0:	5b 4f       	sbci	r21, 0xFB	; 251
    54b2:	89 81       	ldd	r24, Y+1	; 0x01
    54b4:	9a 81       	ldd	r25, Y+2	; 0x02
    54b6:	9c 01       	movw	r18, r24
    54b8:	2e 5f       	subi	r18, 0xFE	; 254
    54ba:	3f 4f       	sbci	r19, 0xFF	; 255
    54bc:	ca 01       	movw	r24, r20
    54be:	b9 01       	movw	r22, r18
    54c0:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    54c4:	e9 81       	ldd	r30, Y+1	; 0x01
    54c6:	fa 81       	ldd	r31, Y+2	; 0x02
    54c8:	96 89       	ldd	r25, Z+22	; 0x16
    54ca:	e0 91 7c 04 	lds	r30, 0x047C
    54ce:	f0 91 7d 04 	lds	r31, 0x047D
    54d2:	86 89       	ldd	r24, Z+22	; 0x16
    54d4:	98 17       	cp	r25, r24
    54d6:	10 f0       	brcs	.+4      	; 0x54dc <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    54d8:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    54dc:	0f 90       	pop	r0
    54de:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    54e0:	0f 90       	pop	r0
    54e2:	0f 90       	pop	r0
    54e4:	0f 90       	pop	r0
    54e6:	0f 90       	pop	r0
    54e8:	cf 91       	pop	r28
    54ea:	df 91       	pop	r29
    54ec:	08 95       	ret

000054ee <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    54ee:	df 93       	push	r29
    54f0:	cf 93       	push	r28
    54f2:	00 d0       	rcall	.+0      	; 0x54f4 <xTaskResumeFromISR+0x6>
    54f4:	00 d0       	rcall	.+0      	; 0x54f6 <xTaskResumeFromISR+0x8>
    54f6:	00 d0       	rcall	.+0      	; 0x54f8 <xTaskResumeFromISR+0xa>
    54f8:	cd b7       	in	r28, 0x3d	; 61
    54fa:	de b7       	in	r29, 0x3e	; 62
    54fc:	9e 83       	std	Y+6, r25	; 0x06
    54fe:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    5500:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    5502:	8d 81       	ldd	r24, Y+5	; 0x05
    5504:	9e 81       	ldd	r25, Y+6	; 0x06
    5506:	9b 83       	std	Y+3, r25	; 0x03
    5508:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    550a:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    550c:	8a 81       	ldd	r24, Y+2	; 0x02
    550e:	9b 81       	ldd	r25, Y+3	; 0x03
    5510:	0e 94 e4 29 	call	0x53c8	; 0x53c8 <prvTaskIsTaskSuspended>
    5514:	88 23       	and	r24, r24
    5516:	09 f4       	brne	.+2      	; 0x551a <xTaskResumeFromISR+0x2c>
    5518:	46 c0       	rjmp	.+140    	; 0x55a6 <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    551a:	80 91 8d 04 	lds	r24, 0x048D
    551e:	88 23       	and	r24, r24
    5520:	c1 f5       	brne	.+112    	; 0x5592 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5522:	ea 81       	ldd	r30, Y+2	; 0x02
    5524:	fb 81       	ldd	r31, Y+3	; 0x03
    5526:	96 89       	ldd	r25, Z+22	; 0x16
    5528:	e0 91 7c 04 	lds	r30, 0x047C
    552c:	f0 91 7d 04 	lds	r31, 0x047D
    5530:	86 89       	ldd	r24, Z+22	; 0x16
    5532:	98 17       	cp	r25, r24
    5534:	10 f0       	brcs	.+4      	; 0x553a <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    5536:	81 e0       	ldi	r24, 0x01	; 1
    5538:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    553a:	8a 81       	ldd	r24, Y+2	; 0x02
    553c:	9b 81       	ldd	r25, Y+3	; 0x03
    553e:	02 96       	adiw	r24, 0x02	; 2
    5540:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    5544:	ea 81       	ldd	r30, Y+2	; 0x02
    5546:	fb 81       	ldd	r31, Y+3	; 0x03
    5548:	96 89       	ldd	r25, Z+22	; 0x16
    554a:	80 91 82 04 	lds	r24, 0x0482
    554e:	89 17       	cp	r24, r25
    5550:	28 f4       	brcc	.+10     	; 0x555c <xTaskResumeFromISR+0x6e>
    5552:	ea 81       	ldd	r30, Y+2	; 0x02
    5554:	fb 81       	ldd	r31, Y+3	; 0x03
    5556:	86 89       	ldd	r24, Z+22	; 0x16
    5558:	80 93 82 04 	sts	0x0482, r24
    555c:	ea 81       	ldd	r30, Y+2	; 0x02
    555e:	fb 81       	ldd	r31, Y+3	; 0x03
    5560:	86 89       	ldd	r24, Z+22	; 0x16
    5562:	28 2f       	mov	r18, r24
    5564:	30 e0       	ldi	r19, 0x00	; 0
    5566:	c9 01       	movw	r24, r18
    5568:	88 0f       	add	r24, r24
    556a:	99 1f       	adc	r25, r25
    556c:	88 0f       	add	r24, r24
    556e:	99 1f       	adc	r25, r25
    5570:	88 0f       	add	r24, r24
    5572:	99 1f       	adc	r25, r25
    5574:	82 0f       	add	r24, r18
    5576:	93 1f       	adc	r25, r19
    5578:	ac 01       	movw	r20, r24
    557a:	42 57       	subi	r20, 0x72	; 114
    557c:	5b 4f       	sbci	r21, 0xFB	; 251
    557e:	8a 81       	ldd	r24, Y+2	; 0x02
    5580:	9b 81       	ldd	r25, Y+3	; 0x03
    5582:	9c 01       	movw	r18, r24
    5584:	2e 5f       	subi	r18, 0xFE	; 254
    5586:	3f 4f       	sbci	r19, 0xFF	; 255
    5588:	ca 01       	movw	r24, r20
    558a:	b9 01       	movw	r22, r18
    558c:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
    5590:	0a c0       	rjmp	.+20     	; 0x55a6 <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5592:	8a 81       	ldd	r24, Y+2	; 0x02
    5594:	9b 81       	ldd	r25, Y+3	; 0x03
    5596:	9c 01       	movw	r18, r24
    5598:	24 5f       	subi	r18, 0xF4	; 244
    559a:	3f 4f       	sbci	r19, 0xFF	; 255
    559c:	81 ed       	ldi	r24, 0xD1	; 209
    559e:	94 e0       	ldi	r25, 0x04	; 4
    55a0:	b9 01       	movw	r22, r18
    55a2:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    55a6:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    55a8:	26 96       	adiw	r28, 0x06	; 6
    55aa:	0f b6       	in	r0, 0x3f	; 63
    55ac:	f8 94       	cli
    55ae:	de bf       	out	0x3e, r29	; 62
    55b0:	0f be       	out	0x3f, r0	; 63
    55b2:	cd bf       	out	0x3d, r28	; 61
    55b4:	cf 91       	pop	r28
    55b6:	df 91       	pop	r29
    55b8:	08 95       	ret

000055ba <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    55ba:	ef 92       	push	r14
    55bc:	ff 92       	push	r15
    55be:	0f 93       	push	r16
    55c0:	df 93       	push	r29
    55c2:	cf 93       	push	r28
    55c4:	0f 92       	push	r0
    55c6:	cd b7       	in	r28, 0x3d	; 61
    55c8:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    55ca:	81 e6       	ldi	r24, 0x61	; 97
    55cc:	9f e2       	ldi	r25, 0x2F	; 47
    55ce:	22 e8       	ldi	r18, 0x82	; 130
    55d0:	30 e0       	ldi	r19, 0x00	; 0
    55d2:	eb e8       	ldi	r30, 0x8B	; 139
    55d4:	f4 e0       	ldi	r31, 0x04	; 4
    55d6:	b9 01       	movw	r22, r18
    55d8:	45 e5       	ldi	r20, 0x55	; 85
    55da:	50 e0       	ldi	r21, 0x00	; 0
    55dc:	20 e0       	ldi	r18, 0x00	; 0
    55de:	30 e0       	ldi	r19, 0x00	; 0
    55e0:	00 e0       	ldi	r16, 0x00	; 0
    55e2:	7f 01       	movw	r14, r30
    55e4:	0e 94 a0 25 	call	0x4b40	; 0x4b40 <xTaskCreate>
    55e8:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    55ea:	89 81       	ldd	r24, Y+1	; 0x01
    55ec:	81 30       	cpi	r24, 0x01	; 1
    55ee:	81 f4       	brne	.+32     	; 0x5610 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    55f0:	f8 94       	cli
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    55f2:	8f ef       	ldi	r24, 0xFF	; 255
    55f4:	9f ef       	ldi	r25, 0xFF	; 255
    55f6:	90 93 8a 04 	sts	0x048A, r25
    55fa:	80 93 89 04 	sts	0x0489, r24
		xSchedulerRunning = pdTRUE;
    55fe:	81 e0       	ldi	r24, 0x01	; 1
    5600:	80 93 83 04 	sts	0x0483, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    5604:	10 92 81 04 	sts	0x0481, r1
    5608:	10 92 80 04 	sts	0x0480, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    560c:	0e 94 2f 1d 	call	0x3a5e	; 0x3a5e <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    5610:	0f 90       	pop	r0
    5612:	cf 91       	pop	r28
    5614:	df 91       	pop	r29
    5616:	0f 91       	pop	r16
    5618:	ff 90       	pop	r15
    561a:	ef 90       	pop	r14
    561c:	08 95       	ret

0000561e <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    561e:	df 93       	push	r29
    5620:	cf 93       	push	r28
    5622:	cd b7       	in	r28, 0x3d	; 61
    5624:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    5626:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    5628:	10 92 83 04 	sts	0x0483, r1
	vPortEndScheduler();
    562c:	0e 94 64 1d 	call	0x3ac8	; 0x3ac8 <vPortEndScheduler>
}
    5630:	cf 91       	pop	r28
    5632:	df 91       	pop	r29
    5634:	08 95       	ret

00005636 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    5636:	df 93       	push	r29
    5638:	cf 93       	push	r28
    563a:	cd b7       	in	r28, 0x3d	; 61
    563c:	de b7       	in	r29, 0x3e	; 62
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
    563e:	80 91 8d 04 	lds	r24, 0x048D
    5642:	8f 5f       	subi	r24, 0xFF	; 255
    5644:	80 93 8d 04 	sts	0x048D, r24

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
    5648:	cf 91       	pop	r28
    564a:	df 91       	pop	r29
    564c:	08 95       	ret

0000564e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    564e:	df 93       	push	r29
    5650:	cf 93       	push	r28
    5652:	00 d0       	rcall	.+0      	; 0x5654 <xTaskResumeAll+0x6>
    5654:	00 d0       	rcall	.+0      	; 0x5656 <xTaskResumeAll+0x8>
    5656:	0f 92       	push	r0
    5658:	cd b7       	in	r28, 0x3d	; 61
    565a:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    565c:	1d 82       	std	Y+5, r1	; 0x05
    565e:	1c 82       	std	Y+4, r1	; 0x04
BaseType_t xAlreadyYielded = pdFALSE;
    5660:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    5662:	0f b6       	in	r0, 0x3f	; 63
    5664:	f8 94       	cli
    5666:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    5668:	80 91 8d 04 	lds	r24, 0x048D
    566c:	81 50       	subi	r24, 0x01	; 1
    566e:	80 93 8d 04 	sts	0x048D, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5672:	80 91 8d 04 	lds	r24, 0x048D
    5676:	88 23       	and	r24, r24
    5678:	09 f0       	breq	.+2      	; 0x567c <xTaskResumeAll+0x2e>
    567a:	7c c0       	rjmp	.+248    	; 0x5774 <xTaskResumeAll+0x126>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    567c:	80 91 7f 04 	lds	r24, 0x047F
    5680:	88 23       	and	r24, r24
    5682:	09 f4       	brne	.+2      	; 0x5686 <xTaskResumeAll+0x38>
    5684:	77 c0       	rjmp	.+238    	; 0x5774 <xTaskResumeAll+0x126>
    5686:	45 c0       	rjmp	.+138    	; 0x5712 <xTaskResumeAll+0xc4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5688:	e0 91 d6 04 	lds	r30, 0x04D6
    568c:	f0 91 d7 04 	lds	r31, 0x04D7
    5690:	86 81       	ldd	r24, Z+6	; 0x06
    5692:	97 81       	ldd	r25, Z+7	; 0x07
    5694:	9d 83       	std	Y+5, r25	; 0x05
    5696:	8c 83       	std	Y+4, r24	; 0x04
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5698:	8c 81       	ldd	r24, Y+4	; 0x04
    569a:	9d 81       	ldd	r25, Y+5	; 0x05
    569c:	0c 96       	adiw	r24, 0x0c	; 12
    569e:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    56a2:	8c 81       	ldd	r24, Y+4	; 0x04
    56a4:	9d 81       	ldd	r25, Y+5	; 0x05
    56a6:	02 96       	adiw	r24, 0x02	; 2
    56a8:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    56ac:	ec 81       	ldd	r30, Y+4	; 0x04
    56ae:	fd 81       	ldd	r31, Y+5	; 0x05
    56b0:	96 89       	ldd	r25, Z+22	; 0x16
    56b2:	80 91 82 04 	lds	r24, 0x0482
    56b6:	89 17       	cp	r24, r25
    56b8:	28 f4       	brcc	.+10     	; 0x56c4 <xTaskResumeAll+0x76>
    56ba:	ec 81       	ldd	r30, Y+4	; 0x04
    56bc:	fd 81       	ldd	r31, Y+5	; 0x05
    56be:	86 89       	ldd	r24, Z+22	; 0x16
    56c0:	80 93 82 04 	sts	0x0482, r24
    56c4:	ec 81       	ldd	r30, Y+4	; 0x04
    56c6:	fd 81       	ldd	r31, Y+5	; 0x05
    56c8:	86 89       	ldd	r24, Z+22	; 0x16
    56ca:	28 2f       	mov	r18, r24
    56cc:	30 e0       	ldi	r19, 0x00	; 0
    56ce:	c9 01       	movw	r24, r18
    56d0:	88 0f       	add	r24, r24
    56d2:	99 1f       	adc	r25, r25
    56d4:	88 0f       	add	r24, r24
    56d6:	99 1f       	adc	r25, r25
    56d8:	88 0f       	add	r24, r24
    56da:	99 1f       	adc	r25, r25
    56dc:	82 0f       	add	r24, r18
    56de:	93 1f       	adc	r25, r19
    56e0:	ac 01       	movw	r20, r24
    56e2:	42 57       	subi	r20, 0x72	; 114
    56e4:	5b 4f       	sbci	r21, 0xFB	; 251
    56e6:	8c 81       	ldd	r24, Y+4	; 0x04
    56e8:	9d 81       	ldd	r25, Y+5	; 0x05
    56ea:	9c 01       	movw	r18, r24
    56ec:	2e 5f       	subi	r18, 0xFE	; 254
    56ee:	3f 4f       	sbci	r19, 0xFF	; 255
    56f0:	ca 01       	movw	r24, r20
    56f2:	b9 01       	movw	r22, r18
    56f4:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    56f8:	ec 81       	ldd	r30, Y+4	; 0x04
    56fa:	fd 81       	ldd	r31, Y+5	; 0x05
    56fc:	96 89       	ldd	r25, Z+22	; 0x16
    56fe:	e0 91 7c 04 	lds	r30, 0x047C
    5702:	f0 91 7d 04 	lds	r31, 0x047D
    5706:	86 89       	ldd	r24, Z+22	; 0x16
    5708:	98 17       	cp	r25, r24
    570a:	18 f0       	brcs	.+6      	; 0x5712 <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    570c:	81 e0       	ldi	r24, 0x01	; 1
    570e:	80 93 86 04 	sts	0x0486, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    5712:	80 91 d1 04 	lds	r24, 0x04D1
    5716:	88 23       	and	r24, r24
    5718:	09 f0       	breq	.+2      	; 0x571c <xTaskResumeAll+0xce>
    571a:	b6 cf       	rjmp	.-148    	; 0x5688 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    571c:	8c 81       	ldd	r24, Y+4	; 0x04
    571e:	9d 81       	ldd	r25, Y+5	; 0x05
    5720:	00 97       	sbiw	r24, 0x00	; 0
    5722:	11 f0       	breq	.+4      	; 0x5728 <xTaskResumeAll+0xda>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    5724:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    5728:	80 91 84 04 	lds	r24, 0x0484
    572c:	90 91 85 04 	lds	r25, 0x0485
    5730:	9a 83       	std	Y+2, r25	; 0x02
    5732:	89 83       	std	Y+1, r24	; 0x01

					if( xPendedCounts > ( TickType_t ) 0U )
    5734:	89 81       	ldd	r24, Y+1	; 0x01
    5736:	9a 81       	ldd	r25, Y+2	; 0x02
    5738:	00 97       	sbiw	r24, 0x00	; 0
    573a:	a1 f0       	breq	.+40     	; 0x5764 <xTaskResumeAll+0x116>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    573c:	0e 94 43 2c 	call	0x5886	; 0x5886 <xTaskIncrementTick>
    5740:	88 23       	and	r24, r24
    5742:	19 f0       	breq	.+6      	; 0x574a <xTaskResumeAll+0xfc>
							{
								xYieldPending = pdTRUE;
    5744:	81 e0       	ldi	r24, 0x01	; 1
    5746:	80 93 86 04 	sts	0x0486, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
    574a:	89 81       	ldd	r24, Y+1	; 0x01
    574c:	9a 81       	ldd	r25, Y+2	; 0x02
    574e:	01 97       	sbiw	r24, 0x01	; 1
    5750:	9a 83       	std	Y+2, r25	; 0x02
    5752:	89 83       	std	Y+1, r24	; 0x01
						} while( xPendedCounts > ( TickType_t ) 0U );
    5754:	89 81       	ldd	r24, Y+1	; 0x01
    5756:	9a 81       	ldd	r25, Y+2	; 0x02
    5758:	00 97       	sbiw	r24, 0x00	; 0
    575a:	81 f7       	brne	.-32     	; 0x573c <xTaskResumeAll+0xee>

						xPendedTicks = 0;
    575c:	10 92 85 04 	sts	0x0485, r1
    5760:	10 92 84 04 	sts	0x0484, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    5764:	80 91 86 04 	lds	r24, 0x0486
    5768:	88 23       	and	r24, r24
    576a:	21 f0       	breq	.+8      	; 0x5774 <xTaskResumeAll+0x126>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    576c:	81 e0       	ldi	r24, 0x01	; 1
    576e:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    5770:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    5774:	0f 90       	pop	r0
    5776:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    5778:	8b 81       	ldd	r24, Y+3	; 0x03
}
    577a:	0f 90       	pop	r0
    577c:	0f 90       	pop	r0
    577e:	0f 90       	pop	r0
    5780:	0f 90       	pop	r0
    5782:	0f 90       	pop	r0
    5784:	cf 91       	pop	r28
    5786:	df 91       	pop	r29
    5788:	08 95       	ret

0000578a <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    578a:	df 93       	push	r29
    578c:	cf 93       	push	r28
    578e:	00 d0       	rcall	.+0      	; 0x5790 <xTaskGetTickCount+0x6>
    5790:	cd b7       	in	r28, 0x3d	; 61
    5792:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    5794:	0f b6       	in	r0, 0x3f	; 63
    5796:	f8 94       	cli
    5798:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    579a:	80 91 80 04 	lds	r24, 0x0480
    579e:	90 91 81 04 	lds	r25, 0x0481
    57a2:	9a 83       	std	Y+2, r25	; 0x02
    57a4:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    57a6:	0f 90       	pop	r0
    57a8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    57aa:	89 81       	ldd	r24, Y+1	; 0x01
    57ac:	9a 81       	ldd	r25, Y+2	; 0x02
}
    57ae:	0f 90       	pop	r0
    57b0:	0f 90       	pop	r0
    57b2:	cf 91       	pop	r28
    57b4:	df 91       	pop	r29
    57b6:	08 95       	ret

000057b8 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    57b8:	df 93       	push	r29
    57ba:	cf 93       	push	r28
    57bc:	00 d0       	rcall	.+0      	; 0x57be <xTaskGetTickCountFromISR+0x6>
    57be:	0f 92       	push	r0
    57c0:	cd b7       	in	r28, 0x3d	; 61
    57c2:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    57c4:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    57c6:	80 91 80 04 	lds	r24, 0x0480
    57ca:	90 91 81 04 	lds	r25, 0x0481
    57ce:	9b 83       	std	Y+3, r25	; 0x03
    57d0:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    57d2:	8a 81       	ldd	r24, Y+2	; 0x02
    57d4:	9b 81       	ldd	r25, Y+3	; 0x03
}
    57d6:	0f 90       	pop	r0
    57d8:	0f 90       	pop	r0
    57da:	0f 90       	pop	r0
    57dc:	cf 91       	pop	r28
    57de:	df 91       	pop	r29
    57e0:	08 95       	ret

000057e2 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    57e2:	df 93       	push	r29
    57e4:	cf 93       	push	r28
    57e6:	cd b7       	in	r28, 0x3d	; 61
    57e8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    57ea:	80 91 7f 04 	lds	r24, 0x047F
}
    57ee:	cf 91       	pop	r28
    57f0:	df 91       	pop	r29
    57f2:	08 95       	ret

000057f4 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    57f4:	df 93       	push	r29
    57f6:	cf 93       	push	r28
    57f8:	00 d0       	rcall	.+0      	; 0x57fa <pcTaskGetName+0x6>
    57fa:	00 d0       	rcall	.+0      	; 0x57fc <pcTaskGetName+0x8>
    57fc:	00 d0       	rcall	.+0      	; 0x57fe <pcTaskGetName+0xa>
    57fe:	cd b7       	in	r28, 0x3d	; 61
    5800:	de b7       	in	r29, 0x3e	; 62
    5802:	9c 83       	std	Y+4, r25	; 0x04
    5804:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    5806:	8b 81       	ldd	r24, Y+3	; 0x03
    5808:	9c 81       	ldd	r25, Y+4	; 0x04
    580a:	00 97       	sbiw	r24, 0x00	; 0
    580c:	39 f4       	brne	.+14     	; 0x581c <pcTaskGetName+0x28>
    580e:	80 91 7c 04 	lds	r24, 0x047C
    5812:	90 91 7d 04 	lds	r25, 0x047D
    5816:	9e 83       	std	Y+6, r25	; 0x06
    5818:	8d 83       	std	Y+5, r24	; 0x05
    581a:	04 c0       	rjmp	.+8      	; 0x5824 <pcTaskGetName+0x30>
    581c:	8b 81       	ldd	r24, Y+3	; 0x03
    581e:	9c 81       	ldd	r25, Y+4	; 0x04
    5820:	9e 83       	std	Y+6, r25	; 0x06
    5822:	8d 83       	std	Y+5, r24	; 0x05
    5824:	8d 81       	ldd	r24, Y+5	; 0x05
    5826:	9e 81       	ldd	r25, Y+6	; 0x06
    5828:	9a 83       	std	Y+2, r25	; 0x02
    582a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    582c:	89 81       	ldd	r24, Y+1	; 0x01
    582e:	9a 81       	ldd	r25, Y+2	; 0x02
    5830:	49 96       	adiw	r24, 0x19	; 25
}
    5832:	26 96       	adiw	r28, 0x06	; 6
    5834:	0f b6       	in	r0, 0x3f	; 63
    5836:	f8 94       	cli
    5838:	de bf       	out	0x3e, r29	; 62
    583a:	0f be       	out	0x3f, r0	; 63
    583c:	cd bf       	out	0x3d, r28	; 61
    583e:	cf 91       	pop	r28
    5840:	df 91       	pop	r29
    5842:	08 95       	ret

00005844 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    5844:	df 93       	push	r29
    5846:	cf 93       	push	r28
    5848:	00 d0       	rcall	.+0      	; 0x584a <xTaskCatchUpTicks+0x6>
    584a:	0f 92       	push	r0
    584c:	cd b7       	in	r28, 0x3d	; 61
    584e:	de b7       	in	r29, 0x3e	; 62
    5850:	9b 83       	std	Y+3, r25	; 0x03
    5852:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xYieldRequired = pdFALSE;
    5854:	19 82       	std	Y+1, r1	; 0x01
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
    5856:	0e 94 1b 2b 	call	0x5636	; 0x5636 <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
    585a:	20 91 84 04 	lds	r18, 0x0484
    585e:	30 91 85 04 	lds	r19, 0x0485
    5862:	8a 81       	ldd	r24, Y+2	; 0x02
    5864:	9b 81       	ldd	r25, Y+3	; 0x03
    5866:	82 0f       	add	r24, r18
    5868:	93 1f       	adc	r25, r19
    586a:	90 93 85 04 	sts	0x0485, r25
    586e:	80 93 84 04 	sts	0x0484, r24
	xYieldRequired = xTaskResumeAll();
    5872:	0e 94 27 2b 	call	0x564e	; 0x564e <xTaskResumeAll>
    5876:	89 83       	std	Y+1, r24	; 0x01

	return xYieldRequired;
    5878:	89 81       	ldd	r24, Y+1	; 0x01
}
    587a:	0f 90       	pop	r0
    587c:	0f 90       	pop	r0
    587e:	0f 90       	pop	r0
    5880:	cf 91       	pop	r28
    5882:	df 91       	pop	r29
    5884:	08 95       	ret

00005886 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    5886:	df 93       	push	r29
    5888:	cf 93       	push	r28
    588a:	cd b7       	in	r28, 0x3d	; 61
    588c:	de b7       	in	r29, 0x3e	; 62
    588e:	29 97       	sbiw	r28, 0x09	; 9
    5890:	0f b6       	in	r0, 0x3f	; 63
    5892:	f8 94       	cli
    5894:	de bf       	out	0x3e, r29	; 62
    5896:	0f be       	out	0x3f, r0	; 63
    5898:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    589a:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    589c:	80 91 8d 04 	lds	r24, 0x048D
    58a0:	88 23       	and	r24, r24
    58a2:	09 f0       	breq	.+2      	; 0x58a6 <xTaskIncrementTick+0x20>
    58a4:	c6 c0       	rjmp	.+396    	; 0x5a32 <xTaskIncrementTick+0x1ac>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    58a6:	80 91 80 04 	lds	r24, 0x0480
    58aa:	90 91 81 04 	lds	r25, 0x0481
    58ae:	01 96       	adiw	r24, 0x01	; 1
    58b0:	9c 83       	std	Y+4, r25	; 0x04
    58b2:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    58b4:	8b 81       	ldd	r24, Y+3	; 0x03
    58b6:	9c 81       	ldd	r25, Y+4	; 0x04
    58b8:	90 93 81 04 	sts	0x0481, r25
    58bc:	80 93 80 04 	sts	0x0480, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    58c0:	8b 81       	ldd	r24, Y+3	; 0x03
    58c2:	9c 81       	ldd	r25, Y+4	; 0x04
    58c4:	00 97       	sbiw	r24, 0x00	; 0
    58c6:	d9 f4       	brne	.+54     	; 0x58fe <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    58c8:	80 91 cd 04 	lds	r24, 0x04CD
    58cc:	90 91 ce 04 	lds	r25, 0x04CE
    58d0:	9a 83       	std	Y+2, r25	; 0x02
    58d2:	89 83       	std	Y+1, r24	; 0x01
    58d4:	80 91 cf 04 	lds	r24, 0x04CF
    58d8:	90 91 d0 04 	lds	r25, 0x04D0
    58dc:	90 93 ce 04 	sts	0x04CE, r25
    58e0:	80 93 cd 04 	sts	0x04CD, r24
    58e4:	89 81       	ldd	r24, Y+1	; 0x01
    58e6:	9a 81       	ldd	r25, Y+2	; 0x02
    58e8:	90 93 d0 04 	sts	0x04D0, r25
    58ec:	80 93 cf 04 	sts	0x04CF, r24
    58f0:	80 91 87 04 	lds	r24, 0x0487
    58f4:	8f 5f       	subi	r24, 0xFF	; 255
    58f6:	80 93 87 04 	sts	0x0487, r24
    58fa:	0e 94 f1 2f 	call	0x5fe2	; 0x5fe2 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    58fe:	20 91 89 04 	lds	r18, 0x0489
    5902:	30 91 8a 04 	lds	r19, 0x048A
    5906:	8b 81       	ldd	r24, Y+3	; 0x03
    5908:	9c 81       	ldd	r25, Y+4	; 0x04
    590a:	82 17       	cp	r24, r18
    590c:	93 07       	cpc	r25, r19
    590e:	08 f4       	brcc	.+2      	; 0x5912 <xTaskIncrementTick+0x8c>
    5910:	71 c0       	rjmp	.+226    	; 0x59f4 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5912:	e0 91 cd 04 	lds	r30, 0x04CD
    5916:	f0 91 ce 04 	lds	r31, 0x04CE
    591a:	80 81       	ld	r24, Z
    591c:	88 23       	and	r24, r24
    591e:	39 f4       	brne	.+14     	; 0x592e <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5920:	8f ef       	ldi	r24, 0xFF	; 255
    5922:	9f ef       	ldi	r25, 0xFF	; 255
    5924:	90 93 8a 04 	sts	0x048A, r25
    5928:	80 93 89 04 	sts	0x0489, r24
    592c:	63 c0       	rjmp	.+198    	; 0x59f4 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    592e:	e0 91 cd 04 	lds	r30, 0x04CD
    5932:	f0 91 ce 04 	lds	r31, 0x04CE
    5936:	05 80       	ldd	r0, Z+5	; 0x05
    5938:	f6 81       	ldd	r31, Z+6	; 0x06
    593a:	e0 2d       	mov	r30, r0
    593c:	86 81       	ldd	r24, Z+6	; 0x06
    593e:	97 81       	ldd	r25, Z+7	; 0x07
    5940:	99 87       	std	Y+9, r25	; 0x09
    5942:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    5944:	e8 85       	ldd	r30, Y+8	; 0x08
    5946:	f9 85       	ldd	r31, Y+9	; 0x09
    5948:	82 81       	ldd	r24, Z+2	; 0x02
    594a:	93 81       	ldd	r25, Z+3	; 0x03
    594c:	9f 83       	std	Y+7, r25	; 0x07
    594e:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    5950:	2b 81       	ldd	r18, Y+3	; 0x03
    5952:	3c 81       	ldd	r19, Y+4	; 0x04
    5954:	8e 81       	ldd	r24, Y+6	; 0x06
    5956:	9f 81       	ldd	r25, Y+7	; 0x07
    5958:	28 17       	cp	r18, r24
    595a:	39 07       	cpc	r19, r25
    595c:	38 f4       	brcc	.+14     	; 0x596c <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    595e:	8e 81       	ldd	r24, Y+6	; 0x06
    5960:	9f 81       	ldd	r25, Y+7	; 0x07
    5962:	90 93 8a 04 	sts	0x048A, r25
    5966:	80 93 89 04 	sts	0x0489, r24
    596a:	44 c0       	rjmp	.+136    	; 0x59f4 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    596c:	88 85       	ldd	r24, Y+8	; 0x08
    596e:	99 85       	ldd	r25, Y+9	; 0x09
    5970:	02 96       	adiw	r24, 0x02	; 2
    5972:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5976:	e8 85       	ldd	r30, Y+8	; 0x08
    5978:	f9 85       	ldd	r31, Y+9	; 0x09
    597a:	84 89       	ldd	r24, Z+20	; 0x14
    597c:	95 89       	ldd	r25, Z+21	; 0x15
    597e:	00 97       	sbiw	r24, 0x00	; 0
    5980:	29 f0       	breq	.+10     	; 0x598c <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5982:	88 85       	ldd	r24, Y+8	; 0x08
    5984:	99 85       	ldd	r25, Y+9	; 0x09
    5986:	0c 96       	adiw	r24, 0x0c	; 12
    5988:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    598c:	e8 85       	ldd	r30, Y+8	; 0x08
    598e:	f9 85       	ldd	r31, Y+9	; 0x09
    5990:	96 89       	ldd	r25, Z+22	; 0x16
    5992:	80 91 82 04 	lds	r24, 0x0482
    5996:	89 17       	cp	r24, r25
    5998:	28 f4       	brcc	.+10     	; 0x59a4 <xTaskIncrementTick+0x11e>
    599a:	e8 85       	ldd	r30, Y+8	; 0x08
    599c:	f9 85       	ldd	r31, Y+9	; 0x09
    599e:	86 89       	ldd	r24, Z+22	; 0x16
    59a0:	80 93 82 04 	sts	0x0482, r24
    59a4:	e8 85       	ldd	r30, Y+8	; 0x08
    59a6:	f9 85       	ldd	r31, Y+9	; 0x09
    59a8:	86 89       	ldd	r24, Z+22	; 0x16
    59aa:	28 2f       	mov	r18, r24
    59ac:	30 e0       	ldi	r19, 0x00	; 0
    59ae:	c9 01       	movw	r24, r18
    59b0:	88 0f       	add	r24, r24
    59b2:	99 1f       	adc	r25, r25
    59b4:	88 0f       	add	r24, r24
    59b6:	99 1f       	adc	r25, r25
    59b8:	88 0f       	add	r24, r24
    59ba:	99 1f       	adc	r25, r25
    59bc:	82 0f       	add	r24, r18
    59be:	93 1f       	adc	r25, r19
    59c0:	ac 01       	movw	r20, r24
    59c2:	42 57       	subi	r20, 0x72	; 114
    59c4:	5b 4f       	sbci	r21, 0xFB	; 251
    59c6:	88 85       	ldd	r24, Y+8	; 0x08
    59c8:	99 85       	ldd	r25, Y+9	; 0x09
    59ca:	9c 01       	movw	r18, r24
    59cc:	2e 5f       	subi	r18, 0xFE	; 254
    59ce:	3f 4f       	sbci	r19, 0xFF	; 255
    59d0:	ca 01       	movw	r24, r20
    59d2:	b9 01       	movw	r22, r18
    59d4:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    59d8:	e8 85       	ldd	r30, Y+8	; 0x08
    59da:	f9 85       	ldd	r31, Y+9	; 0x09
    59dc:	96 89       	ldd	r25, Z+22	; 0x16
    59de:	e0 91 7c 04 	lds	r30, 0x047C
    59e2:	f0 91 7d 04 	lds	r31, 0x047D
    59e6:	86 89       	ldd	r24, Z+22	; 0x16
    59e8:	98 17       	cp	r25, r24
    59ea:	08 f4       	brcc	.+2      	; 0x59ee <xTaskIncrementTick+0x168>
    59ec:	92 cf       	rjmp	.-220    	; 0x5912 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    59ee:	81 e0       	ldi	r24, 0x01	; 1
    59f0:	8d 83       	std	Y+5, r24	; 0x05
    59f2:	8f cf       	rjmp	.-226    	; 0x5912 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    59f4:	e0 91 7c 04 	lds	r30, 0x047C
    59f8:	f0 91 7d 04 	lds	r31, 0x047D
    59fc:	86 89       	ldd	r24, Z+22	; 0x16
    59fe:	28 2f       	mov	r18, r24
    5a00:	30 e0       	ldi	r19, 0x00	; 0
    5a02:	c9 01       	movw	r24, r18
    5a04:	88 0f       	add	r24, r24
    5a06:	99 1f       	adc	r25, r25
    5a08:	88 0f       	add	r24, r24
    5a0a:	99 1f       	adc	r25, r25
    5a0c:	88 0f       	add	r24, r24
    5a0e:	99 1f       	adc	r25, r25
    5a10:	82 0f       	add	r24, r18
    5a12:	93 1f       	adc	r25, r19
    5a14:	fc 01       	movw	r30, r24
    5a16:	e2 57       	subi	r30, 0x72	; 114
    5a18:	fb 4f       	sbci	r31, 0xFB	; 251
    5a1a:	80 81       	ld	r24, Z
    5a1c:	82 30       	cpi	r24, 0x02	; 2
    5a1e:	10 f0       	brcs	.+4      	; 0x5a24 <xTaskIncrementTick+0x19e>
			{
				xSwitchRequired = pdTRUE;
    5a20:	81 e0       	ldi	r24, 0x01	; 1
    5a22:	8d 83       	std	Y+5, r24	; 0x05
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
    5a24:	80 91 86 04 	lds	r24, 0x0486
    5a28:	88 23       	and	r24, r24
    5a2a:	61 f0       	breq	.+24     	; 0x5a44 <xTaskIncrementTick+0x1be>
			{
				xSwitchRequired = pdTRUE;
    5a2c:	81 e0       	ldi	r24, 0x01	; 1
    5a2e:	8d 83       	std	Y+5, r24	; 0x05
    5a30:	09 c0       	rjmp	.+18     	; 0x5a44 <xTaskIncrementTick+0x1be>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
    5a32:	80 91 84 04 	lds	r24, 0x0484
    5a36:	90 91 85 04 	lds	r25, 0x0485
    5a3a:	01 96       	adiw	r24, 0x01	; 1
    5a3c:	90 93 85 04 	sts	0x0485, r25
    5a40:	80 93 84 04 	sts	0x0484, r24
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
    5a44:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5a46:	29 96       	adiw	r28, 0x09	; 9
    5a48:	0f b6       	in	r0, 0x3f	; 63
    5a4a:	f8 94       	cli
    5a4c:	de bf       	out	0x3e, r29	; 62
    5a4e:	0f be       	out	0x3f, r0	; 63
    5a50:	cd bf       	out	0x3d, r28	; 61
    5a52:	cf 91       	pop	r28
    5a54:	df 91       	pop	r29
    5a56:	08 95       	ret

00005a58 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    5a58:	df 93       	push	r29
    5a5a:	cf 93       	push	r28
    5a5c:	00 d0       	rcall	.+0      	; 0x5a5e <vTaskSwitchContext+0x6>
    5a5e:	0f 92       	push	r0
    5a60:	cd b7       	in	r28, 0x3d	; 61
    5a62:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    5a64:	80 91 8d 04 	lds	r24, 0x048D
    5a68:	88 23       	and	r24, r24
    5a6a:	21 f0       	breq	.+8      	; 0x5a74 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    5a6c:	81 e0       	ldi	r24, 0x01	; 1
    5a6e:	80 93 86 04 	sts	0x0486, r24
    5a72:	59 c0       	rjmp	.+178    	; 0x5b26 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    5a74:	10 92 86 04 	sts	0x0486, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5a78:	80 91 82 04 	lds	r24, 0x0482
    5a7c:	8b 83       	std	Y+3, r24	; 0x03
    5a7e:	03 c0       	rjmp	.+6      	; 0x5a86 <vTaskSwitchContext+0x2e>
    5a80:	8b 81       	ldd	r24, Y+3	; 0x03
    5a82:	81 50       	subi	r24, 0x01	; 1
    5a84:	8b 83       	std	Y+3, r24	; 0x03
    5a86:	8b 81       	ldd	r24, Y+3	; 0x03
    5a88:	28 2f       	mov	r18, r24
    5a8a:	30 e0       	ldi	r19, 0x00	; 0
    5a8c:	c9 01       	movw	r24, r18
    5a8e:	88 0f       	add	r24, r24
    5a90:	99 1f       	adc	r25, r25
    5a92:	88 0f       	add	r24, r24
    5a94:	99 1f       	adc	r25, r25
    5a96:	88 0f       	add	r24, r24
    5a98:	99 1f       	adc	r25, r25
    5a9a:	82 0f       	add	r24, r18
    5a9c:	93 1f       	adc	r25, r19
    5a9e:	fc 01       	movw	r30, r24
    5aa0:	e2 57       	subi	r30, 0x72	; 114
    5aa2:	fb 4f       	sbci	r31, 0xFB	; 251
    5aa4:	80 81       	ld	r24, Z
    5aa6:	88 23       	and	r24, r24
    5aa8:	59 f3       	breq	.-42     	; 0x5a80 <vTaskSwitchContext+0x28>
    5aaa:	8b 81       	ldd	r24, Y+3	; 0x03
    5aac:	28 2f       	mov	r18, r24
    5aae:	30 e0       	ldi	r19, 0x00	; 0
    5ab0:	c9 01       	movw	r24, r18
    5ab2:	88 0f       	add	r24, r24
    5ab4:	99 1f       	adc	r25, r25
    5ab6:	88 0f       	add	r24, r24
    5ab8:	99 1f       	adc	r25, r25
    5aba:	88 0f       	add	r24, r24
    5abc:	99 1f       	adc	r25, r25
    5abe:	82 0f       	add	r24, r18
    5ac0:	93 1f       	adc	r25, r19
    5ac2:	82 57       	subi	r24, 0x72	; 114
    5ac4:	9b 4f       	sbci	r25, 0xFB	; 251
    5ac6:	9a 83       	std	Y+2, r25	; 0x02
    5ac8:	89 83       	std	Y+1, r24	; 0x01
    5aca:	e9 81       	ldd	r30, Y+1	; 0x01
    5acc:	fa 81       	ldd	r31, Y+2	; 0x02
    5ace:	01 80       	ldd	r0, Z+1	; 0x01
    5ad0:	f2 81       	ldd	r31, Z+2	; 0x02
    5ad2:	e0 2d       	mov	r30, r0
    5ad4:	82 81       	ldd	r24, Z+2	; 0x02
    5ad6:	93 81       	ldd	r25, Z+3	; 0x03
    5ad8:	e9 81       	ldd	r30, Y+1	; 0x01
    5ada:	fa 81       	ldd	r31, Y+2	; 0x02
    5adc:	92 83       	std	Z+2, r25	; 0x02
    5ade:	81 83       	std	Z+1, r24	; 0x01
    5ae0:	e9 81       	ldd	r30, Y+1	; 0x01
    5ae2:	fa 81       	ldd	r31, Y+2	; 0x02
    5ae4:	21 81       	ldd	r18, Z+1	; 0x01
    5ae6:	32 81       	ldd	r19, Z+2	; 0x02
    5ae8:	89 81       	ldd	r24, Y+1	; 0x01
    5aea:	9a 81       	ldd	r25, Y+2	; 0x02
    5aec:	03 96       	adiw	r24, 0x03	; 3
    5aee:	28 17       	cp	r18, r24
    5af0:	39 07       	cpc	r19, r25
    5af2:	59 f4       	brne	.+22     	; 0x5b0a <vTaskSwitchContext+0xb2>
    5af4:	e9 81       	ldd	r30, Y+1	; 0x01
    5af6:	fa 81       	ldd	r31, Y+2	; 0x02
    5af8:	01 80       	ldd	r0, Z+1	; 0x01
    5afa:	f2 81       	ldd	r31, Z+2	; 0x02
    5afc:	e0 2d       	mov	r30, r0
    5afe:	82 81       	ldd	r24, Z+2	; 0x02
    5b00:	93 81       	ldd	r25, Z+3	; 0x03
    5b02:	e9 81       	ldd	r30, Y+1	; 0x01
    5b04:	fa 81       	ldd	r31, Y+2	; 0x02
    5b06:	92 83       	std	Z+2, r25	; 0x02
    5b08:	81 83       	std	Z+1, r24	; 0x01
    5b0a:	e9 81       	ldd	r30, Y+1	; 0x01
    5b0c:	fa 81       	ldd	r31, Y+2	; 0x02
    5b0e:	01 80       	ldd	r0, Z+1	; 0x01
    5b10:	f2 81       	ldd	r31, Z+2	; 0x02
    5b12:	e0 2d       	mov	r30, r0
    5b14:	86 81       	ldd	r24, Z+6	; 0x06
    5b16:	97 81       	ldd	r25, Z+7	; 0x07
    5b18:	90 93 7d 04 	sts	0x047D, r25
    5b1c:	80 93 7c 04 	sts	0x047C, r24
    5b20:	8b 81       	ldd	r24, Y+3	; 0x03
    5b22:	80 93 82 04 	sts	0x0482, r24
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    5b26:	0f 90       	pop	r0
    5b28:	0f 90       	pop	r0
    5b2a:	0f 90       	pop	r0
    5b2c:	cf 91       	pop	r28
    5b2e:	df 91       	pop	r29
    5b30:	08 95       	ret

00005b32 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    5b32:	df 93       	push	r29
    5b34:	cf 93       	push	r28
    5b36:	00 d0       	rcall	.+0      	; 0x5b38 <vTaskPlaceOnEventList+0x6>
    5b38:	00 d0       	rcall	.+0      	; 0x5b3a <vTaskPlaceOnEventList+0x8>
    5b3a:	cd b7       	in	r28, 0x3d	; 61
    5b3c:	de b7       	in	r29, 0x3e	; 62
    5b3e:	9a 83       	std	Y+2, r25	; 0x02
    5b40:	89 83       	std	Y+1, r24	; 0x01
    5b42:	7c 83       	std	Y+4, r23	; 0x04
    5b44:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5b46:	80 91 7c 04 	lds	r24, 0x047C
    5b4a:	90 91 7d 04 	lds	r25, 0x047D
    5b4e:	9c 01       	movw	r18, r24
    5b50:	24 5f       	subi	r18, 0xF4	; 244
    5b52:	3f 4f       	sbci	r19, 0xFF	; 255
    5b54:	89 81       	ldd	r24, Y+1	; 0x01
    5b56:	9a 81       	ldd	r25, Y+2	; 0x02
    5b58:	b9 01       	movw	r22, r18
    5b5a:	0e 94 62 19 	call	0x32c4	; 0x32c4 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5b5e:	8b 81       	ldd	r24, Y+3	; 0x03
    5b60:	9c 81       	ldd	r25, Y+4	; 0x04
    5b62:	61 e0       	ldi	r22, 0x01	; 1
    5b64:	0e 94 46 34 	call	0x688c	; 0x688c <prvAddCurrentTaskToDelayedList>
}
    5b68:	0f 90       	pop	r0
    5b6a:	0f 90       	pop	r0
    5b6c:	0f 90       	pop	r0
    5b6e:	0f 90       	pop	r0
    5b70:	cf 91       	pop	r28
    5b72:	df 91       	pop	r29
    5b74:	08 95       	ret

00005b76 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    5b76:	df 93       	push	r29
    5b78:	cf 93       	push	r28
    5b7a:	00 d0       	rcall	.+0      	; 0x5b7c <vTaskPlaceOnUnorderedEventList+0x6>
    5b7c:	00 d0       	rcall	.+0      	; 0x5b7e <vTaskPlaceOnUnorderedEventList+0x8>
    5b7e:	00 d0       	rcall	.+0      	; 0x5b80 <vTaskPlaceOnUnorderedEventList+0xa>
    5b80:	cd b7       	in	r28, 0x3d	; 61
    5b82:	de b7       	in	r29, 0x3e	; 62
    5b84:	9a 83       	std	Y+2, r25	; 0x02
    5b86:	89 83       	std	Y+1, r24	; 0x01
    5b88:	7c 83       	std	Y+4, r23	; 0x04
    5b8a:	6b 83       	std	Y+3, r22	; 0x03
    5b8c:	5e 83       	std	Y+6, r21	; 0x06
    5b8e:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5b90:	e0 91 7c 04 	lds	r30, 0x047C
    5b94:	f0 91 7d 04 	lds	r31, 0x047D
    5b98:	8b 81       	ldd	r24, Y+3	; 0x03
    5b9a:	9c 81       	ldd	r25, Y+4	; 0x04
    5b9c:	90 68       	ori	r25, 0x80	; 128
    5b9e:	95 87       	std	Z+13, r25	; 0x0d
    5ba0:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5ba2:	80 91 7c 04 	lds	r24, 0x047C
    5ba6:	90 91 7d 04 	lds	r25, 0x047D
    5baa:	9c 01       	movw	r18, r24
    5bac:	24 5f       	subi	r18, 0xF4	; 244
    5bae:	3f 4f       	sbci	r19, 0xFF	; 255
    5bb0:	89 81       	ldd	r24, Y+1	; 0x01
    5bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    5bb4:	b9 01       	movw	r22, r18
    5bb6:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5bba:	8d 81       	ldd	r24, Y+5	; 0x05
    5bbc:	9e 81       	ldd	r25, Y+6	; 0x06
    5bbe:	61 e0       	ldi	r22, 0x01	; 1
    5bc0:	0e 94 46 34 	call	0x688c	; 0x688c <prvAddCurrentTaskToDelayedList>
}
    5bc4:	26 96       	adiw	r28, 0x06	; 6
    5bc6:	0f b6       	in	r0, 0x3f	; 63
    5bc8:	f8 94       	cli
    5bca:	de bf       	out	0x3e, r29	; 62
    5bcc:	0f be       	out	0x3f, r0	; 63
    5bce:	cd bf       	out	0x3d, r28	; 61
    5bd0:	cf 91       	pop	r28
    5bd2:	df 91       	pop	r29
    5bd4:	08 95       	ret

00005bd6 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    5bd6:	df 93       	push	r29
    5bd8:	cf 93       	push	r28
    5bda:	00 d0       	rcall	.+0      	; 0x5bdc <xTaskRemoveFromEventList+0x6>
    5bdc:	00 d0       	rcall	.+0      	; 0x5bde <xTaskRemoveFromEventList+0x8>
    5bde:	0f 92       	push	r0
    5be0:	cd b7       	in	r28, 0x3d	; 61
    5be2:	de b7       	in	r29, 0x3e	; 62
    5be4:	9d 83       	std	Y+5, r25	; 0x05
    5be6:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5be8:	ec 81       	ldd	r30, Y+4	; 0x04
    5bea:	fd 81       	ldd	r31, Y+5	; 0x05
    5bec:	05 80       	ldd	r0, Z+5	; 0x05
    5bee:	f6 81       	ldd	r31, Z+6	; 0x06
    5bf0:	e0 2d       	mov	r30, r0
    5bf2:	86 81       	ldd	r24, Z+6	; 0x06
    5bf4:	97 81       	ldd	r25, Z+7	; 0x07
    5bf6:	9b 83       	std	Y+3, r25	; 0x03
    5bf8:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    5bfa:	8a 81       	ldd	r24, Y+2	; 0x02
    5bfc:	9b 81       	ldd	r25, Y+3	; 0x03
    5bfe:	0c 96       	adiw	r24, 0x0c	; 12
    5c00:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5c04:	80 91 8d 04 	lds	r24, 0x048D
    5c08:	88 23       	and	r24, r24
    5c0a:	61 f5       	brne	.+88     	; 0x5c64 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5c0c:	8a 81       	ldd	r24, Y+2	; 0x02
    5c0e:	9b 81       	ldd	r25, Y+3	; 0x03
    5c10:	02 96       	adiw	r24, 0x02	; 2
    5c12:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    5c16:	ea 81       	ldd	r30, Y+2	; 0x02
    5c18:	fb 81       	ldd	r31, Y+3	; 0x03
    5c1a:	96 89       	ldd	r25, Z+22	; 0x16
    5c1c:	80 91 82 04 	lds	r24, 0x0482
    5c20:	89 17       	cp	r24, r25
    5c22:	28 f4       	brcc	.+10     	; 0x5c2e <xTaskRemoveFromEventList+0x58>
    5c24:	ea 81       	ldd	r30, Y+2	; 0x02
    5c26:	fb 81       	ldd	r31, Y+3	; 0x03
    5c28:	86 89       	ldd	r24, Z+22	; 0x16
    5c2a:	80 93 82 04 	sts	0x0482, r24
    5c2e:	ea 81       	ldd	r30, Y+2	; 0x02
    5c30:	fb 81       	ldd	r31, Y+3	; 0x03
    5c32:	86 89       	ldd	r24, Z+22	; 0x16
    5c34:	28 2f       	mov	r18, r24
    5c36:	30 e0       	ldi	r19, 0x00	; 0
    5c38:	c9 01       	movw	r24, r18
    5c3a:	88 0f       	add	r24, r24
    5c3c:	99 1f       	adc	r25, r25
    5c3e:	88 0f       	add	r24, r24
    5c40:	99 1f       	adc	r25, r25
    5c42:	88 0f       	add	r24, r24
    5c44:	99 1f       	adc	r25, r25
    5c46:	82 0f       	add	r24, r18
    5c48:	93 1f       	adc	r25, r19
    5c4a:	ac 01       	movw	r20, r24
    5c4c:	42 57       	subi	r20, 0x72	; 114
    5c4e:	5b 4f       	sbci	r21, 0xFB	; 251
    5c50:	8a 81       	ldd	r24, Y+2	; 0x02
    5c52:	9b 81       	ldd	r25, Y+3	; 0x03
    5c54:	9c 01       	movw	r18, r24
    5c56:	2e 5f       	subi	r18, 0xFE	; 254
    5c58:	3f 4f       	sbci	r19, 0xFF	; 255
    5c5a:	ca 01       	movw	r24, r20
    5c5c:	b9 01       	movw	r22, r18
    5c5e:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
    5c62:	0a c0       	rjmp	.+20     	; 0x5c78 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    5c64:	8a 81       	ldd	r24, Y+2	; 0x02
    5c66:	9b 81       	ldd	r25, Y+3	; 0x03
    5c68:	9c 01       	movw	r18, r24
    5c6a:	24 5f       	subi	r18, 0xF4	; 244
    5c6c:	3f 4f       	sbci	r19, 0xFF	; 255
    5c6e:	81 ed       	ldi	r24, 0xD1	; 209
    5c70:	94 e0       	ldi	r25, 0x04	; 4
    5c72:	b9 01       	movw	r22, r18
    5c74:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5c78:	ea 81       	ldd	r30, Y+2	; 0x02
    5c7a:	fb 81       	ldd	r31, Y+3	; 0x03
    5c7c:	96 89       	ldd	r25, Z+22	; 0x16
    5c7e:	e0 91 7c 04 	lds	r30, 0x047C
    5c82:	f0 91 7d 04 	lds	r31, 0x047D
    5c86:	86 89       	ldd	r24, Z+22	; 0x16
    5c88:	89 17       	cp	r24, r25
    5c8a:	30 f4       	brcc	.+12     	; 0x5c98 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    5c8c:	81 e0       	ldi	r24, 0x01	; 1
    5c8e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    5c90:	81 e0       	ldi	r24, 0x01	; 1
    5c92:	80 93 86 04 	sts	0x0486, r24
    5c96:	01 c0       	rjmp	.+2      	; 0x5c9a <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    5c98:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    5c9a:	89 81       	ldd	r24, Y+1	; 0x01
}
    5c9c:	0f 90       	pop	r0
    5c9e:	0f 90       	pop	r0
    5ca0:	0f 90       	pop	r0
    5ca2:	0f 90       	pop	r0
    5ca4:	0f 90       	pop	r0
    5ca6:	cf 91       	pop	r28
    5ca8:	df 91       	pop	r29
    5caa:	08 95       	ret

00005cac <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    5cac:	df 93       	push	r29
    5cae:	cf 93       	push	r28
    5cb0:	00 d0       	rcall	.+0      	; 0x5cb2 <vTaskRemoveFromUnorderedEventList+0x6>
    5cb2:	00 d0       	rcall	.+0      	; 0x5cb4 <vTaskRemoveFromUnorderedEventList+0x8>
    5cb4:	00 d0       	rcall	.+0      	; 0x5cb6 <vTaskRemoveFromUnorderedEventList+0xa>
    5cb6:	cd b7       	in	r28, 0x3d	; 61
    5cb8:	de b7       	in	r29, 0x3e	; 62
    5cba:	9c 83       	std	Y+4, r25	; 0x04
    5cbc:	8b 83       	std	Y+3, r24	; 0x03
    5cbe:	7e 83       	std	Y+6, r23	; 0x06
    5cc0:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5cc2:	8d 81       	ldd	r24, Y+5	; 0x05
    5cc4:	9e 81       	ldd	r25, Y+6	; 0x06
    5cc6:	90 68       	ori	r25, 0x80	; 128
    5cc8:	eb 81       	ldd	r30, Y+3	; 0x03
    5cca:	fc 81       	ldd	r31, Y+4	; 0x04
    5ccc:	91 83       	std	Z+1, r25	; 0x01
    5cce:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5cd0:	eb 81       	ldd	r30, Y+3	; 0x03
    5cd2:	fc 81       	ldd	r31, Y+4	; 0x04
    5cd4:	86 81       	ldd	r24, Z+6	; 0x06
    5cd6:	97 81       	ldd	r25, Z+7	; 0x07
    5cd8:	9a 83       	std	Y+2, r25	; 0x02
    5cda:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    5cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    5cde:	9c 81       	ldd	r25, Y+4	; 0x04
    5ce0:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    5ce4:	89 81       	ldd	r24, Y+1	; 0x01
    5ce6:	9a 81       	ldd	r25, Y+2	; 0x02
    5ce8:	02 96       	adiw	r24, 0x02	; 2
    5cea:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    5cee:	e9 81       	ldd	r30, Y+1	; 0x01
    5cf0:	fa 81       	ldd	r31, Y+2	; 0x02
    5cf2:	96 89       	ldd	r25, Z+22	; 0x16
    5cf4:	80 91 82 04 	lds	r24, 0x0482
    5cf8:	89 17       	cp	r24, r25
    5cfa:	28 f4       	brcc	.+10     	; 0x5d06 <vTaskRemoveFromUnorderedEventList+0x5a>
    5cfc:	e9 81       	ldd	r30, Y+1	; 0x01
    5cfe:	fa 81       	ldd	r31, Y+2	; 0x02
    5d00:	86 89       	ldd	r24, Z+22	; 0x16
    5d02:	80 93 82 04 	sts	0x0482, r24
    5d06:	e9 81       	ldd	r30, Y+1	; 0x01
    5d08:	fa 81       	ldd	r31, Y+2	; 0x02
    5d0a:	86 89       	ldd	r24, Z+22	; 0x16
    5d0c:	28 2f       	mov	r18, r24
    5d0e:	30 e0       	ldi	r19, 0x00	; 0
    5d10:	c9 01       	movw	r24, r18
    5d12:	88 0f       	add	r24, r24
    5d14:	99 1f       	adc	r25, r25
    5d16:	88 0f       	add	r24, r24
    5d18:	99 1f       	adc	r25, r25
    5d1a:	88 0f       	add	r24, r24
    5d1c:	99 1f       	adc	r25, r25
    5d1e:	82 0f       	add	r24, r18
    5d20:	93 1f       	adc	r25, r19
    5d22:	ac 01       	movw	r20, r24
    5d24:	42 57       	subi	r20, 0x72	; 114
    5d26:	5b 4f       	sbci	r21, 0xFB	; 251
    5d28:	89 81       	ldd	r24, Y+1	; 0x01
    5d2a:	9a 81       	ldd	r25, Y+2	; 0x02
    5d2c:	9c 01       	movw	r18, r24
    5d2e:	2e 5f       	subi	r18, 0xFE	; 254
    5d30:	3f 4f       	sbci	r19, 0xFF	; 255
    5d32:	ca 01       	movw	r24, r20
    5d34:	b9 01       	movw	r22, r18
    5d36:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    5d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    5d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    5d3e:	96 89       	ldd	r25, Z+22	; 0x16
    5d40:	e0 91 7c 04 	lds	r30, 0x047C
    5d44:	f0 91 7d 04 	lds	r31, 0x047D
    5d48:	86 89       	ldd	r24, Z+22	; 0x16
    5d4a:	89 17       	cp	r24, r25
    5d4c:	18 f4       	brcc	.+6      	; 0x5d54 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    5d4e:	81 e0       	ldi	r24, 0x01	; 1
    5d50:	80 93 86 04 	sts	0x0486, r24
	}
}
    5d54:	26 96       	adiw	r28, 0x06	; 6
    5d56:	0f b6       	in	r0, 0x3f	; 63
    5d58:	f8 94       	cli
    5d5a:	de bf       	out	0x3e, r29	; 62
    5d5c:	0f be       	out	0x3f, r0	; 63
    5d5e:	cd bf       	out	0x3d, r28	; 61
    5d60:	cf 91       	pop	r28
    5d62:	df 91       	pop	r29
    5d64:	08 95       	ret

00005d66 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5d66:	df 93       	push	r29
    5d68:	cf 93       	push	r28
    5d6a:	00 d0       	rcall	.+0      	; 0x5d6c <vTaskSetTimeOutState+0x6>
    5d6c:	cd b7       	in	r28, 0x3d	; 61
    5d6e:	de b7       	in	r29, 0x3e	; 62
    5d70:	9a 83       	std	Y+2, r25	; 0x02
    5d72:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    5d74:	0f b6       	in	r0, 0x3f	; 63
    5d76:	f8 94       	cli
    5d78:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    5d7a:	80 91 87 04 	lds	r24, 0x0487
    5d7e:	e9 81       	ldd	r30, Y+1	; 0x01
    5d80:	fa 81       	ldd	r31, Y+2	; 0x02
    5d82:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    5d84:	80 91 80 04 	lds	r24, 0x0480
    5d88:	90 91 81 04 	lds	r25, 0x0481
    5d8c:	e9 81       	ldd	r30, Y+1	; 0x01
    5d8e:	fa 81       	ldd	r31, Y+2	; 0x02
    5d90:	92 83       	std	Z+2, r25	; 0x02
    5d92:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5d94:	0f 90       	pop	r0
    5d96:	0f be       	out	0x3f, r0	; 63
}
    5d98:	0f 90       	pop	r0
    5d9a:	0f 90       	pop	r0
    5d9c:	cf 91       	pop	r28
    5d9e:	df 91       	pop	r29
    5da0:	08 95       	ret

00005da2 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    5da2:	df 93       	push	r29
    5da4:	cf 93       	push	r28
    5da6:	00 d0       	rcall	.+0      	; 0x5da8 <vTaskInternalSetTimeOutState+0x6>
    5da8:	cd b7       	in	r28, 0x3d	; 61
    5daa:	de b7       	in	r29, 0x3e	; 62
    5dac:	9a 83       	std	Y+2, r25	; 0x02
    5dae:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    5db0:	80 91 87 04 	lds	r24, 0x0487
    5db4:	e9 81       	ldd	r30, Y+1	; 0x01
    5db6:	fa 81       	ldd	r31, Y+2	; 0x02
    5db8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    5dba:	80 91 80 04 	lds	r24, 0x0480
    5dbe:	90 91 81 04 	lds	r25, 0x0481
    5dc2:	e9 81       	ldd	r30, Y+1	; 0x01
    5dc4:	fa 81       	ldd	r31, Y+2	; 0x02
    5dc6:	92 83       	std	Z+2, r25	; 0x02
    5dc8:	81 83       	std	Z+1, r24	; 0x01
}
    5dca:	0f 90       	pop	r0
    5dcc:	0f 90       	pop	r0
    5dce:	cf 91       	pop	r28
    5dd0:	df 91       	pop	r29
    5dd2:	08 95       	ret

00005dd4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    5dd4:	df 93       	push	r29
    5dd6:	cf 93       	push	r28
    5dd8:	cd b7       	in	r28, 0x3d	; 61
    5dda:	de b7       	in	r29, 0x3e	; 62
    5ddc:	29 97       	sbiw	r28, 0x09	; 9
    5dde:	0f b6       	in	r0, 0x3f	; 63
    5de0:	f8 94       	cli
    5de2:	de bf       	out	0x3e, r29	; 62
    5de4:	0f be       	out	0x3f, r0	; 63
    5de6:	cd bf       	out	0x3d, r28	; 61
    5de8:	9f 83       	std	Y+7, r25	; 0x07
    5dea:	8e 83       	std	Y+6, r24	; 0x06
    5dec:	79 87       	std	Y+9, r23	; 0x09
    5dee:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    5df0:	0f b6       	in	r0, 0x3f	; 63
    5df2:	f8 94       	cli
    5df4:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    5df6:	80 91 80 04 	lds	r24, 0x0480
    5dfa:	90 91 81 04 	lds	r25, 0x0481
    5dfe:	9c 83       	std	Y+4, r25	; 0x04
    5e00:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    5e02:	ee 81       	ldd	r30, Y+6	; 0x06
    5e04:	ff 81       	ldd	r31, Y+7	; 0x07
    5e06:	21 81       	ldd	r18, Z+1	; 0x01
    5e08:	32 81       	ldd	r19, Z+2	; 0x02
    5e0a:	8b 81       	ldd	r24, Y+3	; 0x03
    5e0c:	9c 81       	ldd	r25, Y+4	; 0x04
    5e0e:	82 1b       	sub	r24, r18
    5e10:	93 0b       	sbc	r25, r19
    5e12:	9a 83       	std	Y+2, r25	; 0x02
    5e14:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    5e16:	e8 85       	ldd	r30, Y+8	; 0x08
    5e18:	f9 85       	ldd	r31, Y+9	; 0x09
    5e1a:	80 81       	ld	r24, Z
    5e1c:	91 81       	ldd	r25, Z+1	; 0x01
    5e1e:	2f ef       	ldi	r18, 0xFF	; 255
    5e20:	8f 3f       	cpi	r24, 0xFF	; 255
    5e22:	92 07       	cpc	r25, r18
    5e24:	11 f4       	brne	.+4      	; 0x5e2a <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    5e26:	1d 82       	std	Y+5, r1	; 0x05
    5e28:	36 c0       	rjmp	.+108    	; 0x5e96 <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    5e2a:	ee 81       	ldd	r30, Y+6	; 0x06
    5e2c:	ff 81       	ldd	r31, Y+7	; 0x07
    5e2e:	90 81       	ld	r25, Z
    5e30:	80 91 87 04 	lds	r24, 0x0487
    5e34:	98 17       	cp	r25, r24
    5e36:	61 f0       	breq	.+24     	; 0x5e50 <xTaskCheckForTimeOut+0x7c>
    5e38:	ee 81       	ldd	r30, Y+6	; 0x06
    5e3a:	ff 81       	ldd	r31, Y+7	; 0x07
    5e3c:	21 81       	ldd	r18, Z+1	; 0x01
    5e3e:	32 81       	ldd	r19, Z+2	; 0x02
    5e40:	8b 81       	ldd	r24, Y+3	; 0x03
    5e42:	9c 81       	ldd	r25, Y+4	; 0x04
    5e44:	82 17       	cp	r24, r18
    5e46:	93 07       	cpc	r25, r19
    5e48:	18 f0       	brcs	.+6      	; 0x5e50 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    5e4a:	81 e0       	ldi	r24, 0x01	; 1
    5e4c:	8d 83       	std	Y+5, r24	; 0x05
    5e4e:	23 c0       	rjmp	.+70     	; 0x5e96 <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    5e50:	e8 85       	ldd	r30, Y+8	; 0x08
    5e52:	f9 85       	ldd	r31, Y+9	; 0x09
    5e54:	20 81       	ld	r18, Z
    5e56:	31 81       	ldd	r19, Z+1	; 0x01
    5e58:	89 81       	ldd	r24, Y+1	; 0x01
    5e5a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e5c:	82 17       	cp	r24, r18
    5e5e:	93 07       	cpc	r25, r19
    5e60:	a0 f4       	brcc	.+40     	; 0x5e8a <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    5e62:	e8 85       	ldd	r30, Y+8	; 0x08
    5e64:	f9 85       	ldd	r31, Y+9	; 0x09
    5e66:	20 81       	ld	r18, Z
    5e68:	31 81       	ldd	r19, Z+1	; 0x01
    5e6a:	89 81       	ldd	r24, Y+1	; 0x01
    5e6c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e6e:	a9 01       	movw	r20, r18
    5e70:	48 1b       	sub	r20, r24
    5e72:	59 0b       	sbc	r21, r25
    5e74:	ca 01       	movw	r24, r20
    5e76:	e8 85       	ldd	r30, Y+8	; 0x08
    5e78:	f9 85       	ldd	r31, Y+9	; 0x09
    5e7a:	91 83       	std	Z+1, r25	; 0x01
    5e7c:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    5e7e:	8e 81       	ldd	r24, Y+6	; 0x06
    5e80:	9f 81       	ldd	r25, Y+7	; 0x07
    5e82:	0e 94 d1 2e 	call	0x5da2	; 0x5da2 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    5e86:	1d 82       	std	Y+5, r1	; 0x05
    5e88:	06 c0       	rjmp	.+12     	; 0x5e96 <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    5e8a:	e8 85       	ldd	r30, Y+8	; 0x08
    5e8c:	f9 85       	ldd	r31, Y+9	; 0x09
    5e8e:	11 82       	std	Z+1, r1	; 0x01
    5e90:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    5e92:	81 e0       	ldi	r24, 0x01	; 1
    5e94:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    5e96:	0f 90       	pop	r0
    5e98:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    5e9a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5e9c:	29 96       	adiw	r28, 0x09	; 9
    5e9e:	0f b6       	in	r0, 0x3f	; 63
    5ea0:	f8 94       	cli
    5ea2:	de bf       	out	0x3e, r29	; 62
    5ea4:	0f be       	out	0x3f, r0	; 63
    5ea6:	cd bf       	out	0x3d, r28	; 61
    5ea8:	cf 91       	pop	r28
    5eaa:	df 91       	pop	r29
    5eac:	08 95       	ret

00005eae <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    5eae:	df 93       	push	r29
    5eb0:	cf 93       	push	r28
    5eb2:	cd b7       	in	r28, 0x3d	; 61
    5eb4:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    5eb6:	81 e0       	ldi	r24, 0x01	; 1
    5eb8:	80 93 86 04 	sts	0x0486, r24
}
    5ebc:	cf 91       	pop	r28
    5ebe:	df 91       	pop	r29
    5ec0:	08 95       	ret

00005ec2 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5ec2:	df 93       	push	r29
    5ec4:	cf 93       	push	r28
    5ec6:	00 d0       	rcall	.+0      	; 0x5ec8 <prvIdleTask+0x6>
    5ec8:	cd b7       	in	r28, 0x3d	; 61
    5eca:	de b7       	in	r29, 0x3e	; 62
    5ecc:	9a 83       	std	Y+2, r25	; 0x02
    5ece:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    5ed0:	0e 94 ac 2f 	call	0x5f58	; 0x5f58 <prvCheckTasksWaitingTermination>
    5ed4:	fd cf       	rjmp	.-6      	; 0x5ed0 <prvIdleTask+0xe>

00005ed6 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    5ed6:	df 93       	push	r29
    5ed8:	cf 93       	push	r28
    5eda:	0f 92       	push	r0
    5edc:	cd b7       	in	r28, 0x3d	; 61
    5ede:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5ee0:	19 82       	std	Y+1, r1	; 0x01
    5ee2:	13 c0       	rjmp	.+38     	; 0x5f0a <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    5ee4:	89 81       	ldd	r24, Y+1	; 0x01
    5ee6:	28 2f       	mov	r18, r24
    5ee8:	30 e0       	ldi	r19, 0x00	; 0
    5eea:	c9 01       	movw	r24, r18
    5eec:	88 0f       	add	r24, r24
    5eee:	99 1f       	adc	r25, r25
    5ef0:	88 0f       	add	r24, r24
    5ef2:	99 1f       	adc	r25, r25
    5ef4:	88 0f       	add	r24, r24
    5ef6:	99 1f       	adc	r25, r25
    5ef8:	82 0f       	add	r24, r18
    5efa:	93 1f       	adc	r25, r19
    5efc:	82 57       	subi	r24, 0x72	; 114
    5efe:	9b 4f       	sbci	r25, 0xFB	; 251
    5f00:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    5f04:	89 81       	ldd	r24, Y+1	; 0x01
    5f06:	8f 5f       	subi	r24, 0xFF	; 255
    5f08:	89 83       	std	Y+1, r24	; 0x01
    5f0a:	89 81       	ldd	r24, Y+1	; 0x01
    5f0c:	85 30       	cpi	r24, 0x05	; 5
    5f0e:	50 f3       	brcs	.-44     	; 0x5ee4 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    5f10:	8b eb       	ldi	r24, 0xBB	; 187
    5f12:	94 e0       	ldi	r25, 0x04	; 4
    5f14:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    5f18:	84 ec       	ldi	r24, 0xC4	; 196
    5f1a:	94 e0       	ldi	r25, 0x04	; 4
    5f1c:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    5f20:	81 ed       	ldi	r24, 0xD1	; 209
    5f22:	94 e0       	ldi	r25, 0x04	; 4
    5f24:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    5f28:	8a ed       	ldi	r24, 0xDA	; 218
    5f2a:	94 e0       	ldi	r25, 0x04	; 4
    5f2c:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    5f30:	83 ee       	ldi	r24, 0xE3	; 227
    5f32:	94 e0       	ldi	r25, 0x04	; 4
    5f34:	0e 94 e4 18 	call	0x31c8	; 0x31c8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    5f38:	8b eb       	ldi	r24, 0xBB	; 187
    5f3a:	94 e0       	ldi	r25, 0x04	; 4
    5f3c:	90 93 ce 04 	sts	0x04CE, r25
    5f40:	80 93 cd 04 	sts	0x04CD, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    5f44:	84 ec       	ldi	r24, 0xC4	; 196
    5f46:	94 e0       	ldi	r25, 0x04	; 4
    5f48:	90 93 d0 04 	sts	0x04D0, r25
    5f4c:	80 93 cf 04 	sts	0x04CF, r24
}
    5f50:	0f 90       	pop	r0
    5f52:	cf 91       	pop	r28
    5f54:	df 91       	pop	r29
    5f56:	08 95       	ret

00005f58 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    5f58:	df 93       	push	r29
    5f5a:	cf 93       	push	r28
    5f5c:	00 d0       	rcall	.+0      	; 0x5f5e <prvCheckTasksWaitingTermination+0x6>
    5f5e:	cd b7       	in	r28, 0x3d	; 61
    5f60:	de b7       	in	r29, 0x3e	; 62
    5f62:	20 c0       	rjmp	.+64     	; 0x5fa4 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    5f64:	0f b6       	in	r0, 0x3f	; 63
    5f66:	f8 94       	cli
    5f68:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5f6a:	e0 91 df 04 	lds	r30, 0x04DF
    5f6e:	f0 91 e0 04 	lds	r31, 0x04E0
    5f72:	86 81       	ldd	r24, Z+6	; 0x06
    5f74:	97 81       	ldd	r25, Z+7	; 0x07
    5f76:	9a 83       	std	Y+2, r25	; 0x02
    5f78:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5f7a:	89 81       	ldd	r24, Y+1	; 0x01
    5f7c:	9a 81       	ldd	r25, Y+2	; 0x02
    5f7e:	02 96       	adiw	r24, 0x02	; 2
    5f80:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
				--uxCurrentNumberOfTasks;
    5f84:	80 91 7f 04 	lds	r24, 0x047F
    5f88:	81 50       	subi	r24, 0x01	; 1
    5f8a:	80 93 7f 04 	sts	0x047F, r24
				--uxDeletedTasksWaitingCleanUp;
    5f8e:	80 91 7e 04 	lds	r24, 0x047E
    5f92:	81 50       	subi	r24, 0x01	; 1
    5f94:	80 93 7e 04 	sts	0x047E, r24
			}
			taskEXIT_CRITICAL();
    5f98:	0f 90       	pop	r0
    5f9a:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    5f9c:	89 81       	ldd	r24, Y+1	; 0x01
    5f9e:	9a 81       	ldd	r25, Y+2	; 0x02
    5fa0:	0e 94 db 2f 	call	0x5fb6	; 0x5fb6 <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5fa4:	80 91 7e 04 	lds	r24, 0x047E
    5fa8:	88 23       	and	r24, r24
    5faa:	e1 f6       	brne	.-72     	; 0x5f64 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    5fac:	0f 90       	pop	r0
    5fae:	0f 90       	pop	r0
    5fb0:	cf 91       	pop	r28
    5fb2:	df 91       	pop	r29
    5fb4:	08 95       	ret

00005fb6 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    5fb6:	df 93       	push	r29
    5fb8:	cf 93       	push	r28
    5fba:	00 d0       	rcall	.+0      	; 0x5fbc <prvDeleteTCB+0x6>
    5fbc:	cd b7       	in	r28, 0x3d	; 61
    5fbe:	de b7       	in	r29, 0x3e	; 62
    5fc0:	9a 83       	std	Y+2, r25	; 0x02
    5fc2:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    5fc4:	e9 81       	ldd	r30, Y+1	; 0x01
    5fc6:	fa 81       	ldd	r31, Y+2	; 0x02
    5fc8:	87 89       	ldd	r24, Z+23	; 0x17
    5fca:	90 8d       	ldd	r25, Z+24	; 0x18
    5fcc:	0e 94 be 18 	call	0x317c	; 0x317c <vPortFree>
			vPortFree( pxTCB );
    5fd0:	89 81       	ldd	r24, Y+1	; 0x01
    5fd2:	9a 81       	ldd	r25, Y+2	; 0x02
    5fd4:	0e 94 be 18 	call	0x317c	; 0x317c <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    5fd8:	0f 90       	pop	r0
    5fda:	0f 90       	pop	r0
    5fdc:	cf 91       	pop	r28
    5fde:	df 91       	pop	r29
    5fe0:	08 95       	ret

00005fe2 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    5fe2:	df 93       	push	r29
    5fe4:	cf 93       	push	r28
    5fe6:	00 d0       	rcall	.+0      	; 0x5fe8 <prvResetNextTaskUnblockTime+0x6>
    5fe8:	cd b7       	in	r28, 0x3d	; 61
    5fea:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    5fec:	e0 91 cd 04 	lds	r30, 0x04CD
    5ff0:	f0 91 ce 04 	lds	r31, 0x04CE
    5ff4:	80 81       	ld	r24, Z
    5ff6:	88 23       	and	r24, r24
    5ff8:	39 f4       	brne	.+14     	; 0x6008 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    5ffa:	8f ef       	ldi	r24, 0xFF	; 255
    5ffc:	9f ef       	ldi	r25, 0xFF	; 255
    5ffe:	90 93 8a 04 	sts	0x048A, r25
    6002:	80 93 89 04 	sts	0x0489, r24
    6006:	13 c0       	rjmp	.+38     	; 0x602e <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6008:	e0 91 cd 04 	lds	r30, 0x04CD
    600c:	f0 91 ce 04 	lds	r31, 0x04CE
    6010:	05 80       	ldd	r0, Z+5	; 0x05
    6012:	f6 81       	ldd	r31, Z+6	; 0x06
    6014:	e0 2d       	mov	r30, r0
    6016:	86 81       	ldd	r24, Z+6	; 0x06
    6018:	97 81       	ldd	r25, Z+7	; 0x07
    601a:	9a 83       	std	Y+2, r25	; 0x02
    601c:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    601e:	e9 81       	ldd	r30, Y+1	; 0x01
    6020:	fa 81       	ldd	r31, Y+2	; 0x02
    6022:	82 81       	ldd	r24, Z+2	; 0x02
    6024:	93 81       	ldd	r25, Z+3	; 0x03
    6026:	90 93 8a 04 	sts	0x048A, r25
    602a:	80 93 89 04 	sts	0x0489, r24
	}
}
    602e:	0f 90       	pop	r0
    6030:	0f 90       	pop	r0
    6032:	cf 91       	pop	r28
    6034:	df 91       	pop	r29
    6036:	08 95       	ret

00006038 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    6038:	df 93       	push	r29
    603a:	cf 93       	push	r28
    603c:	00 d0       	rcall	.+0      	; 0x603e <uxTaskResetEventItemValue+0x6>
    603e:	cd b7       	in	r28, 0x3d	; 61
    6040:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    6042:	e0 91 7c 04 	lds	r30, 0x047C
    6046:	f0 91 7d 04 	lds	r31, 0x047D
    604a:	84 85       	ldd	r24, Z+12	; 0x0c
    604c:	95 85       	ldd	r25, Z+13	; 0x0d
    604e:	9a 83       	std	Y+2, r25	; 0x02
    6050:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6052:	a0 91 7c 04 	lds	r26, 0x047C
    6056:	b0 91 7d 04 	lds	r27, 0x047D
    605a:	e0 91 7c 04 	lds	r30, 0x047C
    605e:	f0 91 7d 04 	lds	r31, 0x047D
    6062:	86 89       	ldd	r24, Z+22	; 0x16
    6064:	28 2f       	mov	r18, r24
    6066:	30 e0       	ldi	r19, 0x00	; 0
    6068:	85 e0       	ldi	r24, 0x05	; 5
    606a:	90 e0       	ldi	r25, 0x00	; 0
    606c:	82 1b       	sub	r24, r18
    606e:	93 0b       	sbc	r25, r19
    6070:	1d 96       	adiw	r26, 0x0d	; 13
    6072:	9c 93       	st	X, r25
    6074:	8e 93       	st	-X, r24
    6076:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    6078:	89 81       	ldd	r24, Y+1	; 0x01
    607a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    607c:	0f 90       	pop	r0
    607e:	0f 90       	pop	r0
    6080:	cf 91       	pop	r28
    6082:	df 91       	pop	r29
    6084:	08 95       	ret

00006086 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    6086:	df 93       	push	r29
    6088:	cf 93       	push	r28
    608a:	cd b7       	in	r28, 0x3d	; 61
    608c:	de b7       	in	r29, 0x3e	; 62
    608e:	27 97       	sbiw	r28, 0x07	; 7
    6090:	0f b6       	in	r0, 0x3f	; 63
    6092:	f8 94       	cli
    6094:	de bf       	out	0x3e, r29	; 62
    6096:	0f be       	out	0x3f, r0	; 63
    6098:	cd bf       	out	0x3d, r28	; 61
    609a:	8d 83       	std	Y+5, r24	; 0x05
    609c:	7f 83       	std	Y+7, r23	; 0x07
    609e:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    60a0:	0f b6       	in	r0, 0x3f	; 63
    60a2:	f8 94       	cli
    60a4:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    60a6:	e0 91 7c 04 	lds	r30, 0x047C
    60aa:	f0 91 7d 04 	lds	r31, 0x047D
    60ae:	81 a1       	ldd	r24, Z+33	; 0x21
    60b0:	92 a1       	ldd	r25, Z+34	; 0x22
    60b2:	a3 a1       	ldd	r26, Z+35	; 0x23
    60b4:	b4 a1       	ldd	r27, Z+36	; 0x24
    60b6:	00 97       	sbiw	r24, 0x00	; 0
    60b8:	a1 05       	cpc	r26, r1
    60ba:	b1 05       	cpc	r27, r1
    60bc:	89 f4       	brne	.+34     	; 0x60e0 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    60be:	e0 91 7c 04 	lds	r30, 0x047C
    60c2:	f0 91 7d 04 	lds	r31, 0x047D
    60c6:	81 e0       	ldi	r24, 0x01	; 1
    60c8:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    60ca:	8e 81       	ldd	r24, Y+6	; 0x06
    60cc:	9f 81       	ldd	r25, Y+7	; 0x07
    60ce:	00 97       	sbiw	r24, 0x00	; 0
    60d0:	39 f0       	breq	.+14     	; 0x60e0 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    60d2:	8e 81       	ldd	r24, Y+6	; 0x06
    60d4:	9f 81       	ldd	r25, Y+7	; 0x07
    60d6:	61 e0       	ldi	r22, 0x01	; 1
    60d8:	0e 94 46 34 	call	0x688c	; 0x688c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    60dc:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    60e0:	0f 90       	pop	r0
    60e2:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    60e4:	0f b6       	in	r0, 0x3f	; 63
    60e6:	f8 94       	cli
    60e8:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    60ea:	e0 91 7c 04 	lds	r30, 0x047C
    60ee:	f0 91 7d 04 	lds	r31, 0x047D
    60f2:	81 a1       	ldd	r24, Z+33	; 0x21
    60f4:	92 a1       	ldd	r25, Z+34	; 0x22
    60f6:	a3 a1       	ldd	r26, Z+35	; 0x23
    60f8:	b4 a1       	ldd	r27, Z+36	; 0x24
    60fa:	89 83       	std	Y+1, r24	; 0x01
    60fc:	9a 83       	std	Y+2, r25	; 0x02
    60fe:	ab 83       	std	Y+3, r26	; 0x03
    6100:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    6102:	89 81       	ldd	r24, Y+1	; 0x01
    6104:	9a 81       	ldd	r25, Y+2	; 0x02
    6106:	ab 81       	ldd	r26, Y+3	; 0x03
    6108:	bc 81       	ldd	r27, Y+4	; 0x04
    610a:	00 97       	sbiw	r24, 0x00	; 0
    610c:	a1 05       	cpc	r26, r1
    610e:	b1 05       	cpc	r27, r1
    6110:	d9 f0       	breq	.+54     	; 0x6148 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    6112:	8d 81       	ldd	r24, Y+5	; 0x05
    6114:	88 23       	and	r24, r24
    6116:	49 f0       	breq	.+18     	; 0x612a <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    6118:	e0 91 7c 04 	lds	r30, 0x047C
    611c:	f0 91 7d 04 	lds	r31, 0x047D
    6120:	11 a2       	std	Z+33, r1	; 0x21
    6122:	12 a2       	std	Z+34, r1	; 0x22
    6124:	13 a2       	std	Z+35, r1	; 0x23
    6126:	14 a2       	std	Z+36, r1	; 0x24
    6128:	0f c0       	rjmp	.+30     	; 0x6148 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    612a:	e0 91 7c 04 	lds	r30, 0x047C
    612e:	f0 91 7d 04 	lds	r31, 0x047D
    6132:	89 81       	ldd	r24, Y+1	; 0x01
    6134:	9a 81       	ldd	r25, Y+2	; 0x02
    6136:	ab 81       	ldd	r26, Y+3	; 0x03
    6138:	bc 81       	ldd	r27, Y+4	; 0x04
    613a:	01 97       	sbiw	r24, 0x01	; 1
    613c:	a1 09       	sbc	r26, r1
    613e:	b1 09       	sbc	r27, r1
    6140:	81 a3       	std	Z+33, r24	; 0x21
    6142:	92 a3       	std	Z+34, r25	; 0x22
    6144:	a3 a3       	std	Z+35, r26	; 0x23
    6146:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    6148:	e0 91 7c 04 	lds	r30, 0x047C
    614c:	f0 91 7d 04 	lds	r31, 0x047D
    6150:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    6152:	0f 90       	pop	r0
    6154:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    6156:	89 81       	ldd	r24, Y+1	; 0x01
    6158:	9a 81       	ldd	r25, Y+2	; 0x02
    615a:	ab 81       	ldd	r26, Y+3	; 0x03
    615c:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    615e:	bc 01       	movw	r22, r24
    6160:	cd 01       	movw	r24, r26
    6162:	27 96       	adiw	r28, 0x07	; 7
    6164:	0f b6       	in	r0, 0x3f	; 63
    6166:	f8 94       	cli
    6168:	de bf       	out	0x3e, r29	; 62
    616a:	0f be       	out	0x3f, r0	; 63
    616c:	cd bf       	out	0x3d, r28	; 61
    616e:	cf 91       	pop	r28
    6170:	df 91       	pop	r29
    6172:	08 95       	ret

00006174 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    6174:	ef 92       	push	r14
    6176:	ff 92       	push	r15
    6178:	0f 93       	push	r16
    617a:	1f 93       	push	r17
    617c:	df 93       	push	r29
    617e:	cf 93       	push	r28
    6180:	cd b7       	in	r28, 0x3d	; 61
    6182:	de b7       	in	r29, 0x3e	; 62
    6184:	2d 97       	sbiw	r28, 0x0d	; 13
    6186:	0f b6       	in	r0, 0x3f	; 63
    6188:	f8 94       	cli
    618a:	de bf       	out	0x3e, r29	; 62
    618c:	0f be       	out	0x3f, r0	; 63
    618e:	cd bf       	out	0x3d, r28	; 61
    6190:	6a 83       	std	Y+2, r22	; 0x02
    6192:	7b 83       	std	Y+3, r23	; 0x03
    6194:	8c 83       	std	Y+4, r24	; 0x04
    6196:	9d 83       	std	Y+5, r25	; 0x05
    6198:	2e 83       	std	Y+6, r18	; 0x06
    619a:	3f 83       	std	Y+7, r19	; 0x07
    619c:	48 87       	std	Y+8, r20	; 0x08
    619e:	59 87       	std	Y+9, r21	; 0x09
    61a0:	1b 87       	std	Y+11, r17	; 0x0b
    61a2:	0a 87       	std	Y+10, r16	; 0x0a
    61a4:	fd 86       	std	Y+13, r15	; 0x0d
    61a6:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    61a8:	0f b6       	in	r0, 0x3f	; 63
    61aa:	f8 94       	cli
    61ac:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    61ae:	e0 91 7c 04 	lds	r30, 0x047C
    61b2:	f0 91 7d 04 	lds	r31, 0x047D
    61b6:	85 a1       	ldd	r24, Z+37	; 0x25
    61b8:	82 30       	cpi	r24, 0x02	; 2
    61ba:	49 f1       	breq	.+82     	; 0x620e <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    61bc:	e0 91 7c 04 	lds	r30, 0x047C
    61c0:	f0 91 7d 04 	lds	r31, 0x047D
    61c4:	21 a1       	ldd	r18, Z+33	; 0x21
    61c6:	32 a1       	ldd	r19, Z+34	; 0x22
    61c8:	43 a1       	ldd	r20, Z+35	; 0x23
    61ca:	54 a1       	ldd	r21, Z+36	; 0x24
    61cc:	8a 81       	ldd	r24, Y+2	; 0x02
    61ce:	9b 81       	ldd	r25, Y+3	; 0x03
    61d0:	ac 81       	ldd	r26, Y+4	; 0x04
    61d2:	bd 81       	ldd	r27, Y+5	; 0x05
    61d4:	80 95       	com	r24
    61d6:	90 95       	com	r25
    61d8:	a0 95       	com	r26
    61da:	b0 95       	com	r27
    61dc:	82 23       	and	r24, r18
    61de:	93 23       	and	r25, r19
    61e0:	a4 23       	and	r26, r20
    61e2:	b5 23       	and	r27, r21
    61e4:	81 a3       	std	Z+33, r24	; 0x21
    61e6:	92 a3       	std	Z+34, r25	; 0x22
    61e8:	a3 a3       	std	Z+35, r26	; 0x23
    61ea:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    61ec:	e0 91 7c 04 	lds	r30, 0x047C
    61f0:	f0 91 7d 04 	lds	r31, 0x047D
    61f4:	81 e0       	ldi	r24, 0x01	; 1
    61f6:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    61f8:	8c 85       	ldd	r24, Y+12	; 0x0c
    61fa:	9d 85       	ldd	r25, Y+13	; 0x0d
    61fc:	00 97       	sbiw	r24, 0x00	; 0
    61fe:	39 f0       	breq	.+14     	; 0x620e <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6200:	8c 85       	ldd	r24, Y+12	; 0x0c
    6202:	9d 85       	ldd	r25, Y+13	; 0x0d
    6204:	61 e0       	ldi	r22, 0x01	; 1
    6206:	0e 94 46 34 	call	0x688c	; 0x688c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    620a:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    620e:	0f 90       	pop	r0
    6210:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    6212:	0f b6       	in	r0, 0x3f	; 63
    6214:	f8 94       	cli
    6216:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    6218:	8a 85       	ldd	r24, Y+10	; 0x0a
    621a:	9b 85       	ldd	r25, Y+11	; 0x0b
    621c:	00 97       	sbiw	r24, 0x00	; 0
    621e:	71 f0       	breq	.+28     	; 0x623c <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    6220:	e0 91 7c 04 	lds	r30, 0x047C
    6224:	f0 91 7d 04 	lds	r31, 0x047D
    6228:	81 a1       	ldd	r24, Z+33	; 0x21
    622a:	92 a1       	ldd	r25, Z+34	; 0x22
    622c:	a3 a1       	ldd	r26, Z+35	; 0x23
    622e:	b4 a1       	ldd	r27, Z+36	; 0x24
    6230:	ea 85       	ldd	r30, Y+10	; 0x0a
    6232:	fb 85       	ldd	r31, Y+11	; 0x0b
    6234:	80 83       	st	Z, r24
    6236:	91 83       	std	Z+1, r25	; 0x01
    6238:	a2 83       	std	Z+2, r26	; 0x02
    623a:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    623c:	e0 91 7c 04 	lds	r30, 0x047C
    6240:	f0 91 7d 04 	lds	r31, 0x047D
    6244:	85 a1       	ldd	r24, Z+37	; 0x25
    6246:	82 30       	cpi	r24, 0x02	; 2
    6248:	11 f0       	breq	.+4      	; 0x624e <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    624a:	19 82       	std	Y+1, r1	; 0x01
    624c:	1a c0       	rjmp	.+52     	; 0x6282 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    624e:	e0 91 7c 04 	lds	r30, 0x047C
    6252:	f0 91 7d 04 	lds	r31, 0x047D
    6256:	21 a1       	ldd	r18, Z+33	; 0x21
    6258:	32 a1       	ldd	r19, Z+34	; 0x22
    625a:	43 a1       	ldd	r20, Z+35	; 0x23
    625c:	54 a1       	ldd	r21, Z+36	; 0x24
    625e:	8e 81       	ldd	r24, Y+6	; 0x06
    6260:	9f 81       	ldd	r25, Y+7	; 0x07
    6262:	a8 85       	ldd	r26, Y+8	; 0x08
    6264:	b9 85       	ldd	r27, Y+9	; 0x09
    6266:	80 95       	com	r24
    6268:	90 95       	com	r25
    626a:	a0 95       	com	r26
    626c:	b0 95       	com	r27
    626e:	82 23       	and	r24, r18
    6270:	93 23       	and	r25, r19
    6272:	a4 23       	and	r26, r20
    6274:	b5 23       	and	r27, r21
    6276:	81 a3       	std	Z+33, r24	; 0x21
    6278:	92 a3       	std	Z+34, r25	; 0x22
    627a:	a3 a3       	std	Z+35, r26	; 0x23
    627c:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    627e:	81 e0       	ldi	r24, 0x01	; 1
    6280:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    6282:	e0 91 7c 04 	lds	r30, 0x047C
    6286:	f0 91 7d 04 	lds	r31, 0x047D
    628a:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    628c:	0f 90       	pop	r0
    628e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    6290:	89 81       	ldd	r24, Y+1	; 0x01
	}
    6292:	2d 96       	adiw	r28, 0x0d	; 13
    6294:	0f b6       	in	r0, 0x3f	; 63
    6296:	f8 94       	cli
    6298:	de bf       	out	0x3e, r29	; 62
    629a:	0f be       	out	0x3f, r0	; 63
    629c:	cd bf       	out	0x3d, r28	; 61
    629e:	cf 91       	pop	r28
    62a0:	df 91       	pop	r29
    62a2:	1f 91       	pop	r17
    62a4:	0f 91       	pop	r16
    62a6:	ff 90       	pop	r15
    62a8:	ef 90       	pop	r14
    62aa:	08 95       	ret

000062ac <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    62ac:	0f 93       	push	r16
    62ae:	1f 93       	push	r17
    62b0:	df 93       	push	r29
    62b2:	cf 93       	push	r28
    62b4:	cd b7       	in	r28, 0x3d	; 61
    62b6:	de b7       	in	r29, 0x3e	; 62
    62b8:	2f 97       	sbiw	r28, 0x0f	; 15
    62ba:	0f b6       	in	r0, 0x3f	; 63
    62bc:	f8 94       	cli
    62be:	de bf       	out	0x3e, r29	; 62
    62c0:	0f be       	out	0x3f, r0	; 63
    62c2:	cd bf       	out	0x3d, r28	; 61
    62c4:	9e 83       	std	Y+6, r25	; 0x06
    62c6:	8d 83       	std	Y+5, r24	; 0x05
    62c8:	4f 83       	std	Y+7, r20	; 0x07
    62ca:	58 87       	std	Y+8, r21	; 0x08
    62cc:	69 87       	std	Y+9, r22	; 0x09
    62ce:	7a 87       	std	Y+10, r23	; 0x0a
    62d0:	2b 87       	std	Y+11, r18	; 0x0b
    62d2:	1d 87       	std	Y+13, r17	; 0x0d
    62d4:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    62d6:	81 e0       	ldi	r24, 0x01	; 1
    62d8:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    62da:	8d 81       	ldd	r24, Y+5	; 0x05
    62dc:	9e 81       	ldd	r25, Y+6	; 0x06
    62de:	9c 83       	std	Y+4, r25	; 0x04
    62e0:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    62e2:	0f b6       	in	r0, 0x3f	; 63
    62e4:	f8 94       	cli
    62e6:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    62e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    62ea:	9d 85       	ldd	r25, Y+13	; 0x0d
    62ec:	00 97       	sbiw	r24, 0x00	; 0
    62ee:	61 f0       	breq	.+24     	; 0x6308 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    62f0:	eb 81       	ldd	r30, Y+3	; 0x03
    62f2:	fc 81       	ldd	r31, Y+4	; 0x04
    62f4:	81 a1       	ldd	r24, Z+33	; 0x21
    62f6:	92 a1       	ldd	r25, Z+34	; 0x22
    62f8:	a3 a1       	ldd	r26, Z+35	; 0x23
    62fa:	b4 a1       	ldd	r27, Z+36	; 0x24
    62fc:	ec 85       	ldd	r30, Y+12	; 0x0c
    62fe:	fd 85       	ldd	r31, Y+13	; 0x0d
    6300:	80 83       	st	Z, r24
    6302:	91 83       	std	Z+1, r25	; 0x01
    6304:	a2 83       	std	Z+2, r26	; 0x02
    6306:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6308:	eb 81       	ldd	r30, Y+3	; 0x03
    630a:	fc 81       	ldd	r31, Y+4	; 0x04
    630c:	85 a1       	ldd	r24, Z+37	; 0x25
    630e:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    6310:	eb 81       	ldd	r30, Y+3	; 0x03
    6312:	fc 81       	ldd	r31, Y+4	; 0x04
    6314:	82 e0       	ldi	r24, 0x02	; 2
    6316:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    6318:	8b 85       	ldd	r24, Y+11	; 0x0b
    631a:	28 2f       	mov	r18, r24
    631c:	30 e0       	ldi	r19, 0x00	; 0
    631e:	3f 87       	std	Y+15, r19	; 0x0f
    6320:	2e 87       	std	Y+14, r18	; 0x0e
    6322:	8e 85       	ldd	r24, Y+14	; 0x0e
    6324:	9f 85       	ldd	r25, Y+15	; 0x0f
    6326:	82 30       	cpi	r24, 0x02	; 2
    6328:	91 05       	cpc	r25, r1
    632a:	59 f1       	breq	.+86     	; 0x6382 <xTaskGenericNotify+0xd6>
    632c:	2e 85       	ldd	r18, Y+14	; 0x0e
    632e:	3f 85       	ldd	r19, Y+15	; 0x0f
    6330:	23 30       	cpi	r18, 0x03	; 3
    6332:	31 05       	cpc	r19, r1
    6334:	34 f4       	brge	.+12     	; 0x6342 <xTaskGenericNotify+0x96>
    6336:	8e 85       	ldd	r24, Y+14	; 0x0e
    6338:	9f 85       	ldd	r25, Y+15	; 0x0f
    633a:	81 30       	cpi	r24, 0x01	; 1
    633c:	91 05       	cpc	r25, r1
    633e:	61 f0       	breq	.+24     	; 0x6358 <xTaskGenericNotify+0xac>
    6340:	4a c0       	rjmp	.+148    	; 0x63d6 <xTaskGenericNotify+0x12a>
    6342:	2e 85       	ldd	r18, Y+14	; 0x0e
    6344:	3f 85       	ldd	r19, Y+15	; 0x0f
    6346:	23 30       	cpi	r18, 0x03	; 3
    6348:	31 05       	cpc	r19, r1
    634a:	59 f1       	breq	.+86     	; 0x63a2 <xTaskGenericNotify+0xf6>
    634c:	8e 85       	ldd	r24, Y+14	; 0x0e
    634e:	9f 85       	ldd	r25, Y+15	; 0x0f
    6350:	84 30       	cpi	r24, 0x04	; 4
    6352:	91 05       	cpc	r25, r1
    6354:	89 f1       	breq	.+98     	; 0x63b8 <xTaskGenericNotify+0x10c>
    6356:	3f c0       	rjmp	.+126    	; 0x63d6 <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    6358:	eb 81       	ldd	r30, Y+3	; 0x03
    635a:	fc 81       	ldd	r31, Y+4	; 0x04
    635c:	21 a1       	ldd	r18, Z+33	; 0x21
    635e:	32 a1       	ldd	r19, Z+34	; 0x22
    6360:	43 a1       	ldd	r20, Z+35	; 0x23
    6362:	54 a1       	ldd	r21, Z+36	; 0x24
    6364:	8f 81       	ldd	r24, Y+7	; 0x07
    6366:	98 85       	ldd	r25, Y+8	; 0x08
    6368:	a9 85       	ldd	r26, Y+9	; 0x09
    636a:	ba 85       	ldd	r27, Y+10	; 0x0a
    636c:	82 2b       	or	r24, r18
    636e:	93 2b       	or	r25, r19
    6370:	a4 2b       	or	r26, r20
    6372:	b5 2b       	or	r27, r21
    6374:	eb 81       	ldd	r30, Y+3	; 0x03
    6376:	fc 81       	ldd	r31, Y+4	; 0x04
    6378:	81 a3       	std	Z+33, r24	; 0x21
    637a:	92 a3       	std	Z+34, r25	; 0x22
    637c:	a3 a3       	std	Z+35, r26	; 0x23
    637e:	b4 a3       	std	Z+36, r27	; 0x24
    6380:	2a c0       	rjmp	.+84     	; 0x63d6 <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    6382:	eb 81       	ldd	r30, Y+3	; 0x03
    6384:	fc 81       	ldd	r31, Y+4	; 0x04
    6386:	81 a1       	ldd	r24, Z+33	; 0x21
    6388:	92 a1       	ldd	r25, Z+34	; 0x22
    638a:	a3 a1       	ldd	r26, Z+35	; 0x23
    638c:	b4 a1       	ldd	r27, Z+36	; 0x24
    638e:	01 96       	adiw	r24, 0x01	; 1
    6390:	a1 1d       	adc	r26, r1
    6392:	b1 1d       	adc	r27, r1
    6394:	eb 81       	ldd	r30, Y+3	; 0x03
    6396:	fc 81       	ldd	r31, Y+4	; 0x04
    6398:	81 a3       	std	Z+33, r24	; 0x21
    639a:	92 a3       	std	Z+34, r25	; 0x22
    639c:	a3 a3       	std	Z+35, r26	; 0x23
    639e:	b4 a3       	std	Z+36, r27	; 0x24
    63a0:	1a c0       	rjmp	.+52     	; 0x63d6 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    63a2:	eb 81       	ldd	r30, Y+3	; 0x03
    63a4:	fc 81       	ldd	r31, Y+4	; 0x04
    63a6:	8f 81       	ldd	r24, Y+7	; 0x07
    63a8:	98 85       	ldd	r25, Y+8	; 0x08
    63aa:	a9 85       	ldd	r26, Y+9	; 0x09
    63ac:	ba 85       	ldd	r27, Y+10	; 0x0a
    63ae:	81 a3       	std	Z+33, r24	; 0x21
    63b0:	92 a3       	std	Z+34, r25	; 0x22
    63b2:	a3 a3       	std	Z+35, r26	; 0x23
    63b4:	b4 a3       	std	Z+36, r27	; 0x24
    63b6:	0f c0       	rjmp	.+30     	; 0x63d6 <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    63b8:	89 81       	ldd	r24, Y+1	; 0x01
    63ba:	82 30       	cpi	r24, 0x02	; 2
    63bc:	59 f0       	breq	.+22     	; 0x63d4 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    63be:	eb 81       	ldd	r30, Y+3	; 0x03
    63c0:	fc 81       	ldd	r31, Y+4	; 0x04
    63c2:	8f 81       	ldd	r24, Y+7	; 0x07
    63c4:	98 85       	ldd	r25, Y+8	; 0x08
    63c6:	a9 85       	ldd	r26, Y+9	; 0x09
    63c8:	ba 85       	ldd	r27, Y+10	; 0x0a
    63ca:	81 a3       	std	Z+33, r24	; 0x21
    63cc:	92 a3       	std	Z+34, r25	; 0x22
    63ce:	a3 a3       	std	Z+35, r26	; 0x23
    63d0:	b4 a3       	std	Z+36, r27	; 0x24
    63d2:	01 c0       	rjmp	.+2      	; 0x63d6 <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    63d4:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    63d6:	89 81       	ldd	r24, Y+1	; 0x01
    63d8:	81 30       	cpi	r24, 0x01	; 1
    63da:	b9 f5       	brne	.+110    	; 0x644a <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    63dc:	8b 81       	ldd	r24, Y+3	; 0x03
    63de:	9c 81       	ldd	r25, Y+4	; 0x04
    63e0:	02 96       	adiw	r24, 0x02	; 2
    63e2:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    63e6:	eb 81       	ldd	r30, Y+3	; 0x03
    63e8:	fc 81       	ldd	r31, Y+4	; 0x04
    63ea:	96 89       	ldd	r25, Z+22	; 0x16
    63ec:	80 91 82 04 	lds	r24, 0x0482
    63f0:	89 17       	cp	r24, r25
    63f2:	28 f4       	brcc	.+10     	; 0x63fe <xTaskGenericNotify+0x152>
    63f4:	eb 81       	ldd	r30, Y+3	; 0x03
    63f6:	fc 81       	ldd	r31, Y+4	; 0x04
    63f8:	86 89       	ldd	r24, Z+22	; 0x16
    63fa:	80 93 82 04 	sts	0x0482, r24
    63fe:	eb 81       	ldd	r30, Y+3	; 0x03
    6400:	fc 81       	ldd	r31, Y+4	; 0x04
    6402:	86 89       	ldd	r24, Z+22	; 0x16
    6404:	28 2f       	mov	r18, r24
    6406:	30 e0       	ldi	r19, 0x00	; 0
    6408:	c9 01       	movw	r24, r18
    640a:	88 0f       	add	r24, r24
    640c:	99 1f       	adc	r25, r25
    640e:	88 0f       	add	r24, r24
    6410:	99 1f       	adc	r25, r25
    6412:	88 0f       	add	r24, r24
    6414:	99 1f       	adc	r25, r25
    6416:	82 0f       	add	r24, r18
    6418:	93 1f       	adc	r25, r19
    641a:	ac 01       	movw	r20, r24
    641c:	42 57       	subi	r20, 0x72	; 114
    641e:	5b 4f       	sbci	r21, 0xFB	; 251
    6420:	8b 81       	ldd	r24, Y+3	; 0x03
    6422:	9c 81       	ldd	r25, Y+4	; 0x04
    6424:	9c 01       	movw	r18, r24
    6426:	2e 5f       	subi	r18, 0xFE	; 254
    6428:	3f 4f       	sbci	r19, 0xFF	; 255
    642a:	ca 01       	movw	r24, r20
    642c:	b9 01       	movw	r22, r18
    642e:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6432:	eb 81       	ldd	r30, Y+3	; 0x03
    6434:	fc 81       	ldd	r31, Y+4	; 0x04
    6436:	96 89       	ldd	r25, Z+22	; 0x16
    6438:	e0 91 7c 04 	lds	r30, 0x047C
    643c:	f0 91 7d 04 	lds	r31, 0x047D
    6440:	86 89       	ldd	r24, Z+22	; 0x16
    6442:	89 17       	cp	r24, r25
    6444:	10 f4       	brcc	.+4      	; 0x644a <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    6446:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    644a:	0f 90       	pop	r0
    644c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    644e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    6450:	2f 96       	adiw	r28, 0x0f	; 15
    6452:	0f b6       	in	r0, 0x3f	; 63
    6454:	f8 94       	cli
    6456:	de bf       	out	0x3e, r29	; 62
    6458:	0f be       	out	0x3f, r0	; 63
    645a:	cd bf       	out	0x3d, r28	; 61
    645c:	cf 91       	pop	r28
    645e:	df 91       	pop	r29
    6460:	1f 91       	pop	r17
    6462:	0f 91       	pop	r16
    6464:	08 95       	ret

00006466 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    6466:	ef 92       	push	r14
    6468:	ff 92       	push	r15
    646a:	0f 93       	push	r16
    646c:	1f 93       	push	r17
    646e:	df 93       	push	r29
    6470:	cf 93       	push	r28
    6472:	cd b7       	in	r28, 0x3d	; 61
    6474:	de b7       	in	r29, 0x3e	; 62
    6476:	62 97       	sbiw	r28, 0x12	; 18
    6478:	0f b6       	in	r0, 0x3f	; 63
    647a:	f8 94       	cli
    647c:	de bf       	out	0x3e, r29	; 62
    647e:	0f be       	out	0x3f, r0	; 63
    6480:	cd bf       	out	0x3d, r28	; 61
    6482:	9f 83       	std	Y+7, r25	; 0x07
    6484:	8e 83       	std	Y+6, r24	; 0x06
    6486:	48 87       	std	Y+8, r20	; 0x08
    6488:	59 87       	std	Y+9, r21	; 0x09
    648a:	6a 87       	std	Y+10, r22	; 0x0a
    648c:	7b 87       	std	Y+11, r23	; 0x0b
    648e:	2c 87       	std	Y+12, r18	; 0x0c
    6490:	1e 87       	std	Y+14, r17	; 0x0e
    6492:	0d 87       	std	Y+13, r16	; 0x0d
    6494:	f8 8a       	std	Y+16, r15	; 0x10
    6496:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    6498:	81 e0       	ldi	r24, 0x01	; 1
    649a:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    649c:	8e 81       	ldd	r24, Y+6	; 0x06
    649e:	9f 81       	ldd	r25, Y+7	; 0x07
    64a0:	9d 83       	std	Y+5, r25	; 0x05
    64a2:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    64a4:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    64a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    64a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    64aa:	00 97       	sbiw	r24, 0x00	; 0
    64ac:	61 f0       	breq	.+24     	; 0x64c6 <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    64ae:	ec 81       	ldd	r30, Y+4	; 0x04
    64b0:	fd 81       	ldd	r31, Y+5	; 0x05
    64b2:	81 a1       	ldd	r24, Z+33	; 0x21
    64b4:	92 a1       	ldd	r25, Z+34	; 0x22
    64b6:	a3 a1       	ldd	r26, Z+35	; 0x23
    64b8:	b4 a1       	ldd	r27, Z+36	; 0x24
    64ba:	ed 85       	ldd	r30, Y+13	; 0x0d
    64bc:	fe 85       	ldd	r31, Y+14	; 0x0e
    64be:	80 83       	st	Z, r24
    64c0:	91 83       	std	Z+1, r25	; 0x01
    64c2:	a2 83       	std	Z+2, r26	; 0x02
    64c4:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    64c6:	ec 81       	ldd	r30, Y+4	; 0x04
    64c8:	fd 81       	ldd	r31, Y+5	; 0x05
    64ca:	85 a1       	ldd	r24, Z+37	; 0x25
    64cc:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    64ce:	ec 81       	ldd	r30, Y+4	; 0x04
    64d0:	fd 81       	ldd	r31, Y+5	; 0x05
    64d2:	82 e0       	ldi	r24, 0x02	; 2
    64d4:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    64d6:	8c 85       	ldd	r24, Y+12	; 0x0c
    64d8:	28 2f       	mov	r18, r24
    64da:	30 e0       	ldi	r19, 0x00	; 0
    64dc:	3a 8b       	std	Y+18, r19	; 0x12
    64de:	29 8b       	std	Y+17, r18	; 0x11
    64e0:	89 89       	ldd	r24, Y+17	; 0x11
    64e2:	9a 89       	ldd	r25, Y+18	; 0x12
    64e4:	82 30       	cpi	r24, 0x02	; 2
    64e6:	91 05       	cpc	r25, r1
    64e8:	59 f1       	breq	.+86     	; 0x6540 <xTaskGenericNotifyFromISR+0xda>
    64ea:	29 89       	ldd	r18, Y+17	; 0x11
    64ec:	3a 89       	ldd	r19, Y+18	; 0x12
    64ee:	23 30       	cpi	r18, 0x03	; 3
    64f0:	31 05       	cpc	r19, r1
    64f2:	34 f4       	brge	.+12     	; 0x6500 <xTaskGenericNotifyFromISR+0x9a>
    64f4:	89 89       	ldd	r24, Y+17	; 0x11
    64f6:	9a 89       	ldd	r25, Y+18	; 0x12
    64f8:	81 30       	cpi	r24, 0x01	; 1
    64fa:	91 05       	cpc	r25, r1
    64fc:	61 f0       	breq	.+24     	; 0x6516 <xTaskGenericNotifyFromISR+0xb0>
    64fe:	4a c0       	rjmp	.+148    	; 0x6594 <xTaskGenericNotifyFromISR+0x12e>
    6500:	29 89       	ldd	r18, Y+17	; 0x11
    6502:	3a 89       	ldd	r19, Y+18	; 0x12
    6504:	23 30       	cpi	r18, 0x03	; 3
    6506:	31 05       	cpc	r19, r1
    6508:	59 f1       	breq	.+86     	; 0x6560 <xTaskGenericNotifyFromISR+0xfa>
    650a:	89 89       	ldd	r24, Y+17	; 0x11
    650c:	9a 89       	ldd	r25, Y+18	; 0x12
    650e:	84 30       	cpi	r24, 0x04	; 4
    6510:	91 05       	cpc	r25, r1
    6512:	89 f1       	breq	.+98     	; 0x6576 <xTaskGenericNotifyFromISR+0x110>
    6514:	3f c0       	rjmp	.+126    	; 0x6594 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    6516:	ec 81       	ldd	r30, Y+4	; 0x04
    6518:	fd 81       	ldd	r31, Y+5	; 0x05
    651a:	21 a1       	ldd	r18, Z+33	; 0x21
    651c:	32 a1       	ldd	r19, Z+34	; 0x22
    651e:	43 a1       	ldd	r20, Z+35	; 0x23
    6520:	54 a1       	ldd	r21, Z+36	; 0x24
    6522:	88 85       	ldd	r24, Y+8	; 0x08
    6524:	99 85       	ldd	r25, Y+9	; 0x09
    6526:	aa 85       	ldd	r26, Y+10	; 0x0a
    6528:	bb 85       	ldd	r27, Y+11	; 0x0b
    652a:	82 2b       	or	r24, r18
    652c:	93 2b       	or	r25, r19
    652e:	a4 2b       	or	r26, r20
    6530:	b5 2b       	or	r27, r21
    6532:	ec 81       	ldd	r30, Y+4	; 0x04
    6534:	fd 81       	ldd	r31, Y+5	; 0x05
    6536:	81 a3       	std	Z+33, r24	; 0x21
    6538:	92 a3       	std	Z+34, r25	; 0x22
    653a:	a3 a3       	std	Z+35, r26	; 0x23
    653c:	b4 a3       	std	Z+36, r27	; 0x24
    653e:	2a c0       	rjmp	.+84     	; 0x6594 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    6540:	ec 81       	ldd	r30, Y+4	; 0x04
    6542:	fd 81       	ldd	r31, Y+5	; 0x05
    6544:	81 a1       	ldd	r24, Z+33	; 0x21
    6546:	92 a1       	ldd	r25, Z+34	; 0x22
    6548:	a3 a1       	ldd	r26, Z+35	; 0x23
    654a:	b4 a1       	ldd	r27, Z+36	; 0x24
    654c:	01 96       	adiw	r24, 0x01	; 1
    654e:	a1 1d       	adc	r26, r1
    6550:	b1 1d       	adc	r27, r1
    6552:	ec 81       	ldd	r30, Y+4	; 0x04
    6554:	fd 81       	ldd	r31, Y+5	; 0x05
    6556:	81 a3       	std	Z+33, r24	; 0x21
    6558:	92 a3       	std	Z+34, r25	; 0x22
    655a:	a3 a3       	std	Z+35, r26	; 0x23
    655c:	b4 a3       	std	Z+36, r27	; 0x24
    655e:	1a c0       	rjmp	.+52     	; 0x6594 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    6560:	ec 81       	ldd	r30, Y+4	; 0x04
    6562:	fd 81       	ldd	r31, Y+5	; 0x05
    6564:	88 85       	ldd	r24, Y+8	; 0x08
    6566:	99 85       	ldd	r25, Y+9	; 0x09
    6568:	aa 85       	ldd	r26, Y+10	; 0x0a
    656a:	bb 85       	ldd	r27, Y+11	; 0x0b
    656c:	81 a3       	std	Z+33, r24	; 0x21
    656e:	92 a3       	std	Z+34, r25	; 0x22
    6570:	a3 a3       	std	Z+35, r26	; 0x23
    6572:	b4 a3       	std	Z+36, r27	; 0x24
    6574:	0f c0       	rjmp	.+30     	; 0x6594 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    6576:	8b 81       	ldd	r24, Y+3	; 0x03
    6578:	82 30       	cpi	r24, 0x02	; 2
    657a:	59 f0       	breq	.+22     	; 0x6592 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    657c:	ec 81       	ldd	r30, Y+4	; 0x04
    657e:	fd 81       	ldd	r31, Y+5	; 0x05
    6580:	88 85       	ldd	r24, Y+8	; 0x08
    6582:	99 85       	ldd	r25, Y+9	; 0x09
    6584:	aa 85       	ldd	r26, Y+10	; 0x0a
    6586:	bb 85       	ldd	r27, Y+11	; 0x0b
    6588:	81 a3       	std	Z+33, r24	; 0x21
    658a:	92 a3       	std	Z+34, r25	; 0x22
    658c:	a3 a3       	std	Z+35, r26	; 0x23
    658e:	b4 a3       	std	Z+36, r27	; 0x24
    6590:	01 c0       	rjmp	.+2      	; 0x6594 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    6592:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6594:	8b 81       	ldd	r24, Y+3	; 0x03
    6596:	81 30       	cpi	r24, 0x01	; 1
    6598:	09 f0       	breq	.+2      	; 0x659c <xTaskGenericNotifyFromISR+0x136>
    659a:	4f c0       	rjmp	.+158    	; 0x663a <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    659c:	80 91 8d 04 	lds	r24, 0x048D
    65a0:	88 23       	and	r24, r24
    65a2:	61 f5       	brne	.+88     	; 0x65fc <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    65a4:	8c 81       	ldd	r24, Y+4	; 0x04
    65a6:	9d 81       	ldd	r25, Y+5	; 0x05
    65a8:	02 96       	adiw	r24, 0x02	; 2
    65aa:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    65ae:	ec 81       	ldd	r30, Y+4	; 0x04
    65b0:	fd 81       	ldd	r31, Y+5	; 0x05
    65b2:	96 89       	ldd	r25, Z+22	; 0x16
    65b4:	80 91 82 04 	lds	r24, 0x0482
    65b8:	89 17       	cp	r24, r25
    65ba:	28 f4       	brcc	.+10     	; 0x65c6 <xTaskGenericNotifyFromISR+0x160>
    65bc:	ec 81       	ldd	r30, Y+4	; 0x04
    65be:	fd 81       	ldd	r31, Y+5	; 0x05
    65c0:	86 89       	ldd	r24, Z+22	; 0x16
    65c2:	80 93 82 04 	sts	0x0482, r24
    65c6:	ec 81       	ldd	r30, Y+4	; 0x04
    65c8:	fd 81       	ldd	r31, Y+5	; 0x05
    65ca:	86 89       	ldd	r24, Z+22	; 0x16
    65cc:	28 2f       	mov	r18, r24
    65ce:	30 e0       	ldi	r19, 0x00	; 0
    65d0:	c9 01       	movw	r24, r18
    65d2:	88 0f       	add	r24, r24
    65d4:	99 1f       	adc	r25, r25
    65d6:	88 0f       	add	r24, r24
    65d8:	99 1f       	adc	r25, r25
    65da:	88 0f       	add	r24, r24
    65dc:	99 1f       	adc	r25, r25
    65de:	82 0f       	add	r24, r18
    65e0:	93 1f       	adc	r25, r19
    65e2:	ac 01       	movw	r20, r24
    65e4:	42 57       	subi	r20, 0x72	; 114
    65e6:	5b 4f       	sbci	r21, 0xFB	; 251
    65e8:	8c 81       	ldd	r24, Y+4	; 0x04
    65ea:	9d 81       	ldd	r25, Y+5	; 0x05
    65ec:	9c 01       	movw	r18, r24
    65ee:	2e 5f       	subi	r18, 0xFE	; 254
    65f0:	3f 4f       	sbci	r19, 0xFF	; 255
    65f2:	ca 01       	movw	r24, r20
    65f4:	b9 01       	movw	r22, r18
    65f6:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
    65fa:	0a c0       	rjmp	.+20     	; 0x6610 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    65fc:	8c 81       	ldd	r24, Y+4	; 0x04
    65fe:	9d 81       	ldd	r25, Y+5	; 0x05
    6600:	9c 01       	movw	r18, r24
    6602:	24 5f       	subi	r18, 0xF4	; 244
    6604:	3f 4f       	sbci	r19, 0xFF	; 255
    6606:	81 ed       	ldi	r24, 0xD1	; 209
    6608:	94 e0       	ldi	r25, 0x04	; 4
    660a:	b9 01       	movw	r22, r18
    660c:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6610:	ec 81       	ldd	r30, Y+4	; 0x04
    6612:	fd 81       	ldd	r31, Y+5	; 0x05
    6614:	96 89       	ldd	r25, Z+22	; 0x16
    6616:	e0 91 7c 04 	lds	r30, 0x047C
    661a:	f0 91 7d 04 	lds	r31, 0x047D
    661e:	86 89       	ldd	r24, Z+22	; 0x16
    6620:	89 17       	cp	r24, r25
    6622:	58 f4       	brcc	.+22     	; 0x663a <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    6624:	8f 85       	ldd	r24, Y+15	; 0x0f
    6626:	98 89       	ldd	r25, Y+16	; 0x10
    6628:	00 97       	sbiw	r24, 0x00	; 0
    662a:	21 f0       	breq	.+8      	; 0x6634 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    662c:	ef 85       	ldd	r30, Y+15	; 0x0f
    662e:	f8 89       	ldd	r31, Y+16	; 0x10
    6630:	81 e0       	ldi	r24, 0x01	; 1
    6632:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    6634:	81 e0       	ldi	r24, 0x01	; 1
    6636:	80 93 86 04 	sts	0x0486, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    663a:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    663c:	62 96       	adiw	r28, 0x12	; 18
    663e:	0f b6       	in	r0, 0x3f	; 63
    6640:	f8 94       	cli
    6642:	de bf       	out	0x3e, r29	; 62
    6644:	0f be       	out	0x3f, r0	; 63
    6646:	cd bf       	out	0x3d, r28	; 61
    6648:	cf 91       	pop	r28
    664a:	df 91       	pop	r29
    664c:	1f 91       	pop	r17
    664e:	0f 91       	pop	r16
    6650:	ff 90       	pop	r15
    6652:	ef 90       	pop	r14
    6654:	08 95       	ret

00006656 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    6656:	df 93       	push	r29
    6658:	cf 93       	push	r28
    665a:	cd b7       	in	r28, 0x3d	; 61
    665c:	de b7       	in	r29, 0x3e	; 62
    665e:	28 97       	sbiw	r28, 0x08	; 8
    6660:	0f b6       	in	r0, 0x3f	; 63
    6662:	f8 94       	cli
    6664:	de bf       	out	0x3e, r29	; 62
    6666:	0f be       	out	0x3f, r0	; 63
    6668:	cd bf       	out	0x3d, r28	; 61
    666a:	9e 83       	std	Y+6, r25	; 0x06
    666c:	8d 83       	std	Y+5, r24	; 0x05
    666e:	78 87       	std	Y+8, r23	; 0x08
    6670:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    6672:	8d 81       	ldd	r24, Y+5	; 0x05
    6674:	9e 81       	ldd	r25, Y+6	; 0x06
    6676:	9c 83       	std	Y+4, r25	; 0x04
    6678:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    667a:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    667c:	eb 81       	ldd	r30, Y+3	; 0x03
    667e:	fc 81       	ldd	r31, Y+4	; 0x04
    6680:	85 a1       	ldd	r24, Z+37	; 0x25
    6682:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    6684:	eb 81       	ldd	r30, Y+3	; 0x03
    6686:	fc 81       	ldd	r31, Y+4	; 0x04
    6688:	82 e0       	ldi	r24, 0x02	; 2
    668a:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    668c:	eb 81       	ldd	r30, Y+3	; 0x03
    668e:	fc 81       	ldd	r31, Y+4	; 0x04
    6690:	81 a1       	ldd	r24, Z+33	; 0x21
    6692:	92 a1       	ldd	r25, Z+34	; 0x22
    6694:	a3 a1       	ldd	r26, Z+35	; 0x23
    6696:	b4 a1       	ldd	r27, Z+36	; 0x24
    6698:	01 96       	adiw	r24, 0x01	; 1
    669a:	a1 1d       	adc	r26, r1
    669c:	b1 1d       	adc	r27, r1
    669e:	eb 81       	ldd	r30, Y+3	; 0x03
    66a0:	fc 81       	ldd	r31, Y+4	; 0x04
    66a2:	81 a3       	std	Z+33, r24	; 0x21
    66a4:	92 a3       	std	Z+34, r25	; 0x22
    66a6:	a3 a3       	std	Z+35, r26	; 0x23
    66a8:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    66aa:	8a 81       	ldd	r24, Y+2	; 0x02
    66ac:	81 30       	cpi	r24, 0x01	; 1
    66ae:	09 f0       	breq	.+2      	; 0x66b2 <vTaskNotifyGiveFromISR+0x5c>
    66b0:	4f c0       	rjmp	.+158    	; 0x6750 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    66b2:	80 91 8d 04 	lds	r24, 0x048D
    66b6:	88 23       	and	r24, r24
    66b8:	61 f5       	brne	.+88     	; 0x6712 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    66ba:	8b 81       	ldd	r24, Y+3	; 0x03
    66bc:	9c 81       	ldd	r25, Y+4	; 0x04
    66be:	02 96       	adiw	r24, 0x02	; 2
    66c0:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    66c4:	eb 81       	ldd	r30, Y+3	; 0x03
    66c6:	fc 81       	ldd	r31, Y+4	; 0x04
    66c8:	96 89       	ldd	r25, Z+22	; 0x16
    66ca:	80 91 82 04 	lds	r24, 0x0482
    66ce:	89 17       	cp	r24, r25
    66d0:	28 f4       	brcc	.+10     	; 0x66dc <vTaskNotifyGiveFromISR+0x86>
    66d2:	eb 81       	ldd	r30, Y+3	; 0x03
    66d4:	fc 81       	ldd	r31, Y+4	; 0x04
    66d6:	86 89       	ldd	r24, Z+22	; 0x16
    66d8:	80 93 82 04 	sts	0x0482, r24
    66dc:	eb 81       	ldd	r30, Y+3	; 0x03
    66de:	fc 81       	ldd	r31, Y+4	; 0x04
    66e0:	86 89       	ldd	r24, Z+22	; 0x16
    66e2:	28 2f       	mov	r18, r24
    66e4:	30 e0       	ldi	r19, 0x00	; 0
    66e6:	c9 01       	movw	r24, r18
    66e8:	88 0f       	add	r24, r24
    66ea:	99 1f       	adc	r25, r25
    66ec:	88 0f       	add	r24, r24
    66ee:	99 1f       	adc	r25, r25
    66f0:	88 0f       	add	r24, r24
    66f2:	99 1f       	adc	r25, r25
    66f4:	82 0f       	add	r24, r18
    66f6:	93 1f       	adc	r25, r19
    66f8:	ac 01       	movw	r20, r24
    66fa:	42 57       	subi	r20, 0x72	; 114
    66fc:	5b 4f       	sbci	r21, 0xFB	; 251
    66fe:	8b 81       	ldd	r24, Y+3	; 0x03
    6700:	9c 81       	ldd	r25, Y+4	; 0x04
    6702:	9c 01       	movw	r18, r24
    6704:	2e 5f       	subi	r18, 0xFE	; 254
    6706:	3f 4f       	sbci	r19, 0xFF	; 255
    6708:	ca 01       	movw	r24, r20
    670a:	b9 01       	movw	r22, r18
    670c:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
    6710:	0a c0       	rjmp	.+20     	; 0x6726 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    6712:	8b 81       	ldd	r24, Y+3	; 0x03
    6714:	9c 81       	ldd	r25, Y+4	; 0x04
    6716:	9c 01       	movw	r18, r24
    6718:	24 5f       	subi	r18, 0xF4	; 244
    671a:	3f 4f       	sbci	r19, 0xFF	; 255
    671c:	81 ed       	ldi	r24, 0xD1	; 209
    671e:	94 e0       	ldi	r25, 0x04	; 4
    6720:	b9 01       	movw	r22, r18
    6722:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6726:	eb 81       	ldd	r30, Y+3	; 0x03
    6728:	fc 81       	ldd	r31, Y+4	; 0x04
    672a:	96 89       	ldd	r25, Z+22	; 0x16
    672c:	e0 91 7c 04 	lds	r30, 0x047C
    6730:	f0 91 7d 04 	lds	r31, 0x047D
    6734:	86 89       	ldd	r24, Z+22	; 0x16
    6736:	89 17       	cp	r24, r25
    6738:	58 f4       	brcc	.+22     	; 0x6750 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    673a:	8f 81       	ldd	r24, Y+7	; 0x07
    673c:	98 85       	ldd	r25, Y+8	; 0x08
    673e:	00 97       	sbiw	r24, 0x00	; 0
    6740:	21 f0       	breq	.+8      	; 0x674a <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    6742:	ef 81       	ldd	r30, Y+7	; 0x07
    6744:	f8 85       	ldd	r31, Y+8	; 0x08
    6746:	81 e0       	ldi	r24, 0x01	; 1
    6748:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    674a:	81 e0       	ldi	r24, 0x01	; 1
    674c:	80 93 86 04 	sts	0x0486, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    6750:	28 96       	adiw	r28, 0x08	; 8
    6752:	0f b6       	in	r0, 0x3f	; 63
    6754:	f8 94       	cli
    6756:	de bf       	out	0x3e, r29	; 62
    6758:	0f be       	out	0x3f, r0	; 63
    675a:	cd bf       	out	0x3d, r28	; 61
    675c:	cf 91       	pop	r28
    675e:	df 91       	pop	r29
    6760:	08 95       	ret

00006762 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    6762:	df 93       	push	r29
    6764:	cf 93       	push	r28
    6766:	cd b7       	in	r28, 0x3d	; 61
    6768:	de b7       	in	r29, 0x3e	; 62
    676a:	27 97       	sbiw	r28, 0x07	; 7
    676c:	0f b6       	in	r0, 0x3f	; 63
    676e:	f8 94       	cli
    6770:	de bf       	out	0x3e, r29	; 62
    6772:	0f be       	out	0x3f, r0	; 63
    6774:	cd bf       	out	0x3d, r28	; 61
    6776:	9d 83       	std	Y+5, r25	; 0x05
    6778:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    677a:	8c 81       	ldd	r24, Y+4	; 0x04
    677c:	9d 81       	ldd	r25, Y+5	; 0x05
    677e:	00 97       	sbiw	r24, 0x00	; 0
    6780:	39 f4       	brne	.+14     	; 0x6790 <xTaskNotifyStateClear+0x2e>
    6782:	80 91 7c 04 	lds	r24, 0x047C
    6786:	90 91 7d 04 	lds	r25, 0x047D
    678a:	9f 83       	std	Y+7, r25	; 0x07
    678c:	8e 83       	std	Y+6, r24	; 0x06
    678e:	04 c0       	rjmp	.+8      	; 0x6798 <xTaskNotifyStateClear+0x36>
    6790:	8c 81       	ldd	r24, Y+4	; 0x04
    6792:	9d 81       	ldd	r25, Y+5	; 0x05
    6794:	9f 83       	std	Y+7, r25	; 0x07
    6796:	8e 83       	std	Y+6, r24	; 0x06
    6798:	8e 81       	ldd	r24, Y+6	; 0x06
    679a:	9f 81       	ldd	r25, Y+7	; 0x07
    679c:	9b 83       	std	Y+3, r25	; 0x03
    679e:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    67a0:	0f b6       	in	r0, 0x3f	; 63
    67a2:	f8 94       	cli
    67a4:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    67a6:	ea 81       	ldd	r30, Y+2	; 0x02
    67a8:	fb 81       	ldd	r31, Y+3	; 0x03
    67aa:	85 a1       	ldd	r24, Z+37	; 0x25
    67ac:	82 30       	cpi	r24, 0x02	; 2
    67ae:	31 f4       	brne	.+12     	; 0x67bc <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    67b0:	ea 81       	ldd	r30, Y+2	; 0x02
    67b2:	fb 81       	ldd	r31, Y+3	; 0x03
    67b4:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    67b6:	81 e0       	ldi	r24, 0x01	; 1
    67b8:	89 83       	std	Y+1, r24	; 0x01
    67ba:	01 c0       	rjmp	.+2      	; 0x67be <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    67bc:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    67be:	0f 90       	pop	r0
    67c0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    67c2:	89 81       	ldd	r24, Y+1	; 0x01
	}
    67c4:	27 96       	adiw	r28, 0x07	; 7
    67c6:	0f b6       	in	r0, 0x3f	; 63
    67c8:	f8 94       	cli
    67ca:	de bf       	out	0x3e, r29	; 62
    67cc:	0f be       	out	0x3f, r0	; 63
    67ce:	cd bf       	out	0x3d, r28	; 61
    67d0:	cf 91       	pop	r28
    67d2:	df 91       	pop	r29
    67d4:	08 95       	ret

000067d6 <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
    67d6:	df 93       	push	r29
    67d8:	cf 93       	push	r28
    67da:	cd b7       	in	r28, 0x3d	; 61
    67dc:	de b7       	in	r29, 0x3e	; 62
    67de:	2e 97       	sbiw	r28, 0x0e	; 14
    67e0:	0f b6       	in	r0, 0x3f	; 63
    67e2:	f8 94       	cli
    67e4:	de bf       	out	0x3e, r29	; 62
    67e6:	0f be       	out	0x3f, r0	; 63
    67e8:	cd bf       	out	0x3d, r28	; 61
    67ea:	98 87       	std	Y+8, r25	; 0x08
    67ec:	8f 83       	std	Y+7, r24	; 0x07
    67ee:	49 87       	std	Y+9, r20	; 0x09
    67f0:	5a 87       	std	Y+10, r21	; 0x0a
    67f2:	6b 87       	std	Y+11, r22	; 0x0b
    67f4:	7c 87       	std	Y+12, r23	; 0x0c
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    67f6:	8f 81       	ldd	r24, Y+7	; 0x07
    67f8:	98 85       	ldd	r25, Y+8	; 0x08
    67fa:	00 97       	sbiw	r24, 0x00	; 0
    67fc:	39 f4       	brne	.+14     	; 0x680c <ulTaskNotifyValueClear+0x36>
    67fe:	80 91 7c 04 	lds	r24, 0x047C
    6802:	90 91 7d 04 	lds	r25, 0x047D
    6806:	9e 87       	std	Y+14, r25	; 0x0e
    6808:	8d 87       	std	Y+13, r24	; 0x0d
    680a:	04 c0       	rjmp	.+8      	; 0x6814 <ulTaskNotifyValueClear+0x3e>
    680c:	8f 81       	ldd	r24, Y+7	; 0x07
    680e:	98 85       	ldd	r25, Y+8	; 0x08
    6810:	9e 87       	std	Y+14, r25	; 0x0e
    6812:	8d 87       	std	Y+13, r24	; 0x0d
    6814:	8d 85       	ldd	r24, Y+13	; 0x0d
    6816:	9e 85       	ldd	r25, Y+14	; 0x0e
    6818:	9e 83       	std	Y+6, r25	; 0x06
    681a:	8d 83       	std	Y+5, r24	; 0x05

		taskENTER_CRITICAL();
    681c:	0f b6       	in	r0, 0x3f	; 63
    681e:	f8 94       	cli
    6820:	0f 92       	push	r0
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    6822:	e0 91 7c 04 	lds	r30, 0x047C
    6826:	f0 91 7d 04 	lds	r31, 0x047D
    682a:	81 a1       	ldd	r24, Z+33	; 0x21
    682c:	92 a1       	ldd	r25, Z+34	; 0x22
    682e:	a3 a1       	ldd	r26, Z+35	; 0x23
    6830:	b4 a1       	ldd	r27, Z+36	; 0x24
    6832:	89 83       	std	Y+1, r24	; 0x01
    6834:	9a 83       	std	Y+2, r25	; 0x02
    6836:	ab 83       	std	Y+3, r26	; 0x03
    6838:	bc 83       	std	Y+4, r27	; 0x04
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
    683a:	ed 81       	ldd	r30, Y+5	; 0x05
    683c:	fe 81       	ldd	r31, Y+6	; 0x06
    683e:	21 a1       	ldd	r18, Z+33	; 0x21
    6840:	32 a1       	ldd	r19, Z+34	; 0x22
    6842:	43 a1       	ldd	r20, Z+35	; 0x23
    6844:	54 a1       	ldd	r21, Z+36	; 0x24
    6846:	89 85       	ldd	r24, Y+9	; 0x09
    6848:	9a 85       	ldd	r25, Y+10	; 0x0a
    684a:	ab 85       	ldd	r26, Y+11	; 0x0b
    684c:	bc 85       	ldd	r27, Y+12	; 0x0c
    684e:	80 95       	com	r24
    6850:	90 95       	com	r25
    6852:	a0 95       	com	r26
    6854:	b0 95       	com	r27
    6856:	82 23       	and	r24, r18
    6858:	93 23       	and	r25, r19
    685a:	a4 23       	and	r26, r20
    685c:	b5 23       	and	r27, r21
    685e:	ed 81       	ldd	r30, Y+5	; 0x05
    6860:	fe 81       	ldd	r31, Y+6	; 0x06
    6862:	81 a3       	std	Z+33, r24	; 0x21
    6864:	92 a3       	std	Z+34, r25	; 0x22
    6866:	a3 a3       	std	Z+35, r26	; 0x23
    6868:	b4 a3       	std	Z+36, r27	; 0x24
		}
		taskEXIT_CRITICAL();
    686a:	0f 90       	pop	r0
    686c:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    686e:	89 81       	ldd	r24, Y+1	; 0x01
    6870:	9a 81       	ldd	r25, Y+2	; 0x02
    6872:	ab 81       	ldd	r26, Y+3	; 0x03
    6874:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    6876:	bc 01       	movw	r22, r24
    6878:	cd 01       	movw	r24, r26
    687a:	2e 96       	adiw	r28, 0x0e	; 14
    687c:	0f b6       	in	r0, 0x3f	; 63
    687e:	f8 94       	cli
    6880:	de bf       	out	0x3e, r29	; 62
    6882:	0f be       	out	0x3f, r0	; 63
    6884:	cd bf       	out	0x3d, r28	; 61
    6886:	cf 91       	pop	r28
    6888:	df 91       	pop	r29
    688a:	08 95       	ret

0000688c <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    688c:	df 93       	push	r29
    688e:	cf 93       	push	r28
    6890:	cd b7       	in	r28, 0x3d	; 61
    6892:	de b7       	in	r29, 0x3e	; 62
    6894:	27 97       	sbiw	r28, 0x07	; 7
    6896:	0f b6       	in	r0, 0x3f	; 63
    6898:	f8 94       	cli
    689a:	de bf       	out	0x3e, r29	; 62
    689c:	0f be       	out	0x3f, r0	; 63
    689e:	cd bf       	out	0x3d, r28	; 61
    68a0:	9e 83       	std	Y+6, r25	; 0x06
    68a2:	8d 83       	std	Y+5, r24	; 0x05
    68a4:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    68a6:	80 91 80 04 	lds	r24, 0x0480
    68aa:	90 91 81 04 	lds	r25, 0x0481
    68ae:	9a 83       	std	Y+2, r25	; 0x02
    68b0:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    68b2:	80 91 7c 04 	lds	r24, 0x047C
    68b6:	90 91 7d 04 	lds	r25, 0x047D
    68ba:	02 96       	adiw	r24, 0x02	; 2
    68bc:	0e 94 ce 19 	call	0x339c	; 0x339c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    68c0:	8d 81       	ldd	r24, Y+5	; 0x05
    68c2:	9e 81       	ldd	r25, Y+6	; 0x06
    68c4:	2f ef       	ldi	r18, 0xFF	; 255
    68c6:	8f 3f       	cpi	r24, 0xFF	; 255
    68c8:	92 07       	cpc	r25, r18
    68ca:	81 f4       	brne	.+32     	; 0x68ec <prvAddCurrentTaskToDelayedList+0x60>
    68cc:	8f 81       	ldd	r24, Y+7	; 0x07
    68ce:	88 23       	and	r24, r24
    68d0:	69 f0       	breq	.+26     	; 0x68ec <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    68d2:	80 91 7c 04 	lds	r24, 0x047C
    68d6:	90 91 7d 04 	lds	r25, 0x047D
    68da:	9c 01       	movw	r18, r24
    68dc:	2e 5f       	subi	r18, 0xFE	; 254
    68de:	3f 4f       	sbci	r19, 0xFF	; 255
    68e0:	83 ee       	ldi	r24, 0xE3	; 227
    68e2:	94 e0       	ldi	r25, 0x04	; 4
    68e4:	b9 01       	movw	r22, r18
    68e6:	0e 94 1e 19 	call	0x323c	; 0x323c <vListInsertEnd>
    68ea:	43 c0       	rjmp	.+134    	; 0x6972 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    68ec:	29 81       	ldd	r18, Y+1	; 0x01
    68ee:	3a 81       	ldd	r19, Y+2	; 0x02
    68f0:	8d 81       	ldd	r24, Y+5	; 0x05
    68f2:	9e 81       	ldd	r25, Y+6	; 0x06
    68f4:	82 0f       	add	r24, r18
    68f6:	93 1f       	adc	r25, r19
    68f8:	9c 83       	std	Y+4, r25	; 0x04
    68fa:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    68fc:	e0 91 7c 04 	lds	r30, 0x047C
    6900:	f0 91 7d 04 	lds	r31, 0x047D
    6904:	8b 81       	ldd	r24, Y+3	; 0x03
    6906:	9c 81       	ldd	r25, Y+4	; 0x04
    6908:	93 83       	std	Z+3, r25	; 0x03
    690a:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    690c:	2b 81       	ldd	r18, Y+3	; 0x03
    690e:	3c 81       	ldd	r19, Y+4	; 0x04
    6910:	89 81       	ldd	r24, Y+1	; 0x01
    6912:	9a 81       	ldd	r25, Y+2	; 0x02
    6914:	28 17       	cp	r18, r24
    6916:	39 07       	cpc	r19, r25
    6918:	70 f4       	brcc	.+28     	; 0x6936 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    691a:	80 91 cf 04 	lds	r24, 0x04CF
    691e:	90 91 d0 04 	lds	r25, 0x04D0
    6922:	20 91 7c 04 	lds	r18, 0x047C
    6926:	30 91 7d 04 	lds	r19, 0x047D
    692a:	2e 5f       	subi	r18, 0xFE	; 254
    692c:	3f 4f       	sbci	r19, 0xFF	; 255
    692e:	b9 01       	movw	r22, r18
    6930:	0e 94 62 19 	call	0x32c4	; 0x32c4 <vListInsert>
    6934:	1e c0       	rjmp	.+60     	; 0x6972 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6936:	40 91 cd 04 	lds	r20, 0x04CD
    693a:	50 91 ce 04 	lds	r21, 0x04CE
    693e:	80 91 7c 04 	lds	r24, 0x047C
    6942:	90 91 7d 04 	lds	r25, 0x047D
    6946:	9c 01       	movw	r18, r24
    6948:	2e 5f       	subi	r18, 0xFE	; 254
    694a:	3f 4f       	sbci	r19, 0xFF	; 255
    694c:	ca 01       	movw	r24, r20
    694e:	b9 01       	movw	r22, r18
    6950:	0e 94 62 19 	call	0x32c4	; 0x32c4 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    6954:	20 91 89 04 	lds	r18, 0x0489
    6958:	30 91 8a 04 	lds	r19, 0x048A
    695c:	8b 81       	ldd	r24, Y+3	; 0x03
    695e:	9c 81       	ldd	r25, Y+4	; 0x04
    6960:	82 17       	cp	r24, r18
    6962:	93 07       	cpc	r25, r19
    6964:	30 f4       	brcc	.+12     	; 0x6972 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    6966:	8b 81       	ldd	r24, Y+3	; 0x03
    6968:	9c 81       	ldd	r25, Y+4	; 0x04
    696a:	90 93 8a 04 	sts	0x048A, r25
    696e:	80 93 89 04 	sts	0x0489, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    6972:	27 96       	adiw	r28, 0x07	; 7
    6974:	0f b6       	in	r0, 0x3f	; 63
    6976:	f8 94       	cli
    6978:	de bf       	out	0x3e, r29	; 62
    697a:	0f be       	out	0x3f, r0	; 63
    697c:	cd bf       	out	0x3d, r28	; 61
    697e:	cf 91       	pop	r28
    6980:	df 91       	pop	r29
    6982:	08 95       	ret

00006984 <__udivmodsi4>:
    6984:	a1 e2       	ldi	r26, 0x21	; 33
    6986:	1a 2e       	mov	r1, r26
    6988:	aa 1b       	sub	r26, r26
    698a:	bb 1b       	sub	r27, r27
    698c:	fd 01       	movw	r30, r26
    698e:	0d c0       	rjmp	.+26     	; 0x69aa <__udivmodsi4_ep>

00006990 <__udivmodsi4_loop>:
    6990:	aa 1f       	adc	r26, r26
    6992:	bb 1f       	adc	r27, r27
    6994:	ee 1f       	adc	r30, r30
    6996:	ff 1f       	adc	r31, r31
    6998:	a2 17       	cp	r26, r18
    699a:	b3 07       	cpc	r27, r19
    699c:	e4 07       	cpc	r30, r20
    699e:	f5 07       	cpc	r31, r21
    69a0:	20 f0       	brcs	.+8      	; 0x69aa <__udivmodsi4_ep>
    69a2:	a2 1b       	sub	r26, r18
    69a4:	b3 0b       	sbc	r27, r19
    69a6:	e4 0b       	sbc	r30, r20
    69a8:	f5 0b       	sbc	r31, r21

000069aa <__udivmodsi4_ep>:
    69aa:	66 1f       	adc	r22, r22
    69ac:	77 1f       	adc	r23, r23
    69ae:	88 1f       	adc	r24, r24
    69b0:	99 1f       	adc	r25, r25
    69b2:	1a 94       	dec	r1
    69b4:	69 f7       	brne	.-38     	; 0x6990 <__udivmodsi4_loop>
    69b6:	60 95       	com	r22
    69b8:	70 95       	com	r23
    69ba:	80 95       	com	r24
    69bc:	90 95       	com	r25
    69be:	9b 01       	movw	r18, r22
    69c0:	ac 01       	movw	r20, r24
    69c2:	bd 01       	movw	r22, r26
    69c4:	cf 01       	movw	r24, r30
    69c6:	08 95       	ret

000069c8 <__prologue_saves__>:
    69c8:	2f 92       	push	r2
    69ca:	3f 92       	push	r3
    69cc:	4f 92       	push	r4
    69ce:	5f 92       	push	r5
    69d0:	6f 92       	push	r6
    69d2:	7f 92       	push	r7
    69d4:	8f 92       	push	r8
    69d6:	9f 92       	push	r9
    69d8:	af 92       	push	r10
    69da:	bf 92       	push	r11
    69dc:	cf 92       	push	r12
    69de:	df 92       	push	r13
    69e0:	ef 92       	push	r14
    69e2:	ff 92       	push	r15
    69e4:	0f 93       	push	r16
    69e6:	1f 93       	push	r17
    69e8:	cf 93       	push	r28
    69ea:	df 93       	push	r29
    69ec:	cd b7       	in	r28, 0x3d	; 61
    69ee:	de b7       	in	r29, 0x3e	; 62
    69f0:	ca 1b       	sub	r28, r26
    69f2:	db 0b       	sbc	r29, r27
    69f4:	0f b6       	in	r0, 0x3f	; 63
    69f6:	f8 94       	cli
    69f8:	de bf       	out	0x3e, r29	; 62
    69fa:	0f be       	out	0x3f, r0	; 63
    69fc:	cd bf       	out	0x3d, r28	; 61
    69fe:	09 94       	ijmp

00006a00 <__epilogue_restores__>:
    6a00:	2a 88       	ldd	r2, Y+18	; 0x12
    6a02:	39 88       	ldd	r3, Y+17	; 0x11
    6a04:	48 88       	ldd	r4, Y+16	; 0x10
    6a06:	5f 84       	ldd	r5, Y+15	; 0x0f
    6a08:	6e 84       	ldd	r6, Y+14	; 0x0e
    6a0a:	7d 84       	ldd	r7, Y+13	; 0x0d
    6a0c:	8c 84       	ldd	r8, Y+12	; 0x0c
    6a0e:	9b 84       	ldd	r9, Y+11	; 0x0b
    6a10:	aa 84       	ldd	r10, Y+10	; 0x0a
    6a12:	b9 84       	ldd	r11, Y+9	; 0x09
    6a14:	c8 84       	ldd	r12, Y+8	; 0x08
    6a16:	df 80       	ldd	r13, Y+7	; 0x07
    6a18:	ee 80       	ldd	r14, Y+6	; 0x06
    6a1a:	fd 80       	ldd	r15, Y+5	; 0x05
    6a1c:	0c 81       	ldd	r16, Y+4	; 0x04
    6a1e:	1b 81       	ldd	r17, Y+3	; 0x03
    6a20:	aa 81       	ldd	r26, Y+2	; 0x02
    6a22:	b9 81       	ldd	r27, Y+1	; 0x01
    6a24:	ce 0f       	add	r28, r30
    6a26:	d1 1d       	adc	r29, r1
    6a28:	0f b6       	in	r0, 0x3f	; 63
    6a2a:	f8 94       	cli
    6a2c:	de bf       	out	0x3e, r29	; 62
    6a2e:	0f be       	out	0x3f, r0	; 63
    6a30:	cd bf       	out	0x3d, r28	; 61
    6a32:	ed 01       	movw	r28, r26
    6a34:	08 95       	ret

00006a36 <memcpy>:
    6a36:	fb 01       	movw	r30, r22
    6a38:	dc 01       	movw	r26, r24
    6a3a:	02 c0       	rjmp	.+4      	; 0x6a40 <memcpy+0xa>
    6a3c:	01 90       	ld	r0, Z+
    6a3e:	0d 92       	st	X+, r0
    6a40:	41 50       	subi	r20, 0x01	; 1
    6a42:	50 40       	sbci	r21, 0x00	; 0
    6a44:	d8 f7       	brcc	.-10     	; 0x6a3c <memcpy+0x6>
    6a46:	08 95       	ret

00006a48 <_exit>:
    6a48:	f8 94       	cli

00006a4a <__stop_program>:
    6a4a:	ff cf       	rjmp	.-2      	; 0x6a4a <__stop_program>
